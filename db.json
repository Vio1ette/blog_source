{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/cyanstyle/source/css/style.css","path":"css/style.css","modified":1,"renderable":1},{"_id":"themes/cyanstyle/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1,"renderable":1},{"_id":"themes/cyanstyle/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/cyanstyle/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/cyanstyle/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/cyanstyle/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/cyanstyle/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/cyanstyle/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/cyanstyle/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/cyanstyle/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/cyanstyle/source/js/jquery-3.3.1.min.js","path":"js/jquery-3.3.1.min.js","modified":1,"renderable":1},{"_id":"themes/cyanstyle/source/js/navigation.js","path":"js/navigation.js","modified":1,"renderable":1},{"_id":"themes/cyanstyle/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"themes/cyanstyle/source/js/share.js","path":"js/share.js","modified":1,"renderable":1},{"_id":"themes/cyanstyle/source/css/images/body.jpg","path":"css/images/body.jpg","modified":1,"renderable":1},{"_id":"themes/cyanstyle/source/css/images/favicon.ico","path":"css/images/favicon.ico","modified":1,"renderable":1},{"_id":"themes/cyanstyle/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/cyanstyle/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/cyanstyle/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/cyanstyle/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/cyanstyle/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/cyanstyle/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/_posts/C#/delegate委托.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1652155726946},{"_id":"themes/cyanstyle/_config.yml","hash":"abc4ba6d2eb6c4b815879d33902bac8990177ba4","modified":1662988989893},{"_id":"themes/cyanstyle/package.json","hash":"a41065cdd4aa66a70c058e99d250c8b50a9b0787","modified":1662988989967},{"_id":"themes/cyanstyle/README.md","hash":"368360e0ed5eb943ad4caaf9e6aff8c88833992f","modified":1662988989892},{"_id":"themes/cyanstyle/Gruntfile.js","hash":"412e30530784993c8997aa8b1319c669b83b91c2","modified":1662988989889},{"_id":"themes/cyanstyle/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1662988989960},{"_id":"themes/cyanstyle/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1662988989959},{"_id":"themes/cyanstyle/LICENSE","hash":"450b2b897f0a46934264ca6467ee4ee9145e6095","modified":1662988989890},{"_id":"themes/cyanstyle/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1662988989963},{"_id":"themes/cyanstyle/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1662988989964},{"_id":"themes/cyanstyle/scripts/fancybox.js","hash":"4c130fc242cf9b59b5df6ca5eae3b14302311e8c","modified":1662988989969},{"_id":"themes/cyanstyle/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1662988989958},{"_id":"themes/cyanstyle/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1662988989965},{"_id":"themes/cyanstyle/layout/layout.ejs","hash":"23093cee8cbdb486327ae5b17f7747edae291ddf","modified":1662988989961},{"_id":"themes/cyanstyle/layout/_partial/archive-post.ejs","hash":"624907b4acdc7e805a7b63bd3defef2afce90be8","modified":1662988989896},{"_id":"themes/cyanstyle/layout/_partial/after-footer.ejs","hash":"9ddfe05f5e9b47112fb0a33c96e7d39c1f1b9afb","modified":1662988989895},{"_id":"themes/cyanstyle/layout/_partial/article.ejs","hash":"3436ae8d93c99be44ebc2c184be05ab6a67add27","modified":1662988989899},{"_id":"themes/cyanstyle/layout/_partial/archive.ejs","hash":"72dcd7808824e88f1156f190940e119fe87383fa","modified":1662988989897},{"_id":"themes/cyanstyle/layout/_partial/footer.ejs","hash":"0feb0dfb0d78dc9e695565320e60eb714eba8894","modified":1662988989900},{"_id":"themes/cyanstyle/layout/_partial/comment.ejs","hash":"96ed6cddb410e4255935c3017b88be08485604e8","modified":1662988989900},{"_id":"themes/cyanstyle/layout/_partial/header.ejs","hash":"af500d0bc04fc499a4eb50817859025bc00c19ed","modified":1662988989933},{"_id":"themes/cyanstyle/layout/_partial/mobile-nav.ejs","hash":"347cf1befd2ea637c24bd5901929d8e36e359e75","modified":1662988989934},{"_id":"themes/cyanstyle/layout/_partial/google-analytics.ejs","hash":"1ccc627d7697e68fddc367c73ac09920457e5b35","modified":1662988989931},{"_id":"themes/cyanstyle/layout/_widget/archive.ejs","hash":"a28ae3646d876a4ef2d7f3aa5e1e26d3219f6f82","modified":1662988989944},{"_id":"themes/cyanstyle/layout/_partial/sidebar.ejs","hash":"93f64ba48f4e3c50b5aaf6025812a76dd849ccaf","modified":1662988989942},{"_id":"themes/cyanstyle/layout/_widget/category.ejs","hash":"75837a30bea06d0c525cae1e4002bb617e85b075","modified":1662988989944},{"_id":"themes/cyanstyle/layout/_widget/music.ejs","hash":"0c111576276628c0bc0d5fffc6fdc65a391eb3a0","modified":1662988989946},{"_id":"themes/cyanstyle/layout/_widget/search.ejs","hash":"f3c2d30e33ad18abe0f596e5d67cfc4c0632d505","modified":1662988989948},{"_id":"themes/cyanstyle/layout/_widget/recent_posts.ejs","hash":"45c6f0afc6b78b4efe57f79cd7a7c95a5057a5f8","modified":1662988989947},{"_id":"themes/cyanstyle/layout/_widget/tagcloud.ejs","hash":"968507f2aa235ff224efe139c83c191e8057b1a5","modified":1662988989951},{"_id":"themes/cyanstyle/layout/_widget/tag.ejs","hash":"0c4fe2e60c69daa65c8775abff3589eeadf05af6","modified":1662988989948},{"_id":"themes/cyanstyle/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1662988989982},{"_id":"themes/cyanstyle/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1662988989984},{"_id":"themes/cyanstyle/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1662988989981},{"_id":"themes/cyanstyle/layout/_partial/head.ejs","hash":"d28659a632bbc3f02721f7daad6b1c27cde3254c","modified":1662988989932},{"_id":"themes/cyanstyle/source/css/style.css","hash":"d151d482ed5af5e2de00ed41b5b7038a72617bc5","modified":1662988989979},{"_id":"themes/cyanstyle/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1662988989985},{"_id":"themes/cyanstyle/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1662988989986},{"_id":"themes/cyanstyle/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1662988989988},{"_id":"themes/cyanstyle/source/fancybox/jquery.fancybox.css","hash":"2e54d51d21e68ebc4bb870f6e57d3bfb660d4f9c","modified":1662988989998},{"_id":"themes/cyanstyle/source/js/navigation.js","hash":"675005d8b63ee6a6f735fadc9bd381aa996707a3","modified":1662988990007},{"_id":"themes/cyanstyle/source/fancybox/jquery.fancybox.pack.js","hash":"2da892a02778236b64076e5e8802ef0566e1d9e8","modified":1662988990002},{"_id":"themes/cyanstyle/source/fancybox/jquery.fancybox.js","hash":"58193c802f307ec9bc9e586c0e8a13ebef45d2f8","modified":1662988990000},{"_id":"themes/cyanstyle/source/js/script.js","hash":"0109a0b3f1a9d40c1e044283baa50367c9c4af0c","modified":1662988990010},{"_id":"themes/cyanstyle/layout/_partial/post/category.ejs","hash":"cc8b559bdd8998529007383dd43cbadd0d62da76","modified":1662988989936},{"_id":"themes/cyanstyle/layout/_partial/post/date.ejs","hash":"7c9569019c487e19ce302b63f331b51a355aa712","modified":1662988989936},{"_id":"themes/cyanstyle/layout/_partial/post/nav.ejs","hash":"9f7b89504a9c9e95556354d67997f89212c8d286","modified":1662988989939},{"_id":"themes/cyanstyle/layout/_partial/post/gallery.ejs","hash":"b0bf3f5d923c261ca2b5fabab513f1ec2708c8ca","modified":1662988989938},{"_id":"themes/cyanstyle/layout/_partial/post/title.ejs","hash":"8ab246a55a321deaf1158f198adb4117e80fe788","modified":1662988989941},{"_id":"themes/cyanstyle/source/js/share.js","hash":"d37e2ba6bb0017ae33a8abfb7f071e1aaedf6101","modified":1662988990011},{"_id":"themes/cyanstyle/source/css/images/favicon.ico","hash":"b5b7667c7358e7300c4772d481e556b003716dab","modified":1662988989977},{"_id":"themes/cyanstyle/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1662988989990},{"_id":"themes/cyanstyle/layout/_partial/post/tag.ejs","hash":"6903b6961ed82ecd4211bf39a6d846c0ae99559a","modified":1662988989939},{"_id":"themes/cyanstyle/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"6394c48092085788a8c0ef72670b0652006231a1","modified":1662988989991},{"_id":"themes/cyanstyle/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1662988989995},{"_id":"themes/cyanstyle/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"4c9c395d705d22af7da06870d18f434e2a2eeaf9","modified":1662988989993},{"_id":"themes/cyanstyle/source/fancybox/helpers/jquery.fancybox-media.js","hash":"e14c32cc6823b81b2f758512f13ed8eb9ef2b454","modified":1662988989994},{"_id":"themes/cyanstyle/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"83cdfea43632b613771691a11f56f99d85fb6dbd","modified":1662988989996},{"_id":"source/_data/styles.styl","hash":"4a42cb1509f7713617f9ab60417c282d5ac28097","modified":1640921967843},{"_id":"source/categories/index.md","hash":"319ec2dfa4b99b866df8fa841cbc17f61bd918a5","modified":1640917739398},{"_id":"source/about/index.md","hash":"33c26773af3c6a605dfeee5fada5d75ff3e72a7a","modified":1640918013028},{"_id":"source/tags/index.md","hash":"b8ba45e92b0213389e9a7c0d197542ab5fbb80a1","modified":1640917381101},{"_id":"source/_posts/蓝图与C++交互.md","hash":"166a7027a9d73017e9d5c96caf1564a77eb865e3","modified":1650613539622},{"_id":"source/_posts/C++/初始化.md","hash":"528b6809b945508b21a6fc0c813c2e7f151e30bb","modified":1646896344008},{"_id":"source/_posts/C++/回调函数.md","hash":"9742d8b49e9a552de3700526bdfb1ebb74c0a5b2","modified":1638534544046},{"_id":"source/_posts/C++/只读变量与常量的关系.md","hash":"db86079eda4c63ccc78f8c3df83613c733630c18","modified":1646885551869},{"_id":"source/_posts/C#/ref和out.md","hash":"b07d2f253d46442ec8ed67fd1a84344cde8c08d0","modified":1652155728809},{"_id":"source/_posts/图形学&游戏开发/MVP变换总结.md","hash":"9e4994841bcf92f60390f18d7401f2a5dda29384","modified":1649514562377},{"_id":"source/_posts/图形学&游戏开发/z-early.md","hash":"866e45035a3e297d243948fef9dee4e8aebbb5e9","modified":1652425119919},{"_id":"source/_posts/图形学&游戏开发/shadow mapping.md","hash":"46c705871060be437f6e665d08c29ee5df6d2871","modified":1652409255030},{"_id":"source/_posts/图形学&游戏开发/《游戏常用几何学》课程笔记.md","hash":"a4b7debacf239aee0e53ec776bc9c300bf3a6226","modified":1649991447294},{"_id":"source/_posts/图形学&游戏开发/光线追踪（Ray Tracing）.md","hash":"81e2be66b2ed72225462695461aa6773857ae1dd","modified":1651716987905},{"_id":"source/_posts/图形学&游戏开发/延迟渲染.md","hash":"8f6a0fe32a94e99ec8b7a38793b74a8af3dcd5a0","modified":1652420866149},{"_id":"source/_posts/图形学&游戏开发/如何减少DrawCall？.md","hash":"d83d77b7fbca9a2abf7ff9973a1c3e7a89627067","modified":1651474452929},{"_id":"source/_posts/图形学&游戏开发/渲染管线.md","hash":"f33acaeb3c1f598a9d5cbaf1c56c74cd3190f642","modified":1652405799812},{"_id":"source/_posts/图形学&游戏开发/透明效果（alpha测试，alpha混合）.md","hash":"f45cb4f9a5fcceaba11516aff06f3fd5da80a405","modified":1650592330208},{"_id":"source/_posts/数据结构与算法、/01背包问题.md","hash":"92a11baa6b57d689ff54bfc1db8b024293994655","modified":1649984601457},{"_id":"source/_posts/GLSL语言/GLSL语法.md","hash":"39beb22eb9f23ed2dd4ef7aca2fa72ec3f347415","modified":1649037357129},{"_id":"source/_posts/数据结构与算法、/随机打乱一个数组的算法.md","hash":"9ad89e1017d3fcd766a37920bb5ac18968870b02","modified":1651911045034},{"_id":"source/_posts/操作系统/虚拟内存.md","hash":"9fa5ea8077823504d065191abbef7c403549b730","modified":1651651840487},{"_id":"source/_posts/操作系统/进程和线程.md","hash":"6089b6f6be0b5739d158ab2279d67e177a762c18","modified":1652339209013},{"_id":"source/_posts/网络/TCP和UDP的区别.md","hash":"05945c8423045e12182e31550ca2c0ce9ec61809","modified":1651408583815},{"_id":"source/_posts/网络/网络端口.md","hash":"ec002cfca09c9225fd4883f32fa21e63d44d31b6","modified":1650443401200},{"_id":"source/_posts/英语/定语从句专题.md","hash":"b3e86b5f45530c3f69ccbb576b6ed3216e8752de","modified":1641285899772},{"_id":"source/_posts/C++/C++11/lambda表达式.md","hash":"67c8bacb18a3ce2b10b4c385804efe412e38e442","modified":1652359607508},{"_id":"source/_posts/C++/C++11/初始化列表.md","hash":"3391ce96273ef230be6a02d16aac8907497fc97c","modified":1649493931858},{"_id":"source/_posts/英语/虚拟语气专题.md","hash":"0307b962ff9c3d6f19c9d0e192b5fe0d46b98f3c","modified":1640916635486},{"_id":"source/_posts/C++/C++11/智能指针.md","hash":"a8f83376ccc95730c09a6a1cdba15e40f776a5ac","modified":1648554187079},{"_id":"source/_posts/C++/C++基础/inline.md","hash":"e42ea20ac887ac2019c9946ad31d88f405b33ee0","modified":1651562880736},{"_id":"source/_posts/C++/C++11/移动语义.md","hash":"f50d8ad517e92dc5394ea83542f04769c520d8c3","modified":1652356227791},{"_id":"source/_posts/C++/C++基础/函数调用栈帧解析.md","hash":"36ea600a157290a19a2437b8f9320e4ea431fe2f","modified":1651130610449},{"_id":"source/_posts/C++/C++基础/内存对齐.md","hash":"44a22c5968b62c833447e4036dcb7f8e960389e7","modified":1651128028562},{"_id":"source/_posts/C++/C++基础/变量声明、定义，extern，外部链接，内部链接，静态链接.md","hash":"a77ec8661557de59d26ce8f4dcb6c708e917b3cb","modified":1648626133925},{"_id":"source/_posts/C++/C++基础/static关键字.md","hash":"9dcb736f05d16c7653d0e70b8b994ed7a428f058","modified":1651653340766},{"_id":"source/_posts/C++/C++基础/数组名和指针的区别.md","hash":"349f617379f595e045c31c45a7c268f18f20e67b","modified":1651394648372},{"_id":"source/_posts/C++/C++基础/程序编译过程.md","hash":"d83a7bb6c4cab9244bb06efc582f947d2de6fa40","modified":1651462840322},{"_id":"source/_posts/C++/C++内存管理/new、delete.md","hash":"12076331eb15c585f2b4f1a1c359a2bd2ba7ebef","modified":1654661114683},{"_id":"source/_posts/C++/C++内存管理/内存池.md","hash":"68137b53d6c5c25689f790b3b34603b828b636f8","modified":1650243281813},{"_id":"source/_posts/C++/C++模板/模板基础.md","hash":"a806d6e6b41c85ebdc6e7fb8e626515a5e56fec3","modified":1652364814956},{"_id":"source/_posts/C++/STL/自定义比较器.md","hash":"a136b2550bc1a49dff79640693c1350680e70819","modified":1636803791375},{"_id":"source/_posts/C++/《effective C++ 第三版》读书笔记/初始化列表.md","hash":"80007c463a074cba010750f98a95462854450029","modified":1651752864938},{"_id":"source/_posts/C++/多线程/原子操作和原子类型.md","hash":"788dfbc863489dac26ba2e63eb932a41de9e7a64","modified":1652362849433},{"_id":"source/_posts/C++/拷贝控制/拷贝初始化.md","hash":"2e111f4da0a6b8840e5ae046d3892ed86f4c6f4e","modified":1646188376249},{"_id":"source/_posts/C++/类/访问控制与继承.md","hash":"df671ef7013e93fa293bba05d006d30dfb9a15a2","modified":1640073442107},{"_id":"source/_posts/C++/类/名字查找与继承.md","hash":"21a788f3edaa31c66c4d0ac2a693c25a657a098e","modified":1646895943367},{"_id":"source/_posts/C++/类/虚函数专题.md","hash":"5e9edd5a2aaf8ec7c21deef06bdefce5d54f5fae","modified":1653275749057},{"_id":"source/_posts/C++/类/隐式类型转换.md","hash":"b065cb55612a95510834dea434cca62b0b183ac2","modified":1652929553861},{"_id":"source/_posts/C++/设计模式/装饰模式.md","hash":"337b72c2ffa66f173b366c8fea8cd080bb54ce78","modified":1650636574617},{"_id":"source/_posts/C++/设计模式/享元模式.md","hash":"3bd1341e5a6b07f3e67b7067cd76856c83223e3e","modified":1651631692827},{"_id":"source/_posts/C++/设计模式/命令模式.md","hash":"61247379304f84910c7b1e941598b7e65079ff41","modified":1650697777181},{"_id":"source/_posts/C++/设计模式/单例模式.md","hash":"88f2d3d500819b3a5987f67049a56e0bd33b58a9","modified":1651630201002},{"_id":"source/_posts/C++/设计模式/迭代器模式.md","hash":"7f33e4eeb12db3b2e3600cb58671e3849ab1ad41","modified":1652354037483},{"_id":"source/_posts/C++/设计模式/观察者模式.md","hash":"f616a1484f3a637542f9a583c8e70e798a69c5ee","modified":1651631496666},{"_id":"source/_posts/C++/设计模式/工厂模式.md","hash":"16aca2d74b230714301af94f49304b42e40691d6","modified":1651630569670},{"_id":"source/_posts/图形学&游戏开发/动画/欧拉角.md","hash":"f44296f68c06aaad52a3f54218bb08f09be57a7f","modified":1652494627514},{"_id":"source/_posts/图形学&游戏开发/动画/四元数.md","hash":"e7b3a4972f3b5991030825cb52efa60d45414fc6","modified":1652516347162},{"_id":"source/_posts/图形学&游戏开发/游戏编程模式/单例模式.md","hash":"a44251b6f57d34084cce5a62f1525b1a2c4a7141","modified":1650634158395},{"_id":"source/_posts/图形学&游戏开发/游戏场景管理博客笔记/三、背面剔除.md","hash":"3ab6311f50f95ec4c1fcc98ba6e0aa2f317bd44b","modified":1651719064464},{"_id":"source/_posts/图形学&游戏开发/动画/蒙皮、骨骼动画.md","hash":"674eb2c456a95b235fc9131711bdd56a13ad1e8e","modified":1652412307549},{"_id":"source/_posts/图形学&游戏开发/游戏编程模式/对象池.md","hash":"3306b9853d0a7d593f026bde8ebf00bc22375798","modified":1650634408962},{"_id":"source/_posts/图形学&游戏开发/游戏编程模式/观察者模式.md","hash":"dd0f830139616c5c5a1d430f73578b2d39a80852","modified":1650634307038},{"_id":"source/_posts/图形学&游戏开发/网络多人游戏编程/帧同步与状态同步.md","hash":"fa9cab46c6b4abb3f9dee4659ae8651df6886d32","modified":1652414196721},{"_id":"source/_posts/数据结构与算法、/排序/堆排序.md","hash":"b58731627d9b2856077c897e159f1a17414cc05a","modified":1651834482828},{"_id":"source/_posts/数据结构与算法、/排序/快速排序.md","hash":"3b28236db239036c9fb3566f3ddc9e459b5711f5","modified":1651733040273},{"_id":"source/_posts/英语/名词性从句/主语从句.md","hash":"f73575be748d1e9ef5efbfaa74da99751eeffe8c","modified":1641292757166},{"_id":"source/_posts/C++/STL/顺序容器/字符串输入.md","hash":"d7ea30931e21ff7df5c3f7bd0226e6090c40ce34","modified":1646395446649},{"_id":"source/_posts/C++/STL/顺序容器/顺序容器基础.md","hash":"cd73d1f6143d8a7134bf1ebc178e65c7be12df46","modified":1650192238001},{"_id":"source/_posts/C++/STL/关联容器/关联容器基础.md","hash":"4fc8e03c1971c9d7dbe120752acb38ea5b93726a","modified":1650977692413},{"_id":"source/_posts/C++/《effective C++ 第三版》读书笔记/1. 让自己习惯C++/条款02：尽量以const，enum，inline替换#define.md","hash":"31f26e7a33b2456b11a9f42c1837b347f5e11860","modified":1653555557278},{"_id":"source/_posts/C++/《effective C++ 第三版》读书笔记/1. 让自己习惯C++/条款03：尽可能使用const.md","hash":"ccbff8d7b814d5bf125acfae0ce8588fe6ec0538","modified":1653703573738},{"_id":"source/_posts/C++/《effective C++ 第三版》读书笔记/1. 让自己习惯C++/条款04：确定对象被使用前已先被初始化.md","hash":"cda4353fe5b9a9b3ceeeeba51e83e242d8080335","modified":1654646497945},{"_id":"source/_posts/C++/《effective C++ 第三版》读书笔记/2. 构造、析构、赋值运算/条款 05：了解C++默认编写并调用了哪些函数.md","hash":"e4e8d9e05f96fe6f042026eaeb1df74926f40091","modified":1654651557504},{"_id":"source/_posts/C++/《effective C++ 第三版》读书笔记/2. 构造、析构、赋值运算/条款 07：为多态基类声明 virtual 析构函数.md","hash":"b4619d25d07ba66fe8be78dbc541a0a5aefc0cd7","modified":1654659177158},{"_id":"source/_posts/C++/《effective C++ 第三版》读书笔记/2. 构造、析构、赋值运算/条款 06：若不想使用编译器自动生成的函数，就该明确拒绝.md","hash":"b68ba7bc1a3dc0601889f227cbaab6a80963f762","modified":1654658084576},{"_id":"source/_posts/C++/《effective C++ 第三版》读书笔记/2. 构造、析构、赋值运算/条款09：绝不在构造和析构过程中调用 virtual 函数.md","hash":"4b8560ba7d4275a80a1d3d8309aa6375f590e66b","modified":1654661162880},{"_id":"source/_posts/C++/《effective C++ 第三版》读书笔记/2. 构造、析构、赋值运算/条款10：令 operator= 返回一个 reference to [星号]this.md","hash":"1a96e37529b35cf5d7697312355bb62cc50671a8","modified":1654663768424},{"_id":"source/_posts/C++/《effective C++ 第三版》读书笔记/2. 构造、析构、赋值运算/条款11：在operator=中处理自我赋值.md","hash":"04166d8f371512b0b080ba4b99af304dccfcebd0","modified":1654665209266},{"_id":"source/_posts/C++/《effective C++ 第三版》读书笔记/3. 资源管理/条款13：以对象管理资源-.md","hash":"5282d5c9871756719f401cef8c3bb606a7157137","modified":1655891053843},{"_id":"source/_posts/C++/《effective C++ 第三版》读书笔记/5. 实现/条款三十一：将文件间的编译依存关系降至最低（第一部分） - 副本.md","hash":"295538e01da649e850fec35dfe5c864f7316c6bc","modified":1653312405852},{"_id":"source/_posts/C++/《effective C++ 第三版》读书笔记/4. 设计与声明/条款20：宁以 pass-by-reference-to-const 替换 pass-by-value.md","hash":"5b1538fe8761414c3f23844e0f627aa37f136239","modified":1655890970495},{"_id":"source/_posts/C++/《effective C++ 第三版》读书笔记/4. 设计与声明/条款21：必须返回对象时，别妄想返回其reference.md","hash":"58d211b039d677e511533c8ffcbefc7e66ad0340","modified":1655893280180},{"_id":"source/_posts/C++/多线程/进程间通信IPC/信号量.md","hash":"78bd6a713bb8e5077c43724bfe13d017e9cdf4fb","modified":1652364484386},{"_id":"source/_posts/C++/《effective C++ 第三版》读书笔记/4. 设计与声明/条款24：若所有参数皆需类型转换，请为此采用non-member函数.md","hash":"df9adcfd079d6861bef75c8661226344d277bad0","modified":1655895960934},{"_id":"source/_posts/C++/多线程/进程间通信IPC/消息队列.md","hash":"fa584ba9ba9dcc93ab4151c41a6a3337f4197e1e","modified":1652364335999},{"_id":"themes/cyanstyle/source/css/images/body.jpg","hash":"92743ba769bb7a7de8e93a418ed36c89e60bc639","modified":1662988989971},{"_id":"themes/cyanstyle/source/js/jquery-3.3.1.min.js","hash":"0c3192b500a4fd550e483cf77a49806a5872185b","modified":1662988990003},{"_id":"source/_posts/C++/多线程/进程间通信IPC/共享内存.md","hash":"6a7ebfdcaacc551220951ee76a38915fb6026ef2","modified":1651731929190},{"_id":"source/_posts/C++/多线程/进程间通信IPC/管道.md","hash":"b4f6de34f465447dea7f617096b7a191f2a5a57d","modified":1652364382914},{"_id":"public/categories/index.html","hash":"b3539b1cb78590621e8ce500faf9b2f344a5c0b6","modified":1662989503840},{"_id":"public/about/index.html","hash":"bf39623d2e3b6ab151377053bd04798716ed9c1b","modified":1662989503840},{"_id":"public/tags/index.html","hash":"e026a8f95b369941836f5a7079459157837590b4","modified":1662989503840},{"_id":"public/2022/06/14/C++/《effective C++ 第三版》读书笔记/4. 设计与声明/条款20：宁以 pass-by-reference-to-const 替换 pass-by-value/index.html","hash":"8a298df07e2cfc9b454f3547216d8042358eddfa","modified":1662989503840},{"_id":"public/2022/06/11/C++/《effective C++ 第三版》读书笔记/3. 资源管理/条款13：以对象管理资源-/index.html","hash":"4305d502e0590b5ae1601fad2a6c737bc564dea7","modified":1662989503840},{"_id":"public/2022/06/08/C++/《effective C++ 第三版》读书笔记/2. 构造、析构、赋值运算/条款10：令 operator= 返回一个 reference to [星号]this/index.html","hash":"e15edf17fa2efe60fecc1baffeb79516cada3001","modified":1662989503840},{"_id":"public/2022/06/08/C++/《effective C++ 第三版》读书笔记/2. 构造、析构、赋值运算/条款09：绝不在构造和析构过程中调用 virtual 函数/index.html","hash":"902d947507ece587c74acc624511ac95984fe9bf","modified":1662989503840},{"_id":"public/2022/06/08/C++/《effective C++ 第三版》读书笔记/2. 构造、析构、赋值运算/条款 07：为多态基类声明 virtual 析构函数/index.html","hash":"4488971cc10caa657d9f856ea22306a070d161f7","modified":1662989503840},{"_id":"public/2022/06/08/C++/《effective C++ 第三版》读书笔记/2. 构造、析构、赋值运算/条款 06：若不想使用编译器自动生成的函数，就该明确拒绝/index.html","hash":"74e4fa4520e3e9ec46379ae30216db7a7d857dfc","modified":1662989503840},{"_id":"public/2022/06/08/C++/《effective C++ 第三版》读书笔记/2. 构造、析构、赋值运算/条款 05：了解C++默认编写并调用了哪些函数/index.html","hash":"8069e0035664a3eeee164a09048d21ac259ba90f","modified":1662989503840},{"_id":"public/2022/05/14/图形学&游戏开发/动画/欧拉角/index.html","hash":"30791d1d341a7df45f28f730f573129bc59fb474","modified":1662989503840},{"_id":"public/2022/05/12/C++/C++模板/模板基础/index.html","hash":"0b43258fdc9aef2bd1ec3609008e817a4ad6e671","modified":1662989503840},{"_id":"public/2022/05/12/操作系统/进程和线程/index.html","hash":"7a978e4b169c528acb1e9a7a05987b2d00a9e4cd","modified":1662989503840},{"_id":"public/2022/05/12/C++/设计模式/迭代器模式/index.html","hash":"b1a72db227f124b37c340bdf31b7080d5f2ed858","modified":1662989503840},{"_id":"public/2022/05/10/C#/delegate委托/index.html","hash":"f438bf02a17a99e9a62d07b09eb4aefc9e5a6b0f","modified":1662989503840},{"_id":"public/2022/05/10/C#/ref和out/index.html","hash":"e16ed042c7eec8a9d2d685862f4cd6d998aeea65","modified":1662989503840},{"_id":"public/2022/05/09/C++/《effective C++ 第三版》读书笔记/1. 让自己习惯C++/条款02：尽量以const，enum，inline替换#define/index.html","hash":"de43f43f0fb4116c88395b65a0d6256a19301a6c","modified":1662989503840},{"_id":"public/2022/05/07/数据结构与算法、/随机打乱一个数组的算法/index.html","hash":"afb2f20a62e8b0203df9db4570b84f1f918ae1a9","modified":1662989503840},{"_id":"public/2022/05/06/数据结构与算法、/排序/堆排序/index.html","hash":"8c44232f85acc431bf51bcf40efef15b31b4de3d","modified":1662989503840},{"_id":"public/2022/05/05/C++/C++内存管理/new、delete/index.html","hash":"8786cd002025d57ec7a497733b31b33e11dc1456","modified":1662989503840},{"_id":"public/2022/05/05/C++/《effective C++ 第三版》读书笔记/初始化列表/index.html","hash":"8b9db1e96e5494422f24f6f95c40e7ed79a8482a","modified":1662989503840},{"_id":"public/2022/05/05/图形学&游戏开发/z-early/index.html","hash":"37eae5b8a00006388929f9cc6d46c3b2ba29c00e","modified":1662989503840},{"_id":"public/2022/05/04/操作系统/虚拟内存/index.html","hash":"695f712f13f776e71ffbe49355a8dc4f6fa8d6d3","modified":1662989503840},{"_id":"public/2022/05/03/C++/C++基础/inline/index.html","hash":"05b78c6c2e1fdfb106641a6b4db343102024e940","modified":1662989503840},{"_id":"public/2022/05/02/C++/C++基础/程序编译过程/index.html","hash":"e68036881cb07bd1d125f276625b08ea1cd1f75b","modified":1662989503840},{"_id":"public/2022/05/01/C++/C++基础/数组名和指针的区别/index.html","hash":"a0cc5f3cdb7006062da1a89271247ffb0d992bcd","modified":1662989503840},{"_id":"public/2022/04/29/C++/多线程/进程间通信IPC/信号量/index.html","hash":"b62d1ba2ebb72b6071bc1c75023188fa5ff1e84a","modified":1662989503840},{"_id":"public/2022/04/29/C++/多线程/进程间通信IPC/共享内存/index.html","hash":"df9aafe397102592470f153341e143a99e7378ff","modified":1662989503840},{"_id":"public/2022/04/28/C++/多线程/进程间通信IPC/消息队列/index.html","hash":"4d991cdd333f571db00c9a9d1277179ec6f12e74","modified":1662989503840},{"_id":"public/2022/04/28/C++/多线程/进程间通信IPC/管道/index.html","hash":"469cb9fbc11eba98132c4dcf02dcabaf84812d20","modified":1662989503840},{"_id":"public/2022/04/28/C++/C++基础/内存对齐/index.html","hash":"bc09ce45b3c50a2f0e89b9c59b06c2d1498a3d93","modified":1662989503840},{"_id":"public/2022/04/27/C++/C++基础/函数调用栈帧解析/index.html","hash":"eb628ecca879cb4fceafa391dec3ab76f766e41d","modified":1662989503840},{"_id":"public/2022/04/23/C++/设计模式/享元模式/index.html","hash":"a78d8a14a2553de9bef5fa2f88cfe1a67ed44b88","modified":1662989503840},{"_id":"public/2022/04/23/C++/设计模式/命令模式/index.html","hash":"994174836e54801d5f09fb33bf95faf55044845f","modified":1662989503840},{"_id":"public/2022/04/22/C++/设计模式/装饰模式/index.html","hash":"e93ff474904cdb45e89393524a4f1f5d532c882f","modified":1662989503840},{"_id":"public/2022/04/22/图形学&游戏开发/游戏编程模式/单例模式/index.html","hash":"d574b6d6cdd79cc592454b02d5e6553962f9c83f","modified":1662989503840},{"_id":"public/2022/06/22/C++/《effective C++ 第三版》读书笔记/4. 设计与声明/条款24：若所有参数皆需类型转换，请为此采用non-member函数/index.html","hash":"f7fb0f1689403546c1034125058e5c86f479c208","modified":1662989503840},{"_id":"public/2022/06/22/C++/《effective C++ 第三版》读书笔记/4. 设计与声明/条款21：必须返回对象时，别妄想返回其reference/index.html","hash":"dc60cea97b3587bb3968f3f240341f8326df59c7","modified":1662989503840},{"_id":"public/2022/06/08/C++/《effective C++ 第三版》读书笔记/2. 构造、析构、赋值运算/条款11：在operator=中处理自我赋值/index.html","hash":"d1e47a7048d140fa83428bd8cea30e6473ae3bb0","modified":1662989503840},{"_id":"public/2022/05/28/C++/《effective C++ 第三版》读书笔记/1. 让自己习惯C++/条款04：确定对象被使用前已先被初始化/index.html","hash":"92b6ac546ad8d80e8572bf16694c57a872993125","modified":1662989503840},{"_id":"public/2022/05/23/C++/《effective C++ 第三版》读书笔记/5. 实现/条款三十一：将文件间的编译依存关系降至最低（第一部分） - 副本/index.html","hash":"d11801b2b8f561bbc6342316192dcf279f50712f","modified":1662989503840},{"_id":"public/2022/05/19/C++/《effective C++ 第三版》读书笔记/1. 让自己习惯C++/条款03：尽可能使用const/index.html","hash":"f09451759ec5dacf831da95f732edd4791104b3a","modified":1662989503840},{"_id":"public/2022/05/12/C++/多线程/原子操作和原子类型/index.html","hash":"f7b58e659c7d9737ded157170b806a3563f2a0b9","modified":1662989503840},{"_id":"public/2022/05/01/网络/TCP和UDP的区别/index.html","hash":"e7fc00dcd373ea8222185e23c68b3d0eb01693eb","modified":1662989503840},{"_id":"public/2022/04/22/C++/设计模式/工厂模式/index.html","hash":"090e7468e3e51654074a173465068d7bd55d8854","modified":1662989503840},{"_id":"public/2022/04/22/图形学&游戏开发/游戏编程模式/观察者模式/index.html","hash":"2615b9deb327df6433074944af3f5c4b02dafc6a","modified":1662989503840},{"_id":"public/2022/04/22/图形学&游戏开发/动画/四元数/index.html","hash":"29b6875d3dc172ae93e0300107da7fb54adba821","modified":1662989503840},{"_id":"public/2022/04/21/图形学&游戏开发/动画/蒙皮、骨骼动画/index.html","hash":"413b27170e24349505d30f57153ad63d244f4d66","modified":1662989503840},{"_id":"public/2022/04/21/图形学&游戏开发/游戏编程模式/对象池/index.html","hash":"dcc213fa3e1ea7d8867e928ef26d5d0ad6d5613f","modified":1662989503840},{"_id":"public/2022/04/20/图形学&游戏开发/透明效果（alpha测试，alpha混合）/index.html","hash":"5d8c5664898f1d264339338609faadb02528148e","modified":1662989503840},{"_id":"public/2022/04/20/图形学&游戏开发/游戏场景管理博客笔记/三、背面剔除/index.html","hash":"815af76f48030d918d8a230a8d991fd8c42d6bb6","modified":1662989503840},{"_id":"public/2022/04/20/网络/网络端口/index.html","hash":"47a54acd353ba92898ba97bdcf1a2e5dcd0b30c5","modified":1662989503840},{"_id":"public/2022/04/18/图形学&游戏开发/shadow mapping/index.html","hash":"9367d31dc4a635e7c536aa3a625bc32514fef583","modified":1662989503840},{"_id":"public/2022/04/16/C++/C++内存管理/内存池/index.html","hash":"e4b6b40fa6b9a7cbc6258ae070266c2338cb1733","modified":1662989503840},{"_id":"public/2022/04/15/图形学&游戏开发/《游戏常用几何学》课程笔记/index.html","hash":"aa019581e84ee5361fca218a7c72813a46f6b275","modified":1662989503840},{"_id":"public/2022/04/15/数据结构与算法、/01背包问题/index.html","hash":"e6e1b15a4d43361db7a6ab6bd38e8d732320d099","modified":1662989503840},{"_id":"public/2022/04/14/C++/设计模式/单例模式/index.html","hash":"12bc6afdf6931a0ba79dc8b2c0e5667b7c464852","modified":1662989503840},{"_id":"public/2022/04/14/图形学&游戏开发/延迟渲染/index.html","hash":"3f597d65b4e557b5309d05f27f2f0c4b4fdef2ca","modified":1662989503840},{"_id":"public/2022/04/14/图形学&游戏开发/渲染管线/index.html","hash":"cd3e49fb095c685adf1f4b4746ad8142c6bdcf9e","modified":1662989503840},{"_id":"public/2022/04/14/图形学&游戏开发/如何减少DrawCall？/index.html","hash":"334119ffc0c3e971f9011eb9faa68d33398708b6","modified":1662989503840},{"_id":"public/2022/04/09/图形学&游戏开发/MVP变换总结/index.html","hash":"4643e916e1861254062fd13a467b1e41045846f4","modified":1662989503840},{"_id":"public/2022/04/09/C++/C++11/初始化列表/index.html","hash":"a10710abbf410b4501db49786a4457637ab4c398","modified":1662989503840},{"_id":"public/2022/04/03/GLSL语言/GLSL语法/index.html","hash":"9a85617f7bbdb252e4ac470c554d45d40bc43ad7","modified":1662989503840},{"_id":"public/2022/03/28/图形学&游戏开发/光线追踪（Ray Tracing）/index.html","hash":"b28447be2c08ac3575162ef4d0732686cb872fd6","modified":1662989503840},{"_id":"public/2022/03/25/C++/C++11/移动语义/index.html","hash":"c5afe633a5a5269e46f5e034028c65d57b81b384","modified":1662989503840},{"_id":"public/2022/03/24/蓝图与C++交互/index.html","hash":"222c1f67c4a25073c71e563bcdcbd2b58dfa5149","modified":1662989503840},{"_id":"public/2022/03/10/C++/只读变量与常量的关系/index.html","hash":"ce03612aee50969fb0adece48c56387330187315","modified":1662989503840},{"_id":"public/2022/01/04/英语/名词性从句/主语从句/index.html","hash":"28856a787c232847bc0e96b6219dae320d73808e","modified":1662989503840},{"_id":"public/2021/12/31/C++/类/隐式类型转换/index.html","hash":"205797d6a007721ec48a13b37edef84af6caa31e","modified":1662989503840},{"_id":"public/2021/12/31/C++/类/名字查找与继承/index.html","hash":"dcb0a2469d9f61062913ac7d171d1562b02f017b","modified":1662989503840},{"_id":"public/2021/12/31/C++/STL/自定义比较器/index.html","hash":"c4a8a716d870b53e422d21eb62f54549d175970e","modified":1662989503840},{"_id":"public/2021/12/31/C++/回调函数/index.html","hash":"3e66a2cc4e96030f3a11d15e8b79d19539d5bf13","modified":1662989503840},{"_id":"public/archives/index.html","hash":"e3ae7b24ea01680d54824c9af3f104c709fbb936","modified":1662989503840},{"_id":"public/archives/page/2/index.html","hash":"8f41b7908a137d3b8c8f14e01c5072425982f310","modified":1662989503840},{"_id":"public/archives/page/3/index.html","hash":"91721ee535717ac6485c872ace2e3b28d605f4bc","modified":1662989503840},{"_id":"public/archives/page/4/index.html","hash":"9616442ceec1d61ed5e7e672f8cb8f2f3661a5b1","modified":1662989503840},{"_id":"public/archives/page/5/index.html","hash":"27a86e6d77813dd6292e0cd8a9dc264b00a09ccd","modified":1662989503840},{"_id":"public/archives/page/6/index.html","hash":"5e75c8b80677bb1ef7cb68f9fc2f6845e8713cd1","modified":1662989503840},{"_id":"public/archives/page/7/index.html","hash":"af1c94c0794d570ad00ff2d450e508ecc803f427","modified":1662989503840},{"_id":"public/archives/page/8/index.html","hash":"45f85aa639e5e301eb6dcf74ccb38ea557c2c9ee","modified":1662989503840},{"_id":"public/archives/page/9/index.html","hash":"e19069897778fd7b5e81db1cdd832506022cae0f","modified":1662989503840},{"_id":"public/archives/2021/index.html","hash":"9ae69275508619445b72bfbbd955c90c3db2e639","modified":1662989503840},{"_id":"public/archives/2021/page/2/index.html","hash":"c741e051adbd862bae8e90cc010074b20cac4ab6","modified":1662989503840},{"_id":"public/archives/2021/11/index.html","hash":"7b2bf68f004c09017e8a4bceea524d87637d180c","modified":1662989503840},{"_id":"public/archives/2021/12/index.html","hash":"448ff589b5548f703d565e12729c5ffa96b3a30b","modified":1662989503840},{"_id":"public/archives/2021/12/page/2/index.html","hash":"dae8f65eeb06c5af84f544f3b7ecbcc50e745243","modified":1662989503840},{"_id":"public/archives/2022/index.html","hash":"bf142556c669aa7df579a02001f12c08c936d21b","modified":1662989503840},{"_id":"public/archives/2022/page/2/index.html","hash":"056bb116f4e39c341f0de4b21e08491ed32b3cfa","modified":1662989503840},{"_id":"public/archives/2022/page/3/index.html","hash":"682ee0c6b4ce4128f728e1b3fa082a6f7c46ac2a","modified":1662989503840},{"_id":"public/archives/2022/page/4/index.html","hash":"b98c2fce240c7189d88ab25994540c3b72eb299d","modified":1662989503840},{"_id":"public/archives/2022/page/5/index.html","hash":"fabf49c7bb218327a1e285e1d507016efc162cb0","modified":1662989503840},{"_id":"public/archives/2022/page/6/index.html","hash":"a8b84a76e077e27722a4633e900595d4bbd80e77","modified":1662989503840},{"_id":"public/archives/2022/page/7/index.html","hash":"77495b2c636f4b24fcff5a57e89ce8c2c89437bf","modified":1662989503840},{"_id":"public/archives/2022/01/index.html","hash":"abf0f13e85200ea267bb623e7e58ced027f5b148","modified":1662989503840},{"_id":"public/archives/2022/03/index.html","hash":"7849eb8203b1f00cdc828464b7f88384b575a878","modified":1662989503840},{"_id":"public/archives/2022/04/index.html","hash":"1500e0d147f6030712b33c3264e3ca5eb52297eb","modified":1662989503840},{"_id":"public/archives/2022/04/page/2/index.html","hash":"93192dd22c069933c8ee8b8d19f3a5f78b1ef6ac","modified":1662989503840},{"_id":"public/archives/2022/04/page/3/index.html","hash":"05bde01cb601491eff94588d09e14fc05309c3f8","modified":1662989503840},{"_id":"public/archives/2022/04/page/4/index.html","hash":"e573fcae896475e0272f24e977e6c5f42a54ef4e","modified":1662989503840},{"_id":"public/archives/2022/05/index.html","hash":"2a08541db5fdd4b540d50d7404444d8a95ae991b","modified":1662989503840},{"_id":"public/archives/2022/05/page/2/index.html","hash":"13e5b2ec6663a7555ab04fbc7029395b7ec2da3d","modified":1662989503840},{"_id":"public/archives/2022/05/page/3/index.html","hash":"b9860f1dd32a0bfbb9a5bd83f358f1a5f81c3160","modified":1662989503840},{"_id":"public/archives/2022/06/index.html","hash":"85f0a5191e849bae79641f5a339525ce263743e3","modified":1662989503840},{"_id":"public/categories/English/index.html","hash":"539faffc781a4a27648782d933e4749d58c90923","modified":1662989503840},{"_id":"public/categories/我为什么这么菜/index.html","hash":"2c21044a357929a3a970b0e617f0c0bae3cab008","modified":1662989503840},{"_id":"public/categories/数据结构与算法/index.html","hash":"bddabc57a50fe4f928fc8be82cb242d02e17d88e","modified":1662989503840},{"_id":"public/tags/Grammar/index.html","hash":"1b4d3f10ecbae9cbdbccd4a7464efeaaa876b2ff","modified":1662989503840},{"_id":"public/tags/C-C/index.html","hash":"e8622c9434a3114126b39d3eb12fa284a34fbfe9","modified":1662989503840},{"_id":"public/2022/04/18/C++/设计模式/观察者模式/index.html","hash":"4678c3df682fab578425aa36cc593b39ce1d4896","modified":1662989503840},{"_id":"public/2022/04/16/图形学&游戏开发/网络多人游戏编程/帧同步与状态同步/index.html","hash":"11d48f976def401bd6cdeeb8164452ecef3ded9e","modified":1662989503840},{"_id":"public/2022/03/25/C++/C++11/lambda表达式/index.html","hash":"affb67712e275802819fb2f9bd04abe9a87ad8d7","modified":1662989503840},{"_id":"public/2022/01/11/数据结构与算法、/排序/快速排序/index.html","hash":"7987f9329c13afe0645aee1ad6f12d46d5733dc5","modified":1662989503840},{"_id":"public/2021/12/31/C++/类/访问控制与继承/index.html","hash":"3104623e88c043900eee244d90b29a10ceee53bc","modified":1662989503840},{"_id":"public/2021/12/31/C++/类/虚函数专题/index.html","hash":"bc6637deba5e884d3395b48fb46c0753892014fc","modified":1662989503840},{"_id":"public/2021/12/31/C++/STL/关联容器/关联容器基础/index.html","hash":"61df503f4bbf394fc96387d370dc63b154bf1c15","modified":1662989503840},{"_id":"public/2021/12/31/C++/C++11/智能指针/index.html","hash":"9be96c36b8b8d1eb166705ca5f287d9f4b6bb118","modified":1662989503840},{"_id":"public/2021/12/31/C++/初始化/index.html","hash":"8fe054a26b8c4699ff7444406ac37f9d9997b667","modified":1662989503840},{"_id":"public/2021/12/31/C++/C++基础/变量声明、定义，extern，外部链接，内部链接，静态链接/index.html","hash":"2f33eae3ab248b57321192402f535f11aac58cf5","modified":1662989503840},{"_id":"public/2021/12/20/英语/定语从句专题/index.html","hash":"5f3e56ba39aeff307230841e43fda9d2e14ec18d","modified":1662989503840},{"_id":"public/2021/11/24/C++/拷贝控制/拷贝初始化/index.html","hash":"a1437e61b3e0fe15292b4e01cd246ae256fa9173","modified":1662989503840},{"_id":"public/2021/11/13/英语/虚拟语气专题/index.html","hash":"9f35bfd21b7fab06d3e3d372295a8d38d950817c","modified":1662989503840},{"_id":"public/2021/11/10/C++/STL/顺序容器/字符串输入/index.html","hash":"012f9a803e48b704c9e97c713fb46dfc7c104b48","modified":1662989503840},{"_id":"public/index.html","hash":"e00599322c578cd6be69ada6f08de702926bbfd3","modified":1662989503840},{"_id":"public/page/2/index.html","hash":"2f8d5af4bd9c517791718e37b61e8a32f43a65f2","modified":1662989503840},{"_id":"public/page/4/index.html","hash":"241a44a89135adf7f073c2758934d86cd239756d","modified":1662989503840},{"_id":"public/page/3/index.html","hash":"6440e65f56fdea966ba8675dd89000533516ebbc","modified":1662989503840},{"_id":"public/page/5/index.html","hash":"5152d450ff02fe89873cd754ea02a3755b79e6d0","modified":1662989503840},{"_id":"public/page/6/index.html","hash":"c21fa3ced42342d71333658d1cf0fb20086af879","modified":1662989503840},{"_id":"public/page/7/index.html","hash":"205026d6175700b8a33a5ff4c050da5dd3c6f9ba","modified":1662989503840},{"_id":"public/page/8/index.html","hash":"e5a85b6c19dbf83c4ae541012ea09dec3b817378","modified":1662989503840},{"_id":"public/page/9/index.html","hash":"8145450203c96574e3cdd6feb9f37cd13184ac4a","modified":1662989503840},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1662989503840},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1662989503840},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1662989503840},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1662989503840},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1662989503840},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1662989503840},{"_id":"public/css/images/favicon.ico","hash":"b5b7667c7358e7300c4772d481e556b003716dab","modified":1662989503840},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1662989503840},{"_id":"public/live2dw/assets/exp/f00.exp.json","hash":"84073a497ddb6e56c6cfc244a0fb217ba473abf9","modified":1662989503840},{"_id":"public/live2dw/assets/moc/z16.256/texture_00.png","hash":"19f22619c246067d519aa1e6e477497cc4342414","modified":1662989503840},{"_id":"public/live2dw/assets/moc/z16.512/texture_00.png","hash":"251b9f944fb1575c01a62b8a9d7522fe76954b3b","modified":1662989503840},{"_id":"public/live2dw/assets/z16.physics.json","hash":"67f13f60030d7e4c7f824c001ab5254ce4b9bafd","modified":1662989503840},{"_id":"public/live2dw/lib/L2Dwidget.min.js","hash":"5f1a807437cc723bcadc3791d37add5ceed566a2","modified":1662989503840},{"_id":"public/live2dw/assets/z16.model.json","hash":"e69f3d2ecc9bf51b3972ad9df8f6aaa31956910c","modified":1662989503840},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1662989503840},{"_id":"public/js/script.js","hash":"3ce5942cb952256b75767c85af87b17ef2c20be3","modified":1662989503840},{"_id":"public/js/navigation.js","hash":"d3274e55aa315efa43cc6a2c0941c7e73acdbf0a","modified":1662989503840},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1662989503840},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1662989503840},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1662989503840},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1662989503840},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1662989503840},{"_id":"public/css/style.css","hash":"d6568d25ce8bd84b6ce45b16f628edf97df9a111","modified":1662989503840},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1662989503840},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1662989503840},{"_id":"public/js/jquery-3.3.1.min.js","hash":"0dc32db4aa9c5f03f3b38c47d883dbd4fed13aae","modified":1662989503840},{"_id":"public/js/share.js","hash":"86cf11efa35c5c6c68ba4f254541b5890974cc2b","modified":1662989503840},{"_id":"public/css/images/body.jpg","hash":"92743ba769bb7a7de8e93a418ed36c89e60bc639","modified":1662989503840},{"_id":"public/live2dw/assets/mtn/idle.mtn","hash":"f6b879d9f1d096509a7edbc971b8fdd9697932e9","modified":1662989503840},{"_id":"public/live2dw/assets/moc/z16.moc","hash":"6b0241e80e94664d694b43ad05333960de2550c1","modified":1662989503840},{"_id":"public/live2dw/lib/L2Dwidget.min.js.map","hash":"3290fe2df45f065b51a1cd7b24ec325cbf9bb5ce","modified":1662989503840},{"_id":"public/live2dw/assets/moc/z16.1024/texture_00.png","hash":"c4f7c067d7d37601490554438ab801fce1feb92d","modified":1662989503840},{"_id":"public/live2dw/lib/L2Dwidget.0.min.js","hash":"35bb5b588b6de25c9be2dd51d3fd331feafac02d","modified":1662989503840},{"_id":"public/live2dw/lib/L2Dwidget.0.min.js.map","hash":"35e71cc2a130199efb167b9a06939576602f0d75","modified":1662989503840}],"Category":[{"name":"English","_id":"cl7yt0kxc000rpcu34r1s2utl"},{"name":"我为什么这么菜~~","_id":"cl7yt0kxz001hpcu3b94f8dpi"},{"name":"数据结构与算法","_id":"cl7yt0kyf0026pcu3f2c55v9y"}],"Data":[{"_id":"styles","data":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}],"Page":[{"title":"categories","type":"categories","layout":"categories","date":"2021-12-31T02:28:04.000Z","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ntype: categories\nlayout: \"categories\"\ndate: 2021-12-31 10:28:04\n---\n","updated":"2021-12-31T02:28:59.398Z","path":"categories/index.html","comments":1,"_id":"cl7yt0kvr0000pcu36awig3h6","content":"","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":""},{"title":"about","date":"2021-12-31T02:30:37.000Z","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2021-12-31 10:30:37\n---\n","updated":"2021-12-31T02:33:33.028Z","path":"about/index.html","comments":1,"layout":"page","_id":"cl7yt0kwa0002pcu32yn5hooi","content":"","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":""},{"title":"tags","type":"tags","layout":"tags","date":"2021-12-31T02:22:09.000Z","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ntype: tags\nlayout: \"tags\"\ndate: 2021-12-31 10:22:09\n---\n","updated":"2021-12-31T02:23:01.101Z","path":"tags/index.html","comments":1,"_id":"cl7yt0kwg0004pcu3fi1kd9md","content":"","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":""}],"Post":[{"_content":"互相函数调用\n\n创建C++函数，并公开给蓝图，用宏UFUNCTION将C++函数公开给 反射系统，在蓝图中就可以找到该C++类，第一个参数是BlueprintCallable\n\n\n\nC++中调用蓝图函数，也是用UFUNCTION宏，使用蓝图实现事件BlueprintImplementableEvent\n\n\n\n\n\n\n\n","source":"_posts/蓝图与C++交互.md","raw":"互相函数调用\n\n创建C++函数，并公开给蓝图，用宏UFUNCTION将C++函数公开给 反射系统，在蓝图中就可以找到该C++类，第一个参数是BlueprintCallable\n\n\n\nC++中调用蓝图函数，也是用UFUNCTION宏，使用蓝图实现事件BlueprintImplementableEvent\n\n\n\n\n\n\n\n","slug":"蓝图与C++交互","published":1,"date":"2022-03-24T07:46:21.944Z","updated":"2022-04-22T07:45:39.622Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0kvw0001pcu3hovabzy7","content":"<p>互相函数调用</p>\n<p>创建C++函数，并公开给蓝图，用宏UFUNCTION将C++函数公开给 反射系统，在蓝图中就可以找到该C++类，第一个参数是BlueprintCallable</p>\n<p>C++中调用蓝图函数，也是用UFUNCTION宏，使用蓝图实现事件BlueprintImplementableEvent</p>\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<p>互相函数调用</p>\n<p>创建C++函数，并公开给蓝图，用宏UFUNCTION将C++函数公开给 反射系统，在蓝图中就可以找到该C++类，第一个参数是BlueprintCallable</p>\n<p>C++中调用蓝图函数，也是用UFUNCTION宏，使用蓝图实现事件BlueprintImplementableEvent</p>\n"},{"_content":"## C++初始化那些事儿\n\n### 1. 初始化 vs 赋值💢\n\n初始化不等于赋值，这是两个完全不同的操作\n\n初始化：创建变量时赋予其一个初始值\n\n赋值：把对象的当前值擦除，再用一个新值替换\n\n### 2. 列表初始化\n\nC++初始化有很多种形式，这也是初始化问题复杂性的一个体现。 例如，想要定义一个名为 `units_sold` 的 `int` 变量并初始化为 `0`，以下 4 条语句都能做到这一点：\n\n```c++\nint units_sold = 0;  //最正常的方式\nint units_sold = {0}; //列表初始化\nint units_sold{0}; // 列表初始化【】\nint units_sold(0); // 直接初始化\n```\n\n当用于内置类型的变量时，如果列表初始化存在丢失信息的风险，则编译器将报错：\n\n```c++\nlong double ld = 3.1415026536;\nint a{ld}, b = {ld}; // 列表初始化，报错，转换未执行，因为存在丢失信息（精度）的风险\nint c(ld), d = ld; // 正常，转换执行，虽然确实丢失了精度\n```\n\n### 3. 值初始化 vs. 默认初始化\n\n#### 3.1 值初始化\n\n值初始化对于<u>内置类型</u>初始化为 0，对于<u>类类型</u>则调用<u>默认构造函数</u>，如果没有默认构造函数，则不能进行初始化\n\n如何判断是值初始化：\n\n1. 使用了初始化器（如，圆括号，花括号）\n2. **没有**提供初始值\n\n例如：\n\n```cpp\nint *p = new int();\nvector<string> vec(10);  // 10表示个数\n```\n\n> 当不采用动态分配内存的方式（即不用`new`时），`int a()`是错误的值初始化方式，因为它会<u>被理解为一个函数的声明</u>，而不是值初始化\n>\n> 正确的初始化方式：`int a = int();`\n\n#### 3.2 默认初始化\n\n如果**定义变量**的时候**没有指定初值**，则变量被**默认初始化（default initialized）**，此时变量被赋予“**默认值**”\n\n>  **默认值到底是什么？**\n>\n>  （1）内置类型\n>\n>  由定义的位置决定：\n>\n>  1. **任何函数之外**的变量，它被初始化为 0\n>  2. **在函数体内部**，将**不被初始化**，其值是**未定义**的，是**不能被访问**的\n>\n>  （2）类对象\n>\n>  **类自己决定**其变量的**初始化方式**、**初始化值**、**是否允许不经初始化变量就定义出对象**\n>\n>  绝大多数类都支持**无须显示初始化而定义对象**，它会给没有初始化的**类内变量**提供一个合适的**默认值**\n>\n>  ```c++\n>  std::string empty; // 默认值为空串\n>  Sales_item item; // item的默认值是什么，由 Sales_item 这个类自己定义\n>  ```\n>\n>  一些类要求每个对象都显示初始化， 如果没有就会报错\n\n### 4. 直接初始化 vs. 拷贝初始化\n\n\n\n直接初始化：要求编译器使用**普通的函数匹配**，选择与我们提供的参数**最匹配**的构造函数（也可能最佳匹配上**拷构**）\n\n拷贝初始化：要求编译器将**右侧运算对象**拷贝到正在创建的对象中，需要的话可以进行类型转换\n\n> **拷贝初始化**一般调用**拷贝构造函数**，但也可能调用**移动构造函数**\n\n```\nstring dots(10, '.');   //直初\nstring s(dots);  \t\t//使用了拷构的直初\nstring s = dots; \t\t//拷初\nstring null_book = \"9999\";  //拷初\nstring nines = string(100, '9'); //拷初\n```\n\n> 哪里有临时量生成？ 拷初的参数是 `const&` 肯定没有临时量\n\n发生拷初的常见情况\n\n1. `=`\n2. 非引用函数传参\n3. 非引用函数返回值\n\n### 5. 数组的初始化\n\n#### 5.1 数组的初始化规则\n\n1. 只有在定义数组的时候才能使用初始化，以后就不能使用了\n\n```c++\nint cards[4] = {3,6,8,10}; //okay\nint hand[4];\nhand[4] = {5, 6, 7, 9}; //not allowed，可以使用下标一一赋值\n```\n\n2. 不允许数组间赋值\n\n```c++\nhand = cards; // not allowed\n```\n\n3. 允许部分初始化，剩余的默认采用<u>值初始化</u>\n\n#### 5.2 c++11新特性\n\n#### 列表初始化新特性\n\n```c++\ndouble earnings[4] {1.2e4, 1.6e4}; // 列表初始化，省略等号是可以的\nunsigned int counts[10] = {}; //所有10个元素都为0\nlong plifs[] = {25, 92, 3.0}; //报错，列表初始化禁止缩窄转换\n```\n\n关于`缩窄转换`[C++11 narrowing convertions(缩窄转换)_dai_peixian的专栏-CSDN博客_缩窄转换](https://blog.csdn.net/dai_peixian/article/details/52767057)\n\n### 6. string初始化【6，7都是顺序容器，初始化可以放到一起】\n\n![初始化string](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211109100945293.png)\n\n<center style=\"color:#C0C0C0;text-decoration:underline\">Primer C++ 第五版，P76</center>\n\n### 7. vector初始化【】\n\n```c++\nvector<T> v1;    // 空vector，默认初始化\nvector<T> v2(v1); //拷贝初始化，要求两个vector对象的类型必须相同\nvector<T> v2 = v1; //同上\nvector<T> v3(n,val); // v3包含n个重复元素，每个元素的值都是val\nvector<T> v4(n); // v4包含n个元素，每个元素都被值初始化（如果是内置类型，0，如果是类类型，则执行类定义默认初始化）\nvector<T> v5{a,b,c...} //列表初始化\nvector<T> v6 = {a,b,c...} //同上 \n```\n\n> 如果使用了花括号，但是提供的值不能用来完成列表初始化，编译器就会考虑用提供的值来构造 vector 对象\n>\n> ```c++\n> vector<string> v7{10};  //v7有10个默认初始化元素\n> vector<string> v8{10, \"hi\"}; //v8 有10个值为\"hi\"的元素\n> ```\n\n### 8. \n\n","source":"_posts/C++/初始化.md","raw":"## C++初始化那些事儿\n\n### 1. 初始化 vs 赋值💢\n\n初始化不等于赋值，这是两个完全不同的操作\n\n初始化：创建变量时赋予其一个初始值\n\n赋值：把对象的当前值擦除，再用一个新值替换\n\n### 2. 列表初始化\n\nC++初始化有很多种形式，这也是初始化问题复杂性的一个体现。 例如，想要定义一个名为 `units_sold` 的 `int` 变量并初始化为 `0`，以下 4 条语句都能做到这一点：\n\n```c++\nint units_sold = 0;  //最正常的方式\nint units_sold = {0}; //列表初始化\nint units_sold{0}; // 列表初始化【】\nint units_sold(0); // 直接初始化\n```\n\n当用于内置类型的变量时，如果列表初始化存在丢失信息的风险，则编译器将报错：\n\n```c++\nlong double ld = 3.1415026536;\nint a{ld}, b = {ld}; // 列表初始化，报错，转换未执行，因为存在丢失信息（精度）的风险\nint c(ld), d = ld; // 正常，转换执行，虽然确实丢失了精度\n```\n\n### 3. 值初始化 vs. 默认初始化\n\n#### 3.1 值初始化\n\n值初始化对于<u>内置类型</u>初始化为 0，对于<u>类类型</u>则调用<u>默认构造函数</u>，如果没有默认构造函数，则不能进行初始化\n\n如何判断是值初始化：\n\n1. 使用了初始化器（如，圆括号，花括号）\n2. **没有**提供初始值\n\n例如：\n\n```cpp\nint *p = new int();\nvector<string> vec(10);  // 10表示个数\n```\n\n> 当不采用动态分配内存的方式（即不用`new`时），`int a()`是错误的值初始化方式，因为它会<u>被理解为一个函数的声明</u>，而不是值初始化\n>\n> 正确的初始化方式：`int a = int();`\n\n#### 3.2 默认初始化\n\n如果**定义变量**的时候**没有指定初值**，则变量被**默认初始化（default initialized）**，此时变量被赋予“**默认值**”\n\n>  **默认值到底是什么？**\n>\n>  （1）内置类型\n>\n>  由定义的位置决定：\n>\n>  1. **任何函数之外**的变量，它被初始化为 0\n>  2. **在函数体内部**，将**不被初始化**，其值是**未定义**的，是**不能被访问**的\n>\n>  （2）类对象\n>\n>  **类自己决定**其变量的**初始化方式**、**初始化值**、**是否允许不经初始化变量就定义出对象**\n>\n>  绝大多数类都支持**无须显示初始化而定义对象**，它会给没有初始化的**类内变量**提供一个合适的**默认值**\n>\n>  ```c++\n>  std::string empty; // 默认值为空串\n>  Sales_item item; // item的默认值是什么，由 Sales_item 这个类自己定义\n>  ```\n>\n>  一些类要求每个对象都显示初始化， 如果没有就会报错\n\n### 4. 直接初始化 vs. 拷贝初始化\n\n\n\n直接初始化：要求编译器使用**普通的函数匹配**，选择与我们提供的参数**最匹配**的构造函数（也可能最佳匹配上**拷构**）\n\n拷贝初始化：要求编译器将**右侧运算对象**拷贝到正在创建的对象中，需要的话可以进行类型转换\n\n> **拷贝初始化**一般调用**拷贝构造函数**，但也可能调用**移动构造函数**\n\n```\nstring dots(10, '.');   //直初\nstring s(dots);  \t\t//使用了拷构的直初\nstring s = dots; \t\t//拷初\nstring null_book = \"9999\";  //拷初\nstring nines = string(100, '9'); //拷初\n```\n\n> 哪里有临时量生成？ 拷初的参数是 `const&` 肯定没有临时量\n\n发生拷初的常见情况\n\n1. `=`\n2. 非引用函数传参\n3. 非引用函数返回值\n\n### 5. 数组的初始化\n\n#### 5.1 数组的初始化规则\n\n1. 只有在定义数组的时候才能使用初始化，以后就不能使用了\n\n```c++\nint cards[4] = {3,6,8,10}; //okay\nint hand[4];\nhand[4] = {5, 6, 7, 9}; //not allowed，可以使用下标一一赋值\n```\n\n2. 不允许数组间赋值\n\n```c++\nhand = cards; // not allowed\n```\n\n3. 允许部分初始化，剩余的默认采用<u>值初始化</u>\n\n#### 5.2 c++11新特性\n\n#### 列表初始化新特性\n\n```c++\ndouble earnings[4] {1.2e4, 1.6e4}; // 列表初始化，省略等号是可以的\nunsigned int counts[10] = {}; //所有10个元素都为0\nlong plifs[] = {25, 92, 3.0}; //报错，列表初始化禁止缩窄转换\n```\n\n关于`缩窄转换`[C++11 narrowing convertions(缩窄转换)_dai_peixian的专栏-CSDN博客_缩窄转换](https://blog.csdn.net/dai_peixian/article/details/52767057)\n\n### 6. string初始化【6，7都是顺序容器，初始化可以放到一起】\n\n![初始化string](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211109100945293.png)\n\n<center style=\"color:#C0C0C0;text-decoration:underline\">Primer C++ 第五版，P76</center>\n\n### 7. vector初始化【】\n\n```c++\nvector<T> v1;    // 空vector，默认初始化\nvector<T> v2(v1); //拷贝初始化，要求两个vector对象的类型必须相同\nvector<T> v2 = v1; //同上\nvector<T> v3(n,val); // v3包含n个重复元素，每个元素的值都是val\nvector<T> v4(n); // v4包含n个元素，每个元素都被值初始化（如果是内置类型，0，如果是类类型，则执行类定义默认初始化）\nvector<T> v5{a,b,c...} //列表初始化\nvector<T> v6 = {a,b,c...} //同上 \n```\n\n> 如果使用了花括号，但是提供的值不能用来完成列表初始化，编译器就会考虑用提供的值来构造 vector 对象\n>\n> ```c++\n> vector<string> v7{10};  //v7有10个默认初始化元素\n> vector<string> v8{10, \"hi\"}; //v8 有10个值为\"hi\"的元素\n> ```\n\n### 8. \n\n","slug":"C++/初始化","published":1,"date":"2021-12-31T02:09:01.483Z","updated":"2022-03-10T07:12:24.008Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0kwb0003pcu3aich570s","content":"<h2 id=\"C-初始化那些事儿\"><a href=\"#C-初始化那些事儿\" class=\"headerlink\" title=\"C++初始化那些事儿\"></a>C++初始化那些事儿</h2><h3 id=\"1-初始化-vs-赋值💢\"><a href=\"#1-初始化-vs-赋值💢\" class=\"headerlink\" title=\"1. 初始化 vs 赋值💢\"></a>1. 初始化 vs 赋值💢</h3><p>初始化不等于赋值，这是两个完全不同的操作</p>\n<p>初始化：创建变量时赋予其一个初始值</p>\n<p>赋值：把对象的当前值擦除，再用一个新值替换</p>\n<h3 id=\"2-列表初始化\"><a href=\"#2-列表初始化\" class=\"headerlink\" title=\"2. 列表初始化\"></a>2. 列表初始化</h3><p>C++初始化有很多种形式，这也是初始化问题复杂性的一个体现。 例如，想要定义一个名为 <code>units_sold</code> 的 <code>int</code> 变量并初始化为 <code>0</code>，以下 4 条语句都能做到这一点：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> units_sold = <span class=\"number\">0</span>;  <span class=\"comment\">//最正常的方式</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> units_sold = &#123;<span class=\"number\">0</span>&#125;; <span class=\"comment\">//列表初始化</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> units_sold&#123;<span class=\"number\">0</span>&#125;; <span class=\"comment\">// 列表初始化【】</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">units_sold</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>; <span class=\"comment\">// 直接初始化</span></span><br></pre></td></tr></table></figure>\n\n<p>当用于内置类型的变量时，如果列表初始化存在丢失信息的风险，则编译器将报错：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">double</span> ld = <span class=\"number\">3.1415026536</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> a&#123;ld&#125;, b = &#123;ld&#125;; <span class=\"comment\">// 列表初始化，报错，转换未执行，因为存在丢失信息（精度）的风险</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">c</span><span class=\"params\">(ld)</span>, d </span>= ld; <span class=\"comment\">// 正常，转换执行，虽然确实丢失了精度</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-值初始化-vs-默认初始化\"><a href=\"#3-值初始化-vs-默认初始化\" class=\"headerlink\" title=\"3. 值初始化 vs. 默认初始化\"></a>3. 值初始化 vs. 默认初始化</h3><h4 id=\"3-1-值初始化\"><a href=\"#3-1-值初始化\" class=\"headerlink\" title=\"3.1 值初始化\"></a>3.1 值初始化</h4><p>值初始化对于<u>内置类型</u>初始化为 0，对于<u>类类型</u>则调用<u>默认构造函数</u>，如果没有默认构造函数，则不能进行初始化</p>\n<p>如何判断是值初始化：</p>\n<ol>\n<li>使用了初始化器（如，圆括号，花括号）</li>\n<li><strong>没有</strong>提供初始值</li>\n</ol>\n<p>例如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> *p = <span class=\"keyword\">new</span> <span class=\"built_in\"><span class=\"keyword\">int</span></span>();</span><br><span class=\"line\"><span class=\"function\">vector&lt;string&gt; <span class=\"title\">vec</span><span class=\"params\">(<span class=\"number\">10</span>)</span></span>;  <span class=\"comment\">// 10表示个数</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>当不采用动态分配内存的方式（即不用<code>new</code>时），<code>int a()</code>是错误的值初始化方式，因为它会<u>被理解为一个函数的声明</u>，而不是值初始化</p>\n<p>正确的初始化方式：<code>int a = int();</code></p>\n</blockquote>\n<h4 id=\"3-2-默认初始化\"><a href=\"#3-2-默认初始化\" class=\"headerlink\" title=\"3.2 默认初始化\"></a>3.2 默认初始化</h4><p>如果<strong>定义变量</strong>的时候<strong>没有指定初值</strong>，则变量被<strong>默认初始化（default initialized）</strong>，此时变量被赋予“<strong>默认值</strong>”</p>\n<blockquote>\n<p> <strong>默认值到底是什么？</strong></p>\n<p> （1）内置类型</p>\n<p> 由定义的位置决定：</p>\n<ol>\n<li><strong>任何函数之外</strong>的变量，它被初始化为 0</li>\n<li><strong>在函数体内部</strong>，将<strong>不被初始化</strong>，其值是<strong>未定义</strong>的，是<strong>不能被访问</strong>的</li>\n</ol>\n<p> （2）类对象</p>\n<p> <strong>类自己决定</strong>其变量的<strong>初始化方式</strong>、<strong>初始化值</strong>、<strong>是否允许不经初始化变量就定义出对象</strong></p>\n<p> 绝大多数类都支持<strong>无须显示初始化而定义对象</strong>，它会给没有初始化的<strong>类内变量</strong>提供一个合适的<strong>默认值</strong></p>\n <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::string empty; <span class=\"comment\">// 默认值为空串</span></span><br><span class=\"line\">Sales_item item; <span class=\"comment\">// item的默认值是什么，由 Sales_item 这个类自己定义</span></span><br></pre></td></tr></table></figure>\n\n<p> 一些类要求每个对象都显示初始化， 如果没有就会报错</p>\n</blockquote>\n<h3 id=\"4-直接初始化-vs-拷贝初始化\"><a href=\"#4-直接初始化-vs-拷贝初始化\" class=\"headerlink\" title=\"4. 直接初始化 vs. 拷贝初始化\"></a>4. 直接初始化 vs. 拷贝初始化</h3><p>直接初始化：要求编译器使用<strong>普通的函数匹配</strong>，选择与我们提供的参数<strong>最匹配</strong>的构造函数（也可能最佳匹配上<strong>拷构</strong>）</p>\n<p>拷贝初始化：要求编译器将<strong>右侧运算对象</strong>拷贝到正在创建的对象中，需要的话可以进行类型转换</p>\n<blockquote>\n<p><strong>拷贝初始化</strong>一般调用<strong>拷贝构造函数</strong>，但也可能调用<strong>移动构造函数</strong></p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string dots(10, &#x27;.&#x27;);   //直初</span><br><span class=\"line\">string s(dots);  \t\t//使用了拷构的直初</span><br><span class=\"line\">string s = dots; \t\t//拷初</span><br><span class=\"line\">string null_book = &quot;9999&quot;;  //拷初</span><br><span class=\"line\">string nines = string(100, &#x27;9&#x27;); //拷初</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>哪里有临时量生成？ 拷初的参数是 <code>const&amp;</code> 肯定没有临时量</p>\n</blockquote>\n<p>发生拷初的常见情况</p>\n<ol>\n<li><code>=</code></li>\n<li>非引用函数传参</li>\n<li>非引用函数返回值</li>\n</ol>\n<h3 id=\"5-数组的初始化\"><a href=\"#5-数组的初始化\" class=\"headerlink\" title=\"5. 数组的初始化\"></a>5. 数组的初始化</h3><h4 id=\"5-1-数组的初始化规则\"><a href=\"#5-1-数组的初始化规则\" class=\"headerlink\" title=\"5.1 数组的初始化规则\"></a>5.1 数组的初始化规则</h4><ol>\n<li>只有在定义数组的时候才能使用初始化，以后就不能使用了</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> cards[<span class=\"number\">4</span>] = &#123;<span class=\"number\">3</span>,<span class=\"number\">6</span>,<span class=\"number\">8</span>,<span class=\"number\">10</span>&#125;; <span class=\"comment\">//okay</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> hand[<span class=\"number\">4</span>];</span><br><span class=\"line\">hand[<span class=\"number\">4</span>] = &#123;<span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>&#125;; <span class=\"comment\">//not allowed，可以使用下标一一赋值</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>不允许数组间赋值</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hand = cards; <span class=\"comment\">// not allowed</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>允许部分初始化，剩余的默认采用<u>值初始化</u></li>\n</ol>\n<h4 id=\"5-2-c-11新特性\"><a href=\"#5-2-c-11新特性\" class=\"headerlink\" title=\"5.2 c++11新特性\"></a>5.2 c++11新特性</h4><h4 id=\"列表初始化新特性\"><a href=\"#列表初始化新特性\" class=\"headerlink\" title=\"列表初始化新特性\"></a>列表初始化新特性</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">double</span> earnings[<span class=\"number\">4</span>] &#123;<span class=\"number\">1.2e4</span>, <span class=\"number\">1.6e4</span>&#125;; <span class=\"comment\">// 列表初始化，省略等号是可以的</span></span><br><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> counts[<span class=\"number\">10</span>] = &#123;&#125;; <span class=\"comment\">//所有10个元素都为0</span></span><br><span class=\"line\"><span class=\"keyword\">long</span> plifs[] = &#123;<span class=\"number\">25</span>, <span class=\"number\">92</span>, <span class=\"number\">3.0</span>&#125;; <span class=\"comment\">//报错，列表初始化禁止缩窄转换</span></span><br></pre></td></tr></table></figure>\n\n<p>关于<code>缩窄转换</code><a href=\"https://blog.csdn.net/dai_peixian/article/details/52767057\">C++11 narrowing convertions(缩窄转换)_dai_peixian的专栏-CSDN博客_缩窄转换</a></p>\n<h3 id=\"6-string初始化【6，7都是顺序容器，初始化可以放到一起】\"><a href=\"#6-string初始化【6，7都是顺序容器，初始化可以放到一起】\" class=\"headerlink\" title=\"6. string初始化【6，7都是顺序容器，初始化可以放到一起】\"></a>6. string初始化【6，7都是顺序容器，初始化可以放到一起】</h3><p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211109100945293.png\" alt=\"初始化string\"></p>\n<center style=\"color:#C0C0C0;text-decoration:underline\">Primer C++ 第五版，P76</center>\n\n<h3 id=\"7-vector初始化【】\"><a href=\"#7-vector初始化【】\" class=\"headerlink\" title=\"7. vector初始化【】\"></a>7. vector初始化【】</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;T&gt; v1;    <span class=\"comment\">// 空vector，默认初始化</span></span><br><span class=\"line\"><span class=\"function\">vector&lt;T&gt; <span class=\"title\">v2</span><span class=\"params\">(v1)</span></span>; <span class=\"comment\">//拷贝初始化，要求两个vector对象的类型必须相同</span></span><br><span class=\"line\">vector&lt;T&gt; v2 = v1; <span class=\"comment\">//同上</span></span><br><span class=\"line\"><span class=\"function\">vector&lt;T&gt; <span class=\"title\">v3</span><span class=\"params\">(n,val)</span></span>; <span class=\"comment\">// v3包含n个重复元素，每个元素的值都是val</span></span><br><span class=\"line\"><span class=\"function\">vector&lt;T&gt; <span class=\"title\">v4</span><span class=\"params\">(n)</span></span>; <span class=\"comment\">// v4包含n个元素，每个元素都被值初始化（如果是内置类型，0，如果是类类型，则执行类定义默认初始化）</span></span><br><span class=\"line\">vector&lt;T&gt; v5&#123;a,b,c...&#125; <span class=\"comment\">//列表初始化</span></span><br><span class=\"line\">vector&lt;T&gt; v6 = &#123;a,b,c...&#125; <span class=\"comment\">//同上 </span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>如果使用了花括号，但是提供的值不能用来完成列表初始化，编译器就会考虑用提供的值来构造 vector 对象</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;string&gt; v7&#123;<span class=\"number\">10</span>&#125;;  <span class=\"comment\">//v7有10个默认初始化元素</span></span><br><span class=\"line\">vector&lt;string&gt; v8&#123;<span class=\"number\">10</span>, <span class=\"string\">&quot;hi&quot;</span>&#125;; <span class=\"comment\">//v8 有10个值为&quot;hi&quot;的元素</span></span><br></pre></td></tr></table></figure>\n</blockquote>\n<h3 id=\"8\"><a href=\"#8\" class=\"headerlink\" title=\"8.\"></a>8.</h3>","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<h2 id=\"C-初始化那些事儿\"><a href=\"#C-初始化那些事儿\" class=\"headerlink\" title=\"C++初始化那些事儿\"></a>C++初始化那些事儿</h2><h3 id=\"1-初始化-vs-赋值💢\"><a href=\"#1-初始化-vs-赋值💢\" class=\"headerlink\" title=\"1. 初始化 vs 赋值💢\"></a>1. 初始化 vs 赋值💢</h3><p>初始化不等于赋值，这是两个完全不同的操作</p>\n<p>初始化：创建变量时赋予其一个初始值</p>\n<p>赋值：把对象的当前值擦除，再用一个新值替换</p>\n<h3 id=\"2-列表初始化\"><a href=\"#2-列表初始化\" class=\"headerlink\" title=\"2. 列表初始化\"></a>2. 列表初始化</h3><p>C++初始化有很多种形式，这也是初始化问题复杂性的一个体现。 例如，想要定义一个名为 <code>units_sold</code> 的 <code>int</code> 变量并初始化为 <code>0</code>，以下 4 条语句都能做到这一点：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> units_sold = <span class=\"number\">0</span>;  <span class=\"comment\">//最正常的方式</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> units_sold = &#123;<span class=\"number\">0</span>&#125;; <span class=\"comment\">//列表初始化</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> units_sold&#123;<span class=\"number\">0</span>&#125;; <span class=\"comment\">// 列表初始化【】</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">units_sold</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>; <span class=\"comment\">// 直接初始化</span></span><br></pre></td></tr></table></figure>\n\n<p>当用于内置类型的变量时，如果列表初始化存在丢失信息的风险，则编译器将报错：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">double</span> ld = <span class=\"number\">3.1415026536</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> a&#123;ld&#125;, b = &#123;ld&#125;; <span class=\"comment\">// 列表初始化，报错，转换未执行，因为存在丢失信息（精度）的风险</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">c</span><span class=\"params\">(ld)</span>, d </span>= ld; <span class=\"comment\">// 正常，转换执行，虽然确实丢失了精度</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-值初始化-vs-默认初始化\"><a href=\"#3-值初始化-vs-默认初始化\" class=\"headerlink\" title=\"3. 值初始化 vs. 默认初始化\"></a>3. 值初始化 vs. 默认初始化</h3><h4 id=\"3-1-值初始化\"><a href=\"#3-1-值初始化\" class=\"headerlink\" title=\"3.1 值初始化\"></a>3.1 值初始化</h4><p>值初始化对于<u>内置类型</u>初始化为 0，对于<u>类类型</u>则调用<u>默认构造函数</u>，如果没有默认构造函数，则不能进行初始化</p>\n<p>如何判断是值初始化：</p>\n<ol>\n<li>使用了初始化器（如，圆括号，花括号）</li>\n<li><strong>没有</strong>提供初始值</li>\n</ol>\n<p>例如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> *p = <span class=\"keyword\">new</span> <span class=\"built_in\"><span class=\"keyword\">int</span></span>();</span><br><span class=\"line\"><span class=\"function\">vector&lt;string&gt; <span class=\"title\">vec</span><span class=\"params\">(<span class=\"number\">10</span>)</span></span>;  <span class=\"comment\">// 10表示个数</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>当不采用动态分配内存的方式（即不用<code>new</code>时），<code>int a()</code>是错误的值初始化方式，因为它会<u>被理解为一个函数的声明</u>，而不是值初始化</p>\n<p>正确的初始化方式：<code>int a = int();</code></p>\n</blockquote>\n<h4 id=\"3-2-默认初始化\"><a href=\"#3-2-默认初始化\" class=\"headerlink\" title=\"3.2 默认初始化\"></a>3.2 默认初始化</h4><p>如果<strong>定义变量</strong>的时候<strong>没有指定初值</strong>，则变量被<strong>默认初始化（default initialized）</strong>，此时变量被赋予“<strong>默认值</strong>”</p>\n<blockquote>\n<p> <strong>默认值到底是什么？</strong></p>\n<p> （1）内置类型</p>\n<p> 由定义的位置决定：</p>\n<ol>\n<li><strong>任何函数之外</strong>的变量，它被初始化为 0</li>\n<li><strong>在函数体内部</strong>，将<strong>不被初始化</strong>，其值是<strong>未定义</strong>的，是<strong>不能被访问</strong>的</li>\n</ol>\n<p> （2）类对象</p>\n<p> <strong>类自己决定</strong>其变量的<strong>初始化方式</strong>、<strong>初始化值</strong>、<strong>是否允许不经初始化变量就定义出对象</strong></p>\n<p> 绝大多数类都支持<strong>无须显示初始化而定义对象</strong>，它会给没有初始化的<strong>类内变量</strong>提供一个合适的<strong>默认值</strong></p>\n <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::string empty; <span class=\"comment\">// 默认值为空串</span></span><br><span class=\"line\">Sales_item item; <span class=\"comment\">// item的默认值是什么，由 Sales_item 这个类自己定义</span></span><br></pre></td></tr></table></figure>\n\n<p> 一些类要求每个对象都显示初始化， 如果没有就会报错</p>\n</blockquote>\n<h3 id=\"4-直接初始化-vs-拷贝初始化\"><a href=\"#4-直接初始化-vs-拷贝初始化\" class=\"headerlink\" title=\"4. 直接初始化 vs. 拷贝初始化\"></a>4. 直接初始化 vs. 拷贝初始化</h3><p>直接初始化：要求编译器使用<strong>普通的函数匹配</strong>，选择与我们提供的参数<strong>最匹配</strong>的构造函数（也可能最佳匹配上<strong>拷构</strong>）</p>\n<p>拷贝初始化：要求编译器将<strong>右侧运算对象</strong>拷贝到正在创建的对象中，需要的话可以进行类型转换</p>\n<blockquote>\n<p><strong>拷贝初始化</strong>一般调用<strong>拷贝构造函数</strong>，但也可能调用<strong>移动构造函数</strong></p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string dots(10, &#x27;.&#x27;);   //直初</span><br><span class=\"line\">string s(dots);  \t\t//使用了拷构的直初</span><br><span class=\"line\">string s = dots; \t\t//拷初</span><br><span class=\"line\">string null_book = &quot;9999&quot;;  //拷初</span><br><span class=\"line\">string nines = string(100, &#x27;9&#x27;); //拷初</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>哪里有临时量生成？ 拷初的参数是 <code>const&amp;</code> 肯定没有临时量</p>\n</blockquote>\n<p>发生拷初的常见情况</p>\n<ol>\n<li><code>=</code></li>\n<li>非引用函数传参</li>\n<li>非引用函数返回值</li>\n</ol>\n<h3 id=\"5-数组的初始化\"><a href=\"#5-数组的初始化\" class=\"headerlink\" title=\"5. 数组的初始化\"></a>5. 数组的初始化</h3><h4 id=\"5-1-数组的初始化规则\"><a href=\"#5-1-数组的初始化规则\" class=\"headerlink\" title=\"5.1 数组的初始化规则\"></a>5.1 数组的初始化规则</h4><ol>\n<li>只有在定义数组的时候才能使用初始化，以后就不能使用了</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> cards[<span class=\"number\">4</span>] = &#123;<span class=\"number\">3</span>,<span class=\"number\">6</span>,<span class=\"number\">8</span>,<span class=\"number\">10</span>&#125;; <span class=\"comment\">//okay</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> hand[<span class=\"number\">4</span>];</span><br><span class=\"line\">hand[<span class=\"number\">4</span>] = &#123;<span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>&#125;; <span class=\"comment\">//not allowed，可以使用下标一一赋值</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>不允许数组间赋值</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hand = cards; <span class=\"comment\">// not allowed</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>允许部分初始化，剩余的默认采用<u>值初始化</u></li>\n</ol>\n<h4 id=\"5-2-c-11新特性\"><a href=\"#5-2-c-11新特性\" class=\"headerlink\" title=\"5.2 c++11新特性\"></a>5.2 c++11新特性</h4><h4 id=\"列表初始化新特性\"><a href=\"#列表初始化新特性\" class=\"headerlink\" title=\"列表初始化新特性\"></a>列表初始化新特性</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">double</span> earnings[<span class=\"number\">4</span>] &#123;<span class=\"number\">1.2e4</span>, <span class=\"number\">1.6e4</span>&#125;; <span class=\"comment\">// 列表初始化，省略等号是可以的</span></span><br><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> counts[<span class=\"number\">10</span>] = &#123;&#125;; <span class=\"comment\">//所有10个元素都为0</span></span><br><span class=\"line\"><span class=\"keyword\">long</span> plifs[] = &#123;<span class=\"number\">25</span>, <span class=\"number\">92</span>, <span class=\"number\">3.0</span>&#125;; <span class=\"comment\">//报错，列表初始化禁止缩窄转换</span></span><br></pre></td></tr></table></figure>\n\n<p>关于<code>缩窄转换</code><a href=\"https://blog.csdn.net/dai_peixian/article/details/52767057\">C++11 narrowing convertions(缩窄转换)_dai_peixian的专栏-CSDN博客_缩窄转换</a></p>\n<h3 id=\"6-string初始化【6，7都是顺序容器，初始化可以放到一起】\"><a href=\"#6-string初始化【6，7都是顺序容器，初始化可以放到一起】\" class=\"headerlink\" title=\"6. string初始化【6，7都是顺序容器，初始化可以放到一起】\"></a>6. string初始化【6，7都是顺序容器，初始化可以放到一起】</h3><p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211109100945293.png\" alt=\"初始化string\"></p>\n<center style=\"color:#C0C0C0;text-decoration:underline\">Primer C++ 第五版，P76</center>\n\n<h3 id=\"7-vector初始化【】\"><a href=\"#7-vector初始化【】\" class=\"headerlink\" title=\"7. vector初始化【】\"></a>7. vector初始化【】</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;T&gt; v1;    <span class=\"comment\">// 空vector，默认初始化</span></span><br><span class=\"line\"><span class=\"function\">vector&lt;T&gt; <span class=\"title\">v2</span><span class=\"params\">(v1)</span></span>; <span class=\"comment\">//拷贝初始化，要求两个vector对象的类型必须相同</span></span><br><span class=\"line\">vector&lt;T&gt; v2 = v1; <span class=\"comment\">//同上</span></span><br><span class=\"line\"><span class=\"function\">vector&lt;T&gt; <span class=\"title\">v3</span><span class=\"params\">(n,val)</span></span>; <span class=\"comment\">// v3包含n个重复元素，每个元素的值都是val</span></span><br><span class=\"line\"><span class=\"function\">vector&lt;T&gt; <span class=\"title\">v4</span><span class=\"params\">(n)</span></span>; <span class=\"comment\">// v4包含n个元素，每个元素都被值初始化（如果是内置类型，0，如果是类类型，则执行类定义默认初始化）</span></span><br><span class=\"line\">vector&lt;T&gt; v5&#123;a,b,c...&#125; <span class=\"comment\">//列表初始化</span></span><br><span class=\"line\">vector&lt;T&gt; v6 = &#123;a,b,c...&#125; <span class=\"comment\">//同上 </span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>如果使用了花括号，但是提供的值不能用来完成列表初始化，编译器就会考虑用提供的值来构造 vector 对象</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;string&gt; v7&#123;<span class=\"number\">10</span>&#125;;  <span class=\"comment\">//v7有10个默认初始化元素</span></span><br><span class=\"line\">vector&lt;string&gt; v8&#123;<span class=\"number\">10</span>, <span class=\"string\">&quot;hi&quot;</span>&#125;; <span class=\"comment\">//v8 有10个值为&quot;hi&quot;的元素</span></span><br></pre></td></tr></table></figure>\n</blockquote>\n<h3 id=\"8\"><a href=\"#8\" class=\"headerlink\" title=\"8.\"></a>8.</h3>"},{"_content":"常量，例如5， \"abc\"，等，肯定是只读的，因为常量是被编译器放在内存中的只读区域，当然也就不能够去修改它。而“只读变量”则是在内存中开辟一个地方来存放它的值，只不过这个值由编译器限定不允许被修改。C语言关键字const就是用来限定一个变量不允许被改变的修饰符（Qualifier）。        \n\n  为什么下面的例子在使用一个const变量来初始化数组，ANSI C的编译器会报告一个错误呢？\n const int n = 5;\n int a[n];\n\n   上述代码中变量n被修饰为只读变量，可惜再怎么修饰也不是常量。而ANSI C规定数组定义时长度必须是“常量”，“只读变量”也是不可以的，“常量”不等于“不可变的变量”。但是在C++中，局部数组是可以使用变量作为其长度的。\n\n   常量,用 enum类型和#define宏来定义.只读变量用const来定义;\n   而所有宏定义、枚举常数、只读变量全用大写字母命名，用下划线分割单词。例如：\nconst int MAX_LENGTH = 100; //这不是常量，而是一个只读变量\n#define FILE_PATH “/usr/tmp”.\n\n原文链接：https://blog.csdn.net/xin_mingtian/article/details/46997929","source":"_posts/C++/只读变量与常量的关系.md","raw":"常量，例如5， \"abc\"，等，肯定是只读的，因为常量是被编译器放在内存中的只读区域，当然也就不能够去修改它。而“只读变量”则是在内存中开辟一个地方来存放它的值，只不过这个值由编译器限定不允许被修改。C语言关键字const就是用来限定一个变量不允许被改变的修饰符（Qualifier）。        \n\n  为什么下面的例子在使用一个const变量来初始化数组，ANSI C的编译器会报告一个错误呢？\n const int n = 5;\n int a[n];\n\n   上述代码中变量n被修饰为只读变量，可惜再怎么修饰也不是常量。而ANSI C规定数组定义时长度必须是“常量”，“只读变量”也是不可以的，“常量”不等于“不可变的变量”。但是在C++中，局部数组是可以使用变量作为其长度的。\n\n   常量,用 enum类型和#define宏来定义.只读变量用const来定义;\n   而所有宏定义、枚举常数、只读变量全用大写字母命名，用下划线分割单词。例如：\nconst int MAX_LENGTH = 100; //这不是常量，而是一个只读变量\n#define FILE_PATH “/usr/tmp”.\n\n原文链接：https://blog.csdn.net/xin_mingtian/article/details/46997929","slug":"C++/只读变量与常量的关系","published":1,"date":"2022-03-10T07:05:26.923Z","updated":"2022-03-10T04:12:31.869Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0kwh0005pcu3733d16de","content":"<p>常量，例如5， “abc”，等，肯定是只读的，因为常量是被编译器放在内存中的只读区域，当然也就不能够去修改它。而“只读变量”则是在内存中开辟一个地方来存放它的值，只不过这个值由编译器限定不允许被修改。C语言关键字const就是用来限定一个变量不允许被改变的修饰符（Qualifier）。        </p>\n<p>  为什么下面的例子在使用一个const变量来初始化数组，ANSI C的编译器会报告一个错误呢？<br> const int n = 5;<br> int a[n];</p>\n<p>   上述代码中变量n被修饰为只读变量，可惜再怎么修饰也不是常量。而ANSI C规定数组定义时长度必须是“常量”，“只读变量”也是不可以的，“常量”不等于“不可变的变量”。但是在C++中，局部数组是可以使用变量作为其长度的。</p>\n<p>   常量,用 enum类型和#define宏来定义.只读变量用const来定义;<br>   而所有宏定义、枚举常数、只读变量全用大写字母命名，用下划线分割单词。例如：<br>const int MAX_LENGTH = 100; //这不是常量，而是一个只读变量<br>#define FILE_PATH “/usr/tmp”.</p>\n<p>原文链接：<a href=\"https://blog.csdn.net/xin_mingtian/article/details/46997929\">https://blog.csdn.net/xin_mingtian/article/details/46997929</a></p>\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<p>常量，例如5， “abc”，等，肯定是只读的，因为常量是被编译器放在内存中的只读区域，当然也就不能够去修改它。而“只读变量”则是在内存中开辟一个地方来存放它的值，只不过这个值由编译器限定不允许被修改。C语言关键字const就是用来限定一个变量不允许被改变的修饰符（Qualifier）。        </p>\n<p>  为什么下面的例子在使用一个const变量来初始化数组，ANSI C的编译器会报告一个错误呢？<br> const int n = 5;<br> int a[n];</p>\n<p>   上述代码中变量n被修饰为只读变量，可惜再怎么修饰也不是常量。而ANSI C规定数组定义时长度必须是“常量”，“只读变量”也是不可以的，“常量”不等于“不可变的变量”。但是在C++中，局部数组是可以使用变量作为其长度的。</p>\n<p>   常量,用 enum类型和#define宏来定义.只读变量用const来定义;<br>   而所有宏定义、枚举常数、只读变量全用大写字母命名，用下划线分割单词。例如：<br>const int MAX_LENGTH = 100; //这不是常量，而是一个只读变量<br>#define FILE_PATH “/usr/tmp”.</p>\n<p>原文链接：<a href=\"https://blog.csdn.net/xin_mingtian/article/details/46997929\">https://blog.csdn.net/xin_mingtian/article/details/46997929</a></p>\n"},{"_content":"### 回调函数\n\n学习回调函数的基础是**函数指针**，你还要搞清楚回调函数的**应用场景**。\n\n[函数指针](./函数指针.md)\n\n一个回调函数的例子，不明白为什么会出错，先挖【坑】\n\n```c++\n#include <iostream>\nusing namespace std;\n\ntypedef void (*ff)(char);\n\nvoid ftest1(ff) {\n\tcout << \"ftest1 is called!\" << endl;\n\tchar y = 'a';\n\tff(y);\n}\n\nvoid ftest2(char a)\n{\n\tcout << \"ftest2 is called!\" << endl;\n}\n\nint main(int argc, char** argv) {\n\tftest1(ftest2);\n\treturn 0;\n}\n```\n\n\n","source":"_posts/C++/回调函数.md","raw":"### 回调函数\n\n学习回调函数的基础是**函数指针**，你还要搞清楚回调函数的**应用场景**。\n\n[函数指针](./函数指针.md)\n\n一个回调函数的例子，不明白为什么会出错，先挖【坑】\n\n```c++\n#include <iostream>\nusing namespace std;\n\ntypedef void (*ff)(char);\n\nvoid ftest1(ff) {\n\tcout << \"ftest1 is called!\" << endl;\n\tchar y = 'a';\n\tff(y);\n}\n\nvoid ftest2(char a)\n{\n\tcout << \"ftest2 is called!\" << endl;\n}\n\nint main(int argc, char** argv) {\n\tftest1(ftest2);\n\treturn 0;\n}\n```\n\n\n","slug":"C++/回调函数","published":1,"date":"2021-12-31T02:09:01.490Z","updated":"2021-12-03T12:29:04.046Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0kwj0006pcu38j9jev14","content":"<h3 id=\"回调函数\"><a href=\"#回调函数\" class=\"headerlink\" title=\"回调函数\"></a>回调函数</h3><p>学习回调函数的基础是<strong>函数指针</strong>，你还要搞清楚回调函数的<strong>应用场景</strong>。</p>\n<p><a href=\"./%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88.md\">函数指针</a></p>\n<p>一个回调函数的例子，不明白为什么会出错，先挖【坑】</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">void</span> <span class=\"params\">(*ff)</span><span class=\"params\">(<span class=\"keyword\">char</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ftest1</span><span class=\"params\">(ff)</span> </span>&#123;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;ftest1 is called!&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> y = <span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">ff</span>(y);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ftest2</span><span class=\"params\">(<span class=\"keyword\">char</span> a)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;ftest2 is called!&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">ftest1</span>(ftest2);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<h3 id=\"回调函数\"><a href=\"#回调函数\" class=\"headerlink\" title=\"回调函数\"></a>回调函数</h3><p>学习回调函数的基础是<strong>函数指针</strong>，你还要搞清楚回调函数的<strong>应用场景</strong>。</p>\n<p><a href=\"./%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88.md\">函数指针</a></p>\n<p>一个回调函数的例子，不明白为什么会出错，先挖【坑】</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">void</span> <span class=\"params\">(*ff)</span><span class=\"params\">(<span class=\"keyword\">char</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ftest1</span><span class=\"params\">(ff)</span> </span>&#123;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;ftest1 is called!&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> y = <span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">ff</span>(y);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ftest2</span><span class=\"params\">(<span class=\"keyword\">char</span> a)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;ftest2 is called!&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">ftest1</span>(ftest2);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n"},{"_content":"","source":"_posts/C#/delegate委托.md","raw":"","slug":"C#/delegate委托","published":1,"date":"2022-05-10T04:08:25.887Z","updated":"2022-05-10T04:08:46.946Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0kwk0007pcu36o143sn9","content":"","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":""},{"_content":"#### 1. ref 和 out\n\nref关键字通过引用传递变量，在声明方法和调用方法时，都要加ref关键字，变量传递给方法之前必须先做初始化\n\n使用out关键字可以实现让方法返回多个值\n\n```c#\npublic static bool TryParse(string s, out int result);\n```\n\nTryParse的返回值有一个bool值，指明解析是否成功，如果解析成功，还会有第二个返回值，即解析的结果result\n\nresult在传递给方法之前不需要预先初始化\n\n和ref类似，在声明方法和调用方法时都要加out\n\n> 这里的out int result也是引用传递，但是ref和out的应用场景是不一样的，**ref** 用在需要传引用时，**out** 用在需要返回多个值时\n\n","source":"_posts/C#/ref和out.md","raw":"#### 1. ref 和 out\n\nref关键字通过引用传递变量，在声明方法和调用方法时，都要加ref关键字，变量传递给方法之前必须先做初始化\n\n使用out关键字可以实现让方法返回多个值\n\n```c#\npublic static bool TryParse(string s, out int result);\n```\n\nTryParse的返回值有一个bool值，指明解析是否成功，如果解析成功，还会有第二个返回值，即解析的结果result\n\nresult在传递给方法之前不需要预先初始化\n\n和ref类似，在声明方法和调用方法时都要加out\n\n> 这里的out int result也是引用传递，但是ref和out的应用场景是不一样的，**ref** 用在需要传引用时，**out** 用在需要返回多个值时\n\n","slug":"C#/ref和out","published":1,"date":"2022-05-10T03:27:36.938Z","updated":"2022-05-10T04:08:48.809Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0kwm0008pcu39a9a2rkg","content":"<h4 id=\"1-ref-和-out\"><a href=\"#1-ref-和-out\" class=\"headerlink\" title=\"1. ref 和 out\"></a>1. ref 和 out</h4><p>ref关键字通过引用传递变量，在声明方法和调用方法时，都要加ref关键字，变量传递给方法之前必须先做初始化</p>\n<p>使用out关键字可以实现让方法返回多个值</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static bool TryParse(string s, out int result);</span><br></pre></td></tr></table></figure>\n\n<p>TryParse的返回值有一个bool值，指明解析是否成功，如果解析成功，还会有第二个返回值，即解析的结果result</p>\n<p>result在传递给方法之前不需要预先初始化</p>\n<p>和ref类似，在声明方法和调用方法时都要加out</p>\n<blockquote>\n<p>这里的out int result也是引用传递，但是ref和out的应用场景是不一样的，<strong>ref</strong> 用在需要传引用时，<strong>out</strong> 用在需要返回多个值时</p>\n</blockquote>\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<h4 id=\"1-ref-和-out\"><a href=\"#1-ref-和-out\" class=\"headerlink\" title=\"1. ref 和 out\"></a>1. ref 和 out</h4><p>ref关键字通过引用传递变量，在声明方法和调用方法时，都要加ref关键字，变量传递给方法之前必须先做初始化</p>\n<p>使用out关键字可以实现让方法返回多个值</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static bool TryParse(string s, out int result);</span><br></pre></td></tr></table></figure>\n\n<p>TryParse的返回值有一个bool值，指明解析是否成功，如果解析成功，还会有第二个返回值，即解析的结果result</p>\n<p>result在传递给方法之前不需要预先初始化</p>\n<p>和ref类似，在声明方法和调用方法时都要加out</p>\n<blockquote>\n<p>这里的out int result也是引用传递，但是ref和out的应用场景是不一样的，<strong>ref</strong> 用在需要传引用时，<strong>out</strong> 用在需要返回多个值时</p>\n</blockquote>\n"},{"_content":"参考：Unity Shader入门精要，第四章\n\n4.6.4 模型空间\n\n每个模型都有自己的模型空间，当模型移动或旋转时，模型空间也会跟着它移动和旋转。模型空间的原点和坐标轴都是由美术人员在建模软件里预设好的，模型空间中的每个顶点坐标都是相对于模型空间的原点（通常位于模型的重心）定义的\n\n4.6.5 世界空间\n\n可以理解为模型根节点的父坐标系。<u>模型变换矩阵</u>将点从模型空间变换到世界空间 ，其构成是模型空间中跟节点的Transform\n\n","source":"_posts/图形学&游戏开发/MVP变换总结.md","raw":"参考：Unity Shader入门精要，第四章\n\n4.6.4 模型空间\n\n每个模型都有自己的模型空间，当模型移动或旋转时，模型空间也会跟着它移动和旋转。模型空间的原点和坐标轴都是由美术人员在建模软件里预设好的，模型空间中的每个顶点坐标都是相对于模型空间的原点（通常位于模型的重心）定义的\n\n4.6.5 世界空间\n\n可以理解为模型根节点的父坐标系。<u>模型变换矩阵</u>将点从模型空间变换到世界空间 ，其构成是模型空间中跟节点的Transform\n\n","slug":"图形学&游戏开发/MVP变换总结","published":1,"date":"2022-04-09T14:13:07.265Z","updated":"2022-04-09T14:29:22.377Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0kwo0009pcu34c3seols","content":"<p>参考：Unity Shader入门精要，第四章</p>\n<p>4.6.4 模型空间</p>\n<p>每个模型都有自己的模型空间，当模型移动或旋转时，模型空间也会跟着它移动和旋转。模型空间的原点和坐标轴都是由美术人员在建模软件里预设好的，模型空间中的每个顶点坐标都是相对于模型空间的原点（通常位于模型的重心）定义的</p>\n<p>4.6.5 世界空间</p>\n<p>可以理解为模型根节点的父坐标系。<u>模型变换矩阵</u>将点从模型空间变换到世界空间 ，其构成是模型空间中跟节点的Transform</p>\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<p>参考：Unity Shader入门精要，第四章</p>\n<p>4.6.4 模型空间</p>\n<p>每个模型都有自己的模型空间，当模型移动或旋转时，模型空间也会跟着它移动和旋转。模型空间的原点和坐标轴都是由美术人员在建模软件里预设好的，模型空间中的每个顶点坐标都是相对于模型空间的原点（通常位于模型的重心）定义的</p>\n<p>4.6.5 世界空间</p>\n<p>可以理解为模型根节点的父坐标系。<u>模型变换矩阵</u>将点从模型空间变换到世界空间 ，其构成是模型空间中跟节点的Transform</p>\n"},{"_content":"z-early\n\n原来是在片段着色器之后进行深度测试，但是片段着色器进行光照的计算会有比较大的开销，如果将开销耗费在一个在未来的深度测试中将被抛弃的片元，很不合理\n\n所以z-early就是为了解决这个问题，将深度测试提前到片段着色器之前进行\n\nz-early的不足之处\n\n避免过度绘制的效果不稳定，如果绘制顺序是由远及近的话，z-early也无法避免过度绘制\n\n","source":"_posts/图形学&游戏开发/z-early.md","raw":"z-early\n\n原来是在片段着色器之后进行深度测试，但是片段着色器进行光照的计算会有比较大的开销，如果将开销耗费在一个在未来的深度测试中将被抛弃的片元，很不合理\n\n所以z-early就是为了解决这个问题，将深度测试提前到片段着色器之前进行\n\nz-early的不足之处\n\n避免过度绘制的效果不稳定，如果绘制顺序是由远及近的话，z-early也无法避免过度绘制\n\n","slug":"图形学&游戏开发/z-early","published":1,"date":"2022-05-05T03:14:01.506Z","updated":"2022-05-13T06:58:39.919Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0kwp000apcu32h92gvhj","content":"<p>z-early</p>\n<p>原来是在片段着色器之后进行深度测试，但是片段着色器进行光照的计算会有比较大的开销，如果将开销耗费在一个在未来的深度测试中将被抛弃的片元，很不合理</p>\n<p>所以z-early就是为了解决这个问题，将深度测试提前到片段着色器之前进行</p>\n<p>z-early的不足之处</p>\n<p>避免过度绘制的效果不稳定，如果绘制顺序是由远及近的话，z-early也无法避免过度绘制</p>\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<p>z-early</p>\n<p>原来是在片段着色器之后进行深度测试，但是片段着色器进行光照的计算会有比较大的开销，如果将开销耗费在一个在未来的深度测试中将被抛弃的片元，很不合理</p>\n<p>所以z-early就是为了解决这个问题，将深度测试提前到片段着色器之前进行</p>\n<p>z-early的不足之处</p>\n<p>避免过度绘制的效果不稳定，如果绘制顺序是由远及近的话，z-early也无法避免过度绘制</p>\n"},{"_content":"shadowMap\n\n第一个阶段，把光源当作一个摄像机去渲染一遍场景，然后将光源能照到的点的深度值存储在一张纹理上， 称为shadow map\n\n![image-20220513101640352](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220513101640352.png)\n\n第二个阶段，从相机视角渲染场景，并利用光源视角下的投影矩阵的逆矩阵，将坐标从世界空间转换到光源空间【如果要逆转换，不应该用view矩阵的逆吗？怎么这里说是投影矩阵的逆？】得到光源空间下的坐标和深度值，前者可以用来对shadow map进行查询，后者可以用来和shadow map上的值进行比较，如果该点投影回光源视角的实际深度值大于在shadow map上对应的深度值，说明该点无法被光源照亮，处在阴影\n\n渲染方程的改变：\n\n![image-20220418103352469](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220418103352469.png)\n\nGAMES202中主要实现的函数：\n\n- DirectionalLight.js中的CalcLightMVP(translate, scale)函数\n- phongFragment.glsl中的useShadowMap\n- PCF\n- PCSS\n- main\n\nshadowMap是一个uniform变量，不知道是怎么得到的\n\n代码的实现是在已知shadowMap的基础之上进行的实现\n\n## 0x01 CalcLightMVP(translate, scale)\n\n利用给出的translate，scale，光线有关参数（lightPos、focalPoint、lightUp）得出MVP矩阵\n\n## 0x02 useShadowMap(sampler2D shadowMap, vec4 shadowCoord)\n\nshadowCoord是已经转换到light空间的点坐标，所以可以用其z坐标和shadowMap上的对应值做比较，如果是阴影，则visibility=0.0，可见则visibility=1.0\n\n## 0x03 PCF\n\n阴影抗锯齿，用shadowMap上的对应像素周围的多个像素，和shadowCoord.z做比较，比较结果从简单的0，1，变成了0~1之间的值，例如9次比较，6次为1，则visibility为6/9=0.667，可以在阴影边缘处实现抗锯齿的效果，进一步可以模拟软阴影\n\n## 0x04 PCSS\n\n在shadowMap取多大的范围来一起作比较，添加两个因素来调节这个范围，遮挡物到光源的距离和光源的大小\n\n可以实现，近处的阴影偏硬，远处的阴影偏软\n\n","source":"_posts/图形学&游戏开发/shadow mapping.md","raw":"shadowMap\n\n第一个阶段，把光源当作一个摄像机去渲染一遍场景，然后将光源能照到的点的深度值存储在一张纹理上， 称为shadow map\n\n![image-20220513101640352](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220513101640352.png)\n\n第二个阶段，从相机视角渲染场景，并利用光源视角下的投影矩阵的逆矩阵，将坐标从世界空间转换到光源空间【如果要逆转换，不应该用view矩阵的逆吗？怎么这里说是投影矩阵的逆？】得到光源空间下的坐标和深度值，前者可以用来对shadow map进行查询，后者可以用来和shadow map上的值进行比较，如果该点投影回光源视角的实际深度值大于在shadow map上对应的深度值，说明该点无法被光源照亮，处在阴影\n\n渲染方程的改变：\n\n![image-20220418103352469](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220418103352469.png)\n\nGAMES202中主要实现的函数：\n\n- DirectionalLight.js中的CalcLightMVP(translate, scale)函数\n- phongFragment.glsl中的useShadowMap\n- PCF\n- PCSS\n- main\n\nshadowMap是一个uniform变量，不知道是怎么得到的\n\n代码的实现是在已知shadowMap的基础之上进行的实现\n\n## 0x01 CalcLightMVP(translate, scale)\n\n利用给出的translate，scale，光线有关参数（lightPos、focalPoint、lightUp）得出MVP矩阵\n\n## 0x02 useShadowMap(sampler2D shadowMap, vec4 shadowCoord)\n\nshadowCoord是已经转换到light空间的点坐标，所以可以用其z坐标和shadowMap上的对应值做比较，如果是阴影，则visibility=0.0，可见则visibility=1.0\n\n## 0x03 PCF\n\n阴影抗锯齿，用shadowMap上的对应像素周围的多个像素，和shadowCoord.z做比较，比较结果从简单的0，1，变成了0~1之间的值，例如9次比较，6次为1，则visibility为6/9=0.667，可以在阴影边缘处实现抗锯齿的效果，进一步可以模拟软阴影\n\n## 0x04 PCSS\n\n在shadowMap取多大的范围来一起作比较，添加两个因素来调节这个范围，遮挡物到光源的距离和光源的大小\n\n可以实现，近处的阴影偏硬，远处的阴影偏软\n\n","slug":"图形学&游戏开发/shadow mapping","published":1,"date":"2022-04-18T02:18:20.591Z","updated":"2022-05-13T02:34:15.030Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0kwt000bpcu31aewd33k","content":"<p>shadowMap</p>\n<p>第一个阶段，把光源当作一个摄像机去渲染一遍场景，然后将光源能照到的点的深度值存储在一张纹理上， 称为shadow map</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220513101640352.png\" alt=\"image-20220513101640352\"></p>\n<p>第二个阶段，从相机视角渲染场景，并利用光源视角下的投影矩阵的逆矩阵，将坐标从世界空间转换到光源空间【如果要逆转换，不应该用view矩阵的逆吗？怎么这里说是投影矩阵的逆？】得到光源空间下的坐标和深度值，前者可以用来对shadow map进行查询，后者可以用来和shadow map上的值进行比较，如果该点投影回光源视角的实际深度值大于在shadow map上对应的深度值，说明该点无法被光源照亮，处在阴影</p>\n<p>渲染方程的改变：</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220418103352469.png\" alt=\"image-20220418103352469\"></p>\n<p>GAMES202中主要实现的函数：</p>\n<ul>\n<li>DirectionalLight.js中的CalcLightMVP(translate, scale)函数</li>\n<li>phongFragment.glsl中的useShadowMap</li>\n<li>PCF</li>\n<li>PCSS</li>\n<li>main</li>\n</ul>\n<p>shadowMap是一个uniform变量，不知道是怎么得到的</p>\n<p>代码的实现是在已知shadowMap的基础之上进行的实现</p>\n<h2 id=\"0x01-CalcLightMVP-translate-scale\"><a href=\"#0x01-CalcLightMVP-translate-scale\" class=\"headerlink\" title=\"0x01 CalcLightMVP(translate, scale)\"></a>0x01 CalcLightMVP(translate, scale)</h2><p>利用给出的translate，scale，光线有关参数（lightPos、focalPoint、lightUp）得出MVP矩阵</p>\n<h2 id=\"0x02-useShadowMap-sampler2D-shadowMap-vec4-shadowCoord\"><a href=\"#0x02-useShadowMap-sampler2D-shadowMap-vec4-shadowCoord\" class=\"headerlink\" title=\"0x02 useShadowMap(sampler2D shadowMap, vec4 shadowCoord)\"></a>0x02 useShadowMap(sampler2D shadowMap, vec4 shadowCoord)</h2><p>shadowCoord是已经转换到light空间的点坐标，所以可以用其z坐标和shadowMap上的对应值做比较，如果是阴影，则visibility=0.0，可见则visibility=1.0</p>\n<h2 id=\"0x03-PCF\"><a href=\"#0x03-PCF\" class=\"headerlink\" title=\"0x03 PCF\"></a>0x03 PCF</h2><p>阴影抗锯齿，用shadowMap上的对应像素周围的多个像素，和shadowCoord.z做比较，比较结果从简单的0，1，变成了0~1之间的值，例如9次比较，6次为1，则visibility为6/9=0.667，可以在阴影边缘处实现抗锯齿的效果，进一步可以模拟软阴影</p>\n<h2 id=\"0x04-PCSS\"><a href=\"#0x04-PCSS\" class=\"headerlink\" title=\"0x04 PCSS\"></a>0x04 PCSS</h2><p>在shadowMap取多大的范围来一起作比较，添加两个因素来调节这个范围，遮挡物到光源的距离和光源的大小</p>\n<p>可以实现，近处的阴影偏硬，远处的阴影偏软</p>\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<p>shadowMap</p>\n<p>第一个阶段，把光源当作一个摄像机去渲染一遍场景，然后将光源能照到的点的深度值存储在一张纹理上， 称为shadow map</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220513101640352.png\" alt=\"image-20220513101640352\"></p>\n<p>第二个阶段，从相机视角渲染场景，并利用光源视角下的投影矩阵的逆矩阵，将坐标从世界空间转换到光源空间【如果要逆转换，不应该用view矩阵的逆吗？怎么这里说是投影矩阵的逆？】得到光源空间下的坐标和深度值，前者可以用来对shadow map进行查询，后者可以用来和shadow map上的值进行比较，如果该点投影回光源视角的实际深度值大于在shadow map上对应的深度值，说明该点无法被光源照亮，处在阴影</p>\n<p>渲染方程的改变：</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220418103352469.png\" alt=\"image-20220418103352469\"></p>\n<p>GAMES202中主要实现的函数：</p>\n<ul>\n<li>DirectionalLight.js中的CalcLightMVP(translate, scale)函数</li>\n<li>phongFragment.glsl中的useShadowMap</li>\n<li>PCF</li>\n<li>PCSS</li>\n<li>main</li>\n</ul>\n<p>shadowMap是一个uniform变量，不知道是怎么得到的</p>\n<p>代码的实现是在已知shadowMap的基础之上进行的实现</p>\n<h2 id=\"0x01-CalcLightMVP-translate-scale\"><a href=\"#0x01-CalcLightMVP-translate-scale\" class=\"headerlink\" title=\"0x01 CalcLightMVP(translate, scale)\"></a>0x01 CalcLightMVP(translate, scale)</h2><p>利用给出的translate，scale，光线有关参数（lightPos、focalPoint、lightUp）得出MVP矩阵</p>\n<h2 id=\"0x02-useShadowMap-sampler2D-shadowMap-vec4-shadowCoord\"><a href=\"#0x02-useShadowMap-sampler2D-shadowMap-vec4-shadowCoord\" class=\"headerlink\" title=\"0x02 useShadowMap(sampler2D shadowMap, vec4 shadowCoord)\"></a>0x02 useShadowMap(sampler2D shadowMap, vec4 shadowCoord)</h2><p>shadowCoord是已经转换到light空间的点坐标，所以可以用其z坐标和shadowMap上的对应值做比较，如果是阴影，则visibility=0.0，可见则visibility=1.0</p>\n<h2 id=\"0x03-PCF\"><a href=\"#0x03-PCF\" class=\"headerlink\" title=\"0x03 PCF\"></a>0x03 PCF</h2><p>阴影抗锯齿，用shadowMap上的对应像素周围的多个像素，和shadowCoord.z做比较，比较结果从简单的0，1，变成了0~1之间的值，例如9次比较，6次为1，则visibility为6/9=0.667，可以在阴影边缘处实现抗锯齿的效果，进一步可以模拟软阴影</p>\n<h2 id=\"0x04-PCSS\"><a href=\"#0x04-PCSS\" class=\"headerlink\" title=\"0x04 PCSS\"></a>0x04 PCSS</h2><p>在shadowMap取多大的范围来一起作比较，添加两个因素来调节这个范围，遮挡物到光源的距离和光源的大小</p>\n<p>可以实现，近处的阴影偏硬，远处的阴影偏软</p>\n"},{"_content":"https://gameinstitute.qq.com/course/detail/10255\n\n##### 1. 点到直线的距离\n\n##### 2. 点到线段的距离\n\n##### 3. 点到平面的距离\n\n##### 4. 点到三角形的最近点\n\n4.1 二维情况下\n\n利用三角形把平面分成7个区域，然后看点落在哪个区域，分类讨论\n\n##### 5. 点到四面体的最近点\n\n##### 6. 凸包与凸包之间的最短距离\n\n","source":"_posts/图形学&游戏开发/《游戏常用几何学》课程笔记.md","raw":"https://gameinstitute.qq.com/course/detail/10255\n\n##### 1. 点到直线的距离\n\n##### 2. 点到线段的距离\n\n##### 3. 点到平面的距离\n\n##### 4. 点到三角形的最近点\n\n4.1 二维情况下\n\n利用三角形把平面分成7个区域，然后看点落在哪个区域，分类讨论\n\n##### 5. 点到四面体的最近点\n\n##### 6. 凸包与凸包之间的最短距离\n\n","slug":"图形学&游戏开发/《游戏常用几何学》课程笔记","published":1,"date":"2022-04-15T02:49:09.806Z","updated":"2022-04-15T02:57:27.294Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0kwv000cpcu30n5pa3hp","content":"<p><a href=\"https://gameinstitute.qq.com/course/detail/10255\">https://gameinstitute.qq.com/course/detail/10255</a></p>\n<h5 id=\"1-点到直线的距离\"><a href=\"#1-点到直线的距离\" class=\"headerlink\" title=\"1. 点到直线的距离\"></a>1. 点到直线的距离</h5><h5 id=\"2-点到线段的距离\"><a href=\"#2-点到线段的距离\" class=\"headerlink\" title=\"2. 点到线段的距离\"></a>2. 点到线段的距离</h5><h5 id=\"3-点到平面的距离\"><a href=\"#3-点到平面的距离\" class=\"headerlink\" title=\"3. 点到平面的距离\"></a>3. 点到平面的距离</h5><h5 id=\"4-点到三角形的最近点\"><a href=\"#4-点到三角形的最近点\" class=\"headerlink\" title=\"4. 点到三角形的最近点\"></a>4. 点到三角形的最近点</h5><p>4.1 二维情况下</p>\n<p>利用三角形把平面分成7个区域，然后看点落在哪个区域，分类讨论</p>\n<h5 id=\"5-点到四面体的最近点\"><a href=\"#5-点到四面体的最近点\" class=\"headerlink\" title=\"5. 点到四面体的最近点\"></a>5. 点到四面体的最近点</h5><h5 id=\"6-凸包与凸包之间的最短距离\"><a href=\"#6-凸包与凸包之间的最短距离\" class=\"headerlink\" title=\"6. 凸包与凸包之间的最短距离\"></a>6. 凸包与凸包之间的最短距离</h5>","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<p><a href=\"https://gameinstitute.qq.com/course/detail/10255\">https://gameinstitute.qq.com/course/detail/10255</a></p>\n<h5 id=\"1-点到直线的距离\"><a href=\"#1-点到直线的距离\" class=\"headerlink\" title=\"1. 点到直线的距离\"></a>1. 点到直线的距离</h5><h5 id=\"2-点到线段的距离\"><a href=\"#2-点到线段的距离\" class=\"headerlink\" title=\"2. 点到线段的距离\"></a>2. 点到线段的距离</h5><h5 id=\"3-点到平面的距离\"><a href=\"#3-点到平面的距离\" class=\"headerlink\" title=\"3. 点到平面的距离\"></a>3. 点到平面的距离</h5><h5 id=\"4-点到三角形的最近点\"><a href=\"#4-点到三角形的最近点\" class=\"headerlink\" title=\"4. 点到三角形的最近点\"></a>4. 点到三角形的最近点</h5><p>4.1 二维情况下</p>\n<p>利用三角形把平面分成7个区域，然后看点落在哪个区域，分类讨论</p>\n<h5 id=\"5-点到四面体的最近点\"><a href=\"#5-点到四面体的最近点\" class=\"headerlink\" title=\"5. 点到四面体的最近点\"></a>5. 点到四面体的最近点</h5><h5 id=\"6-凸包与凸包之间的最短距离\"><a href=\"#6-凸包与凸包之间的最短距离\" class=\"headerlink\" title=\"6. 凸包与凸包之间的最短距离\"></a>6. 凸包与凸包之间的最短距离</h5>"},{"_content":"# 一、光线追踪（Ray Tracing）\n\n## 1. 为什么需要光线追踪？:star:\n\n1. 光栅化不能很好地处理全局效果（软阴影、光线多次弹射），强行用光栅化处理会比较低效\n\n   > 全局光照：直接光照+间接光照（回想渲染方程）\n\n2. 光栅化比较快，用的是经验模型，是近似的，质量精度比较低，多用来做实时渲染（比较快）。\n\n   光线追踪比较准确，但是会非常慢，更多的被用来做一些离线渲染，比如电影、动画\n\n## 2. 一些假设\n\n## 3. 光线追踪过程\n\n3.1 光线投射\n\n3.2 像素着色\n\n3.3 递归\n\n3.4 着色结果叠加\n\n## 4. 光线求交——数学基础\n\n### 4.1 光线的表示\n\n### 4.2 球体\n\n### 4.3 隐式表面\n\n### 4.4 三角网格\n\n## 5. 光线求交加速\n\n### 5.1 包围盒:star:\n\n### 5.2 均匀网格\n\n### 5.3 空间划分\n\n#### 5.3.1 八叉树（Oct-Tree）\n\n#### 5.3.2 BSP-Tree\n\n#### 5.3.3 KD-Tree\n\n5.3.3.1 KD-Tree的两个缺点：\n\n1. \n2. \n\n### 5.4 物体划分——层次包围盒（BVH）:star:\n\n不是对空间进行划分，而是对物体进行划分\n\n## 6. 辐射度量学\n\n### 6.1 为什么需要辐射度量学？:star:\n\n`Blinn-Phong`只是一种经验模型，而辐射度量学在物理的角度更加严谨\n\n1. 能量Q\n2. 功率，对应于光学中的power，lumen\n\n### 6.2 Radiant Intensity\n\n每个单位立体角的power\n\n整个球的立体角\n\n### 6.3 Irradiance\n\n单位面积的能量\n\n### 6.4 Radiance\n\n## 7. BRDF & 反射方程\n\n### 7.1 BRDF\n\n### 7.2 反射方程\n\n## 8.渲染方程\n\n8.1 渲染方程\n\n8.2 理解渲染方程\n\n## 9. Monte Cralo积分\n\nwhy？\n\n有些复杂积分用黎曼积分解不出来，考虑另外一种积分方法，即Monte Cralo积分，它可以得到一个定积分的近似数值解\n\nwhat？\n\n从特殊情况去理解Monte Cralo积分\n\nhow？\n\n## 10. Path Tracing\n\nwhy?\n\nWhitted-style光线追踪的缺陷：\n\n1. 光线弹射总是按镜面反射规则（没有考虑<u>不同材质的反射</u>）\n2. 光线在漫反射处停止弹射（没有考虑到<u>间接光照</u>）\n\nwhat？\n\npath tracing基于渲染方程，考虑全局光照\n\nhow？\n\n用蒙特卡洛积分求解渲染方程，得到出射方向$\\omega_o$上的能量\n\n考虑间接光照：递归求解\n","source":"_posts/图形学&游戏开发/光线追踪（Ray Tracing）.md","raw":"# 一、光线追踪（Ray Tracing）\n\n## 1. 为什么需要光线追踪？:star:\n\n1. 光栅化不能很好地处理全局效果（软阴影、光线多次弹射），强行用光栅化处理会比较低效\n\n   > 全局光照：直接光照+间接光照（回想渲染方程）\n\n2. 光栅化比较快，用的是经验模型，是近似的，质量精度比较低，多用来做实时渲染（比较快）。\n\n   光线追踪比较准确，但是会非常慢，更多的被用来做一些离线渲染，比如电影、动画\n\n## 2. 一些假设\n\n## 3. 光线追踪过程\n\n3.1 光线投射\n\n3.2 像素着色\n\n3.3 递归\n\n3.4 着色结果叠加\n\n## 4. 光线求交——数学基础\n\n### 4.1 光线的表示\n\n### 4.2 球体\n\n### 4.3 隐式表面\n\n### 4.4 三角网格\n\n## 5. 光线求交加速\n\n### 5.1 包围盒:star:\n\n### 5.2 均匀网格\n\n### 5.3 空间划分\n\n#### 5.3.1 八叉树（Oct-Tree）\n\n#### 5.3.2 BSP-Tree\n\n#### 5.3.3 KD-Tree\n\n5.3.3.1 KD-Tree的两个缺点：\n\n1. \n2. \n\n### 5.4 物体划分——层次包围盒（BVH）:star:\n\n不是对空间进行划分，而是对物体进行划分\n\n## 6. 辐射度量学\n\n### 6.1 为什么需要辐射度量学？:star:\n\n`Blinn-Phong`只是一种经验模型，而辐射度量学在物理的角度更加严谨\n\n1. 能量Q\n2. 功率，对应于光学中的power，lumen\n\n### 6.2 Radiant Intensity\n\n每个单位立体角的power\n\n整个球的立体角\n\n### 6.3 Irradiance\n\n单位面积的能量\n\n### 6.4 Radiance\n\n## 7. BRDF & 反射方程\n\n### 7.1 BRDF\n\n### 7.2 反射方程\n\n## 8.渲染方程\n\n8.1 渲染方程\n\n8.2 理解渲染方程\n\n## 9. Monte Cralo积分\n\nwhy？\n\n有些复杂积分用黎曼积分解不出来，考虑另外一种积分方法，即Monte Cralo积分，它可以得到一个定积分的近似数值解\n\nwhat？\n\n从特殊情况去理解Monte Cralo积分\n\nhow？\n\n## 10. Path Tracing\n\nwhy?\n\nWhitted-style光线追踪的缺陷：\n\n1. 光线弹射总是按镜面反射规则（没有考虑<u>不同材质的反射</u>）\n2. 光线在漫反射处停止弹射（没有考虑到<u>间接光照</u>）\n\nwhat？\n\npath tracing基于渲染方程，考虑全局光照\n\nhow？\n\n用蒙特卡洛积分求解渲染方程，得到出射方向$\\omega_o$上的能量\n\n考虑间接光照：递归求解\n","slug":"图形学&游戏开发/光线追踪（Ray Tracing）","published":1,"date":"2022-03-28T12:43:01.095Z","updated":"2022-05-05T02:16:27.905Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0kwx000dpcu3d2uz7o08","content":"<h1 id=\"一、光线追踪（Ray-Tracing）\"><a href=\"#一、光线追踪（Ray-Tracing）\" class=\"headerlink\" title=\"一、光线追踪（Ray Tracing）\"></a>一、光线追踪（Ray Tracing）</h1><h2 id=\"1-为什么需要光线追踪？-star\"><a href=\"#1-为什么需要光线追踪？-star\" class=\"headerlink\" title=\"1. 为什么需要光线追踪？:star:\"></a>1. 为什么需要光线追踪？:star:</h2><ol>\n<li><p>光栅化不能很好地处理全局效果（软阴影、光线多次弹射），强行用光栅化处理会比较低效</p>\n<blockquote>\n<p>全局光照：直接光照+间接光照（回想渲染方程）</p>\n</blockquote>\n</li>\n<li><p>光栅化比较快，用的是经验模型，是近似的，质量精度比较低，多用来做实时渲染（比较快）。</p>\n<p>光线追踪比较准确，但是会非常慢，更多的被用来做一些离线渲染，比如电影、动画</p>\n</li>\n</ol>\n<h2 id=\"2-一些假设\"><a href=\"#2-一些假设\" class=\"headerlink\" title=\"2. 一些假设\"></a>2. 一些假设</h2><h2 id=\"3-光线追踪过程\"><a href=\"#3-光线追踪过程\" class=\"headerlink\" title=\"3. 光线追踪过程\"></a>3. 光线追踪过程</h2><p>3.1 光线投射</p>\n<p>3.2 像素着色</p>\n<p>3.3 递归</p>\n<p>3.4 着色结果叠加</p>\n<h2 id=\"4-光线求交——数学基础\"><a href=\"#4-光线求交——数学基础\" class=\"headerlink\" title=\"4. 光线求交——数学基础\"></a>4. 光线求交——数学基础</h2><h3 id=\"4-1-光线的表示\"><a href=\"#4-1-光线的表示\" class=\"headerlink\" title=\"4.1 光线的表示\"></a>4.1 光线的表示</h3><h3 id=\"4-2-球体\"><a href=\"#4-2-球体\" class=\"headerlink\" title=\"4.2 球体\"></a>4.2 球体</h3><h3 id=\"4-3-隐式表面\"><a href=\"#4-3-隐式表面\" class=\"headerlink\" title=\"4.3 隐式表面\"></a>4.3 隐式表面</h3><h3 id=\"4-4-三角网格\"><a href=\"#4-4-三角网格\" class=\"headerlink\" title=\"4.4 三角网格\"></a>4.4 三角网格</h3><h2 id=\"5-光线求交加速\"><a href=\"#5-光线求交加速\" class=\"headerlink\" title=\"5. 光线求交加速\"></a>5. 光线求交加速</h2><h3 id=\"5-1-包围盒-star\"><a href=\"#5-1-包围盒-star\" class=\"headerlink\" title=\"5.1 包围盒:star:\"></a>5.1 包围盒:star:</h3><h3 id=\"5-2-均匀网格\"><a href=\"#5-2-均匀网格\" class=\"headerlink\" title=\"5.2 均匀网格\"></a>5.2 均匀网格</h3><h3 id=\"5-3-空间划分\"><a href=\"#5-3-空间划分\" class=\"headerlink\" title=\"5.3 空间划分\"></a>5.3 空间划分</h3><h4 id=\"5-3-1-八叉树（Oct-Tree）\"><a href=\"#5-3-1-八叉树（Oct-Tree）\" class=\"headerlink\" title=\"5.3.1 八叉树（Oct-Tree）\"></a>5.3.1 八叉树（Oct-Tree）</h4><h4 id=\"5-3-2-BSP-Tree\"><a href=\"#5-3-2-BSP-Tree\" class=\"headerlink\" title=\"5.3.2 BSP-Tree\"></a>5.3.2 BSP-Tree</h4><h4 id=\"5-3-3-KD-Tree\"><a href=\"#5-3-3-KD-Tree\" class=\"headerlink\" title=\"5.3.3 KD-Tree\"></a>5.3.3 KD-Tree</h4><p>5.3.3.1 KD-Tree的两个缺点：</p>\n<ol>\n<li></li>\n<li></li>\n</ol>\n<h3 id=\"5-4-物体划分——层次包围盒（BVH）-star\"><a href=\"#5-4-物体划分——层次包围盒（BVH）-star\" class=\"headerlink\" title=\"5.4 物体划分——层次包围盒（BVH）:star:\"></a>5.4 物体划分——层次包围盒（BVH）:star:</h3><p>不是对空间进行划分，而是对物体进行划分</p>\n<h2 id=\"6-辐射度量学\"><a href=\"#6-辐射度量学\" class=\"headerlink\" title=\"6. 辐射度量学\"></a>6. 辐射度量学</h2><h3 id=\"6-1-为什么需要辐射度量学？-star\"><a href=\"#6-1-为什么需要辐射度量学？-star\" class=\"headerlink\" title=\"6.1 为什么需要辐射度量学？:star:\"></a>6.1 为什么需要辐射度量学？:star:</h3><p><code>Blinn-Phong</code>只是一种经验模型，而辐射度量学在物理的角度更加严谨</p>\n<ol>\n<li>能量Q</li>\n<li>功率，对应于光学中的power，lumen</li>\n</ol>\n<h3 id=\"6-2-Radiant-Intensity\"><a href=\"#6-2-Radiant-Intensity\" class=\"headerlink\" title=\"6.2 Radiant Intensity\"></a>6.2 Radiant Intensity</h3><p>每个单位立体角的power</p>\n<p>整个球的立体角</p>\n<h3 id=\"6-3-Irradiance\"><a href=\"#6-3-Irradiance\" class=\"headerlink\" title=\"6.3 Irradiance\"></a>6.3 Irradiance</h3><p>单位面积的能量</p>\n<h3 id=\"6-4-Radiance\"><a href=\"#6-4-Radiance\" class=\"headerlink\" title=\"6.4 Radiance\"></a>6.4 Radiance</h3><h2 id=\"7-BRDF-amp-反射方程\"><a href=\"#7-BRDF-amp-反射方程\" class=\"headerlink\" title=\"7. BRDF &amp; 反射方程\"></a>7. BRDF &amp; 反射方程</h2><h3 id=\"7-1-BRDF\"><a href=\"#7-1-BRDF\" class=\"headerlink\" title=\"7.1 BRDF\"></a>7.1 BRDF</h3><h3 id=\"7-2-反射方程\"><a href=\"#7-2-反射方程\" class=\"headerlink\" title=\"7.2 反射方程\"></a>7.2 反射方程</h3><h2 id=\"8-渲染方程\"><a href=\"#8-渲染方程\" class=\"headerlink\" title=\"8.渲染方程\"></a>8.渲染方程</h2><p>8.1 渲染方程</p>\n<p>8.2 理解渲染方程</p>\n<h2 id=\"9-Monte-Cralo积分\"><a href=\"#9-Monte-Cralo积分\" class=\"headerlink\" title=\"9. Monte Cralo积分\"></a>9. Monte Cralo积分</h2><p>why？</p>\n<p>有些复杂积分用黎曼积分解不出来，考虑另外一种积分方法，即Monte Cralo积分，它可以得到一个定积分的近似数值解</p>\n<p>what？</p>\n<p>从特殊情况去理解Monte Cralo积分</p>\n<p>how？</p>\n<h2 id=\"10-Path-Tracing\"><a href=\"#10-Path-Tracing\" class=\"headerlink\" title=\"10. Path Tracing\"></a>10. Path Tracing</h2><p>why?</p>\n<p>Whitted-style光线追踪的缺陷：</p>\n<ol>\n<li>光线弹射总是按镜面反射规则（没有考虑<u>不同材质的反射</u>）</li>\n<li>光线在漫反射处停止弹射（没有考虑到<u>间接光照</u>）</li>\n</ol>\n<p>what？</p>\n<p>path tracing基于渲染方程，考虑全局光照</p>\n<p>how？</p>\n<p>用蒙特卡洛积分求解渲染方程，得到出射方向$\\omega_o$上的能量</p>\n<p>考虑间接光照：递归求解</p>\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<h1 id=\"一、光线追踪（Ray-Tracing）\"><a href=\"#一、光线追踪（Ray-Tracing）\" class=\"headerlink\" title=\"一、光线追踪（Ray Tracing）\"></a>一、光线追踪（Ray Tracing）</h1><h2 id=\"1-为什么需要光线追踪？-star\"><a href=\"#1-为什么需要光线追踪？-star\" class=\"headerlink\" title=\"1. 为什么需要光线追踪？:star:\"></a>1. 为什么需要光线追踪？:star:</h2><ol>\n<li><p>光栅化不能很好地处理全局效果（软阴影、光线多次弹射），强行用光栅化处理会比较低效</p>\n<blockquote>\n<p>全局光照：直接光照+间接光照（回想渲染方程）</p>\n</blockquote>\n</li>\n<li><p>光栅化比较快，用的是经验模型，是近似的，质量精度比较低，多用来做实时渲染（比较快）。</p>\n<p>光线追踪比较准确，但是会非常慢，更多的被用来做一些离线渲染，比如电影、动画</p>\n</li>\n</ol>\n<h2 id=\"2-一些假设\"><a href=\"#2-一些假设\" class=\"headerlink\" title=\"2. 一些假设\"></a>2. 一些假设</h2><h2 id=\"3-光线追踪过程\"><a href=\"#3-光线追踪过程\" class=\"headerlink\" title=\"3. 光线追踪过程\"></a>3. 光线追踪过程</h2><p>3.1 光线投射</p>\n<p>3.2 像素着色</p>\n<p>3.3 递归</p>\n<p>3.4 着色结果叠加</p>\n<h2 id=\"4-光线求交——数学基础\"><a href=\"#4-光线求交——数学基础\" class=\"headerlink\" title=\"4. 光线求交——数学基础\"></a>4. 光线求交——数学基础</h2><h3 id=\"4-1-光线的表示\"><a href=\"#4-1-光线的表示\" class=\"headerlink\" title=\"4.1 光线的表示\"></a>4.1 光线的表示</h3><h3 id=\"4-2-球体\"><a href=\"#4-2-球体\" class=\"headerlink\" title=\"4.2 球体\"></a>4.2 球体</h3><h3 id=\"4-3-隐式表面\"><a href=\"#4-3-隐式表面\" class=\"headerlink\" title=\"4.3 隐式表面\"></a>4.3 隐式表面</h3><h3 id=\"4-4-三角网格\"><a href=\"#4-4-三角网格\" class=\"headerlink\" title=\"4.4 三角网格\"></a>4.4 三角网格</h3><h2 id=\"5-光线求交加速\"><a href=\"#5-光线求交加速\" class=\"headerlink\" title=\"5. 光线求交加速\"></a>5. 光线求交加速</h2><h3 id=\"5-1-包围盒-star\"><a href=\"#5-1-包围盒-star\" class=\"headerlink\" title=\"5.1 包围盒:star:\"></a>5.1 包围盒:star:</h3><h3 id=\"5-2-均匀网格\"><a href=\"#5-2-均匀网格\" class=\"headerlink\" title=\"5.2 均匀网格\"></a>5.2 均匀网格</h3><h3 id=\"5-3-空间划分\"><a href=\"#5-3-空间划分\" class=\"headerlink\" title=\"5.3 空间划分\"></a>5.3 空间划分</h3><h4 id=\"5-3-1-八叉树（Oct-Tree）\"><a href=\"#5-3-1-八叉树（Oct-Tree）\" class=\"headerlink\" title=\"5.3.1 八叉树（Oct-Tree）\"></a>5.3.1 八叉树（Oct-Tree）</h4><h4 id=\"5-3-2-BSP-Tree\"><a href=\"#5-3-2-BSP-Tree\" class=\"headerlink\" title=\"5.3.2 BSP-Tree\"></a>5.3.2 BSP-Tree</h4><h4 id=\"5-3-3-KD-Tree\"><a href=\"#5-3-3-KD-Tree\" class=\"headerlink\" title=\"5.3.3 KD-Tree\"></a>5.3.3 KD-Tree</h4><p>5.3.3.1 KD-Tree的两个缺点：</p>\n<ol>\n<li></li>\n<li></li>\n</ol>\n<h3 id=\"5-4-物体划分——层次包围盒（BVH）-star\"><a href=\"#5-4-物体划分——层次包围盒（BVH）-star\" class=\"headerlink\" title=\"5.4 物体划分——层次包围盒（BVH）:star:\"></a>5.4 物体划分——层次包围盒（BVH）:star:</h3><p>不是对空间进行划分，而是对物体进行划分</p>\n<h2 id=\"6-辐射度量学\"><a href=\"#6-辐射度量学\" class=\"headerlink\" title=\"6. 辐射度量学\"></a>6. 辐射度量学</h2><h3 id=\"6-1-为什么需要辐射度量学？-star\"><a href=\"#6-1-为什么需要辐射度量学？-star\" class=\"headerlink\" title=\"6.1 为什么需要辐射度量学？:star:\"></a>6.1 为什么需要辐射度量学？:star:</h3><p><code>Blinn-Phong</code>只是一种经验模型，而辐射度量学在物理的角度更加严谨</p>\n<ol>\n<li>能量Q</li>\n<li>功率，对应于光学中的power，lumen</li>\n</ol>\n<h3 id=\"6-2-Radiant-Intensity\"><a href=\"#6-2-Radiant-Intensity\" class=\"headerlink\" title=\"6.2 Radiant Intensity\"></a>6.2 Radiant Intensity</h3><p>每个单位立体角的power</p>\n<p>整个球的立体角</p>\n<h3 id=\"6-3-Irradiance\"><a href=\"#6-3-Irradiance\" class=\"headerlink\" title=\"6.3 Irradiance\"></a>6.3 Irradiance</h3><p>单位面积的能量</p>\n<h3 id=\"6-4-Radiance\"><a href=\"#6-4-Radiance\" class=\"headerlink\" title=\"6.4 Radiance\"></a>6.4 Radiance</h3><h2 id=\"7-BRDF-amp-反射方程\"><a href=\"#7-BRDF-amp-反射方程\" class=\"headerlink\" title=\"7. BRDF &amp; 反射方程\"></a>7. BRDF &amp; 反射方程</h2><h3 id=\"7-1-BRDF\"><a href=\"#7-1-BRDF\" class=\"headerlink\" title=\"7.1 BRDF\"></a>7.1 BRDF</h3><h3 id=\"7-2-反射方程\"><a href=\"#7-2-反射方程\" class=\"headerlink\" title=\"7.2 反射方程\"></a>7.2 反射方程</h3><h2 id=\"8-渲染方程\"><a href=\"#8-渲染方程\" class=\"headerlink\" title=\"8.渲染方程\"></a>8.渲染方程</h2><p>8.1 渲染方程</p>\n<p>8.2 理解渲染方程</p>\n<h2 id=\"9-Monte-Cralo积分\"><a href=\"#9-Monte-Cralo积分\" class=\"headerlink\" title=\"9. Monte Cralo积分\"></a>9. Monte Cralo积分</h2><p>why？</p>\n<p>有些复杂积分用黎曼积分解不出来，考虑另外一种积分方法，即Monte Cralo积分，它可以得到一个定积分的近似数值解</p>\n<p>what？</p>\n<p>从特殊情况去理解Monte Cralo积分</p>\n<p>how？</p>\n<h2 id=\"10-Path-Tracing\"><a href=\"#10-Path-Tracing\" class=\"headerlink\" title=\"10. Path Tracing\"></a>10. Path Tracing</h2><p>why?</p>\n<p>Whitted-style光线追踪的缺陷：</p>\n<ol>\n<li>光线弹射总是按镜面反射规则（没有考虑<u>不同材质的反射</u>）</li>\n<li>光线在漫反射处停止弹射（没有考虑到<u>间接光照</u>）</li>\n</ol>\n<p>what？</p>\n<p>path tracing基于渲染方程，考虑全局光照</p>\n<p>how？</p>\n<p>用蒙特卡洛积分求解渲染方程，得到出射方向$\\omega_o$上的能量</p>\n<p>考虑间接光照：递归求解</p>\n"},{"_content":"draw call就是CPU发出发出绘制指令，调用GPU，GPU再进行渲染 \n\nGPU渲染的速度是很快的，相比之下，CPU进行绘制调用的耗时还要大一些，所以讨论如何减小draw call是有意义的\n\n##### 1. 动态批处理\n\n前提是<u>共享材质</u>，运行时多次合并，每渲染一帧就要进行一次合并操作；只适用于小物体。\n\n##### 2. 静态批处理\n\n前提也是<u>共享材质</u>，但只合并所有的静态物体，且只在运行前进行一次合并。\n\n静态批处理比动态批处理要高效，但缺点是要<u>占用更多的内存</u>来存储合并后的几何结构。比如对1000个使用同样树模型的树木使用静态批处理，存储时就会多占用1000倍的内存。\n\n在内部实现上，Unity首先把这些静态物体变换到世界空间下， 然后为它们构建一个更大的顶点和索引缓存。\n\n静态批处理要注意的地方\n\n\n\n##### 共享材质\n\n##### 3. GPU实例化\n\nhttps://catlikecoding.com/unity/tutorials/rendering/part-19/Rendering-19.pdf\n\n动态时进行的，适用于场景中存在大量相同材质和网格的物体的渲染","source":"_posts/图形学&游戏开发/如何减少DrawCall？.md","raw":"draw call就是CPU发出发出绘制指令，调用GPU，GPU再进行渲染 \n\nGPU渲染的速度是很快的，相比之下，CPU进行绘制调用的耗时还要大一些，所以讨论如何减小draw call是有意义的\n\n##### 1. 动态批处理\n\n前提是<u>共享材质</u>，运行时多次合并，每渲染一帧就要进行一次合并操作；只适用于小物体。\n\n##### 2. 静态批处理\n\n前提也是<u>共享材质</u>，但只合并所有的静态物体，且只在运行前进行一次合并。\n\n静态批处理比动态批处理要高效，但缺点是要<u>占用更多的内存</u>来存储合并后的几何结构。比如对1000个使用同样树模型的树木使用静态批处理，存储时就会多占用1000倍的内存。\n\n在内部实现上，Unity首先把这些静态物体变换到世界空间下， 然后为它们构建一个更大的顶点和索引缓存。\n\n静态批处理要注意的地方\n\n\n\n##### 共享材质\n\n##### 3. GPU实例化\n\nhttps://catlikecoding.com/unity/tutorials/rendering/part-19/Rendering-19.pdf\n\n动态时进行的，适用于场景中存在大量相同材质和网格的物体的渲染","slug":"图形学&游戏开发/如何减少DrawCall？","published":1,"date":"2022-04-14T03:45:30.263Z","updated":"2022-05-02T06:54:12.929Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0kwz000epcu34paaecmj","content":"<p>draw call就是CPU发出发出绘制指令，调用GPU，GPU再进行渲染 </p>\n<p>GPU渲染的速度是很快的，相比之下，CPU进行绘制调用的耗时还要大一些，所以讨论如何减小draw call是有意义的</p>\n<h5 id=\"1-动态批处理\"><a href=\"#1-动态批处理\" class=\"headerlink\" title=\"1. 动态批处理\"></a>1. 动态批处理</h5><p>前提是<u>共享材质</u>，运行时多次合并，每渲染一帧就要进行一次合并操作；只适用于小物体。</p>\n<h5 id=\"2-静态批处理\"><a href=\"#2-静态批处理\" class=\"headerlink\" title=\"2. 静态批处理\"></a>2. 静态批处理</h5><p>前提也是<u>共享材质</u>，但只合并所有的静态物体，且只在运行前进行一次合并。</p>\n<p>静态批处理比动态批处理要高效，但缺点是要<u>占用更多的内存</u>来存储合并后的几何结构。比如对1000个使用同样树模型的树木使用静态批处理，存储时就会多占用1000倍的内存。</p>\n<p>在内部实现上，Unity首先把这些静态物体变换到世界空间下， 然后为它们构建一个更大的顶点和索引缓存。</p>\n<p>静态批处理要注意的地方</p>\n<h5 id=\"共享材质\"><a href=\"#共享材质\" class=\"headerlink\" title=\"共享材质\"></a>共享材质</h5><h5 id=\"3-GPU实例化\"><a href=\"#3-GPU实例化\" class=\"headerlink\" title=\"3. GPU实例化\"></a>3. GPU实例化</h5><p><a href=\"https://catlikecoding.com/unity/tutorials/rendering/part-19/Rendering-19.pdf\">https://catlikecoding.com/unity/tutorials/rendering/part-19/Rendering-19.pdf</a></p>\n<p>动态时进行的，适用于场景中存在大量相同材质和网格的物体的渲染</p>\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<p>draw call就是CPU发出发出绘制指令，调用GPU，GPU再进行渲染 </p>\n<p>GPU渲染的速度是很快的，相比之下，CPU进行绘制调用的耗时还要大一些，所以讨论如何减小draw call是有意义的</p>\n<h5 id=\"1-动态批处理\"><a href=\"#1-动态批处理\" class=\"headerlink\" title=\"1. 动态批处理\"></a>1. 动态批处理</h5><p>前提是<u>共享材质</u>，运行时多次合并，每渲染一帧就要进行一次合并操作；只适用于小物体。</p>\n<h5 id=\"2-静态批处理\"><a href=\"#2-静态批处理\" class=\"headerlink\" title=\"2. 静态批处理\"></a>2. 静态批处理</h5><p>前提也是<u>共享材质</u>，但只合并所有的静态物体，且只在运行前进行一次合并。</p>\n<p>静态批处理比动态批处理要高效，但缺点是要<u>占用更多的内存</u>来存储合并后的几何结构。比如对1000个使用同样树模型的树木使用静态批处理，存储时就会多占用1000倍的内存。</p>\n<p>在内部实现上，Unity首先把这些静态物体变换到世界空间下， 然后为它们构建一个更大的顶点和索引缓存。</p>\n<p>静态批处理要注意的地方</p>\n<h5 id=\"共享材质\"><a href=\"#共享材质\" class=\"headerlink\" title=\"共享材质\"></a>共享材质</h5><h5 id=\"3-GPU实例化\"><a href=\"#3-GPU实例化\" class=\"headerlink\" title=\"3. GPU实例化\"></a>3. GPU实例化</h5><p><a href=\"https://catlikecoding.com/unity/tutorials/rendering/part-19/Rendering-19.pdf\">https://catlikecoding.com/unity/tutorials/rendering/part-19/Rendering-19.pdf</a></p>\n<p>动态时进行的，适用于场景中存在大量相同材质和网格的物体的渲染</p>\n"},{"_content":"## 1. 前向渲染【】\n\n遍历场景中的每个光源，计算着色，最后在屏幕空间进行深度测试\n\n缺点：\n\n1. 对每个光源都有一个Pass，每个pass计算一个逐像素光源的光照结果，复杂度较大\n2. 进行深度测试后，一些片元不可见，它的光照计算结果相当于白算了\n\n## 2. 延迟渲染\n\nwhy？\n\n前向渲染在面对多光源场景时会有性能瓶颈，对每个光源都要进行一个Pass，每个Pass都要重新渲染一遍场景\n\nwhat？\n\n延迟渲染增加第三个缓冲区 ：G缓冲区，存储可见片元的属性（漫反射颜色，高光反射、自发光、法线、位置等）\n\n- 第一遍Pass：先从相机看场景，计算场景中的深度图，做深度测试，留下可见片元（利用深度缓冲技术），将它们的属性（光照数据）存入G缓冲区。第一个Pass实际上是将多个光源的信息都存储到了G-Buffer\n- 第二遍Pass：利用G缓冲区的属性对这些可见片元做昂贵的光照计算\n\n【每个pass都要干什么？为什么前向渲染需要多个Pass，多个Pass的意思是什么？要调用多次fragment shader吗？】\n\n延迟渲染的缺点：\n\n- G缓冲占用了额外的空间\n- 不支持MSAA功能\n- 不能处理半透明物体\n- 对显卡有要求\n","source":"_posts/图形学&游戏开发/延迟渲染.md","raw":"## 1. 前向渲染【】\n\n遍历场景中的每个光源，计算着色，最后在屏幕空间进行深度测试\n\n缺点：\n\n1. 对每个光源都有一个Pass，每个pass计算一个逐像素光源的光照结果，复杂度较大\n2. 进行深度测试后，一些片元不可见，它的光照计算结果相当于白算了\n\n## 2. 延迟渲染\n\nwhy？\n\n前向渲染在面对多光源场景时会有性能瓶颈，对每个光源都要进行一个Pass，每个Pass都要重新渲染一遍场景\n\nwhat？\n\n延迟渲染增加第三个缓冲区 ：G缓冲区，存储可见片元的属性（漫反射颜色，高光反射、自发光、法线、位置等）\n\n- 第一遍Pass：先从相机看场景，计算场景中的深度图，做深度测试，留下可见片元（利用深度缓冲技术），将它们的属性（光照数据）存入G缓冲区。第一个Pass实际上是将多个光源的信息都存储到了G-Buffer\n- 第二遍Pass：利用G缓冲区的属性对这些可见片元做昂贵的光照计算\n\n【每个pass都要干什么？为什么前向渲染需要多个Pass，多个Pass的意思是什么？要调用多次fragment shader吗？】\n\n延迟渲染的缺点：\n\n- G缓冲占用了额外的空间\n- 不支持MSAA功能\n- 不能处理半透明物体\n- 对显卡有要求\n","slug":"图形学&游戏开发/延迟渲染","published":1,"date":"2022-04-14T08:16:11.660Z","updated":"2022-05-13T05:47:46.149Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0kx0000fpcu3c9n32n6g","content":"<h2 id=\"1-前向渲染【】\"><a href=\"#1-前向渲染【】\" class=\"headerlink\" title=\"1. 前向渲染【】\"></a>1. 前向渲染【】</h2><p>遍历场景中的每个光源，计算着色，最后在屏幕空间进行深度测试</p>\n<p>缺点：</p>\n<ol>\n<li>对每个光源都有一个Pass，每个pass计算一个逐像素光源的光照结果，复杂度较大</li>\n<li>进行深度测试后，一些片元不可见，它的光照计算结果相当于白算了</li>\n</ol>\n<h2 id=\"2-延迟渲染\"><a href=\"#2-延迟渲染\" class=\"headerlink\" title=\"2. 延迟渲染\"></a>2. 延迟渲染</h2><p>why？</p>\n<p>前向渲染在面对多光源场景时会有性能瓶颈，对每个光源都要进行一个Pass，每个Pass都要重新渲染一遍场景</p>\n<p>what？</p>\n<p>延迟渲染增加第三个缓冲区 ：G缓冲区，存储可见片元的属性（漫反射颜色，高光反射、自发光、法线、位置等）</p>\n<ul>\n<li>第一遍Pass：先从相机看场景，计算场景中的深度图，做深度测试，留下可见片元（利用深度缓冲技术），将它们的属性（光照数据）存入G缓冲区。第一个Pass实际上是将多个光源的信息都存储到了G-Buffer</li>\n<li>第二遍Pass：利用G缓冲区的属性对这些可见片元做昂贵的光照计算</li>\n</ul>\n<p>【每个pass都要干什么？为什么前向渲染需要多个Pass，多个Pass的意思是什么？要调用多次fragment shader吗？】</p>\n<p>延迟渲染的缺点：</p>\n<ul>\n<li>G缓冲占用了额外的空间</li>\n<li>不支持MSAA功能</li>\n<li>不能处理半透明物体</li>\n<li>对显卡有要求</li>\n</ul>\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<h2 id=\"1-前向渲染【】\"><a href=\"#1-前向渲染【】\" class=\"headerlink\" title=\"1. 前向渲染【】\"></a>1. 前向渲染【】</h2><p>遍历场景中的每个光源，计算着色，最后在屏幕空间进行深度测试</p>\n<p>缺点：</p>\n<ol>\n<li>对每个光源都有一个Pass，每个pass计算一个逐像素光源的光照结果，复杂度较大</li>\n<li>进行深度测试后，一些片元不可见，它的光照计算结果相当于白算了</li>\n</ol>\n<h2 id=\"2-延迟渲染\"><a href=\"#2-延迟渲染\" class=\"headerlink\" title=\"2. 延迟渲染\"></a>2. 延迟渲染</h2><p>why？</p>\n<p>前向渲染在面对多光源场景时会有性能瓶颈，对每个光源都要进行一个Pass，每个Pass都要重新渲染一遍场景</p>\n<p>what？</p>\n<p>延迟渲染增加第三个缓冲区 ：G缓冲区，存储可见片元的属性（漫反射颜色，高光反射、自发光、法线、位置等）</p>\n<ul>\n<li>第一遍Pass：先从相机看场景，计算场景中的深度图，做深度测试，留下可见片元（利用深度缓冲技术），将它们的属性（光照数据）存入G缓冲区。第一个Pass实际上是将多个光源的信息都存储到了G-Buffer</li>\n<li>第二遍Pass：利用G缓冲区的属性对这些可见片元做昂贵的光照计算</li>\n</ul>\n<p>【每个pass都要干什么？为什么前向渲染需要多个Pass，多个Pass的意思是什么？要调用多次fragment shader吗？】</p>\n<p>延迟渲染的缺点：</p>\n<ul>\n<li>G缓冲占用了额外的空间</li>\n<li>不支持MSAA功能</li>\n<li>不能处理半透明物体</li>\n<li>对显卡有要求</li>\n</ul>\n"},{"_content":"## 1. 应用阶段（CPU->GPU）\n\n1.1 把数据加载到显存中\n\n所有渲染所需数据，从硬盘中加载到物理内存；网格、纹理等数据又被加载到GPU的显存（显卡上的存储空间）\n\n1.2 渲染状态\n\n例如，使用哪个shader，光源的属性\n\n1.3 调用 draw call\n\nCPU发出绘制指令\n\n## 2. 几何阶段\n\n2.1 顶点着色器\n\nMVP变换\n\n2.1.1 模型变换\n\n平移、缩放、旋转，注意是先缩放，再旋转，再平移\n\n输出归一化的设备坐标（normalized device coordinates，NDC）\n\n2.2 裁剪\n\n2.3 屏幕映射\n\n## 3. 光栅化阶段\n\n3.1 光栅化\n\n3.2 片段着色器\n\n3.3 深度测试、混合\n\nGAMES101将深度测试提前进行，即在光栅化和片段着色器之间就进行深度测试，这是为了避免片段着色器计算出来片元的属性之后，才发现它根本就不可见，那就白白耗费了计算资源。\n\n","source":"_posts/图形学&游戏开发/渲染管线.md","raw":"## 1. 应用阶段（CPU->GPU）\n\n1.1 把数据加载到显存中\n\n所有渲染所需数据，从硬盘中加载到物理内存；网格、纹理等数据又被加载到GPU的显存（显卡上的存储空间）\n\n1.2 渲染状态\n\n例如，使用哪个shader，光源的属性\n\n1.3 调用 draw call\n\nCPU发出绘制指令\n\n## 2. 几何阶段\n\n2.1 顶点着色器\n\nMVP变换\n\n2.1.1 模型变换\n\n平移、缩放、旋转，注意是先缩放，再旋转，再平移\n\n输出归一化的设备坐标（normalized device coordinates，NDC）\n\n2.2 裁剪\n\n2.3 屏幕映射\n\n## 3. 光栅化阶段\n\n3.1 光栅化\n\n3.2 片段着色器\n\n3.3 深度测试、混合\n\nGAMES101将深度测试提前进行，即在光栅化和片段着色器之间就进行深度测试，这是为了避免片段着色器计算出来片元的属性之后，才发现它根本就不可见，那就白白耗费了计算资源。\n\n","slug":"图形学&游戏开发/渲染管线","published":1,"date":"2022-04-14T06:47:12.331Z","updated":"2022-05-13T01:36:39.812Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0kx2000gpcu3accxa462","content":"<h2 id=\"1-应用阶段（CPU-gt-GPU）\"><a href=\"#1-应用阶段（CPU-gt-GPU）\" class=\"headerlink\" title=\"1. 应用阶段（CPU-&gt;GPU）\"></a>1. 应用阶段（CPU-&gt;GPU）</h2><p>1.1 把数据加载到显存中</p>\n<p>所有渲染所需数据，从硬盘中加载到物理内存；网格、纹理等数据又被加载到GPU的显存（显卡上的存储空间）</p>\n<p>1.2 渲染状态</p>\n<p>例如，使用哪个shader，光源的属性</p>\n<p>1.3 调用 draw call</p>\n<p>CPU发出绘制指令</p>\n<h2 id=\"2-几何阶段\"><a href=\"#2-几何阶段\" class=\"headerlink\" title=\"2. 几何阶段\"></a>2. 几何阶段</h2><p>2.1 顶点着色器</p>\n<p>MVP变换</p>\n<p>2.1.1 模型变换</p>\n<p>平移、缩放、旋转，注意是先缩放，再旋转，再平移</p>\n<p>输出归一化的设备坐标（normalized device coordinates，NDC）</p>\n<p>2.2 裁剪</p>\n<p>2.3 屏幕映射</p>\n<h2 id=\"3-光栅化阶段\"><a href=\"#3-光栅化阶段\" class=\"headerlink\" title=\"3. 光栅化阶段\"></a>3. 光栅化阶段</h2><p>3.1 光栅化</p>\n<p>3.2 片段着色器</p>\n<p>3.3 深度测试、混合</p>\n<p>GAMES101将深度测试提前进行，即在光栅化和片段着色器之间就进行深度测试，这是为了避免片段着色器计算出来片元的属性之后，才发现它根本就不可见，那就白白耗费了计算资源。</p>\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<h2 id=\"1-应用阶段（CPU-gt-GPU）\"><a href=\"#1-应用阶段（CPU-gt-GPU）\" class=\"headerlink\" title=\"1. 应用阶段（CPU-&gt;GPU）\"></a>1. 应用阶段（CPU-&gt;GPU）</h2><p>1.1 把数据加载到显存中</p>\n<p>所有渲染所需数据，从硬盘中加载到物理内存；网格、纹理等数据又被加载到GPU的显存（显卡上的存储空间）</p>\n<p>1.2 渲染状态</p>\n<p>例如，使用哪个shader，光源的属性</p>\n<p>1.3 调用 draw call</p>\n<p>CPU发出绘制指令</p>\n<h2 id=\"2-几何阶段\"><a href=\"#2-几何阶段\" class=\"headerlink\" title=\"2. 几何阶段\"></a>2. 几何阶段</h2><p>2.1 顶点着色器</p>\n<p>MVP变换</p>\n<p>2.1.1 模型变换</p>\n<p>平移、缩放、旋转，注意是先缩放，再旋转，再平移</p>\n<p>输出归一化的设备坐标（normalized device coordinates，NDC）</p>\n<p>2.2 裁剪</p>\n<p>2.3 屏幕映射</p>\n<h2 id=\"3-光栅化阶段\"><a href=\"#3-光栅化阶段\" class=\"headerlink\" title=\"3. 光栅化阶段\"></a>3. 光栅化阶段</h2><p>3.1 光栅化</p>\n<p>3.2 片段着色器</p>\n<p>3.3 深度测试、混合</p>\n<p>GAMES101将深度测试提前进行，即在光栅化和片段着色器之间就进行深度测试，这是为了避免片段着色器计算出来片元的属性之后，才发现它根本就不可见，那就白白耗费了计算资源。</p>\n"},{"_content":"透明效果\n\n参考资料：Unity Shader入门精要第8章\n\nUnity中的alpha测试函数：clip，alpha混合命令：Blend\n\n### 1. alpha测试\n\nalpha测试比较简单‘粗糙，它判断像素的alpha通道是否满足条件（小于某个阈值），如果是，就不对这个物体进行渲染，否则就正常渲染。这种方式没法实现半透明的效果，所以alpha混合用的多一些。\n\n### 2. alpha混合\n\n#### 2.1 取消z-write\n\n为了实现半透明效果，即能透过半透明物体看到后面的不透明物体（半透明物体离摄像机更近），必须取消半透明物体的深度写入，否则进行深度测试之后，将判定半透明物体遮挡住后面的不透明物体，后面的不透明物体就无法渲染\n\n>  如果开启了深度写入，深度缓冲里保存的就是半透明物体的深度，按道理来讲，颜色缓冲应该和深度缓冲对应，即应该保存半透明物体的颜色，但这样就没办法看到后面的不透明物体的颜色了。所以关闭半透明物体的深度写入功能，即半透明物体对深度缓冲是只读的\n\n#### 2.2 注意渲染顺序的重要性\n\n##### 2.2.1 半透明物体和不透明物体\n\n![0CD49E095BA9CD240B3603CD9F463AA0](https://raw.githubusercontent.com/Vio1ette/blog-img/main/0CD49E095BA9CD240B3603CD9F463AA0.png)\n\n在已经取消z-write的情况下，如果先渲染A，没有深度写入，将A的颜色写入颜色缓冲区。在渲染B时，深度写入被打开，此时B会发现自己的深度是最近的（深度缓冲区为空），所以它的颜色会直接写入帧缓冲区，将会覆盖A的颜色，得到了错误的效果。\n\n<u>所以要先渲染不透明物体，再渲染半透明物体</u>\n\nB正常渲染，渲染A时，进行正常的深度测试，判断出A更近，将A的alpha通道的值和颜色缓冲区的值（B的颜色）进行混合（具体实现细节还需要查资料），最终正确实现半透明效果。\n\n##### 2.2.2 半透明物体和半透明物体\n\n![C590C84FA1ED2D7BD42EC4EC2BA0EA48](https://raw.githubusercontent.com/Vio1ette/blog-img/main/C590C84FA1ED2D7BD42EC4EC2BA0EA48.png)\n\n先渲染B，将B的颜色写入颜色缓冲区，但不进行深度写入，再渲染A，进行深度测试判断A更近，将A和颜色缓冲区的B的颜色混合，得到正确的透明效果。由于没有深度写入，先渲染A再渲染B将会得到一个错误的半透明效果（看起来B是在A的前面）\n\n<u>所以要先渲染远处的半透明物体，再渲染近的半透明物体</u>\n\n### 3. 渲染引擎的一般处理方法\n\n1. 正常渲染所有不透明物体\n2. 将半透明物体按离摄像机的远近排序，先渲染远的，再渲染近的\n\n问题：深度缓冲中的值是像素级别的，对物体进行排序时不能依赖像素级别的深度值。难以排序的情况：物体互相重叠，\n\n解决方案：分割网格、模型拆解\n\n### 4. 开启深度写入的半透明效果\n\n两个Pass\n\n第一个Pass：开启深度写入，单纯记录深度，但不输出颜色\n\n第二个Pass：依据像素级深度值排序结果进行透明度混合\n\n以前的方法要得到半透明物体的排序结果，现在进行像素级排序，而非整个物体\n\n### 5. 半透明物体的阴影\n\n","source":"_posts/图形学&游戏开发/透明效果（alpha测试，alpha混合）.md","raw":"透明效果\n\n参考资料：Unity Shader入门精要第8章\n\nUnity中的alpha测试函数：clip，alpha混合命令：Blend\n\n### 1. alpha测试\n\nalpha测试比较简单‘粗糙，它判断像素的alpha通道是否满足条件（小于某个阈值），如果是，就不对这个物体进行渲染，否则就正常渲染。这种方式没法实现半透明的效果，所以alpha混合用的多一些。\n\n### 2. alpha混合\n\n#### 2.1 取消z-write\n\n为了实现半透明效果，即能透过半透明物体看到后面的不透明物体（半透明物体离摄像机更近），必须取消半透明物体的深度写入，否则进行深度测试之后，将判定半透明物体遮挡住后面的不透明物体，后面的不透明物体就无法渲染\n\n>  如果开启了深度写入，深度缓冲里保存的就是半透明物体的深度，按道理来讲，颜色缓冲应该和深度缓冲对应，即应该保存半透明物体的颜色，但这样就没办法看到后面的不透明物体的颜色了。所以关闭半透明物体的深度写入功能，即半透明物体对深度缓冲是只读的\n\n#### 2.2 注意渲染顺序的重要性\n\n##### 2.2.1 半透明物体和不透明物体\n\n![0CD49E095BA9CD240B3603CD9F463AA0](https://raw.githubusercontent.com/Vio1ette/blog-img/main/0CD49E095BA9CD240B3603CD9F463AA0.png)\n\n在已经取消z-write的情况下，如果先渲染A，没有深度写入，将A的颜色写入颜色缓冲区。在渲染B时，深度写入被打开，此时B会发现自己的深度是最近的（深度缓冲区为空），所以它的颜色会直接写入帧缓冲区，将会覆盖A的颜色，得到了错误的效果。\n\n<u>所以要先渲染不透明物体，再渲染半透明物体</u>\n\nB正常渲染，渲染A时，进行正常的深度测试，判断出A更近，将A的alpha通道的值和颜色缓冲区的值（B的颜色）进行混合（具体实现细节还需要查资料），最终正确实现半透明效果。\n\n##### 2.2.2 半透明物体和半透明物体\n\n![C590C84FA1ED2D7BD42EC4EC2BA0EA48](https://raw.githubusercontent.com/Vio1ette/blog-img/main/C590C84FA1ED2D7BD42EC4EC2BA0EA48.png)\n\n先渲染B，将B的颜色写入颜色缓冲区，但不进行深度写入，再渲染A，进行深度测试判断A更近，将A和颜色缓冲区的B的颜色混合，得到正确的透明效果。由于没有深度写入，先渲染A再渲染B将会得到一个错误的半透明效果（看起来B是在A的前面）\n\n<u>所以要先渲染远处的半透明物体，再渲染近的半透明物体</u>\n\n### 3. 渲染引擎的一般处理方法\n\n1. 正常渲染所有不透明物体\n2. 将半透明物体按离摄像机的远近排序，先渲染远的，再渲染近的\n\n问题：深度缓冲中的值是像素级别的，对物体进行排序时不能依赖像素级别的深度值。难以排序的情况：物体互相重叠，\n\n解决方案：分割网格、模型拆解\n\n### 4. 开启深度写入的半透明效果\n\n两个Pass\n\n第一个Pass：开启深度写入，单纯记录深度，但不输出颜色\n\n第二个Pass：依据像素级深度值排序结果进行透明度混合\n\n以前的方法要得到半透明物体的排序结果，现在进行像素级排序，而非整个物体\n\n### 5. 半透明物体的阴影\n\n","slug":"图形学&游戏开发/透明效果（alpha测试，alpha混合）","published":1,"date":"2022-04-20T13:35:03.439Z","updated":"2022-04-22T01:52:10.208Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0kx3000hpcu3bia37128","content":"<p>透明效果</p>\n<p>参考资料：Unity Shader入门精要第8章</p>\n<p>Unity中的alpha测试函数：clip，alpha混合命令：Blend</p>\n<h3 id=\"1-alpha测试\"><a href=\"#1-alpha测试\" class=\"headerlink\" title=\"1. alpha测试\"></a>1. alpha测试</h3><p>alpha测试比较简单‘粗糙，它判断像素的alpha通道是否满足条件（小于某个阈值），如果是，就不对这个物体进行渲染，否则就正常渲染。这种方式没法实现半透明的效果，所以alpha混合用的多一些。</p>\n<h3 id=\"2-alpha混合\"><a href=\"#2-alpha混合\" class=\"headerlink\" title=\"2. alpha混合\"></a>2. alpha混合</h3><h4 id=\"2-1-取消z-write\"><a href=\"#2-1-取消z-write\" class=\"headerlink\" title=\"2.1 取消z-write\"></a>2.1 取消z-write</h4><p>为了实现半透明效果，即能透过半透明物体看到后面的不透明物体（半透明物体离摄像机更近），必须取消半透明物体的深度写入，否则进行深度测试之后，将判定半透明物体遮挡住后面的不透明物体，后面的不透明物体就无法渲染</p>\n<blockquote>\n<p> 如果开启了深度写入，深度缓冲里保存的就是半透明物体的深度，按道理来讲，颜色缓冲应该和深度缓冲对应，即应该保存半透明物体的颜色，但这样就没办法看到后面的不透明物体的颜色了。所以关闭半透明物体的深度写入功能，即半透明物体对深度缓冲是只读的</p>\n</blockquote>\n<h4 id=\"2-2-注意渲染顺序的重要性\"><a href=\"#2-2-注意渲染顺序的重要性\" class=\"headerlink\" title=\"2.2 注意渲染顺序的重要性\"></a>2.2 注意渲染顺序的重要性</h4><h5 id=\"2-2-1-半透明物体和不透明物体\"><a href=\"#2-2-1-半透明物体和不透明物体\" class=\"headerlink\" title=\"2.2.1 半透明物体和不透明物体\"></a>2.2.1 半透明物体和不透明物体</h5><p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/0CD49E095BA9CD240B3603CD9F463AA0.png\" alt=\"0CD49E095BA9CD240B3603CD9F463AA0\"></p>\n<p>在已经取消z-write的情况下，如果先渲染A，没有深度写入，将A的颜色写入颜色缓冲区。在渲染B时，深度写入被打开，此时B会发现自己的深度是最近的（深度缓冲区为空），所以它的颜色会直接写入帧缓冲区，将会覆盖A的颜色，得到了错误的效果。</p>\n<p><u>所以要先渲染不透明物体，再渲染半透明物体</u></p>\n<p>B正常渲染，渲染A时，进行正常的深度测试，判断出A更近，将A的alpha通道的值和颜色缓冲区的值（B的颜色）进行混合（具体实现细节还需要查资料），最终正确实现半透明效果。</p>\n<h5 id=\"2-2-2-半透明物体和半透明物体\"><a href=\"#2-2-2-半透明物体和半透明物体\" class=\"headerlink\" title=\"2.2.2 半透明物体和半透明物体\"></a>2.2.2 半透明物体和半透明物体</h5><p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/C590C84FA1ED2D7BD42EC4EC2BA0EA48.png\" alt=\"C590C84FA1ED2D7BD42EC4EC2BA0EA48\"></p>\n<p>先渲染B，将B的颜色写入颜色缓冲区，但不进行深度写入，再渲染A，进行深度测试判断A更近，将A和颜色缓冲区的B的颜色混合，得到正确的透明效果。由于没有深度写入，先渲染A再渲染B将会得到一个错误的半透明效果（看起来B是在A的前面）</p>\n<p><u>所以要先渲染远处的半透明物体，再渲染近的半透明物体</u></p>\n<h3 id=\"3-渲染引擎的一般处理方法\"><a href=\"#3-渲染引擎的一般处理方法\" class=\"headerlink\" title=\"3. 渲染引擎的一般处理方法\"></a>3. 渲染引擎的一般处理方法</h3><ol>\n<li>正常渲染所有不透明物体</li>\n<li>将半透明物体按离摄像机的远近排序，先渲染远的，再渲染近的</li>\n</ol>\n<p>问题：深度缓冲中的值是像素级别的，对物体进行排序时不能依赖像素级别的深度值。难以排序的情况：物体互相重叠，</p>\n<p>解决方案：分割网格、模型拆解</p>\n<h3 id=\"4-开启深度写入的半透明效果\"><a href=\"#4-开启深度写入的半透明效果\" class=\"headerlink\" title=\"4. 开启深度写入的半透明效果\"></a>4. 开启深度写入的半透明效果</h3><p>两个Pass</p>\n<p>第一个Pass：开启深度写入，单纯记录深度，但不输出颜色</p>\n<p>第二个Pass：依据像素级深度值排序结果进行透明度混合</p>\n<p>以前的方法要得到半透明物体的排序结果，现在进行像素级排序，而非整个物体</p>\n<h3 id=\"5-半透明物体的阴影\"><a href=\"#5-半透明物体的阴影\" class=\"headerlink\" title=\"5. 半透明物体的阴影\"></a>5. 半透明物体的阴影</h3>","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<p>透明效果</p>\n<p>参考资料：Unity Shader入门精要第8章</p>\n<p>Unity中的alpha测试函数：clip，alpha混合命令：Blend</p>\n<h3 id=\"1-alpha测试\"><a href=\"#1-alpha测试\" class=\"headerlink\" title=\"1. alpha测试\"></a>1. alpha测试</h3><p>alpha测试比较简单‘粗糙，它判断像素的alpha通道是否满足条件（小于某个阈值），如果是，就不对这个物体进行渲染，否则就正常渲染。这种方式没法实现半透明的效果，所以alpha混合用的多一些。</p>\n<h3 id=\"2-alpha混合\"><a href=\"#2-alpha混合\" class=\"headerlink\" title=\"2. alpha混合\"></a>2. alpha混合</h3><h4 id=\"2-1-取消z-write\"><a href=\"#2-1-取消z-write\" class=\"headerlink\" title=\"2.1 取消z-write\"></a>2.1 取消z-write</h4><p>为了实现半透明效果，即能透过半透明物体看到后面的不透明物体（半透明物体离摄像机更近），必须取消半透明物体的深度写入，否则进行深度测试之后，将判定半透明物体遮挡住后面的不透明物体，后面的不透明物体就无法渲染</p>\n<blockquote>\n<p> 如果开启了深度写入，深度缓冲里保存的就是半透明物体的深度，按道理来讲，颜色缓冲应该和深度缓冲对应，即应该保存半透明物体的颜色，但这样就没办法看到后面的不透明物体的颜色了。所以关闭半透明物体的深度写入功能，即半透明物体对深度缓冲是只读的</p>\n</blockquote>\n<h4 id=\"2-2-注意渲染顺序的重要性\"><a href=\"#2-2-注意渲染顺序的重要性\" class=\"headerlink\" title=\"2.2 注意渲染顺序的重要性\"></a>2.2 注意渲染顺序的重要性</h4><h5 id=\"2-2-1-半透明物体和不透明物体\"><a href=\"#2-2-1-半透明物体和不透明物体\" class=\"headerlink\" title=\"2.2.1 半透明物体和不透明物体\"></a>2.2.1 半透明物体和不透明物体</h5><p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/0CD49E095BA9CD240B3603CD9F463AA0.png\" alt=\"0CD49E095BA9CD240B3603CD9F463AA0\"></p>\n<p>在已经取消z-write的情况下，如果先渲染A，没有深度写入，将A的颜色写入颜色缓冲区。在渲染B时，深度写入被打开，此时B会发现自己的深度是最近的（深度缓冲区为空），所以它的颜色会直接写入帧缓冲区，将会覆盖A的颜色，得到了错误的效果。</p>\n<p><u>所以要先渲染不透明物体，再渲染半透明物体</u></p>\n<p>B正常渲染，渲染A时，进行正常的深度测试，判断出A更近，将A的alpha通道的值和颜色缓冲区的值（B的颜色）进行混合（具体实现细节还需要查资料），最终正确实现半透明效果。</p>\n<h5 id=\"2-2-2-半透明物体和半透明物体\"><a href=\"#2-2-2-半透明物体和半透明物体\" class=\"headerlink\" title=\"2.2.2 半透明物体和半透明物体\"></a>2.2.2 半透明物体和半透明物体</h5><p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/C590C84FA1ED2D7BD42EC4EC2BA0EA48.png\" alt=\"C590C84FA1ED2D7BD42EC4EC2BA0EA48\"></p>\n<p>先渲染B，将B的颜色写入颜色缓冲区，但不进行深度写入，再渲染A，进行深度测试判断A更近，将A和颜色缓冲区的B的颜色混合，得到正确的透明效果。由于没有深度写入，先渲染A再渲染B将会得到一个错误的半透明效果（看起来B是在A的前面）</p>\n<p><u>所以要先渲染远处的半透明物体，再渲染近的半透明物体</u></p>\n<h3 id=\"3-渲染引擎的一般处理方法\"><a href=\"#3-渲染引擎的一般处理方法\" class=\"headerlink\" title=\"3. 渲染引擎的一般处理方法\"></a>3. 渲染引擎的一般处理方法</h3><ol>\n<li>正常渲染所有不透明物体</li>\n<li>将半透明物体按离摄像机的远近排序，先渲染远的，再渲染近的</li>\n</ol>\n<p>问题：深度缓冲中的值是像素级别的，对物体进行排序时不能依赖像素级别的深度值。难以排序的情况：物体互相重叠，</p>\n<p>解决方案：分割网格、模型拆解</p>\n<h3 id=\"4-开启深度写入的半透明效果\"><a href=\"#4-开启深度写入的半透明效果\" class=\"headerlink\" title=\"4. 开启深度写入的半透明效果\"></a>4. 开启深度写入的半透明效果</h3><p>两个Pass</p>\n<p>第一个Pass：开启深度写入，单纯记录深度，但不输出颜色</p>\n<p>第二个Pass：依据像素级深度值排序结果进行透明度混合</p>\n<p>以前的方法要得到半透明物体的排序结果，现在进行像素级排序，而非整个物体</p>\n<h3 id=\"5-半透明物体的阴影\"><a href=\"#5-半透明物体的阴影\" class=\"headerlink\" title=\"5. 半透明物体的阴影\"></a>5. 半透明物体的阴影</h3>"},{"_content":"# GLSL学习\n\n## 1. 三种变量类型（uniform、attribute、varying）\n\n1.1 uniform变量\n\nuniform变量由外部程序传递给shader的变量。","source":"_posts/GLSL语言/GLSL语法.md","raw":"# GLSL学习\n\n## 1. 三种变量类型（uniform、attribute、varying）\n\n1.1 uniform变量\n\nuniform变量由外部程序传递给shader的变量。","slug":"GLSL语言/GLSL语法","published":1,"date":"2022-04-03T09:24:14.521Z","updated":"2022-04-04T01:55:57.129Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0kx5000ipcu3eolhb97x","content":"<h1 id=\"GLSL学习\"><a href=\"#GLSL学习\" class=\"headerlink\" title=\"GLSL学习\"></a>GLSL学习</h1><h2 id=\"1-三种变量类型（uniform、attribute、varying）\"><a href=\"#1-三种变量类型（uniform、attribute、varying）\" class=\"headerlink\" title=\"1. 三种变量类型（uniform、attribute、varying）\"></a>1. 三种变量类型（uniform、attribute、varying）</h2><p>1.1 uniform变量</p>\n<p>uniform变量由外部程序传递给shader的变量。</p>\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<h1 id=\"GLSL学习\"><a href=\"#GLSL学习\" class=\"headerlink\" title=\"GLSL学习\"></a>GLSL学习</h1><h2 id=\"1-三种变量类型（uniform、attribute、varying）\"><a href=\"#1-三种变量类型（uniform、attribute、varying）\" class=\"headerlink\" title=\"1. 三种变量类型（uniform、attribute、varying）\"></a>1. 三种变量类型（uniform、attribute、varying）</h2><p>1.1 uniform变量</p>\n<p>uniform变量由外部程序传递给shader的变量。</p>\n"},{"_content":"#### 1. 普通01背包\n\n现有一个容量大小为`V`的背包和`N`件物品，每件物品有两个属性，<u>体积</u>和<u>价值</u>，请问这个背包最多能装价值为多少的物品？\n\n##### 1.1 状态定义:star:\n\ndp\\[i][v]，$i\\in[0,n]$，i=0无定义，i=1表示处理第1件物品，总体解释为：前i件物品已经处理完成了，总体积为v，此时的最大价值为dp\\[i][v]\n\n##### 1.2 状态转移方程\n\n$$\ndp[i][v]=\n\\begin{cases}\ndp[i-1][v],\\quad \\quad \\quad \\ \\ \\ 把第i件物品放入背包的最大价值\\\\\ndp[i-1][v-v[i]]+e[i],\\quad 不把第i件物品放入背包的最大价值\\\\\n\\end{cases}\n$$\n\n##### 1.3 边界预处理\n\n```cpp\nfor(int i=0;i<=n;i++){\n    dp[i][0]=0;\n}\n```\n\n##### 1.4 状态转移\n\n```cpp\nfor(int i=1;i<=n;i++){\n    for(int j=1;j<=v;j++){\n        if(j>=v[i])\n            dp[i][j]=max(dp[i-1][j],dp[i-1][j-v[i]]+e[i]);\n        else dp[i][j]=dp[i-1][j]\n    }\n}\n```\n\n##### 1.5 空间优化\n\n","source":"_posts/数据结构与算法、/01背包问题.md","raw":"#### 1. 普通01背包\n\n现有一个容量大小为`V`的背包和`N`件物品，每件物品有两个属性，<u>体积</u>和<u>价值</u>，请问这个背包最多能装价值为多少的物品？\n\n##### 1.1 状态定义:star:\n\ndp\\[i][v]，$i\\in[0,n]$，i=0无定义，i=1表示处理第1件物品，总体解释为：前i件物品已经处理完成了，总体积为v，此时的最大价值为dp\\[i][v]\n\n##### 1.2 状态转移方程\n\n$$\ndp[i][v]=\n\\begin{cases}\ndp[i-1][v],\\quad \\quad \\quad \\ \\ \\ 把第i件物品放入背包的最大价值\\\\\ndp[i-1][v-v[i]]+e[i],\\quad 不把第i件物品放入背包的最大价值\\\\\n\\end{cases}\n$$\n\n##### 1.3 边界预处理\n\n```cpp\nfor(int i=0;i<=n;i++){\n    dp[i][0]=0;\n}\n```\n\n##### 1.4 状态转移\n\n```cpp\nfor(int i=1;i<=n;i++){\n    for(int j=1;j<=v;j++){\n        if(j>=v[i])\n            dp[i][j]=max(dp[i-1][j],dp[i-1][j-v[i]]+e[i]);\n        else dp[i][j]=dp[i-1][j]\n    }\n}\n```\n\n##### 1.5 空间优化\n\n","slug":"数据结构与算法、/01背包问题","published":1,"date":"2022-04-15T00:34:47.773Z","updated":"2022-04-15T01:03:21.457Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0kx5000jpcu38611cy1f","content":"<h4 id=\"1-普通01背包\"><a href=\"#1-普通01背包\" class=\"headerlink\" title=\"1. 普通01背包\"></a>1. 普通01背包</h4><p>现有一个容量大小为<code>V</code>的背包和<code>N</code>件物品，每件物品有两个属性，<u>体积</u>和<u>价值</u>，请问这个背包最多能装价值为多少的物品？</p>\n<h5 id=\"1-1-状态定义-star\"><a href=\"#1-1-状态定义-star\" class=\"headerlink\" title=\"1.1 状态定义:star:\"></a>1.1 状态定义:star:</h5><p>dp[i][v]，$i\\in[0,n]$，i=0无定义，i=1表示处理第1件物品，总体解释为：前i件物品已经处理完成了，总体积为v，此时的最大价值为dp[i][v]</p>\n<h5 id=\"1-2-状态转移方程\"><a href=\"#1-2-状态转移方程\" class=\"headerlink\" title=\"1.2 状态转移方程\"></a>1.2 状态转移方程</h5><p>$$<br>dp[i][v]=<br>\\begin{cases}<br>dp[i-1][v],\\quad \\quad \\quad \\ \\ \\ 把第i件物品放入背包的最大价值\\<br>dp[i-1][v-v[i]]+e[i],\\quad 不把第i件物品放入背包的最大价值\\<br>\\end{cases}<br>$$</p>\n<h5 id=\"1-3-边界预处理\"><a href=\"#1-3-边界预处理\" class=\"headerlink\" title=\"1.3 边界预处理\"></a>1.3 边界预处理</h5><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">    dp[i][<span class=\"number\">0</span>]=<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"1-4-状态转移\"><a href=\"#1-4-状态转移\" class=\"headerlink\" title=\"1.4 状态转移\"></a>1.4 状态转移</h5><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">1</span>;j&lt;=v;j++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(j&gt;=v[i])</span><br><span class=\"line\">            dp[i][j]=<span class=\"built_in\">max</span>(dp[i<span class=\"number\">-1</span>][j],dp[i<span class=\"number\">-1</span>][j-v[i]]+e[i]);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> dp[i][j]=dp[i<span class=\"number\">-1</span>][j]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"1-5-空间优化\"><a href=\"#1-5-空间优化\" class=\"headerlink\" title=\"1.5 空间优化\"></a>1.5 空间优化</h5>","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<h4 id=\"1-普通01背包\"><a href=\"#1-普通01背包\" class=\"headerlink\" title=\"1. 普通01背包\"></a>1. 普通01背包</h4><p>现有一个容量大小为<code>V</code>的背包和<code>N</code>件物品，每件物品有两个属性，<u>体积</u>和<u>价值</u>，请问这个背包最多能装价值为多少的物品？</p>\n<h5 id=\"1-1-状态定义-star\"><a href=\"#1-1-状态定义-star\" class=\"headerlink\" title=\"1.1 状态定义:star:\"></a>1.1 状态定义:star:</h5><p>dp[i][v]，$i\\in[0,n]$，i=0无定义，i=1表示处理第1件物品，总体解释为：前i件物品已经处理完成了，总体积为v，此时的最大价值为dp[i][v]</p>\n<h5 id=\"1-2-状态转移方程\"><a href=\"#1-2-状态转移方程\" class=\"headerlink\" title=\"1.2 状态转移方程\"></a>1.2 状态转移方程</h5><p>$$<br>dp[i][v]=<br>\\begin{cases}<br>dp[i-1][v],\\quad \\quad \\quad \\ \\ \\ 把第i件物品放入背包的最大价值\\<br>dp[i-1][v-v[i]]+e[i],\\quad 不把第i件物品放入背包的最大价值\\<br>\\end{cases}<br>$$</p>\n<h5 id=\"1-3-边界预处理\"><a href=\"#1-3-边界预处理\" class=\"headerlink\" title=\"1.3 边界预处理\"></a>1.3 边界预处理</h5><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">    dp[i][<span class=\"number\">0</span>]=<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"1-4-状态转移\"><a href=\"#1-4-状态转移\" class=\"headerlink\" title=\"1.4 状态转移\"></a>1.4 状态转移</h5><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">1</span>;j&lt;=v;j++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(j&gt;=v[i])</span><br><span class=\"line\">            dp[i][j]=<span class=\"built_in\">max</span>(dp[i<span class=\"number\">-1</span>][j],dp[i<span class=\"number\">-1</span>][j-v[i]]+e[i]);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> dp[i][j]=dp[i<span class=\"number\">-1</span>][j]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"1-5-空间优化\"><a href=\"#1-5-空间优化\" class=\"headerlink\" title=\"1.5 空间优化\"></a>1.5 空间优化</h5>"},{"_content":"随机打乱一个数组的算法\n\nShuffleArray(array)\n\n```CPP\n    vector<int> shuffle() {\n        vector<int> nums(arr);\n        for (int i = 0; i < nums.size(); i++) {\n            int index = i + rand() % (nums.size() - i);\n            swap(nums, index, i);\n        }\n        return nums;\n    }\n```\n\n假设有`n`个元素，遍历数组中每一个元素，对于下标为`i`的元素，在`[i,n-i]`的范围内随机选择一个元素，与下标为`i`的元素作交换\n\n这样为什么可以实现公平？即每个数都有相等的概率被放到任意一个位置中，即每个位置中出现任意一个数的概率都是相同的\n\n`i=0`时，在`n`个元素中随机选择一个数与`arr[0]`交换，每个数在arr[0]的概率都是1/n\n\n`i=1`时，在`n-1`个元素中随机选择一个数与`arr[1]`交换，每个数在`arr[1]`的概率=$\\frac{4}{5}\\times\\frac{1}{4}=\\frac{1}{5}$，所以也是`1/n`\n\n`4/5`的意思是，某数要出现在`arr[1]`，那它不能在上一轮被确定位置，所以，它需要属于上一轮的幸存者，概率为$\\frac{n-1}{n}=\\frac{4}{5}$，然后在当前轮中，它需要被选中，概率是$\\frac{1}{4}$，所以总概率为$\\frac{1}{5}$\n\n以此类推，每个位置中出现任意一个数的概率都是相同的\n\n![img](https://raw.githubusercontent.com/Vio1ette/blog-img/main/1616380923-YvHlbL-53BF82B993210EA6F26B63EC7BDBFB04.png)","source":"_posts/数据结构与算法、/随机打乱一个数组的算法.md","raw":"随机打乱一个数组的算法\n\nShuffleArray(array)\n\n```CPP\n    vector<int> shuffle() {\n        vector<int> nums(arr);\n        for (int i = 0; i < nums.size(); i++) {\n            int index = i + rand() % (nums.size() - i);\n            swap(nums, index, i);\n        }\n        return nums;\n    }\n```\n\n假设有`n`个元素，遍历数组中每一个元素，对于下标为`i`的元素，在`[i,n-i]`的范围内随机选择一个元素，与下标为`i`的元素作交换\n\n这样为什么可以实现公平？即每个数都有相等的概率被放到任意一个位置中，即每个位置中出现任意一个数的概率都是相同的\n\n`i=0`时，在`n`个元素中随机选择一个数与`arr[0]`交换，每个数在arr[0]的概率都是1/n\n\n`i=1`时，在`n-1`个元素中随机选择一个数与`arr[1]`交换，每个数在`arr[1]`的概率=$\\frac{4}{5}\\times\\frac{1}{4}=\\frac{1}{5}$，所以也是`1/n`\n\n`4/5`的意思是，某数要出现在`arr[1]`，那它不能在上一轮被确定位置，所以，它需要属于上一轮的幸存者，概率为$\\frac{n-1}{n}=\\frac{4}{5}$，然后在当前轮中，它需要被选中，概率是$\\frac{1}{4}$，所以总概率为$\\frac{1}{5}$\n\n以此类推，每个位置中出现任意一个数的概率都是相同的\n\n![img](https://raw.githubusercontent.com/Vio1ette/blog-img/main/1616380923-YvHlbL-53BF82B993210EA6F26B63EC7BDBFB04.png)","slug":"数据结构与算法、/随机打乱一个数组的算法","published":1,"date":"2022-05-07T02:06:18.917Z","updated":"2022-05-07T08:10:45.034Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0kx6000kpcu39hmv3h3s","content":"<p>随机打乱一个数组的算法</p>\n<p>ShuffleArray(array)</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">shuffle</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">nums</span><span class=\"params\">(arr)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.<span class=\"built_in\">size</span>(); i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = i + <span class=\"built_in\">rand</span>() % (nums.<span class=\"built_in\">size</span>() - i);</span><br><span class=\"line\">        <span class=\"built_in\">swap</span>(nums, index, i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nums;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>假设有<code>n</code>个元素，遍历数组中每一个元素，对于下标为<code>i</code>的元素，在<code>[i,n-i]</code>的范围内随机选择一个元素，与下标为<code>i</code>的元素作交换</p>\n<p>这样为什么可以实现公平？即每个数都有相等的概率被放到任意一个位置中，即每个位置中出现任意一个数的概率都是相同的</p>\n<p><code>i=0</code>时，在<code>n</code>个元素中随机选择一个数与<code>arr[0]</code>交换，每个数在arr[0]的概率都是1/n</p>\n<p><code>i=1</code>时，在<code>n-1</code>个元素中随机选择一个数与<code>arr[1]</code>交换，每个数在<code>arr[1]</code>的概率=$\\frac{4}{5}\\times\\frac{1}{4}=\\frac{1}{5}$，所以也是<code>1/n</code></p>\n<p><code>4/5</code>的意思是，某数要出现在<code>arr[1]</code>，那它不能在上一轮被确定位置，所以，它需要属于上一轮的幸存者，概率为$\\frac{n-1}{n}=\\frac{4}{5}$，然后在当前轮中，它需要被选中，概率是$\\frac{1}{4}$，所以总概率为$\\frac{1}{5}$</p>\n<p>以此类推，每个位置中出现任意一个数的概率都是相同的</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/1616380923-YvHlbL-53BF82B993210EA6F26B63EC7BDBFB04.png\" alt=\"img\"></p>\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<p>随机打乱一个数组的算法</p>\n<p>ShuffleArray(array)</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">shuffle</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">nums</span><span class=\"params\">(arr)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.<span class=\"built_in\">size</span>(); i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = i + <span class=\"built_in\">rand</span>() % (nums.<span class=\"built_in\">size</span>() - i);</span><br><span class=\"line\">        <span class=\"built_in\">swap</span>(nums, index, i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nums;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>假设有<code>n</code>个元素，遍历数组中每一个元素，对于下标为<code>i</code>的元素，在<code>[i,n-i]</code>的范围内随机选择一个元素，与下标为<code>i</code>的元素作交换</p>\n<p>这样为什么可以实现公平？即每个数都有相等的概率被放到任意一个位置中，即每个位置中出现任意一个数的概率都是相同的</p>\n<p><code>i=0</code>时，在<code>n</code>个元素中随机选择一个数与<code>arr[0]</code>交换，每个数在arr[0]的概率都是1/n</p>\n<p><code>i=1</code>时，在<code>n-1</code>个元素中随机选择一个数与<code>arr[1]</code>交换，每个数在<code>arr[1]</code>的概率=$\\frac{4}{5}\\times\\frac{1}{4}=\\frac{1}{5}$，所以也是<code>1/n</code></p>\n<p><code>4/5</code>的意思是，某数要出现在<code>arr[1]</code>，那它不能在上一轮被确定位置，所以，它需要属于上一轮的幸存者，概率为$\\frac{n-1}{n}=\\frac{4}{5}$，然后在当前轮中，它需要被选中，概率是$\\frac{1}{4}$，所以总概率为$\\frac{1}{5}$</p>\n<p>以此类推，每个位置中出现任意一个数的概率都是相同的</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/1616380923-YvHlbL-53BF82B993210EA6F26B63EC7BDBFB04.png\" alt=\"img\"></p>\n"},{"_content":"参考：CSAPP\n\n使用虚拟内存的好处：\n\n1. 将主存看作一个存储在磁盘上的地址空间的高速缓存，在主存中只保留活动区域，需要时再从磁盘传送数据，不用将整个程序全部装入内存，即使程序的运行只会使用到其中一小部分代码\n2. 为每个进程提供了一致的地址空间，从而简化了内存管理\n3. 保护了每个进程的地址空间不被其他进程破坏（安全性）\n\n#### 1. 缓存\n\n![image-20220504151725878](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220504151725878.png)\n\n在任意时刻，虚拟页面的集合都分为三个不相交的子集：\n\n1. 未分配的，未分配的页没有任何数据，不占用磁盘空间（虚拟的）\n2. 已缓存的，当前在主存中的页\n3. 未缓存的，已经分配的，但暂时用不到，所以未缓存在物理内存中\n\n##### 1.1 页表\n\n进程的逻辑地址被分页处理，每个进程都有一个页表，进程虚拟地址空间中的每一页都对应着一个页表项，用来将虚拟页面映射为页框，从数学角度说，页表是一个函数，它的输入是虚拟页号，输出是物理页框号\n\n示例：\n\n![image-20220504154324556](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220504154324556.png)\n\n输入的16位虚拟地址8196（二进制是00100000000000100）被分为4位的页号和12位的偏移，利用页号作为索引查找页表，映射后的物理页框号为110，再加上虚拟地址的低12位偏移，就构成了15位的物理地址。\n\n##### 1.2 局部性\n\n局部性原则保证了在任意时刻，程序将趋向于在一个较小的活动页面（active page）集合上工作，称为工作集（working set）或者常驻集合（resident set），这就保证了可接受的缓存命中率\n\n#### 2. 内存管理\n\n每个进程都有自己页表，都有自己的独立地址空间，多个虚拟页面可以映射到同一个共享物理内存页面上，VM在内存管理方面的作用：\n\n1. 简化链接，独立的地址空间允许每个进程的内存映像使用相同的基本格式\n2. 简化加载\n3. 简化共享\n4. 简化内存分配，逻辑上连续的内存在物理上不一定连续\n\n#### 3. 内存保护\n\n每个进程都有自己私有的代码、数据、堆以及栈区域，不与其他进程共享，利用页表控制一个虚拟页面的访问权限也十分容易","source":"_posts/操作系统/虚拟内存.md","raw":"参考：CSAPP\n\n使用虚拟内存的好处：\n\n1. 将主存看作一个存储在磁盘上的地址空间的高速缓存，在主存中只保留活动区域，需要时再从磁盘传送数据，不用将整个程序全部装入内存，即使程序的运行只会使用到其中一小部分代码\n2. 为每个进程提供了一致的地址空间，从而简化了内存管理\n3. 保护了每个进程的地址空间不被其他进程破坏（安全性）\n\n#### 1. 缓存\n\n![image-20220504151725878](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220504151725878.png)\n\n在任意时刻，虚拟页面的集合都分为三个不相交的子集：\n\n1. 未分配的，未分配的页没有任何数据，不占用磁盘空间（虚拟的）\n2. 已缓存的，当前在主存中的页\n3. 未缓存的，已经分配的，但暂时用不到，所以未缓存在物理内存中\n\n##### 1.1 页表\n\n进程的逻辑地址被分页处理，每个进程都有一个页表，进程虚拟地址空间中的每一页都对应着一个页表项，用来将虚拟页面映射为页框，从数学角度说，页表是一个函数，它的输入是虚拟页号，输出是物理页框号\n\n示例：\n\n![image-20220504154324556](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220504154324556.png)\n\n输入的16位虚拟地址8196（二进制是00100000000000100）被分为4位的页号和12位的偏移，利用页号作为索引查找页表，映射后的物理页框号为110，再加上虚拟地址的低12位偏移，就构成了15位的物理地址。\n\n##### 1.2 局部性\n\n局部性原则保证了在任意时刻，程序将趋向于在一个较小的活动页面（active page）集合上工作，称为工作集（working set）或者常驻集合（resident set），这就保证了可接受的缓存命中率\n\n#### 2. 内存管理\n\n每个进程都有自己页表，都有自己的独立地址空间，多个虚拟页面可以映射到同一个共享物理内存页面上，VM在内存管理方面的作用：\n\n1. 简化链接，独立的地址空间允许每个进程的内存映像使用相同的基本格式\n2. 简化加载\n3. 简化共享\n4. 简化内存分配，逻辑上连续的内存在物理上不一定连续\n\n#### 3. 内存保护\n\n每个进程都有自己私有的代码、数据、堆以及栈区域，不与其他进程共享，利用页表控制一个虚拟页面的访问权限也十分容易","slug":"操作系统/虚拟内存","published":1,"date":"2022-05-04T06:53:44.442Z","updated":"2022-05-04T08:10:40.487Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0kx7000lpcu38k8ldy2d","content":"<p>参考：CSAPP</p>\n<p>使用虚拟内存的好处：</p>\n<ol>\n<li>将主存看作一个存储在磁盘上的地址空间的高速缓存，在主存中只保留活动区域，需要时再从磁盘传送数据，不用将整个程序全部装入内存，即使程序的运行只会使用到其中一小部分代码</li>\n<li>为每个进程提供了一致的地址空间，从而简化了内存管理</li>\n<li>保护了每个进程的地址空间不被其他进程破坏（安全性）</li>\n</ol>\n<h4 id=\"1-缓存\"><a href=\"#1-缓存\" class=\"headerlink\" title=\"1. 缓存\"></a>1. 缓存</h4><p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220504151725878.png\" alt=\"image-20220504151725878\"></p>\n<p>在任意时刻，虚拟页面的集合都分为三个不相交的子集：</p>\n<ol>\n<li>未分配的，未分配的页没有任何数据，不占用磁盘空间（虚拟的）</li>\n<li>已缓存的，当前在主存中的页</li>\n<li>未缓存的，已经分配的，但暂时用不到，所以未缓存在物理内存中</li>\n</ol>\n<h5 id=\"1-1-页表\"><a href=\"#1-1-页表\" class=\"headerlink\" title=\"1.1 页表\"></a>1.1 页表</h5><p>进程的逻辑地址被分页处理，每个进程都有一个页表，进程虚拟地址空间中的每一页都对应着一个页表项，用来将虚拟页面映射为页框，从数学角度说，页表是一个函数，它的输入是虚拟页号，输出是物理页框号</p>\n<p>示例：</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220504154324556.png\" alt=\"image-20220504154324556\"></p>\n<p>输入的16位虚拟地址8196（二进制是00100000000000100）被分为4位的页号和12位的偏移，利用页号作为索引查找页表，映射后的物理页框号为110，再加上虚拟地址的低12位偏移，就构成了15位的物理地址。</p>\n<h5 id=\"1-2-局部性\"><a href=\"#1-2-局部性\" class=\"headerlink\" title=\"1.2 局部性\"></a>1.2 局部性</h5><p>局部性原则保证了在任意时刻，程序将趋向于在一个较小的活动页面（active page）集合上工作，称为工作集（working set）或者常驻集合（resident set），这就保证了可接受的缓存命中率</p>\n<h4 id=\"2-内存管理\"><a href=\"#2-内存管理\" class=\"headerlink\" title=\"2. 内存管理\"></a>2. 内存管理</h4><p>每个进程都有自己页表，都有自己的独立地址空间，多个虚拟页面可以映射到同一个共享物理内存页面上，VM在内存管理方面的作用：</p>\n<ol>\n<li>简化链接，独立的地址空间允许每个进程的内存映像使用相同的基本格式</li>\n<li>简化加载</li>\n<li>简化共享</li>\n<li>简化内存分配，逻辑上连续的内存在物理上不一定连续</li>\n</ol>\n<h4 id=\"3-内存保护\"><a href=\"#3-内存保护\" class=\"headerlink\" title=\"3. 内存保护\"></a>3. 内存保护</h4><p>每个进程都有自己私有的代码、数据、堆以及栈区域，不与其他进程共享，利用页表控制一个虚拟页面的访问权限也十分容易</p>\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<p>参考：CSAPP</p>\n<p>使用虚拟内存的好处：</p>\n<ol>\n<li>将主存看作一个存储在磁盘上的地址空间的高速缓存，在主存中只保留活动区域，需要时再从磁盘传送数据，不用将整个程序全部装入内存，即使程序的运行只会使用到其中一小部分代码</li>\n<li>为每个进程提供了一致的地址空间，从而简化了内存管理</li>\n<li>保护了每个进程的地址空间不被其他进程破坏（安全性）</li>\n</ol>\n<h4 id=\"1-缓存\"><a href=\"#1-缓存\" class=\"headerlink\" title=\"1. 缓存\"></a>1. 缓存</h4><p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220504151725878.png\" alt=\"image-20220504151725878\"></p>\n<p>在任意时刻，虚拟页面的集合都分为三个不相交的子集：</p>\n<ol>\n<li>未分配的，未分配的页没有任何数据，不占用磁盘空间（虚拟的）</li>\n<li>已缓存的，当前在主存中的页</li>\n<li>未缓存的，已经分配的，但暂时用不到，所以未缓存在物理内存中</li>\n</ol>\n<h5 id=\"1-1-页表\"><a href=\"#1-1-页表\" class=\"headerlink\" title=\"1.1 页表\"></a>1.1 页表</h5><p>进程的逻辑地址被分页处理，每个进程都有一个页表，进程虚拟地址空间中的每一页都对应着一个页表项，用来将虚拟页面映射为页框，从数学角度说，页表是一个函数，它的输入是虚拟页号，输出是物理页框号</p>\n<p>示例：</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220504154324556.png\" alt=\"image-20220504154324556\"></p>\n<p>输入的16位虚拟地址8196（二进制是00100000000000100）被分为4位的页号和12位的偏移，利用页号作为索引查找页表，映射后的物理页框号为110，再加上虚拟地址的低12位偏移，就构成了15位的物理地址。</p>\n<h5 id=\"1-2-局部性\"><a href=\"#1-2-局部性\" class=\"headerlink\" title=\"1.2 局部性\"></a>1.2 局部性</h5><p>局部性原则保证了在任意时刻，程序将趋向于在一个较小的活动页面（active page）集合上工作，称为工作集（working set）或者常驻集合（resident set），这就保证了可接受的缓存命中率</p>\n<h4 id=\"2-内存管理\"><a href=\"#2-内存管理\" class=\"headerlink\" title=\"2. 内存管理\"></a>2. 内存管理</h4><p>每个进程都有自己页表，都有自己的独立地址空间，多个虚拟页面可以映射到同一个共享物理内存页面上，VM在内存管理方面的作用：</p>\n<ol>\n<li>简化链接，独立的地址空间允许每个进程的内存映像使用相同的基本格式</li>\n<li>简化加载</li>\n<li>简化共享</li>\n<li>简化内存分配，逻辑上连续的内存在物理上不一定连续</li>\n</ol>\n<h4 id=\"3-内存保护\"><a href=\"#3-内存保护\" class=\"headerlink\" title=\"3. 内存保护\"></a>3. 内存保护</h4><p>每个进程都有自己私有的代码、数据、堆以及栈区域，不与其他进程共享，利用页表控制一个虚拟页面的访问权限也十分容易</p>\n"},{"_content":"进程和线程的区别\n\n进程是os分配资源的最小单位，线程是CPU进行调度的最小单位\n\n一个进程可以有多个线程，这些线程共享同一进程的地址空间\n\n线程间进行切换和通信的开销小于进程间切换和通信\n\n一个进程的终止不会影响其他进程，而一个线程的终止会使整个进程终止，即同属这个进程的其他线程也无法执行\n\n#### 线程间到底共享了哪些进程资源？\n\n可以反向考虑，哪些资源是线程私有的？线程的本质就是函数的执行，所以一个线程执行的私有资源就是一个函数调用所需要的资源，包括：栈（帧）、寄存器，除了这些，进程地址空间中的其他资源，都是线程间共享的\n\n","source":"_posts/操作系统/进程和线程.md","raw":"进程和线程的区别\n\n进程是os分配资源的最小单位，线程是CPU进行调度的最小单位\n\n一个进程可以有多个线程，这些线程共享同一进程的地址空间\n\n线程间进行切换和通信的开销小于进程间切换和通信\n\n一个进程的终止不会影响其他进程，而一个线程的终止会使整个进程终止，即同属这个进程的其他线程也无法执行\n\n#### 线程间到底共享了哪些进程资源？\n\n可以反向考虑，哪些资源是线程私有的？线程的本质就是函数的执行，所以一个线程执行的私有资源就是一个函数调用所需要的资源，包括：栈（帧）、寄存器，除了这些，进程地址空间中的其他资源，都是线程间共享的\n\n","slug":"操作系统/进程和线程","published":1,"date":"2022-05-12T06:54:21.188Z","updated":"2022-05-12T07:06:49.013Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0kx7000mpcu3798ddufo","content":"<p>进程和线程的区别</p>\n<p>进程是os分配资源的最小单位，线程是CPU进行调度的最小单位</p>\n<p>一个进程可以有多个线程，这些线程共享同一进程的地址空间</p>\n<p>线程间进行切换和通信的开销小于进程间切换和通信</p>\n<p>一个进程的终止不会影响其他进程，而一个线程的终止会使整个进程终止，即同属这个进程的其他线程也无法执行</p>\n<h4 id=\"线程间到底共享了哪些进程资源？\"><a href=\"#线程间到底共享了哪些进程资源？\" class=\"headerlink\" title=\"线程间到底共享了哪些进程资源？\"></a>线程间到底共享了哪些进程资源？</h4><p>可以反向考虑，哪些资源是线程私有的？线程的本质就是函数的执行，所以一个线程执行的私有资源就是一个函数调用所需要的资源，包括：栈（帧）、寄存器，除了这些，进程地址空间中的其他资源，都是线程间共享的</p>\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<p>进程和线程的区别</p>\n<p>进程是os分配资源的最小单位，线程是CPU进行调度的最小单位</p>\n<p>一个进程可以有多个线程，这些线程共享同一进程的地址空间</p>\n<p>线程间进行切换和通信的开销小于进程间切换和通信</p>\n<p>一个进程的终止不会影响其他进程，而一个线程的终止会使整个进程终止，即同属这个进程的其他线程也无法执行</p>\n<h4 id=\"线程间到底共享了哪些进程资源？\"><a href=\"#线程间到底共享了哪些进程资源？\" class=\"headerlink\" title=\"线程间到底共享了哪些进程资源？\"></a>线程间到底共享了哪些进程资源？</h4><p>可以反向考虑，哪些资源是线程私有的？线程的本质就是函数的执行，所以一个线程执行的私有资源就是一个函数调用所需要的资源，包括：栈（帧）、寄存器，除了这些，进程地址空间中的其他资源，都是线程间共享的</p>\n"},{"_content":"TCP是可靠的传输，它通过乱序、丢包重传、流量控制、拥塞控制来保证可靠性\n\n### 1. 流量控制（滑动窗口）\n\n每发送一个包，必须接收到它的确认后才能发下一个包，这种方式效率太低。滑动窗口可以允许发送方一次发送多个包，只用接收方确认一次，且还能根据接收方的接收窗口调整发送窗口的大小， 以避免发送过多的包\n\n![image-20220501193841881](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220501193841881.png)\n\n发送窗口的大小 = 接收窗口的大小 - 已发送但没被确认的包的数量\n\n### 2. 拥塞控制\n\n流量控制和拥塞控制的区别\n\n> 流量控制为了解决发送方和接收方速率不匹配的问题，而拥塞控制是作用于网络的，是为了防止过多的数据注入到网络中，避免出现网络负载过大的情况。\n\n#### 2.1 慢开始\n\n> 为了讨论方便，假设接收方总是有足够大的接收缓存\n\n发送方维持一个拥塞窗口（cwnd）的状态变量，拥塞窗口的大小取决于网络的拥塞程度，并且动态地变化，通常情况下，发送窗口 = min(cwnd, 接收窗口)，这里由于假设接收窗口足够大，所以，发送窗口 = 拥塞窗口\n\n为了对网络进行“试探”，拥塞窗口的初始值很小，只有一个发送方的最大报文段MSS的大小，然后在随后的过程中，没收到一个新的对报文段的确认，就可以把拥塞窗口增加一个MSS\n\n![image-20220501202208725](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220501202208725.png)\n\n从图中可以看出cwnd是呈指数增长，每过一个轮次就加倍\n\n> 一个传输轮次：发送方从发送一批分组到收到它们的确认所经历的时间，即往返时间RTT\n\n#### 2.2 拥塞避免\n\n为了防止过大的拥塞窗口，出现了慢开始门限，当拥塞窗口的大小小于慢开始门限时，使用慢开始算法，反之，当拥塞窗口大于慢开始门限时，说明拥塞窗口的大小已经很大了，需要加以限制，于是就有了拥塞避免算法，即加法增大拥塞窗口\n\n\n\n![image-20220501201652395](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220501201652395.png)\n\n无论何时（慢开始阶段或拥塞避免阶段），只要出现<u>超时</u>现象，就把慢开始门限设置为超时时拥塞窗口的一半大小，然后将拥塞窗口大小重置为1，重新开始慢开始阶段\n\n#### 2.3 快重传和快恢复\n\n快重传：发送方如果收到了三个冗余ACK，就说明个别包已经丢失，执行快重传，立即重传这个包（即使现在还没有超时）\n\n快恢复：收到三个冗余的ACK时，虽然还未出现超时现象，但已经直到个别包出现了丢失现象，此时调整慢开始门限值为当前拥塞窗口的一半，同时设置拥塞窗口为新的门限值，简单来讲就是拥塞窗口变为了原来的一半，然后执行加法增大（门限值=拥塞窗口大小）\n\n### 3. TCP三次握手\n\n![image-20220501185937682](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220501185937682.png)\n\n#### 2.1 二次握手可以吗？\n\n不行，因为\n\n（1）需要三次握手才能确定发送方和接受方的发送功能和接收功能都是正常的\n\n（2）假设只需两次握手就可以建立连接，且客户端向服务端发送的同步包在网络中滞留时间过长，导致重传，如果在重传正常建立连接、传输数据、关闭连接后，原先滞留的数据包到达服务器，服务器回传确认包给发送方，由于是二次握手，就会导致异常的连接被建立。\n\n#### 2.2 三次握手可以携带数据吗？\n\n第三次握手可以\n\n### 3. TCP四次挥手\n\n![image-20220501190853686](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220501190853686.png)\n\n#### 3.1 为什么客户端要等待2MSL\n\nMSL是报文在网络中可存活的最大时间，如果客户端发的最后一个ACK丢失了，服务器将会重发一个FIN，此时如果客户端早早关闭了的话，服务器就无法正常关闭了\n\n\n\n和UDP的区别\n\n1. TCP是有连接的，需要三次握手建立连接，UDP是无连接的\n2. TCP保证可靠的传输，而UDP不是\n3. TCP是端到端的，而UDP除了端到端还可以多播、广播\n4. TCP传输的是字节流，而UDP传输的是报文","source":"_posts/网络/TCP和UDP的区别.md","raw":"TCP是可靠的传输，它通过乱序、丢包重传、流量控制、拥塞控制来保证可靠性\n\n### 1. 流量控制（滑动窗口）\n\n每发送一个包，必须接收到它的确认后才能发下一个包，这种方式效率太低。滑动窗口可以允许发送方一次发送多个包，只用接收方确认一次，且还能根据接收方的接收窗口调整发送窗口的大小， 以避免发送过多的包\n\n![image-20220501193841881](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220501193841881.png)\n\n发送窗口的大小 = 接收窗口的大小 - 已发送但没被确认的包的数量\n\n### 2. 拥塞控制\n\n流量控制和拥塞控制的区别\n\n> 流量控制为了解决发送方和接收方速率不匹配的问题，而拥塞控制是作用于网络的，是为了防止过多的数据注入到网络中，避免出现网络负载过大的情况。\n\n#### 2.1 慢开始\n\n> 为了讨论方便，假设接收方总是有足够大的接收缓存\n\n发送方维持一个拥塞窗口（cwnd）的状态变量，拥塞窗口的大小取决于网络的拥塞程度，并且动态地变化，通常情况下，发送窗口 = min(cwnd, 接收窗口)，这里由于假设接收窗口足够大，所以，发送窗口 = 拥塞窗口\n\n为了对网络进行“试探”，拥塞窗口的初始值很小，只有一个发送方的最大报文段MSS的大小，然后在随后的过程中，没收到一个新的对报文段的确认，就可以把拥塞窗口增加一个MSS\n\n![image-20220501202208725](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220501202208725.png)\n\n从图中可以看出cwnd是呈指数增长，每过一个轮次就加倍\n\n> 一个传输轮次：发送方从发送一批分组到收到它们的确认所经历的时间，即往返时间RTT\n\n#### 2.2 拥塞避免\n\n为了防止过大的拥塞窗口，出现了慢开始门限，当拥塞窗口的大小小于慢开始门限时，使用慢开始算法，反之，当拥塞窗口大于慢开始门限时，说明拥塞窗口的大小已经很大了，需要加以限制，于是就有了拥塞避免算法，即加法增大拥塞窗口\n\n\n\n![image-20220501201652395](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220501201652395.png)\n\n无论何时（慢开始阶段或拥塞避免阶段），只要出现<u>超时</u>现象，就把慢开始门限设置为超时时拥塞窗口的一半大小，然后将拥塞窗口大小重置为1，重新开始慢开始阶段\n\n#### 2.3 快重传和快恢复\n\n快重传：发送方如果收到了三个冗余ACK，就说明个别包已经丢失，执行快重传，立即重传这个包（即使现在还没有超时）\n\n快恢复：收到三个冗余的ACK时，虽然还未出现超时现象，但已经直到个别包出现了丢失现象，此时调整慢开始门限值为当前拥塞窗口的一半，同时设置拥塞窗口为新的门限值，简单来讲就是拥塞窗口变为了原来的一半，然后执行加法增大（门限值=拥塞窗口大小）\n\n### 3. TCP三次握手\n\n![image-20220501185937682](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220501185937682.png)\n\n#### 2.1 二次握手可以吗？\n\n不行，因为\n\n（1）需要三次握手才能确定发送方和接受方的发送功能和接收功能都是正常的\n\n（2）假设只需两次握手就可以建立连接，且客户端向服务端发送的同步包在网络中滞留时间过长，导致重传，如果在重传正常建立连接、传输数据、关闭连接后，原先滞留的数据包到达服务器，服务器回传确认包给发送方，由于是二次握手，就会导致异常的连接被建立。\n\n#### 2.2 三次握手可以携带数据吗？\n\n第三次握手可以\n\n### 3. TCP四次挥手\n\n![image-20220501190853686](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220501190853686.png)\n\n#### 3.1 为什么客户端要等待2MSL\n\nMSL是报文在网络中可存活的最大时间，如果客户端发的最后一个ACK丢失了，服务器将会重发一个FIN，此时如果客户端早早关闭了的话，服务器就无法正常关闭了\n\n\n\n和UDP的区别\n\n1. TCP是有连接的，需要三次握手建立连接，UDP是无连接的\n2. TCP保证可靠的传输，而UDP不是\n3. TCP是端到端的，而UDP除了端到端还可以多播、广播\n4. TCP传输的是字节流，而UDP传输的是报文","slug":"网络/TCP和UDP的区别","published":1,"date":"2022-05-01T10:56:33.965Z","updated":"2022-05-01T12:36:23.815Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0kx8000npcu3biaheu1v","content":"<p>TCP是可靠的传输，它通过乱序、丢包重传、流量控制、拥塞控制来保证可靠性</p>\n<h3 id=\"1-流量控制（滑动窗口）\"><a href=\"#1-流量控制（滑动窗口）\" class=\"headerlink\" title=\"1. 流量控制（滑动窗口）\"></a>1. 流量控制（滑动窗口）</h3><p>每发送一个包，必须接收到它的确认后才能发下一个包，这种方式效率太低。滑动窗口可以允许发送方一次发送多个包，只用接收方确认一次，且还能根据接收方的接收窗口调整发送窗口的大小， 以避免发送过多的包</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220501193841881.png\" alt=\"image-20220501193841881\"></p>\n<p>发送窗口的大小 = 接收窗口的大小 - 已发送但没被确认的包的数量</p>\n<h3 id=\"2-拥塞控制\"><a href=\"#2-拥塞控制\" class=\"headerlink\" title=\"2. 拥塞控制\"></a>2. 拥塞控制</h3><p>流量控制和拥塞控制的区别</p>\n<blockquote>\n<p>流量控制为了解决发送方和接收方速率不匹配的问题，而拥塞控制是作用于网络的，是为了防止过多的数据注入到网络中，避免出现网络负载过大的情况。</p>\n</blockquote>\n<h4 id=\"2-1-慢开始\"><a href=\"#2-1-慢开始\" class=\"headerlink\" title=\"2.1 慢开始\"></a>2.1 慢开始</h4><blockquote>\n<p>为了讨论方便，假设接收方总是有足够大的接收缓存</p>\n</blockquote>\n<p>发送方维持一个拥塞窗口（cwnd）的状态变量，拥塞窗口的大小取决于网络的拥塞程度，并且动态地变化，通常情况下，发送窗口 = min(cwnd, 接收窗口)，这里由于假设接收窗口足够大，所以，发送窗口 = 拥塞窗口</p>\n<p>为了对网络进行“试探”，拥塞窗口的初始值很小，只有一个发送方的最大报文段MSS的大小，然后在随后的过程中，没收到一个新的对报文段的确认，就可以把拥塞窗口增加一个MSS</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220501202208725.png\" alt=\"image-20220501202208725\"></p>\n<p>从图中可以看出cwnd是呈指数增长，每过一个轮次就加倍</p>\n<blockquote>\n<p>一个传输轮次：发送方从发送一批分组到收到它们的确认所经历的时间，即往返时间RTT</p>\n</blockquote>\n<h4 id=\"2-2-拥塞避免\"><a href=\"#2-2-拥塞避免\" class=\"headerlink\" title=\"2.2 拥塞避免\"></a>2.2 拥塞避免</h4><p>为了防止过大的拥塞窗口，出现了慢开始门限，当拥塞窗口的大小小于慢开始门限时，使用慢开始算法，反之，当拥塞窗口大于慢开始门限时，说明拥塞窗口的大小已经很大了，需要加以限制，于是就有了拥塞避免算法，即加法增大拥塞窗口</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220501201652395.png\" alt=\"image-20220501201652395\"></p>\n<p>无论何时（慢开始阶段或拥塞避免阶段），只要出现<u>超时</u>现象，就把慢开始门限设置为超时时拥塞窗口的一半大小，然后将拥塞窗口大小重置为1，重新开始慢开始阶段</p>\n<h4 id=\"2-3-快重传和快恢复\"><a href=\"#2-3-快重传和快恢复\" class=\"headerlink\" title=\"2.3 快重传和快恢复\"></a>2.3 快重传和快恢复</h4><p>快重传：发送方如果收到了三个冗余ACK，就说明个别包已经丢失，执行快重传，立即重传这个包（即使现在还没有超时）</p>\n<p>快恢复：收到三个冗余的ACK时，虽然还未出现超时现象，但已经直到个别包出现了丢失现象，此时调整慢开始门限值为当前拥塞窗口的一半，同时设置拥塞窗口为新的门限值，简单来讲就是拥塞窗口变为了原来的一半，然后执行加法增大（门限值=拥塞窗口大小）</p>\n<h3 id=\"3-TCP三次握手\"><a href=\"#3-TCP三次握手\" class=\"headerlink\" title=\"3. TCP三次握手\"></a>3. TCP三次握手</h3><p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220501185937682.png\" alt=\"image-20220501185937682\"></p>\n<h4 id=\"2-1-二次握手可以吗？\"><a href=\"#2-1-二次握手可以吗？\" class=\"headerlink\" title=\"2.1 二次握手可以吗？\"></a>2.1 二次握手可以吗？</h4><p>不行，因为</p>\n<p>（1）需要三次握手才能确定发送方和接受方的发送功能和接收功能都是正常的</p>\n<p>（2）假设只需两次握手就可以建立连接，且客户端向服务端发送的同步包在网络中滞留时间过长，导致重传，如果在重传正常建立连接、传输数据、关闭连接后，原先滞留的数据包到达服务器，服务器回传确认包给发送方，由于是二次握手，就会导致异常的连接被建立。</p>\n<h4 id=\"2-2-三次握手可以携带数据吗？\"><a href=\"#2-2-三次握手可以携带数据吗？\" class=\"headerlink\" title=\"2.2 三次握手可以携带数据吗？\"></a>2.2 三次握手可以携带数据吗？</h4><p>第三次握手可以</p>\n<h3 id=\"3-TCP四次挥手\"><a href=\"#3-TCP四次挥手\" class=\"headerlink\" title=\"3. TCP四次挥手\"></a>3. TCP四次挥手</h3><p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220501190853686.png\" alt=\"image-20220501190853686\"></p>\n<h4 id=\"3-1-为什么客户端要等待2MSL\"><a href=\"#3-1-为什么客户端要等待2MSL\" class=\"headerlink\" title=\"3.1 为什么客户端要等待2MSL\"></a>3.1 为什么客户端要等待2MSL</h4><p>MSL是报文在网络中可存活的最大时间，如果客户端发的最后一个ACK丢失了，服务器将会重发一个FIN，此时如果客户端早早关闭了的话，服务器就无法正常关闭了</p>\n<p>和UDP的区别</p>\n<ol>\n<li>TCP是有连接的，需要三次握手建立连接，UDP是无连接的</li>\n<li>TCP保证可靠的传输，而UDP不是</li>\n<li>TCP是端到端的，而UDP除了端到端还可以多播、广播</li>\n<li>TCP传输的是字节流，而UDP传输的是报文</li>\n</ol>\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<p>TCP是可靠的传输，它通过乱序、丢包重传、流量控制、拥塞控制来保证可靠性</p>\n<h3 id=\"1-流量控制（滑动窗口）\"><a href=\"#1-流量控制（滑动窗口）\" class=\"headerlink\" title=\"1. 流量控制（滑动窗口）\"></a>1. 流量控制（滑动窗口）</h3><p>每发送一个包，必须接收到它的确认后才能发下一个包，这种方式效率太低。滑动窗口可以允许发送方一次发送多个包，只用接收方确认一次，且还能根据接收方的接收窗口调整发送窗口的大小， 以避免发送过多的包</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220501193841881.png\" alt=\"image-20220501193841881\"></p>\n<p>发送窗口的大小 = 接收窗口的大小 - 已发送但没被确认的包的数量</p>\n<h3 id=\"2-拥塞控制\"><a href=\"#2-拥塞控制\" class=\"headerlink\" title=\"2. 拥塞控制\"></a>2. 拥塞控制</h3><p>流量控制和拥塞控制的区别</p>\n<blockquote>\n<p>流量控制为了解决发送方和接收方速率不匹配的问题，而拥塞控制是作用于网络的，是为了防止过多的数据注入到网络中，避免出现网络负载过大的情况。</p>\n</blockquote>\n<h4 id=\"2-1-慢开始\"><a href=\"#2-1-慢开始\" class=\"headerlink\" title=\"2.1 慢开始\"></a>2.1 慢开始</h4><blockquote>\n<p>为了讨论方便，假设接收方总是有足够大的接收缓存</p>\n</blockquote>\n<p>发送方维持一个拥塞窗口（cwnd）的状态变量，拥塞窗口的大小取决于网络的拥塞程度，并且动态地变化，通常情况下，发送窗口 = min(cwnd, 接收窗口)，这里由于假设接收窗口足够大，所以，发送窗口 = 拥塞窗口</p>\n<p>为了对网络进行“试探”，拥塞窗口的初始值很小，只有一个发送方的最大报文段MSS的大小，然后在随后的过程中，没收到一个新的对报文段的确认，就可以把拥塞窗口增加一个MSS</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220501202208725.png\" alt=\"image-20220501202208725\"></p>\n<p>从图中可以看出cwnd是呈指数增长，每过一个轮次就加倍</p>\n<blockquote>\n<p>一个传输轮次：发送方从发送一批分组到收到它们的确认所经历的时间，即往返时间RTT</p>\n</blockquote>\n<h4 id=\"2-2-拥塞避免\"><a href=\"#2-2-拥塞避免\" class=\"headerlink\" title=\"2.2 拥塞避免\"></a>2.2 拥塞避免</h4><p>为了防止过大的拥塞窗口，出现了慢开始门限，当拥塞窗口的大小小于慢开始门限时，使用慢开始算法，反之，当拥塞窗口大于慢开始门限时，说明拥塞窗口的大小已经很大了，需要加以限制，于是就有了拥塞避免算法，即加法增大拥塞窗口</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220501201652395.png\" alt=\"image-20220501201652395\"></p>\n<p>无论何时（慢开始阶段或拥塞避免阶段），只要出现<u>超时</u>现象，就把慢开始门限设置为超时时拥塞窗口的一半大小，然后将拥塞窗口大小重置为1，重新开始慢开始阶段</p>\n<h4 id=\"2-3-快重传和快恢复\"><a href=\"#2-3-快重传和快恢复\" class=\"headerlink\" title=\"2.3 快重传和快恢复\"></a>2.3 快重传和快恢复</h4><p>快重传：发送方如果收到了三个冗余ACK，就说明个别包已经丢失，执行快重传，立即重传这个包（即使现在还没有超时）</p>\n<p>快恢复：收到三个冗余的ACK时，虽然还未出现超时现象，但已经直到个别包出现了丢失现象，此时调整慢开始门限值为当前拥塞窗口的一半，同时设置拥塞窗口为新的门限值，简单来讲就是拥塞窗口变为了原来的一半，然后执行加法增大（门限值=拥塞窗口大小）</p>\n<h3 id=\"3-TCP三次握手\"><a href=\"#3-TCP三次握手\" class=\"headerlink\" title=\"3. TCP三次握手\"></a>3. TCP三次握手</h3><p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220501185937682.png\" alt=\"image-20220501185937682\"></p>\n<h4 id=\"2-1-二次握手可以吗？\"><a href=\"#2-1-二次握手可以吗？\" class=\"headerlink\" title=\"2.1 二次握手可以吗？\"></a>2.1 二次握手可以吗？</h4><p>不行，因为</p>\n<p>（1）需要三次握手才能确定发送方和接受方的发送功能和接收功能都是正常的</p>\n<p>（2）假设只需两次握手就可以建立连接，且客户端向服务端发送的同步包在网络中滞留时间过长，导致重传，如果在重传正常建立连接、传输数据、关闭连接后，原先滞留的数据包到达服务器，服务器回传确认包给发送方，由于是二次握手，就会导致异常的连接被建立。</p>\n<h4 id=\"2-2-三次握手可以携带数据吗？\"><a href=\"#2-2-三次握手可以携带数据吗？\" class=\"headerlink\" title=\"2.2 三次握手可以携带数据吗？\"></a>2.2 三次握手可以携带数据吗？</h4><p>第三次握手可以</p>\n<h3 id=\"3-TCP四次挥手\"><a href=\"#3-TCP四次挥手\" class=\"headerlink\" title=\"3. TCP四次挥手\"></a>3. TCP四次挥手</h3><p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220501190853686.png\" alt=\"image-20220501190853686\"></p>\n<h4 id=\"3-1-为什么客户端要等待2MSL\"><a href=\"#3-1-为什么客户端要等待2MSL\" class=\"headerlink\" title=\"3.1 为什么客户端要等待2MSL\"></a>3.1 为什么客户端要等待2MSL</h4><p>MSL是报文在网络中可存活的最大时间，如果客户端发的最后一个ACK丢失了，服务器将会重发一个FIN，此时如果客户端早早关闭了的话，服务器就无法正常关闭了</p>\n<p>和UDP的区别</p>\n<ol>\n<li>TCP是有连接的，需要三次握手建立连接，UDP是无连接的</li>\n<li>TCP保证可靠的传输，而UDP不是</li>\n<li>TCP是端到端的，而UDP除了端到端还可以多播、广播</li>\n<li>TCP传输的是字节流，而UDP传输的是报文</li>\n</ol>\n"},{"_content":"#### 引言\n\n> 传输层有复用、分用的概念，在发送端，应用层的不同进程的数据交付给传输层，由传输层的同一个协议统一处理；在接收端，传输层在根据同一协议将数据交付给应用层的不同进程。但是，当不同进程的数据向下交付时，如何来知道这些数据是由哪个进程交付下来的？当向上交付数据时，又要交给上层的哪个应用进程呢？\n\n> 各个主机间通过TCP/IP来发送和接收数据，各个数据包根据IP地址进行路由，但是数据包到了主机之后，主机中那么多进程，到底传给哪个进程？\n\n**端口就是用来识别主机中不同的进程**\n\n既然是用来识别不同进程的，那跟协议是无关的，所有不同的协议可以使用同一个端口\n\n#### 1. 服务器端口号\n\n服务器要一直运行，所以它的端口是众所周知的，固定的\n\n##### （1）知名端口号（0~1023）\n\n标识服务器上大家都比较熟悉的应用层协议用的端口号\n\nHTTP：80\n\nHTTPS：443\n\nFTP：21\n\nSSH：22\n\ntelnet：23\n\n##### （2）登记端口号（1024~49151）\n\n非熟知端口号\n\n#### 2. 客户端端口号（49152~65535）\n\n由操作系统动态分配，不是固定的，进程终止时，端口就回收了\n\n\n\n","source":"_posts/网络/网络端口.md","raw":"#### 引言\n\n> 传输层有复用、分用的概念，在发送端，应用层的不同进程的数据交付给传输层，由传输层的同一个协议统一处理；在接收端，传输层在根据同一协议将数据交付给应用层的不同进程。但是，当不同进程的数据向下交付时，如何来知道这些数据是由哪个进程交付下来的？当向上交付数据时，又要交给上层的哪个应用进程呢？\n\n> 各个主机间通过TCP/IP来发送和接收数据，各个数据包根据IP地址进行路由，但是数据包到了主机之后，主机中那么多进程，到底传给哪个进程？\n\n**端口就是用来识别主机中不同的进程**\n\n既然是用来识别不同进程的，那跟协议是无关的，所有不同的协议可以使用同一个端口\n\n#### 1. 服务器端口号\n\n服务器要一直运行，所以它的端口是众所周知的，固定的\n\n##### （1）知名端口号（0~1023）\n\n标识服务器上大家都比较熟悉的应用层协议用的端口号\n\nHTTP：80\n\nHTTPS：443\n\nFTP：21\n\nSSH：22\n\ntelnet：23\n\n##### （2）登记端口号（1024~49151）\n\n非熟知端口号\n\n#### 2. 客户端端口号（49152~65535）\n\n由操作系统动态分配，不是固定的，进程终止时，端口就回收了\n\n\n\n","slug":"网络/网络端口","published":1,"date":"2022-04-20T07:34:50.992Z","updated":"2022-04-20T08:30:01.200Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0kx8000opcu36fl18f15","content":"<h4 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h4><blockquote>\n<p>传输层有复用、分用的概念，在发送端，应用层的不同进程的数据交付给传输层，由传输层的同一个协议统一处理；在接收端，传输层在根据同一协议将数据交付给应用层的不同进程。但是，当不同进程的数据向下交付时，如何来知道这些数据是由哪个进程交付下来的？当向上交付数据时，又要交给上层的哪个应用进程呢？</p>\n</blockquote>\n<blockquote>\n<p>各个主机间通过TCP/IP来发送和接收数据，各个数据包根据IP地址进行路由，但是数据包到了主机之后，主机中那么多进程，到底传给哪个进程？</p>\n</blockquote>\n<p><strong>端口就是用来识别主机中不同的进程</strong></p>\n<p>既然是用来识别不同进程的，那跟协议是无关的，所有不同的协议可以使用同一个端口</p>\n<h4 id=\"1-服务器端口号\"><a href=\"#1-服务器端口号\" class=\"headerlink\" title=\"1. 服务器端口号\"></a>1. 服务器端口号</h4><p>服务器要一直运行，所以它的端口是众所周知的，固定的</p>\n<h5 id=\"（1）知名端口号（0-1023）\"><a href=\"#（1）知名端口号（0-1023）\" class=\"headerlink\" title=\"（1）知名端口号（0~1023）\"></a>（1）知名端口号（0~1023）</h5><p>标识服务器上大家都比较熟悉的应用层协议用的端口号</p>\n<p>HTTP：80</p>\n<p>HTTPS：443</p>\n<p>FTP：21</p>\n<p>SSH：22</p>\n<p>telnet：23</p>\n<h5 id=\"（2）登记端口号（1024-49151）\"><a href=\"#（2）登记端口号（1024-49151）\" class=\"headerlink\" title=\"（2）登记端口号（1024~49151）\"></a>（2）登记端口号（1024~49151）</h5><p>非熟知端口号</p>\n<h4 id=\"2-客户端端口号（49152-65535）\"><a href=\"#2-客户端端口号（49152-65535）\" class=\"headerlink\" title=\"2. 客户端端口号（49152~65535）\"></a>2. 客户端端口号（49152~65535）</h4><p>由操作系统动态分配，不是固定的，进程终止时，端口就回收了</p>\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<h4 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h4><blockquote>\n<p>传输层有复用、分用的概念，在发送端，应用层的不同进程的数据交付给传输层，由传输层的同一个协议统一处理；在接收端，传输层在根据同一协议将数据交付给应用层的不同进程。但是，当不同进程的数据向下交付时，如何来知道这些数据是由哪个进程交付下来的？当向上交付数据时，又要交给上层的哪个应用进程呢？</p>\n</blockquote>\n<blockquote>\n<p>各个主机间通过TCP/IP来发送和接收数据，各个数据包根据IP地址进行路由，但是数据包到了主机之后，主机中那么多进程，到底传给哪个进程？</p>\n</blockquote>\n<p><strong>端口就是用来识别主机中不同的进程</strong></p>\n<p>既然是用来识别不同进程的，那跟协议是无关的，所有不同的协议可以使用同一个端口</p>\n<h4 id=\"1-服务器端口号\"><a href=\"#1-服务器端口号\" class=\"headerlink\" title=\"1. 服务器端口号\"></a>1. 服务器端口号</h4><p>服务器要一直运行，所以它的端口是众所周知的，固定的</p>\n<h5 id=\"（1）知名端口号（0-1023）\"><a href=\"#（1）知名端口号（0-1023）\" class=\"headerlink\" title=\"（1）知名端口号（0~1023）\"></a>（1）知名端口号（0~1023）</h5><p>标识服务器上大家都比较熟悉的应用层协议用的端口号</p>\n<p>HTTP：80</p>\n<p>HTTPS：443</p>\n<p>FTP：21</p>\n<p>SSH：22</p>\n<p>telnet：23</p>\n<h5 id=\"（2）登记端口号（1024-49151）\"><a href=\"#（2）登记端口号（1024-49151）\" class=\"headerlink\" title=\"（2）登记端口号（1024~49151）\"></a>（2）登记端口号（1024~49151）</h5><p>非熟知端口号</p>\n<h4 id=\"2-客户端端口号（49152-65535）\"><a href=\"#2-客户端端口号（49152-65535）\" class=\"headerlink\" title=\"2. 客户端端口号（49152~65535）\"></a>2. 客户端端口号（49152~65535）</h4><p>由操作系统动态分配，不是固定的，进程终止时，端口就回收了</p>\n"},{"title":"【专题】定语从句","date":"2021-12-19T16:00:00.000Z","draft":false,"_content":"\n\n\n什么是定语从句？\n\n用一句话作定语，通常用来修饰名词、代词，被修饰的词称为`先行词`\n\n### 一、限制性定语从句\n\n引导词**代替先行词**，在定语从句**充当成分**\n\n> 对比宾语从句中，`that`不充当任何成分，可以省略\n\n#### 1. 关系代词：\n\n- 指代**人**：`who`（在从句中充当主语、宾语）、`whom`（充当宾语）\n\n  The man `who(that) robbed him` has been arrested.\n\n  The girl `whom I saw` told me to come back today.\n\n  The friend `with whom I was traveling` spoke French.\n\n- 指代**物**：`which`（主、宾）\n\n  The car `which (that) I hired` broke down.\n\n  I don't like the novel `which you are reading`.\n\n- 指代**人或物**：`that`（主、宾），`whose`（定语，意思是`谁的`）\n\n  I like the girl `whose eyes are very big`.\n\n#### 2. 关系副词：\n\n- `when`（时间状语）：指代**时间**\n\n  At the time `when` I saw him, he was quite strong.\n\n  I will never forget the day `when (on which)` I came to Beijing.\n\n- where`（地点状语）：表示地点`\n\n  This is the village `where` I was born.\n\n  The police searched the house `where (in which)` he lived.\n\n- `why`（原因状语）：`why`的先行词只能是`reason`\n\n  I don't know the reason `why (for which)` he is angry.\n\n### 3. 省略\n\n- 在**限制性定语从句**中，当关系代词在从句中作**宾语**时，一般都可以**省略**\n\n  Have you got everything (`that`) you need?\n\n  That's the only thing (`that`) we can do now.\n\n  You can take any room (`that`) you like.\n\n- **口语**中，在从句作**主语**也可以**省略**\n\n  There's a strange man (`that`) lives in that small village.\n\n  There's something (`that`) keeps worrying me.\n\n#### 4. 有些表示时间的定语从句并不由when引导\n\nThis was the first `time` I had serious trouble with my boss.\n\nEvery `time` the telephone rings, he gets nervous.\n\n#### 5. way后也可跟定语从句，不需要关系代词或副词\n\nI didn't like the way he eyed me. 【应该是方式状语？】\n\n### 二、非限制性定语从句\n\n**非限制性定语从句**对所修饰的词没有限制词义的作用，而只是补充说明，通常都有逗号，译成中文时，多翻译为并列句\n\n限制性定语从句拿掉以后，句子意思常发生变化。而**非限制性定语**从句拿掉以后，对剩下部分没有太大影响\n\n> 注意非限制性定语从句中**不能**使用**关系代词 that** 和**关系副词 why**，也**不能**省略任何关系副词\n\nPeter, `who` had been driving all day, suggested stopping at the next town.\n\nPaul, `whom` everyone suspected, turned out to be innocent.\n\nThe 9:30 train, `which` is usually very punctual, was late today.\n\nSunday is a holiday, `when` people do not go to work.\n\n#### 非限制性定语从句中，which 和 whom 和 of 或其他介词连用\n\nThe buses, `most of which` were already full, were surrounded by an angry crowd.\n\nShe had eight children, `three of whom` lived to grow up. ( three of whom 在从句中作主语 )\n\nHer sons, `both of whom` work abroad, ring her up every week. \n\nI met the fruit-pickers, `several of whom` were college students.\n\n#### which 有时代表一个句子\n\nThey rely on themselves, `which` is much better.\n\nHe invited us to dinner, `which` was very kind of him.\n\nHe changed his mind, `which` made me very angry.\n\nShe was very patient towards the children, `which` her husband seldom was. \n\n","source":"_posts/英语/定语从句专题.md","raw":"---\ntitle: \"【专题】定语从句\"\ndate: 2021-12-20\ndraft: false\ntags: [\"Grammar\"]\ncategories: [\"English\"]\n---\n\n\n\n什么是定语从句？\n\n用一句话作定语，通常用来修饰名词、代词，被修饰的词称为`先行词`\n\n### 一、限制性定语从句\n\n引导词**代替先行词**，在定语从句**充当成分**\n\n> 对比宾语从句中，`that`不充当任何成分，可以省略\n\n#### 1. 关系代词：\n\n- 指代**人**：`who`（在从句中充当主语、宾语）、`whom`（充当宾语）\n\n  The man `who(that) robbed him` has been arrested.\n\n  The girl `whom I saw` told me to come back today.\n\n  The friend `with whom I was traveling` spoke French.\n\n- 指代**物**：`which`（主、宾）\n\n  The car `which (that) I hired` broke down.\n\n  I don't like the novel `which you are reading`.\n\n- 指代**人或物**：`that`（主、宾），`whose`（定语，意思是`谁的`）\n\n  I like the girl `whose eyes are very big`.\n\n#### 2. 关系副词：\n\n- `when`（时间状语）：指代**时间**\n\n  At the time `when` I saw him, he was quite strong.\n\n  I will never forget the day `when (on which)` I came to Beijing.\n\n- where`（地点状语）：表示地点`\n\n  This is the village `where` I was born.\n\n  The police searched the house `where (in which)` he lived.\n\n- `why`（原因状语）：`why`的先行词只能是`reason`\n\n  I don't know the reason `why (for which)` he is angry.\n\n### 3. 省略\n\n- 在**限制性定语从句**中，当关系代词在从句中作**宾语**时，一般都可以**省略**\n\n  Have you got everything (`that`) you need?\n\n  That's the only thing (`that`) we can do now.\n\n  You can take any room (`that`) you like.\n\n- **口语**中，在从句作**主语**也可以**省略**\n\n  There's a strange man (`that`) lives in that small village.\n\n  There's something (`that`) keeps worrying me.\n\n#### 4. 有些表示时间的定语从句并不由when引导\n\nThis was the first `time` I had serious trouble with my boss.\n\nEvery `time` the telephone rings, he gets nervous.\n\n#### 5. way后也可跟定语从句，不需要关系代词或副词\n\nI didn't like the way he eyed me. 【应该是方式状语？】\n\n### 二、非限制性定语从句\n\n**非限制性定语从句**对所修饰的词没有限制词义的作用，而只是补充说明，通常都有逗号，译成中文时，多翻译为并列句\n\n限制性定语从句拿掉以后，句子意思常发生变化。而**非限制性定语**从句拿掉以后，对剩下部分没有太大影响\n\n> 注意非限制性定语从句中**不能**使用**关系代词 that** 和**关系副词 why**，也**不能**省略任何关系副词\n\nPeter, `who` had been driving all day, suggested stopping at the next town.\n\nPaul, `whom` everyone suspected, turned out to be innocent.\n\nThe 9:30 train, `which` is usually very punctual, was late today.\n\nSunday is a holiday, `when` people do not go to work.\n\n#### 非限制性定语从句中，which 和 whom 和 of 或其他介词连用\n\nThe buses, `most of which` were already full, were surrounded by an angry crowd.\n\nShe had eight children, `three of whom` lived to grow up. ( three of whom 在从句中作主语 )\n\nHer sons, `both of whom` work abroad, ring her up every week. \n\nI met the fruit-pickers, `several of whom` were college students.\n\n#### which 有时代表一个句子\n\nThey rely on themselves, `which` is much better.\n\nHe invited us to dinner, `which` was very kind of him.\n\nHe changed his mind, `which` made me very angry.\n\nShe was very patient towards the children, `which` her husband seldom was. \n\n","slug":"英语/定语从句专题","published":1,"updated":"2022-01-04T08:44:59.772Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0kx9000ppcu39gt2hosc","content":"<p>什么是定语从句？</p>\n<p>用一句话作定语，通常用来修饰名词、代词，被修饰的词称为<code>先行词</code></p>\n<h3 id=\"一、限制性定语从句\"><a href=\"#一、限制性定语从句\" class=\"headerlink\" title=\"一、限制性定语从句\"></a>一、限制性定语从句</h3><p>引导词<strong>代替先行词</strong>，在定语从句<strong>充当成分</strong></p>\n<blockquote>\n<p>对比宾语从句中，<code>that</code>不充当任何成分，可以省略</p>\n</blockquote>\n<h4 id=\"1-关系代词：\"><a href=\"#1-关系代词：\" class=\"headerlink\" title=\"1. 关系代词：\"></a>1. 关系代词：</h4><ul>\n<li><p>指代<strong>人</strong>：<code>who</code>（在从句中充当主语、宾语）、<code>whom</code>（充当宾语）</p>\n<p>The man <code>who(that) robbed him</code> has been arrested.</p>\n<p>The girl <code>whom I saw</code> told me to come back today.</p>\n<p>The friend <code>with whom I was traveling</code> spoke French.</p>\n</li>\n<li><p>指代<strong>物</strong>：<code>which</code>（主、宾）</p>\n<p>The car <code>which (that) I hired</code> broke down.</p>\n<p>I don’t like the novel <code>which you are reading</code>.</p>\n</li>\n<li><p>指代<strong>人或物</strong>：<code>that</code>（主、宾），<code>whose</code>（定语，意思是<code>谁的</code>）</p>\n<p>I like the girl <code>whose eyes are very big</code>.</p>\n</li>\n</ul>\n<h4 id=\"2-关系副词：\"><a href=\"#2-关系副词：\" class=\"headerlink\" title=\"2. 关系副词：\"></a>2. 关系副词：</h4><ul>\n<li><p><code>when</code>（时间状语）：指代<strong>时间</strong></p>\n<p>At the time <code>when</code> I saw him, he was quite strong.</p>\n<p>I will never forget the day <code>when (on which)</code> I came to Beijing.</p>\n</li>\n<li><p>where<code>（地点状语）：表示地点</code></p>\n<p>This is the village <code>where</code> I was born.</p>\n<p>The police searched the house <code>where (in which)</code> he lived.</p>\n</li>\n<li><p><code>why</code>（原因状语）：<code>why</code>的先行词只能是<code>reason</code></p>\n<p>I don’t know the reason <code>why (for which)</code> he is angry.</p>\n</li>\n</ul>\n<h3 id=\"3-省略\"><a href=\"#3-省略\" class=\"headerlink\" title=\"3. 省略\"></a>3. 省略</h3><ul>\n<li><p>在<strong>限制性定语从句</strong>中，当关系代词在从句中作<strong>宾语</strong>时，一般都可以<strong>省略</strong></p>\n<p>Have you got everything (<code>that</code>) you need?</p>\n<p>That’s the only thing (<code>that</code>) we can do now.</p>\n<p>You can take any room (<code>that</code>) you like.</p>\n</li>\n<li><p><strong>口语</strong>中，在从句作<strong>主语</strong>也可以<strong>省略</strong></p>\n<p>There’s a strange man (<code>that</code>) lives in that small village.</p>\n<p>There’s something (<code>that</code>) keeps worrying me.</p>\n</li>\n</ul>\n<h4 id=\"4-有些表示时间的定语从句并不由when引导\"><a href=\"#4-有些表示时间的定语从句并不由when引导\" class=\"headerlink\" title=\"4. 有些表示时间的定语从句并不由when引导\"></a>4. 有些表示时间的定语从句并不由when引导</h4><p>This was the first <code>time</code> I had serious trouble with my boss.</p>\n<p>Every <code>time</code> the telephone rings, he gets nervous.</p>\n<h4 id=\"5-way后也可跟定语从句，不需要关系代词或副词\"><a href=\"#5-way后也可跟定语从句，不需要关系代词或副词\" class=\"headerlink\" title=\"5. way后也可跟定语从句，不需要关系代词或副词\"></a>5. way后也可跟定语从句，不需要关系代词或副词</h4><p>I didn’t like the way he eyed me. 【应该是方式状语？】</p>\n<h3 id=\"二、非限制性定语从句\"><a href=\"#二、非限制性定语从句\" class=\"headerlink\" title=\"二、非限制性定语从句\"></a>二、非限制性定语从句</h3><p><strong>非限制性定语从句</strong>对所修饰的词没有限制词义的作用，而只是补充说明，通常都有逗号，译成中文时，多翻译为并列句</p>\n<p>限制性定语从句拿掉以后，句子意思常发生变化。而<strong>非限制性定语</strong>从句拿掉以后，对剩下部分没有太大影响</p>\n<blockquote>\n<p>注意非限制性定语从句中<strong>不能</strong>使用<strong>关系代词 that</strong> 和<strong>关系副词 why</strong>，也<strong>不能</strong>省略任何关系副词</p>\n</blockquote>\n<p>Peter, <code>who</code> had been driving all day, suggested stopping at the next town.</p>\n<p>Paul, <code>whom</code> everyone suspected, turned out to be innocent.</p>\n<p>The 9:30 train, <code>which</code> is usually very punctual, was late today.</p>\n<p>Sunday is a holiday, <code>when</code> people do not go to work.</p>\n<h4 id=\"非限制性定语从句中，which-和-whom-和-of-或其他介词连用\"><a href=\"#非限制性定语从句中，which-和-whom-和-of-或其他介词连用\" class=\"headerlink\" title=\"非限制性定语从句中，which 和 whom 和 of 或其他介词连用\"></a>非限制性定语从句中，which 和 whom 和 of 或其他介词连用</h4><p>The buses, <code>most of which</code> were already full, were surrounded by an angry crowd.</p>\n<p>She had eight children, <code>three of whom</code> lived to grow up. ( three of whom 在从句中作主语 )</p>\n<p>Her sons, <code>both of whom</code> work abroad, ring her up every week. </p>\n<p>I met the fruit-pickers, <code>several of whom</code> were college students.</p>\n<h4 id=\"which-有时代表一个句子\"><a href=\"#which-有时代表一个句子\" class=\"headerlink\" title=\"which 有时代表一个句子\"></a>which 有时代表一个句子</h4><p>They rely on themselves, <code>which</code> is much better.</p>\n<p>He invited us to dinner, <code>which</code> was very kind of him.</p>\n<p>He changed his mind, <code>which</code> made me very angry.</p>\n<p>She was very patient towards the children, <code>which</code> her husband seldom was. </p>\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<p>什么是定语从句？</p>\n<p>用一句话作定语，通常用来修饰名词、代词，被修饰的词称为<code>先行词</code></p>\n<h3 id=\"一、限制性定语从句\"><a href=\"#一、限制性定语从句\" class=\"headerlink\" title=\"一、限制性定语从句\"></a>一、限制性定语从句</h3><p>引导词<strong>代替先行词</strong>，在定语从句<strong>充当成分</strong></p>\n<blockquote>\n<p>对比宾语从句中，<code>that</code>不充当任何成分，可以省略</p>\n</blockquote>\n<h4 id=\"1-关系代词：\"><a href=\"#1-关系代词：\" class=\"headerlink\" title=\"1. 关系代词：\"></a>1. 关系代词：</h4><ul>\n<li><p>指代<strong>人</strong>：<code>who</code>（在从句中充当主语、宾语）、<code>whom</code>（充当宾语）</p>\n<p>The man <code>who(that) robbed him</code> has been arrested.</p>\n<p>The girl <code>whom I saw</code> told me to come back today.</p>\n<p>The friend <code>with whom I was traveling</code> spoke French.</p>\n</li>\n<li><p>指代<strong>物</strong>：<code>which</code>（主、宾）</p>\n<p>The car <code>which (that) I hired</code> broke down.</p>\n<p>I don’t like the novel <code>which you are reading</code>.</p>\n</li>\n<li><p>指代<strong>人或物</strong>：<code>that</code>（主、宾），<code>whose</code>（定语，意思是<code>谁的</code>）</p>\n<p>I like the girl <code>whose eyes are very big</code>.</p>\n</li>\n</ul>\n<h4 id=\"2-关系副词：\"><a href=\"#2-关系副词：\" class=\"headerlink\" title=\"2. 关系副词：\"></a>2. 关系副词：</h4><ul>\n<li><p><code>when</code>（时间状语）：指代<strong>时间</strong></p>\n<p>At the time <code>when</code> I saw him, he was quite strong.</p>\n<p>I will never forget the day <code>when (on which)</code> I came to Beijing.</p>\n</li>\n<li><p>where<code>（地点状语）：表示地点</code></p>\n<p>This is the village <code>where</code> I was born.</p>\n<p>The police searched the house <code>where (in which)</code> he lived.</p>\n</li>\n<li><p><code>why</code>（原因状语）：<code>why</code>的先行词只能是<code>reason</code></p>\n<p>I don’t know the reason <code>why (for which)</code> he is angry.</p>\n</li>\n</ul>\n<h3 id=\"3-省略\"><a href=\"#3-省略\" class=\"headerlink\" title=\"3. 省略\"></a>3. 省略</h3><ul>\n<li><p>在<strong>限制性定语从句</strong>中，当关系代词在从句中作<strong>宾语</strong>时，一般都可以<strong>省略</strong></p>\n<p>Have you got everything (<code>that</code>) you need?</p>\n<p>That’s the only thing (<code>that</code>) we can do now.</p>\n<p>You can take any room (<code>that</code>) you like.</p>\n</li>\n<li><p><strong>口语</strong>中，在从句作<strong>主语</strong>也可以<strong>省略</strong></p>\n<p>There’s a strange man (<code>that</code>) lives in that small village.</p>\n<p>There’s something (<code>that</code>) keeps worrying me.</p>\n</li>\n</ul>\n<h4 id=\"4-有些表示时间的定语从句并不由when引导\"><a href=\"#4-有些表示时间的定语从句并不由when引导\" class=\"headerlink\" title=\"4. 有些表示时间的定语从句并不由when引导\"></a>4. 有些表示时间的定语从句并不由when引导</h4><p>This was the first <code>time</code> I had serious trouble with my boss.</p>\n<p>Every <code>time</code> the telephone rings, he gets nervous.</p>\n<h4 id=\"5-way后也可跟定语从句，不需要关系代词或副词\"><a href=\"#5-way后也可跟定语从句，不需要关系代词或副词\" class=\"headerlink\" title=\"5. way后也可跟定语从句，不需要关系代词或副词\"></a>5. way后也可跟定语从句，不需要关系代词或副词</h4><p>I didn’t like the way he eyed me. 【应该是方式状语？】</p>\n<h3 id=\"二、非限制性定语从句\"><a href=\"#二、非限制性定语从句\" class=\"headerlink\" title=\"二、非限制性定语从句\"></a>二、非限制性定语从句</h3><p><strong>非限制性定语从句</strong>对所修饰的词没有限制词义的作用，而只是补充说明，通常都有逗号，译成中文时，多翻译为并列句</p>\n<p>限制性定语从句拿掉以后，句子意思常发生变化。而<strong>非限制性定语</strong>从句拿掉以后，对剩下部分没有太大影响</p>\n<blockquote>\n<p>注意非限制性定语从句中<strong>不能</strong>使用<strong>关系代词 that</strong> 和<strong>关系副词 why</strong>，也<strong>不能</strong>省略任何关系副词</p>\n</blockquote>\n<p>Peter, <code>who</code> had been driving all day, suggested stopping at the next town.</p>\n<p>Paul, <code>whom</code> everyone suspected, turned out to be innocent.</p>\n<p>The 9:30 train, <code>which</code> is usually very punctual, was late today.</p>\n<p>Sunday is a holiday, <code>when</code> people do not go to work.</p>\n<h4 id=\"非限制性定语从句中，which-和-whom-和-of-或其他介词连用\"><a href=\"#非限制性定语从句中，which-和-whom-和-of-或其他介词连用\" class=\"headerlink\" title=\"非限制性定语从句中，which 和 whom 和 of 或其他介词连用\"></a>非限制性定语从句中，which 和 whom 和 of 或其他介词连用</h4><p>The buses, <code>most of which</code> were already full, were surrounded by an angry crowd.</p>\n<p>She had eight children, <code>three of whom</code> lived to grow up. ( three of whom 在从句中作主语 )</p>\n<p>Her sons, <code>both of whom</code> work abroad, ring her up every week. </p>\n<p>I met the fruit-pickers, <code>several of whom</code> were college students.</p>\n<h4 id=\"which-有时代表一个句子\"><a href=\"#which-有时代表一个句子\" class=\"headerlink\" title=\"which 有时代表一个句子\"></a>which 有时代表一个句子</h4><p>They rely on themselves, <code>which</code> is much better.</p>\n<p>He invited us to dinner, <code>which</code> was very kind of him.</p>\n<p>He changed his mind, <code>which</code> made me very angry.</p>\n<p>She was very patient towards the children, <code>which</code> her husband seldom was. </p>\n"},{"title":"【专题】虚拟语气","date":"2021-11-12T16:00:00.000Z","draft":false,"_content":"\n\n\n虚拟语气在形式上分为三类\n\n1. **现在**虚拟语气——动词原形\n\n   *God `bless` you.* \n\n2. **过去**虚拟语气——和陈述语气的过去时相同，但动词 `be` 要用 `were`\n\n   *If only I `were` not so nervous. // 我要是不那么紧张就好了*\n\n   *She treated me as though I `were` a stranger.*\n\n3. **过去完成**形式——和陈述语气中的过去完成时相同\n\n   *I wish I `hadn't done` so.*\n\n   *If only I `had listened` to your advice.*\n\n[If only](https://dictionary.cambridge.org/grammar/british-grammar/if-only) 用法\n\n### 1. 虚拟条件句\n\n#### 1.1 表示**与（现在、将来）事实相反**的情况或**可能性不大**\n\n| 条件从句                    | 主句                       |\n| --------------------------- | -------------------------- |\n| 过去式（通常 **be->were**） | would/might/could + **do** |\n\n*If I `were` you, I`'d plant` some trees round the house.* 如果我是你，我就会在房子周围种些树（你还没种，未来可能种）\n\n*If I `had` a map I `would lend` it to you.* 如果我有地图，我就借给你（但是我还没有，未来可能有）\n\n*If I `dyed` my hair blue everyone `would` laugh at me.*  如果我把我的头发染成蓝色（还没染，未来小概率染）\n\n*//从句用`If it were not for`，表示“若不是”*\n\n*If `it weren't for` Ruth, you `wouldn't be` anywhere. //要不是Ruth，你不会有任何成就*\n\n*If `it weren't for` your help, we `would be` in serious trouble.*\n\n#### 1.2 表示与过去事实相反\n\n| 条件从句        | 主句                                     |\n| --------------- | ---------------------------------------- |\n| If **had done** | would/might/could/should **have done**** |\n\n*If anything `had happend`, he `would have` let us know.*  如果发生了什么，他**早**就通知我们了（没发生什么已经是事实了）\n\n*If Hanyu `had recieved` the present, she `should` have thanked me.*  如果HY收到了礼物（表明HY没有受到礼物已经是事实了），她早就谢谢我了\n\n*If I `had been` Nancy, I `wouldn't have` left him.* 如果我是南希，我不会离开他（南希已经离开了他）\n\n\n\n`had not been for` 表示 “要不是“\n\n*If it `hadn't been` for your timely help, we `would have` got into serious trouble.*\n\n#### 1.3 错综时间条件句\n\n有些条件句主句谓语和从句谓语在时间上并不一致（不符合上述两点）\n\n*If you `had taken` her advice, you `wouldn't be` in such trouble now.*\n\n*If he `were leaving`, you `should have` heard about it.*\n\n#### 1.4 含蓄条件句\n\n隐含的条件句\n\n*I might see her personally, it `would be` better.*\n\n*I did not press the point as it `would be` useless.*\n\n*In the old days she `would have` argued.*\n\n*I `wouldn't worry` about it.*\n\n#### 1.5 委婉客气的语气，情态动词的使用（should, would, could, might）\n\n*`Would` you mind shutting the window?*\n\n*`Would` you tell me how to ...*\n\n*`Could` you lend me your computer?*\n\n*If necessary, you `might` shorten it.*\n\n### 2. 虚拟语气在某些从句中的应用\n\n#### 2.1 宾语从句\n\n1. `wish`\n\n   a. 与**现在**事实相反（**be->were**），**过去式**\n\n   *I wish I `had` more time.*   还没有更多时间，但可能有\n\n   *I wish I `could` help you.* 我希望我能帮你（还没帮，未来可能帮，I wish I had helped you. 我希望我已经帮你，没帮已经是过去的事实了）\n\n   *I wish I `were`(was) young again.  // 用 was 也行*\n\n   b. 与**过去**事实相反，**过去完成时**，常表示**遗憾**\n\n   *I wish I `had thought` what she really want.*  我没想过她真正想要什么，已经是事实了\n\n   *I wish I `had restrained` my emotion.*  我没有控制我的情感，已经是事实了\n\n   c. 谈论**将来**的愿望，从句用 `would、could、might + do`\n\n   *I wish I `could` do something for you in return. 我希望我能做点什么回报你*\n\n2. `would rather`\n\n   谓语多用**过去式**，表**现在、将来**\n\n   *I'd rather you `told` me the truth.*  我宁愿你给我讲真话\n\n   \n\n   suppose 虚拟+宾语从句（如果是对将来的假设，动词用过去时）\n\n   *Suppose her father turned her out of doors!*\n\n3. `suggest`、`demand`、`insist`、`ask`等表示要求、命令、建议一类的动词\n\n   从句用 `should + do`，但是 `should` 一般省略\n\n   *The doctor advised that he `change` the job.*\n\n   *I propose that sb (should) `be` ...*\n\n   *He commanded that we (should) `attack` at once.*\n\n#### 2.2 主语从句、表语从句、同位语从句\n\n从句用 `(should) do`\n\n**主语从句**\n\n*It's important that he `work` hard.*\n\n*It's _________ you `(should) not be` seen here. // 你不该出现在这里，这很...*\n\n`should do` 有时表达“竟然”的情感色彩\n\n*It seems so unfair that this `should happen` to me.*\n\n*It's strange that she `should be` so late. //真奇怪，她竟然来得这么晚*\n\n**表语从句**\n\n*Her idea was that they `should lock` up the house.*\n\n**同位语从句**\n\n*They expressed the wish that they `(should) be` given more free time.*\n\n#### 3. 状语从句\n\n- `as if`、`as though`\n\n  表示**现在**情况用**过去式**，表示**过去**情况用**过去完成形式**\n\n  *I have loved you as if you `were` my son.*\n\n  *I remember it as if it `happened` last night.*\n\n  *He looks as though he `had known` Millie for years.* \n\n  在 `look`、`seem`、`taste`、`smell` 后，`as if` 引导的从句可用**陈述**语气，大概率事件\n\n  *It looks as if they `are` in a terrible hurry.*\n\n  *The meat tastes as if it `has` gone bad.*\n\n  `as if (though)` 引导**表语从句**\n\n  *You look as if you `didn't` care.*\n\n- **让步状语从句**\n\n  *Whether she `be(is)` right or wrong, we will support her.*\n\n- **目的状语**\n\n  从句谓语多用 would、should、could、might\n\n  *I hired a boat so that I `could` go fish.*\n\n  *He left early in order that the children `would` not be alone in the house.*\n\n- **be+形容词，should+动词原形**（张道真认为形容词后的从句为状语从句，有些认为是宾语从句）\n\n  *I'm `surprised` that you `should` press the suggestion. //我很奇怪你竟然坚持你的建议*\n\n  *They're especially `anxious` that you `should` come.  //他们特别期盼你能来*\n\n### 虚拟语气的一些其他用法\n\n只记录了较常见的\n\n- `It's (high) time` 后的定语从句中的虚拟语气\n\n  多用**过去虚拟**语气\n\n  *It's time we `went`.*\n\n  *It's time we `were` leaving.*\n\n  *It's high time you `made` up your mind.*\n\n- `would have thought`\n\n  *Who `would have thought` to see you here!  //谁能想到会在这里看到你！*\n\n  *Who `would have thought` it was going to break like that?*  \n\n\n\n参考资料：[张道真实用英语语法](https://book.douban.com/subject/1210225/)\n\n","source":"_posts/英语/虚拟语气专题.md","raw":"---\ntitle: \"【专题】虚拟语气\"\ndate: 2021-11-13\ndraft: false\ntags: [\"Grammar\"]\ncategories: [\"English\"]\n---\n\n\n\n虚拟语气在形式上分为三类\n\n1. **现在**虚拟语气——动词原形\n\n   *God `bless` you.* \n\n2. **过去**虚拟语气——和陈述语气的过去时相同，但动词 `be` 要用 `were`\n\n   *If only I `were` not so nervous. // 我要是不那么紧张就好了*\n\n   *She treated me as though I `were` a stranger.*\n\n3. **过去完成**形式——和陈述语气中的过去完成时相同\n\n   *I wish I `hadn't done` so.*\n\n   *If only I `had listened` to your advice.*\n\n[If only](https://dictionary.cambridge.org/grammar/british-grammar/if-only) 用法\n\n### 1. 虚拟条件句\n\n#### 1.1 表示**与（现在、将来）事实相反**的情况或**可能性不大**\n\n| 条件从句                    | 主句                       |\n| --------------------------- | -------------------------- |\n| 过去式（通常 **be->were**） | would/might/could + **do** |\n\n*If I `were` you, I`'d plant` some trees round the house.* 如果我是你，我就会在房子周围种些树（你还没种，未来可能种）\n\n*If I `had` a map I `would lend` it to you.* 如果我有地图，我就借给你（但是我还没有，未来可能有）\n\n*If I `dyed` my hair blue everyone `would` laugh at me.*  如果我把我的头发染成蓝色（还没染，未来小概率染）\n\n*//从句用`If it were not for`，表示“若不是”*\n\n*If `it weren't for` Ruth, you `wouldn't be` anywhere. //要不是Ruth，你不会有任何成就*\n\n*If `it weren't for` your help, we `would be` in serious trouble.*\n\n#### 1.2 表示与过去事实相反\n\n| 条件从句        | 主句                                     |\n| --------------- | ---------------------------------------- |\n| If **had done** | would/might/could/should **have done**** |\n\n*If anything `had happend`, he `would have` let us know.*  如果发生了什么，他**早**就通知我们了（没发生什么已经是事实了）\n\n*If Hanyu `had recieved` the present, she `should` have thanked me.*  如果HY收到了礼物（表明HY没有受到礼物已经是事实了），她早就谢谢我了\n\n*If I `had been` Nancy, I `wouldn't have` left him.* 如果我是南希，我不会离开他（南希已经离开了他）\n\n\n\n`had not been for` 表示 “要不是“\n\n*If it `hadn't been` for your timely help, we `would have` got into serious trouble.*\n\n#### 1.3 错综时间条件句\n\n有些条件句主句谓语和从句谓语在时间上并不一致（不符合上述两点）\n\n*If you `had taken` her advice, you `wouldn't be` in such trouble now.*\n\n*If he `were leaving`, you `should have` heard about it.*\n\n#### 1.4 含蓄条件句\n\n隐含的条件句\n\n*I might see her personally, it `would be` better.*\n\n*I did not press the point as it `would be` useless.*\n\n*In the old days she `would have` argued.*\n\n*I `wouldn't worry` about it.*\n\n#### 1.5 委婉客气的语气，情态动词的使用（should, would, could, might）\n\n*`Would` you mind shutting the window?*\n\n*`Would` you tell me how to ...*\n\n*`Could` you lend me your computer?*\n\n*If necessary, you `might` shorten it.*\n\n### 2. 虚拟语气在某些从句中的应用\n\n#### 2.1 宾语从句\n\n1. `wish`\n\n   a. 与**现在**事实相反（**be->were**），**过去式**\n\n   *I wish I `had` more time.*   还没有更多时间，但可能有\n\n   *I wish I `could` help you.* 我希望我能帮你（还没帮，未来可能帮，I wish I had helped you. 我希望我已经帮你，没帮已经是过去的事实了）\n\n   *I wish I `were`(was) young again.  // 用 was 也行*\n\n   b. 与**过去**事实相反，**过去完成时**，常表示**遗憾**\n\n   *I wish I `had thought` what she really want.*  我没想过她真正想要什么，已经是事实了\n\n   *I wish I `had restrained` my emotion.*  我没有控制我的情感，已经是事实了\n\n   c. 谈论**将来**的愿望，从句用 `would、could、might + do`\n\n   *I wish I `could` do something for you in return. 我希望我能做点什么回报你*\n\n2. `would rather`\n\n   谓语多用**过去式**，表**现在、将来**\n\n   *I'd rather you `told` me the truth.*  我宁愿你给我讲真话\n\n   \n\n   suppose 虚拟+宾语从句（如果是对将来的假设，动词用过去时）\n\n   *Suppose her father turned her out of doors!*\n\n3. `suggest`、`demand`、`insist`、`ask`等表示要求、命令、建议一类的动词\n\n   从句用 `should + do`，但是 `should` 一般省略\n\n   *The doctor advised that he `change` the job.*\n\n   *I propose that sb (should) `be` ...*\n\n   *He commanded that we (should) `attack` at once.*\n\n#### 2.2 主语从句、表语从句、同位语从句\n\n从句用 `(should) do`\n\n**主语从句**\n\n*It's important that he `work` hard.*\n\n*It's _________ you `(should) not be` seen here. // 你不该出现在这里，这很...*\n\n`should do` 有时表达“竟然”的情感色彩\n\n*It seems so unfair that this `should happen` to me.*\n\n*It's strange that she `should be` so late. //真奇怪，她竟然来得这么晚*\n\n**表语从句**\n\n*Her idea was that they `should lock` up the house.*\n\n**同位语从句**\n\n*They expressed the wish that they `(should) be` given more free time.*\n\n#### 3. 状语从句\n\n- `as if`、`as though`\n\n  表示**现在**情况用**过去式**，表示**过去**情况用**过去完成形式**\n\n  *I have loved you as if you `were` my son.*\n\n  *I remember it as if it `happened` last night.*\n\n  *He looks as though he `had known` Millie for years.* \n\n  在 `look`、`seem`、`taste`、`smell` 后，`as if` 引导的从句可用**陈述**语气，大概率事件\n\n  *It looks as if they `are` in a terrible hurry.*\n\n  *The meat tastes as if it `has` gone bad.*\n\n  `as if (though)` 引导**表语从句**\n\n  *You look as if you `didn't` care.*\n\n- **让步状语从句**\n\n  *Whether she `be(is)` right or wrong, we will support her.*\n\n- **目的状语**\n\n  从句谓语多用 would、should、could、might\n\n  *I hired a boat so that I `could` go fish.*\n\n  *He left early in order that the children `would` not be alone in the house.*\n\n- **be+形容词，should+动词原形**（张道真认为形容词后的从句为状语从句，有些认为是宾语从句）\n\n  *I'm `surprised` that you `should` press the suggestion. //我很奇怪你竟然坚持你的建议*\n\n  *They're especially `anxious` that you `should` come.  //他们特别期盼你能来*\n\n### 虚拟语气的一些其他用法\n\n只记录了较常见的\n\n- `It's (high) time` 后的定语从句中的虚拟语气\n\n  多用**过去虚拟**语气\n\n  *It's time we `went`.*\n\n  *It's time we `were` leaving.*\n\n  *It's high time you `made` up your mind.*\n\n- `would have thought`\n\n  *Who `would have thought` to see you here!  //谁能想到会在这里看到你！*\n\n  *Who `would have thought` it was going to break like that?*  \n\n\n\n参考资料：[张道真实用英语语法](https://book.douban.com/subject/1210225/)\n\n","slug":"英语/虚拟语气专题","published":1,"updated":"2021-12-31T02:10:35.486Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0kxa000qpcu3g2ya4oqv","content":"<p>虚拟语气在形式上分为三类</p>\n<ol>\n<li><p><strong>现在</strong>虚拟语气——动词原形</p>\n<p><em>God <code>bless</code> you.</em> </p>\n</li>\n<li><p><strong>过去</strong>虚拟语气——和陈述语气的过去时相同，但动词 <code>be</code> 要用 <code>were</code></p>\n<p><em>If only I <code>were</code> not so nervous. // 我要是不那么紧张就好了</em></p>\n<p><em>She treated me as though I <code>were</code> a stranger.</em></p>\n</li>\n<li><p><strong>过去完成</strong>形式——和陈述语气中的过去完成时相同</p>\n<p><em>I wish I <code>hadn&#39;t done</code> so.</em></p>\n<p><em>If only I <code>had listened</code> to your advice.</em></p>\n</li>\n</ol>\n<p><a href=\"https://dictionary.cambridge.org/grammar/british-grammar/if-only\">If only</a> 用法</p>\n<h3 id=\"1-虚拟条件句\"><a href=\"#1-虚拟条件句\" class=\"headerlink\" title=\"1. 虚拟条件句\"></a>1. 虚拟条件句</h3><h4 id=\"1-1-表示与（现在、将来）事实相反的情况或可能性不大\"><a href=\"#1-1-表示与（现在、将来）事实相反的情况或可能性不大\" class=\"headerlink\" title=\"1.1 表示与（现在、将来）事实相反的情况或可能性不大\"></a>1.1 表示<strong>与（现在、将来）事实相反</strong>的情况或<strong>可能性不大</strong></h4><table>\n<thead>\n<tr>\n<th>条件从句</th>\n<th>主句</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>过去式（通常 <strong>be-&gt;were</strong>）</td>\n<td>would/might/could + <strong>do</strong></td>\n</tr>\n</tbody></table>\n<p><em>If I <code>were</code> you, I<code>&#39;d plant</code> some trees round the house.</em> 如果我是你，我就会在房子周围种些树（你还没种，未来可能种）</p>\n<p><em>If I <code>had</code> a map I <code>would lend</code> it to you.</em> 如果我有地图，我就借给你（但是我还没有，未来可能有）</p>\n<p><em>If I <code>dyed</code> my hair blue everyone <code>would</code> laugh at me.</em>  如果我把我的头发染成蓝色（还没染，未来小概率染）</p>\n<p><em>//从句用<code>If it were not for</code>，表示“若不是”</em></p>\n<p><em>If <code>it weren&#39;t for</code> Ruth, you <code>wouldn&#39;t be</code> anywhere. //要不是Ruth，你不会有任何成就</em></p>\n<p><em>If <code>it weren&#39;t for</code> your help, we <code>would be</code> in serious trouble.</em></p>\n<h4 id=\"1-2-表示与过去事实相反\"><a href=\"#1-2-表示与过去事实相反\" class=\"headerlink\" title=\"1.2 表示与过去事实相反\"></a>1.2 表示与过去事实相反</h4><table>\n<thead>\n<tr>\n<th>条件从句</th>\n<th>主句</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>If <strong>had done</strong></td>\n<td>would/might/could/should <strong>have done</strong>**</td>\n</tr>\n</tbody></table>\n<p><em>If anything <code>had happend</code>, he <code>would have</code> let us know.</em>  如果发生了什么，他<strong>早</strong>就通知我们了（没发生什么已经是事实了）</p>\n<p><em>If Hanyu <code>had recieved</code> the present, she <code>should</code> have thanked me.</em>  如果HY收到了礼物（表明HY没有受到礼物已经是事实了），她早就谢谢我了</p>\n<p><em>If I <code>had been</code> Nancy, I <code>wouldn&#39;t have</code> left him.</em> 如果我是南希，我不会离开他（南希已经离开了他）</p>\n<p><code>had not been for</code> 表示 “要不是“</p>\n<p><em>If it <code>hadn&#39;t been</code> for your timely help, we <code>would have</code> got into serious trouble.</em></p>\n<h4 id=\"1-3-错综时间条件句\"><a href=\"#1-3-错综时间条件句\" class=\"headerlink\" title=\"1.3 错综时间条件句\"></a>1.3 错综时间条件句</h4><p>有些条件句主句谓语和从句谓语在时间上并不一致（不符合上述两点）</p>\n<p><em>If you <code>had taken</code> her advice, you <code>wouldn&#39;t be</code> in such trouble now.</em></p>\n<p><em>If he <code>were leaving</code>, you <code>should have</code> heard about it.</em></p>\n<h4 id=\"1-4-含蓄条件句\"><a href=\"#1-4-含蓄条件句\" class=\"headerlink\" title=\"1.4 含蓄条件句\"></a>1.4 含蓄条件句</h4><p>隐含的条件句</p>\n<p><em>I might see her personally, it <code>would be</code> better.</em></p>\n<p><em>I did not press the point as it <code>would be</code> useless.</em></p>\n<p><em>In the old days she <code>would have</code> argued.</em></p>\n<p><em>I <code>wouldn&#39;t worry</code> about it.</em></p>\n<h4 id=\"1-5-委婉客气的语气，情态动词的使用（should-would-could-might）\"><a href=\"#1-5-委婉客气的语气，情态动词的使用（should-would-could-might）\" class=\"headerlink\" title=\"1.5 委婉客气的语气，情态动词的使用（should, would, could, might）\"></a>1.5 委婉客气的语气，情态动词的使用（should, would, could, might）</h4><p><em><code>Would</code> you mind shutting the window?</em></p>\n<p><em><code>Would</code> you tell me how to …</em></p>\n<p><em><code>Could</code> you lend me your computer?</em></p>\n<p><em>If necessary, you <code>might</code> shorten it.</em></p>\n<h3 id=\"2-虚拟语气在某些从句中的应用\"><a href=\"#2-虚拟语气在某些从句中的应用\" class=\"headerlink\" title=\"2. 虚拟语气在某些从句中的应用\"></a>2. 虚拟语气在某些从句中的应用</h3><h4 id=\"2-1-宾语从句\"><a href=\"#2-1-宾语从句\" class=\"headerlink\" title=\"2.1 宾语从句\"></a>2.1 宾语从句</h4><ol>\n<li><p><code>wish</code></p>\n<p>a. 与<strong>现在</strong>事实相反（<strong>be-&gt;were</strong>），<strong>过去式</strong></p>\n<p><em>I wish I <code>had</code> more time.</em>   还没有更多时间，但可能有</p>\n<p><em>I wish I <code>could</code> help you.</em> 我希望我能帮你（还没帮，未来可能帮，I wish I had helped you. 我希望我已经帮你，没帮已经是过去的事实了）</p>\n<p><em>I wish I <code>were</code>(was) young again.  // 用 was 也行</em></p>\n<p>b. 与<strong>过去</strong>事实相反，<strong>过去完成时</strong>，常表示<strong>遗憾</strong></p>\n<p><em>I wish I <code>had thought</code> what she really want.</em>  我没想过她真正想要什么，已经是事实了</p>\n<p><em>I wish I <code>had restrained</code> my emotion.</em>  我没有控制我的情感，已经是事实了</p>\n<p>c. 谈论<strong>将来</strong>的愿望，从句用 <code>would、could、might + do</code></p>\n<p><em>I wish I <code>could</code> do something for you in return. 我希望我能做点什么回报你</em></p>\n</li>\n<li><p><code>would rather</code></p>\n<p>谓语多用<strong>过去式</strong>，表<strong>现在、将来</strong></p>\n<p><em>I’d rather you <code>told</code> me the truth.</em>  我宁愿你给我讲真话</p>\n<p>suppose 虚拟+宾语从句（如果是对将来的假设，动词用过去时）</p>\n<p><em>Suppose her father turned her out of doors!</em></p>\n</li>\n<li><p><code>suggest</code>、<code>demand</code>、<code>insist</code>、<code>ask</code>等表示要求、命令、建议一类的动词</p>\n<p>从句用 <code>should + do</code>，但是 <code>should</code> 一般省略</p>\n<p><em>The doctor advised that he <code>change</code> the job.</em></p>\n<p><em>I propose that sb (should) <code>be</code> …</em></p>\n<p><em>He commanded that we (should) <code>attack</code> at once.</em></p>\n</li>\n</ol>\n<h4 id=\"2-2-主语从句、表语从句、同位语从句\"><a href=\"#2-2-主语从句、表语从句、同位语从句\" class=\"headerlink\" title=\"2.2 主语从句、表语从句、同位语从句\"></a>2.2 主语从句、表语从句、同位语从句</h4><p>从句用 <code>(should) do</code></p>\n<p><strong>主语从句</strong></p>\n<p><em>It’s important that he <code>work</code> hard.</em></p>\n<p><em>It’s _________ you <code>(should) not be</code> seen here. // 你不该出现在这里，这很…</em></p>\n<p><code>should do</code> 有时表达“竟然”的情感色彩</p>\n<p><em>It seems so unfair that this <code>should happen</code> to me.</em></p>\n<p><em>It’s strange that she <code>should be</code> so late. //真奇怪，她竟然来得这么晚</em></p>\n<p><strong>表语从句</strong></p>\n<p><em>Her idea was that they <code>should lock</code> up the house.</em></p>\n<p><strong>同位语从句</strong></p>\n<p><em>They expressed the wish that they <code>(should) be</code> given more free time.</em></p>\n<h4 id=\"3-状语从句\"><a href=\"#3-状语从句\" class=\"headerlink\" title=\"3. 状语从句\"></a>3. 状语从句</h4><ul>\n<li><p><code>as if</code>、<code>as though</code></p>\n<p>表示<strong>现在</strong>情况用<strong>过去式</strong>，表示<strong>过去</strong>情况用<strong>过去完成形式</strong></p>\n<p><em>I have loved you as if you <code>were</code> my son.</em></p>\n<p><em>I remember it as if it <code>happened</code> last night.</em></p>\n<p><em>He looks as though he <code>had known</code> Millie for years.</em> </p>\n<p>在 <code>look</code>、<code>seem</code>、<code>taste</code>、<code>smell</code> 后，<code>as if</code> 引导的从句可用<strong>陈述</strong>语气，大概率事件</p>\n<p><em>It looks as if they <code>are</code> in a terrible hurry.</em></p>\n<p><em>The meat tastes as if it <code>has</code> gone bad.</em></p>\n<p><code>as if (though)</code> 引导<strong>表语从句</strong></p>\n<p><em>You look as if you <code>didn&#39;t</code> care.</em></p>\n</li>\n<li><p><strong>让步状语从句</strong></p>\n<p><em>Whether she <code>be(is)</code> right or wrong, we will support her.</em></p>\n</li>\n<li><p><strong>目的状语</strong></p>\n<p>从句谓语多用 would、should、could、might</p>\n<p><em>I hired a boat so that I <code>could</code> go fish.</em></p>\n<p><em>He left early in order that the children <code>would</code> not be alone in the house.</em></p>\n</li>\n<li><p><strong>be+形容词，should+动词原形</strong>（张道真认为形容词后的从句为状语从句，有些认为是宾语从句）</p>\n<p><em>I’m <code>surprised</code> that you <code>should</code> press the suggestion. //我很奇怪你竟然坚持你的建议</em></p>\n<p><em>They’re especially <code>anxious</code> that you <code>should</code> come.  //他们特别期盼你能来</em></p>\n</li>\n</ul>\n<h3 id=\"虚拟语气的一些其他用法\"><a href=\"#虚拟语气的一些其他用法\" class=\"headerlink\" title=\"虚拟语气的一些其他用法\"></a>虚拟语气的一些其他用法</h3><p>只记录了较常见的</p>\n<ul>\n<li><p><code>It&#39;s (high) time</code> 后的定语从句中的虚拟语气</p>\n<p>多用<strong>过去虚拟</strong>语气</p>\n<p><em>It’s time we <code>went</code>.</em></p>\n<p><em>It’s time we <code>were</code> leaving.</em></p>\n<p><em>It’s high time you <code>made</code> up your mind.</em></p>\n</li>\n<li><p><code>would have thought</code></p>\n<p><em>Who <code>would have thought</code> to see you here!  //谁能想到会在这里看到你！</em></p>\n<p><em>Who <code>would have thought</code> it was going to break like that?</em>  </p>\n</li>\n</ul>\n<p>参考资料：<a href=\"https://book.douban.com/subject/1210225/\">张道真实用英语语法</a></p>\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<p>虚拟语气在形式上分为三类</p>\n<ol>\n<li><p><strong>现在</strong>虚拟语气——动词原形</p>\n<p><em>God <code>bless</code> you.</em> </p>\n</li>\n<li><p><strong>过去</strong>虚拟语气——和陈述语气的过去时相同，但动词 <code>be</code> 要用 <code>were</code></p>\n<p><em>If only I <code>were</code> not so nervous. // 我要是不那么紧张就好了</em></p>\n<p><em>She treated me as though I <code>were</code> a stranger.</em></p>\n</li>\n<li><p><strong>过去完成</strong>形式——和陈述语气中的过去完成时相同</p>\n<p><em>I wish I <code>hadn&#39;t done</code> so.</em></p>\n<p><em>If only I <code>had listened</code> to your advice.</em></p>\n</li>\n</ol>\n<p><a href=\"https://dictionary.cambridge.org/grammar/british-grammar/if-only\">If only</a> 用法</p>\n<h3 id=\"1-虚拟条件句\"><a href=\"#1-虚拟条件句\" class=\"headerlink\" title=\"1. 虚拟条件句\"></a>1. 虚拟条件句</h3><h4 id=\"1-1-表示与（现在、将来）事实相反的情况或可能性不大\"><a href=\"#1-1-表示与（现在、将来）事实相反的情况或可能性不大\" class=\"headerlink\" title=\"1.1 表示与（现在、将来）事实相反的情况或可能性不大\"></a>1.1 表示<strong>与（现在、将来）事实相反</strong>的情况或<strong>可能性不大</strong></h4><table>\n<thead>\n<tr>\n<th>条件从句</th>\n<th>主句</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>过去式（通常 <strong>be-&gt;were</strong>）</td>\n<td>would/might/could + <strong>do</strong></td>\n</tr>\n</tbody></table>\n<p><em>If I <code>were</code> you, I<code>&#39;d plant</code> some trees round the house.</em> 如果我是你，我就会在房子周围种些树（你还没种，未来可能种）</p>\n<p><em>If I <code>had</code> a map I <code>would lend</code> it to you.</em> 如果我有地图，我就借给你（但是我还没有，未来可能有）</p>\n<p><em>If I <code>dyed</code> my hair blue everyone <code>would</code> laugh at me.</em>  如果我把我的头发染成蓝色（还没染，未来小概率染）</p>\n<p><em>//从句用<code>If it were not for</code>，表示“若不是”</em></p>\n<p><em>If <code>it weren&#39;t for</code> Ruth, you <code>wouldn&#39;t be</code> anywhere. //要不是Ruth，你不会有任何成就</em></p>\n<p><em>If <code>it weren&#39;t for</code> your help, we <code>would be</code> in serious trouble.</em></p>\n<h4 id=\"1-2-表示与过去事实相反\"><a href=\"#1-2-表示与过去事实相反\" class=\"headerlink\" title=\"1.2 表示与过去事实相反\"></a>1.2 表示与过去事实相反</h4><table>\n<thead>\n<tr>\n<th>条件从句</th>\n<th>主句</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>If <strong>had done</strong></td>\n<td>would/might/could/should <strong>have done</strong>**</td>\n</tr>\n</tbody></table>\n<p><em>If anything <code>had happend</code>, he <code>would have</code> let us know.</em>  如果发生了什么，他<strong>早</strong>就通知我们了（没发生什么已经是事实了）</p>\n<p><em>If Hanyu <code>had recieved</code> the present, she <code>should</code> have thanked me.</em>  如果HY收到了礼物（表明HY没有受到礼物已经是事实了），她早就谢谢我了</p>\n<p><em>If I <code>had been</code> Nancy, I <code>wouldn&#39;t have</code> left him.</em> 如果我是南希，我不会离开他（南希已经离开了他）</p>\n<p><code>had not been for</code> 表示 “要不是“</p>\n<p><em>If it <code>hadn&#39;t been</code> for your timely help, we <code>would have</code> got into serious trouble.</em></p>\n<h4 id=\"1-3-错综时间条件句\"><a href=\"#1-3-错综时间条件句\" class=\"headerlink\" title=\"1.3 错综时间条件句\"></a>1.3 错综时间条件句</h4><p>有些条件句主句谓语和从句谓语在时间上并不一致（不符合上述两点）</p>\n<p><em>If you <code>had taken</code> her advice, you <code>wouldn&#39;t be</code> in such trouble now.</em></p>\n<p><em>If he <code>were leaving</code>, you <code>should have</code> heard about it.</em></p>\n<h4 id=\"1-4-含蓄条件句\"><a href=\"#1-4-含蓄条件句\" class=\"headerlink\" title=\"1.4 含蓄条件句\"></a>1.4 含蓄条件句</h4><p>隐含的条件句</p>\n<p><em>I might see her personally, it <code>would be</code> better.</em></p>\n<p><em>I did not press the point as it <code>would be</code> useless.</em></p>\n<p><em>In the old days she <code>would have</code> argued.</em></p>\n<p><em>I <code>wouldn&#39;t worry</code> about it.</em></p>\n<h4 id=\"1-5-委婉客气的语气，情态动词的使用（should-would-could-might）\"><a href=\"#1-5-委婉客气的语气，情态动词的使用（should-would-could-might）\" class=\"headerlink\" title=\"1.5 委婉客气的语气，情态动词的使用（should, would, could, might）\"></a>1.5 委婉客气的语气，情态动词的使用（should, would, could, might）</h4><p><em><code>Would</code> you mind shutting the window?</em></p>\n<p><em><code>Would</code> you tell me how to …</em></p>\n<p><em><code>Could</code> you lend me your computer?</em></p>\n<p><em>If necessary, you <code>might</code> shorten it.</em></p>\n<h3 id=\"2-虚拟语气在某些从句中的应用\"><a href=\"#2-虚拟语气在某些从句中的应用\" class=\"headerlink\" title=\"2. 虚拟语气在某些从句中的应用\"></a>2. 虚拟语气在某些从句中的应用</h3><h4 id=\"2-1-宾语从句\"><a href=\"#2-1-宾语从句\" class=\"headerlink\" title=\"2.1 宾语从句\"></a>2.1 宾语从句</h4><ol>\n<li><p><code>wish</code></p>\n<p>a. 与<strong>现在</strong>事实相反（<strong>be-&gt;were</strong>），<strong>过去式</strong></p>\n<p><em>I wish I <code>had</code> more time.</em>   还没有更多时间，但可能有</p>\n<p><em>I wish I <code>could</code> help you.</em> 我希望我能帮你（还没帮，未来可能帮，I wish I had helped you. 我希望我已经帮你，没帮已经是过去的事实了）</p>\n<p><em>I wish I <code>were</code>(was) young again.  // 用 was 也行</em></p>\n<p>b. 与<strong>过去</strong>事实相反，<strong>过去完成时</strong>，常表示<strong>遗憾</strong></p>\n<p><em>I wish I <code>had thought</code> what she really want.</em>  我没想过她真正想要什么，已经是事实了</p>\n<p><em>I wish I <code>had restrained</code> my emotion.</em>  我没有控制我的情感，已经是事实了</p>\n<p>c. 谈论<strong>将来</strong>的愿望，从句用 <code>would、could、might + do</code></p>\n<p><em>I wish I <code>could</code> do something for you in return. 我希望我能做点什么回报你</em></p>\n</li>\n<li><p><code>would rather</code></p>\n<p>谓语多用<strong>过去式</strong>，表<strong>现在、将来</strong></p>\n<p><em>I’d rather you <code>told</code> me the truth.</em>  我宁愿你给我讲真话</p>\n<p>suppose 虚拟+宾语从句（如果是对将来的假设，动词用过去时）</p>\n<p><em>Suppose her father turned her out of doors!</em></p>\n</li>\n<li><p><code>suggest</code>、<code>demand</code>、<code>insist</code>、<code>ask</code>等表示要求、命令、建议一类的动词</p>\n<p>从句用 <code>should + do</code>，但是 <code>should</code> 一般省略</p>\n<p><em>The doctor advised that he <code>change</code> the job.</em></p>\n<p><em>I propose that sb (should) <code>be</code> …</em></p>\n<p><em>He commanded that we (should) <code>attack</code> at once.</em></p>\n</li>\n</ol>\n<h4 id=\"2-2-主语从句、表语从句、同位语从句\"><a href=\"#2-2-主语从句、表语从句、同位语从句\" class=\"headerlink\" title=\"2.2 主语从句、表语从句、同位语从句\"></a>2.2 主语从句、表语从句、同位语从句</h4><p>从句用 <code>(should) do</code></p>\n<p><strong>主语从句</strong></p>\n<p><em>It’s important that he <code>work</code> hard.</em></p>\n<p><em>It’s _________ you <code>(should) not be</code> seen here. // 你不该出现在这里，这很…</em></p>\n<p><code>should do</code> 有时表达“竟然”的情感色彩</p>\n<p><em>It seems so unfair that this <code>should happen</code> to me.</em></p>\n<p><em>It’s strange that she <code>should be</code> so late. //真奇怪，她竟然来得这么晚</em></p>\n<p><strong>表语从句</strong></p>\n<p><em>Her idea was that they <code>should lock</code> up the house.</em></p>\n<p><strong>同位语从句</strong></p>\n<p><em>They expressed the wish that they <code>(should) be</code> given more free time.</em></p>\n<h4 id=\"3-状语从句\"><a href=\"#3-状语从句\" class=\"headerlink\" title=\"3. 状语从句\"></a>3. 状语从句</h4><ul>\n<li><p><code>as if</code>、<code>as though</code></p>\n<p>表示<strong>现在</strong>情况用<strong>过去式</strong>，表示<strong>过去</strong>情况用<strong>过去完成形式</strong></p>\n<p><em>I have loved you as if you <code>were</code> my son.</em></p>\n<p><em>I remember it as if it <code>happened</code> last night.</em></p>\n<p><em>He looks as though he <code>had known</code> Millie for years.</em> </p>\n<p>在 <code>look</code>、<code>seem</code>、<code>taste</code>、<code>smell</code> 后，<code>as if</code> 引导的从句可用<strong>陈述</strong>语气，大概率事件</p>\n<p><em>It looks as if they <code>are</code> in a terrible hurry.</em></p>\n<p><em>The meat tastes as if it <code>has</code> gone bad.</em></p>\n<p><code>as if (though)</code> 引导<strong>表语从句</strong></p>\n<p><em>You look as if you <code>didn&#39;t</code> care.</em></p>\n</li>\n<li><p><strong>让步状语从句</strong></p>\n<p><em>Whether she <code>be(is)</code> right or wrong, we will support her.</em></p>\n</li>\n<li><p><strong>目的状语</strong></p>\n<p>从句谓语多用 would、should、could、might</p>\n<p><em>I hired a boat so that I <code>could</code> go fish.</em></p>\n<p><em>He left early in order that the children <code>would</code> not be alone in the house.</em></p>\n</li>\n<li><p><strong>be+形容词，should+动词原形</strong>（张道真认为形容词后的从句为状语从句，有些认为是宾语从句）</p>\n<p><em>I’m <code>surprised</code> that you <code>should</code> press the suggestion. //我很奇怪你竟然坚持你的建议</em></p>\n<p><em>They’re especially <code>anxious</code> that you <code>should</code> come.  //他们特别期盼你能来</em></p>\n</li>\n</ul>\n<h3 id=\"虚拟语气的一些其他用法\"><a href=\"#虚拟语气的一些其他用法\" class=\"headerlink\" title=\"虚拟语气的一些其他用法\"></a>虚拟语气的一些其他用法</h3><p>只记录了较常见的</p>\n<ul>\n<li><p><code>It&#39;s (high) time</code> 后的定语从句中的虚拟语气</p>\n<p>多用<strong>过去虚拟</strong>语气</p>\n<p><em>It’s time we <code>went</code>.</em></p>\n<p><em>It’s time we <code>were</code> leaving.</em></p>\n<p><em>It’s high time you <code>made</code> up your mind.</em></p>\n</li>\n<li><p><code>would have thought</code></p>\n<p><em>Who <code>would have thought</code> to see you here!  //谁能想到会在这里看到你！</em></p>\n<p><em>Who <code>would have thought</code> it was going to break like that?</em>  </p>\n</li>\n</ul>\n<p>参考资料：<a href=\"https://book.douban.com/subject/1210225/\">张道真实用英语语法</a></p>\n"},{"_content":"why？为什么要发明lambda函数？\n\n简化仿函数\n\n#### 1. 语法\n\n```cpp\n[capture](parameters) mutable -> return_type{statement} \n```\n\n其中：\n\n- [capture]：lambda函数引出符\n\n  > [var]：以值传递的方式捕捉变量var\n  >\n  > [=]：以值传递的方式捕捉所有父作用域的变量（包括this）\n  >\n  > [&var]：以引用传递的方式捕捉var\n  >\n  > [&]：以引用传递的方式捕捉所有父作用域的变量（包括this）\n  >\n  > 注意：1. 以上方式可以组合（[=, &a, &b]），但不允许重复捕获，例如[=, a]会导致编译错误\n\n- (parameters)：参数列表，不需要时可连同括号()一起省略\n\n- mutable：mutable修饰符。默认情况下lambda函数总是一个const函数，mutable可以取消其常量性。在使用该修饰符时，参数列表不可省略（即使参数为空）\n\n- ->return_type：返回类型，没有返回值时，可连同->一起省略\n\n- {statement}：函数体\n\n#### 2. lambda底层实现 & 仿函数\n\n##### 2.1 仿函数\n\n###### 仿函数定义\n\n在一个类中重载()运算符，可以将该类对象像函数一样使用\n\n```cpp\nclass _functor {\npublic:\n    int operator()(int a, int b){\n        return a + b;\n    }\n};\n\nint main()\n{\n    int girls = 3, boys = 4;  \n    _functor totalChild;\n    cout << totalChild(5, 6) << endl;\n    return 0;\n}\n```\n\n###### 仿函数的初始状态\n\n仿函数可以有初始状态，这是它与普通函数的重要区别。<u>class私有成员的状态构成了仿函数的初始状态</u>，可以通过构造函数在声明对象时初始化状态\n\n> 仿函数其可以拥有多个不同的初始状态（多个具有不同初始值的对象）\n\n```cpp\nclass Tax {\nprivate:\n    float rate;\n    int base;\npublic:\n    Tax(float r, int b):rate(r),base(b){}\n    float operator()(float money){return (money - base) * rate;}\n};\n\nint main()\n{\n    //调用构造函数\n    Tax high(0.4, 30000);  \t\t\t// 设定初始状态（rate，base）\n    Tax middle(0.25, 20000);  \t\t// 设定初始状态（rate，base）\n    cout <<\"tax over 3w:\"<<high(37500)<< endl;\n    cout << \"tax over 2w:\" << middle(27500) << endl;\n    return 0;\n}\n```\n\n##### 2.2 lambda函数与仿函数的比较\n\n<u>lambda捕捉父作用域（用户）的变量作为初始状态</u>，仿函数通过构造函数来初始化状态（构造函数的参数由用户传递）。事实上，仿函数是编译器<u>实现</u>lambda的一种方式，现阶段，通常<u>编译器</u>都会把lambda函数转化为一个仿函数\n\n> lambda函数是仿函数的“语法糖”\n\n![image-20220401162858026](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220401162858026.png)\n\n——图源：《深入理解C++11》\n\n#### lambda捕获的参数存在内存中的什么位置？\n\n面试时遇到这个题，当时脑子懵了，没回答上来，其实挺简单的，猜都能猜到\n\n1. 值传递\n\n```cpp\nint main()\n{\n    int a=1;\n    cout<<\"父作用域的a的内存位置：\"<<&a<<endl;\n    int girls =3,boys=4; \n    auto totalChild = [a](int x,int y)->int{\n    \tcout<<\"lambda作用域中a的内存位置：\"<<&a<<endl;\n        return x+y+a;\n    };\n    cout<<totalChild(girls,boys)<<endl;\n    return 0;\n}\n```\n\n对于父作用域的局部变量a，它存在栈中，lambda值捕获的a也在栈中，其内存地址在boys后面分配，就像是新定义的局部变量\n\n2. 引用传递\n\n引用传递地址肯定是不变的，父作用域什么地址，lambda表达式中也是一样的地址\n\n#### 3. 与函数指针的区别是什么？\n\n\n\n#### lambda表达式内部无法修改<u>值传递</u>的值，因为lambda表达式内部仿函数实现时，()重载函数默认是`const`的\n\n```cpp\nint main()\n{\n    int a = 1;\n    cout << \"父作用域的a的内存位置：\" << &a << endl;\n    int girls = 3, boys = 4;\n    auto totalChild = [a](int x, int y)->int {\n        a = 2; //编译器报错，表达式不是可修改的左值\n        cout << \"lambda作用域中a的内存位置：\" << &a << endl;\n        return x + y + a;\n    };\n    cout << totalChild(girls, boys) << endl;\n    return 0;\n}\n```\n\n如果要修改，需要加`mutable`取消()重载函数的常量性\n\n```cpp\nauto totalChild = [a](int x, int y)mutable->int {\n\t...\n}\n```\n\n#### lambda表达式是不能赋值的\n\n```cpp\nauto a = [] { cout << \"A\" << endl; };\nauto b = [] { cout << \"B\" << endl; };\na = b;   // 非法，lambda无法赋值\nauto c = a;   // 合法，生成一个副本\n```\n\na、b的类型都是`lambda []void()->void`，但是不能赋值，因为lambda表达式内部实现禁用了赋值运算符（=delete）。但是没有禁用拷贝构造函数，所以可以用一个lambda表达式去初始化另一个lambda表达式\n\n","source":"_posts/C++/C++11/lambda表达式.md","raw":"why？为什么要发明lambda函数？\n\n简化仿函数\n\n#### 1. 语法\n\n```cpp\n[capture](parameters) mutable -> return_type{statement} \n```\n\n其中：\n\n- [capture]：lambda函数引出符\n\n  > [var]：以值传递的方式捕捉变量var\n  >\n  > [=]：以值传递的方式捕捉所有父作用域的变量（包括this）\n  >\n  > [&var]：以引用传递的方式捕捉var\n  >\n  > [&]：以引用传递的方式捕捉所有父作用域的变量（包括this）\n  >\n  > 注意：1. 以上方式可以组合（[=, &a, &b]），但不允许重复捕获，例如[=, a]会导致编译错误\n\n- (parameters)：参数列表，不需要时可连同括号()一起省略\n\n- mutable：mutable修饰符。默认情况下lambda函数总是一个const函数，mutable可以取消其常量性。在使用该修饰符时，参数列表不可省略（即使参数为空）\n\n- ->return_type：返回类型，没有返回值时，可连同->一起省略\n\n- {statement}：函数体\n\n#### 2. lambda底层实现 & 仿函数\n\n##### 2.1 仿函数\n\n###### 仿函数定义\n\n在一个类中重载()运算符，可以将该类对象像函数一样使用\n\n```cpp\nclass _functor {\npublic:\n    int operator()(int a, int b){\n        return a + b;\n    }\n};\n\nint main()\n{\n    int girls = 3, boys = 4;  \n    _functor totalChild;\n    cout << totalChild(5, 6) << endl;\n    return 0;\n}\n```\n\n###### 仿函数的初始状态\n\n仿函数可以有初始状态，这是它与普通函数的重要区别。<u>class私有成员的状态构成了仿函数的初始状态</u>，可以通过构造函数在声明对象时初始化状态\n\n> 仿函数其可以拥有多个不同的初始状态（多个具有不同初始值的对象）\n\n```cpp\nclass Tax {\nprivate:\n    float rate;\n    int base;\npublic:\n    Tax(float r, int b):rate(r),base(b){}\n    float operator()(float money){return (money - base) * rate;}\n};\n\nint main()\n{\n    //调用构造函数\n    Tax high(0.4, 30000);  \t\t\t// 设定初始状态（rate，base）\n    Tax middle(0.25, 20000);  \t\t// 设定初始状态（rate，base）\n    cout <<\"tax over 3w:\"<<high(37500)<< endl;\n    cout << \"tax over 2w:\" << middle(27500) << endl;\n    return 0;\n}\n```\n\n##### 2.2 lambda函数与仿函数的比较\n\n<u>lambda捕捉父作用域（用户）的变量作为初始状态</u>，仿函数通过构造函数来初始化状态（构造函数的参数由用户传递）。事实上，仿函数是编译器<u>实现</u>lambda的一种方式，现阶段，通常<u>编译器</u>都会把lambda函数转化为一个仿函数\n\n> lambda函数是仿函数的“语法糖”\n\n![image-20220401162858026](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220401162858026.png)\n\n——图源：《深入理解C++11》\n\n#### lambda捕获的参数存在内存中的什么位置？\n\n面试时遇到这个题，当时脑子懵了，没回答上来，其实挺简单的，猜都能猜到\n\n1. 值传递\n\n```cpp\nint main()\n{\n    int a=1;\n    cout<<\"父作用域的a的内存位置：\"<<&a<<endl;\n    int girls =3,boys=4; \n    auto totalChild = [a](int x,int y)->int{\n    \tcout<<\"lambda作用域中a的内存位置：\"<<&a<<endl;\n        return x+y+a;\n    };\n    cout<<totalChild(girls,boys)<<endl;\n    return 0;\n}\n```\n\n对于父作用域的局部变量a，它存在栈中，lambda值捕获的a也在栈中，其内存地址在boys后面分配，就像是新定义的局部变量\n\n2. 引用传递\n\n引用传递地址肯定是不变的，父作用域什么地址，lambda表达式中也是一样的地址\n\n#### 3. 与函数指针的区别是什么？\n\n\n\n#### lambda表达式内部无法修改<u>值传递</u>的值，因为lambda表达式内部仿函数实现时，()重载函数默认是`const`的\n\n```cpp\nint main()\n{\n    int a = 1;\n    cout << \"父作用域的a的内存位置：\" << &a << endl;\n    int girls = 3, boys = 4;\n    auto totalChild = [a](int x, int y)->int {\n        a = 2; //编译器报错，表达式不是可修改的左值\n        cout << \"lambda作用域中a的内存位置：\" << &a << endl;\n        return x + y + a;\n    };\n    cout << totalChild(girls, boys) << endl;\n    return 0;\n}\n```\n\n如果要修改，需要加`mutable`取消()重载函数的常量性\n\n```cpp\nauto totalChild = [a](int x, int y)mutable->int {\n\t...\n}\n```\n\n#### lambda表达式是不能赋值的\n\n```cpp\nauto a = [] { cout << \"A\" << endl; };\nauto b = [] { cout << \"B\" << endl; };\na = b;   // 非法，lambda无法赋值\nauto c = a;   // 合法，生成一个副本\n```\n\na、b的类型都是`lambda []void()->void`，但是不能赋值，因为lambda表达式内部实现禁用了赋值运算符（=delete）。但是没有禁用拷贝构造函数，所以可以用一个lambda表达式去初始化另一个lambda表达式\n\n","slug":"C++/C++11/lambda表达式","published":1,"date":"2022-03-25T13:55:54.668Z","updated":"2022-05-12T12:46:47.508Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0kxi000tpcu30uwz2zux","content":"<p>why？为什么要发明lambda函数？</p>\n<p>简化仿函数</p>\n<h4 id=\"1-语法\"><a href=\"#1-语法\" class=\"headerlink\" title=\"1. 语法\"></a>1. 语法</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[capture](parameters) <span class=\"keyword\">mutable</span> -&gt; return_type&#123;statement&#125; </span><br></pre></td></tr></table></figure>\n\n<p>其中：</p>\n<ul>\n<li><p>[capture]：lambda函数引出符</p>\n<blockquote>\n<p>[var]：以值传递的方式捕捉变量var</p>\n<p>[=]：以值传递的方式捕捉所有父作用域的变量（包括this）</p>\n<p>[&amp;var]：以引用传递的方式捕捉var</p>\n<p>[&amp;]：以引用传递的方式捕捉所有父作用域的变量（包括this）</p>\n<p>注意：1. 以上方式可以组合（[=, &amp;a, &amp;b]），但不允许重复捕获，例如[=, a]会导致编译错误</p>\n</blockquote>\n</li>\n<li><p>(parameters)：参数列表，不需要时可连同括号()一起省略</p>\n</li>\n<li><p>mutable：mutable修饰符。默认情况下lambda函数总是一个const函数，mutable可以取消其常量性。在使用该修饰符时，参数列表不可省略（即使参数为空）</p>\n</li>\n<li><p>-&gt;return_type：返回类型，没有返回值时，可连同-&gt;一起省略</p>\n</li>\n<li><p>{statement}：函数体</p>\n</li>\n</ul>\n<h4 id=\"2-lambda底层实现-amp-仿函数\"><a href=\"#2-lambda底层实现-amp-仿函数\" class=\"headerlink\" title=\"2. lambda底层实现 &amp; 仿函数\"></a>2. lambda底层实现 &amp; 仿函数</h4><h5 id=\"2-1-仿函数\"><a href=\"#2-1-仿函数\" class=\"headerlink\" title=\"2.1 仿函数\"></a>2.1 仿函数</h5><h6 id=\"仿函数定义\"><a href=\"#仿函数定义\" class=\"headerlink\" title=\"仿函数定义\"></a>仿函数定义</h6><p>在一个类中重载()运算符，可以将该类对象像函数一样使用</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">functor</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> girls = <span class=\"number\">3</span>, boys = <span class=\"number\">4</span>;  </span><br><span class=\"line\">    _functor totalChild;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"built_in\">totalChild</span>(<span class=\"number\">5</span>, <span class=\"number\">6</span>) &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"仿函数的初始状态\"><a href=\"#仿函数的初始状态\" class=\"headerlink\" title=\"仿函数的初始状态\"></a>仿函数的初始状态</h6><p>仿函数可以有初始状态，这是它与普通函数的重要区别。<u>class私有成员的状态构成了仿函数的初始状态</u>，可以通过构造函数在声明对象时初始化状态</p>\n<blockquote>\n<p>仿函数其可以拥有多个不同的初始状态（多个具有不同初始值的对象）</p>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Tax</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">float</span> rate;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> base;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Tax</span>(<span class=\"keyword\">float</span> r, <span class=\"keyword\">int</span> b):<span class=\"built_in\">rate</span>(r),<span class=\"built_in\">base</span>(b)&#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">float</span> <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">(<span class=\"keyword\">float</span> money)</span></span>&#123;<span class=\"keyword\">return</span> (money - base) * rate;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//调用构造函数</span></span><br><span class=\"line\">    <span class=\"function\">Tax <span class=\"title\">high</span><span class=\"params\">(<span class=\"number\">0.4</span>, <span class=\"number\">30000</span>)</span></span>;  \t\t\t<span class=\"comment\">// 设定初始状态（rate，base）</span></span><br><span class=\"line\">    <span class=\"function\">Tax <span class=\"title\">middle</span><span class=\"params\">(<span class=\"number\">0.25</span>, <span class=\"number\">20000</span>)</span></span>;  \t\t<span class=\"comment\">// 设定初始状态（rate，base）</span></span><br><span class=\"line\">    cout &lt;&lt;<span class=\"string\">&quot;tax over 3w:&quot;</span>&lt;&lt;<span class=\"built_in\">high</span>(<span class=\"number\">37500</span>)&lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;tax over 2w:&quot;</span> &lt;&lt; <span class=\"built_in\">middle</span>(<span class=\"number\">27500</span>) &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"2-2-lambda函数与仿函数的比较\"><a href=\"#2-2-lambda函数与仿函数的比较\" class=\"headerlink\" title=\"2.2 lambda函数与仿函数的比较\"></a>2.2 lambda函数与仿函数的比较</h5><p><u>lambda捕捉父作用域（用户）的变量作为初始状态</u>，仿函数通过构造函数来初始化状态（构造函数的参数由用户传递）。事实上，仿函数是编译器<u>实现</u>lambda的一种方式，现阶段，通常<u>编译器</u>都会把lambda函数转化为一个仿函数</p>\n<blockquote>\n<p>lambda函数是仿函数的“语法糖”</p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220401162858026.png\" alt=\"image-20220401162858026\"></p>\n<p>——图源：《深入理解C++11》</p>\n<h4 id=\"lambda捕获的参数存在内存中的什么位置？\"><a href=\"#lambda捕获的参数存在内存中的什么位置？\" class=\"headerlink\" title=\"lambda捕获的参数存在内存中的什么位置？\"></a>lambda捕获的参数存在内存中的什么位置？</h4><p>面试时遇到这个题，当时脑子懵了，没回答上来，其实挺简单的，猜都能猜到</p>\n<ol>\n<li>值传递</li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a=<span class=\"number\">1</span>;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;父作用域的a的内存位置：&quot;</span>&lt;&lt;&amp;a&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> girls =<span class=\"number\">3</span>,boys=<span class=\"number\">4</span>; </span><br><span class=\"line\">    <span class=\"keyword\">auto</span> totalChild = [a](<span class=\"keyword\">int</span> x,<span class=\"keyword\">int</span> y)-&gt;<span class=\"keyword\">int</span>&#123;</span><br><span class=\"line\">    \tcout&lt;&lt;<span class=\"string\">&quot;lambda作用域中a的内存位置：&quot;</span>&lt;&lt;&amp;a&lt;&lt;endl;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x+y+a;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"built_in\">totalChild</span>(girls,boys)&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于父作用域的局部变量a，它存在栈中，lambda值捕获的a也在栈中，其内存地址在boys后面分配，就像是新定义的局部变量</p>\n<ol start=\"2\">\n<li>引用传递</li>\n</ol>\n<p>引用传递地址肯定是不变的，父作用域什么地址，lambda表达式中也是一样的地址</p>\n<h4 id=\"3-与函数指针的区别是什么？\"><a href=\"#3-与函数指针的区别是什么？\" class=\"headerlink\" title=\"3. 与函数指针的区别是什么？\"></a>3. 与函数指针的区别是什么？</h4><h4 id=\"lambda表达式内部无法修改值传递的值，因为lambda表达式内部仿函数实现时，-重载函数默认是const的\"><a href=\"#lambda表达式内部无法修改值传递的值，因为lambda表达式内部仿函数实现时，-重载函数默认是const的\" class=\"headerlink\" title=\"lambda表达式内部无法修改值传递的值，因为lambda表达式内部仿函数实现时，()重载函数默认是const的\"></a>lambda表达式内部无法修改<u>值传递</u>的值，因为lambda表达式内部仿函数实现时，()重载函数默认是<code>const</code>的</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;父作用域的a的内存位置：&quot;</span> &lt;&lt; &amp;a &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> girls = <span class=\"number\">3</span>, boys = <span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> totalChild = [a](<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)-&gt;<span class=\"keyword\">int</span> &#123;</span><br><span class=\"line\">        a = <span class=\"number\">2</span>; <span class=\"comment\">//编译器报错，表达式不是可修改的左值</span></span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;lambda作用域中a的内存位置：&quot;</span> &lt;&lt; &amp;a &lt;&lt; endl;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x + y + a;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"built_in\">totalChild</span>(girls, boys) &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果要修改，需要加<code>mutable</code>取消()重载函数的常量性</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> totalChild = [a](<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)<span class=\"keyword\">mutable</span>-&gt;<span class=\"keyword\">int</span> &#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"lambda表达式是不能赋值的\"><a href=\"#lambda表达式是不能赋值的\" class=\"headerlink\" title=\"lambda表达式是不能赋值的\"></a>lambda表达式是不能赋值的</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> a = [] &#123; cout &lt;&lt; <span class=\"string\">&quot;A&quot;</span> &lt;&lt; endl; &#125;;</span><br><span class=\"line\"><span class=\"keyword\">auto</span> b = [] &#123; cout &lt;&lt; <span class=\"string\">&quot;B&quot;</span> &lt;&lt; endl; &#125;;</span><br><span class=\"line\">a = b;   <span class=\"comment\">// 非法，lambda无法赋值</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> c = a;   <span class=\"comment\">// 合法，生成一个副本</span></span><br></pre></td></tr></table></figure>\n\n<p>a、b的类型都是<code>lambda []void()-&gt;void</code>，但是不能赋值，因为lambda表达式内部实现禁用了赋值运算符（=delete）。但是没有禁用拷贝构造函数，所以可以用一个lambda表达式去初始化另一个lambda表达式</p>\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<p>why？为什么要发明lambda函数？</p>\n<p>简化仿函数</p>\n<h4 id=\"1-语法\"><a href=\"#1-语法\" class=\"headerlink\" title=\"1. 语法\"></a>1. 语法</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[capture](parameters) <span class=\"keyword\">mutable</span> -&gt; return_type&#123;statement&#125; </span><br></pre></td></tr></table></figure>\n\n<p>其中：</p>\n<ul>\n<li><p>[capture]：lambda函数引出符</p>\n<blockquote>\n<p>[var]：以值传递的方式捕捉变量var</p>\n<p>[=]：以值传递的方式捕捉所有父作用域的变量（包括this）</p>\n<p>[&amp;var]：以引用传递的方式捕捉var</p>\n<p>[&amp;]：以引用传递的方式捕捉所有父作用域的变量（包括this）</p>\n<p>注意：1. 以上方式可以组合（[=, &amp;a, &amp;b]），但不允许重复捕获，例如[=, a]会导致编译错误</p>\n</blockquote>\n</li>\n<li><p>(parameters)：参数列表，不需要时可连同括号()一起省略</p>\n</li>\n<li><p>mutable：mutable修饰符。默认情况下lambda函数总是一个const函数，mutable可以取消其常量性。在使用该修饰符时，参数列表不可省略（即使参数为空）</p>\n</li>\n<li><p>-&gt;return_type：返回类型，没有返回值时，可连同-&gt;一起省略</p>\n</li>\n<li><p>{statement}：函数体</p>\n</li>\n</ul>\n<h4 id=\"2-lambda底层实现-amp-仿函数\"><a href=\"#2-lambda底层实现-amp-仿函数\" class=\"headerlink\" title=\"2. lambda底层实现 &amp; 仿函数\"></a>2. lambda底层实现 &amp; 仿函数</h4><h5 id=\"2-1-仿函数\"><a href=\"#2-1-仿函数\" class=\"headerlink\" title=\"2.1 仿函数\"></a>2.1 仿函数</h5><h6 id=\"仿函数定义\"><a href=\"#仿函数定义\" class=\"headerlink\" title=\"仿函数定义\"></a>仿函数定义</h6><p>在一个类中重载()运算符，可以将该类对象像函数一样使用</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">functor</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> girls = <span class=\"number\">3</span>, boys = <span class=\"number\">4</span>;  </span><br><span class=\"line\">    _functor totalChild;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"built_in\">totalChild</span>(<span class=\"number\">5</span>, <span class=\"number\">6</span>) &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"仿函数的初始状态\"><a href=\"#仿函数的初始状态\" class=\"headerlink\" title=\"仿函数的初始状态\"></a>仿函数的初始状态</h6><p>仿函数可以有初始状态，这是它与普通函数的重要区别。<u>class私有成员的状态构成了仿函数的初始状态</u>，可以通过构造函数在声明对象时初始化状态</p>\n<blockquote>\n<p>仿函数其可以拥有多个不同的初始状态（多个具有不同初始值的对象）</p>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Tax</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">float</span> rate;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> base;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Tax</span>(<span class=\"keyword\">float</span> r, <span class=\"keyword\">int</span> b):<span class=\"built_in\">rate</span>(r),<span class=\"built_in\">base</span>(b)&#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">float</span> <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">(<span class=\"keyword\">float</span> money)</span></span>&#123;<span class=\"keyword\">return</span> (money - base) * rate;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//调用构造函数</span></span><br><span class=\"line\">    <span class=\"function\">Tax <span class=\"title\">high</span><span class=\"params\">(<span class=\"number\">0.4</span>, <span class=\"number\">30000</span>)</span></span>;  \t\t\t<span class=\"comment\">// 设定初始状态（rate，base）</span></span><br><span class=\"line\">    <span class=\"function\">Tax <span class=\"title\">middle</span><span class=\"params\">(<span class=\"number\">0.25</span>, <span class=\"number\">20000</span>)</span></span>;  \t\t<span class=\"comment\">// 设定初始状态（rate，base）</span></span><br><span class=\"line\">    cout &lt;&lt;<span class=\"string\">&quot;tax over 3w:&quot;</span>&lt;&lt;<span class=\"built_in\">high</span>(<span class=\"number\">37500</span>)&lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;tax over 2w:&quot;</span> &lt;&lt; <span class=\"built_in\">middle</span>(<span class=\"number\">27500</span>) &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"2-2-lambda函数与仿函数的比较\"><a href=\"#2-2-lambda函数与仿函数的比较\" class=\"headerlink\" title=\"2.2 lambda函数与仿函数的比较\"></a>2.2 lambda函数与仿函数的比较</h5><p><u>lambda捕捉父作用域（用户）的变量作为初始状态</u>，仿函数通过构造函数来初始化状态（构造函数的参数由用户传递）。事实上，仿函数是编译器<u>实现</u>lambda的一种方式，现阶段，通常<u>编译器</u>都会把lambda函数转化为一个仿函数</p>\n<blockquote>\n<p>lambda函数是仿函数的“语法糖”</p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220401162858026.png\" alt=\"image-20220401162858026\"></p>\n<p>——图源：《深入理解C++11》</p>\n<h4 id=\"lambda捕获的参数存在内存中的什么位置？\"><a href=\"#lambda捕获的参数存在内存中的什么位置？\" class=\"headerlink\" title=\"lambda捕获的参数存在内存中的什么位置？\"></a>lambda捕获的参数存在内存中的什么位置？</h4><p>面试时遇到这个题，当时脑子懵了，没回答上来，其实挺简单的，猜都能猜到</p>\n<ol>\n<li>值传递</li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a=<span class=\"number\">1</span>;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;父作用域的a的内存位置：&quot;</span>&lt;&lt;&amp;a&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> girls =<span class=\"number\">3</span>,boys=<span class=\"number\">4</span>; </span><br><span class=\"line\">    <span class=\"keyword\">auto</span> totalChild = [a](<span class=\"keyword\">int</span> x,<span class=\"keyword\">int</span> y)-&gt;<span class=\"keyword\">int</span>&#123;</span><br><span class=\"line\">    \tcout&lt;&lt;<span class=\"string\">&quot;lambda作用域中a的内存位置：&quot;</span>&lt;&lt;&amp;a&lt;&lt;endl;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x+y+a;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"built_in\">totalChild</span>(girls,boys)&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于父作用域的局部变量a，它存在栈中，lambda值捕获的a也在栈中，其内存地址在boys后面分配，就像是新定义的局部变量</p>\n<ol start=\"2\">\n<li>引用传递</li>\n</ol>\n<p>引用传递地址肯定是不变的，父作用域什么地址，lambda表达式中也是一样的地址</p>\n<h4 id=\"3-与函数指针的区别是什么？\"><a href=\"#3-与函数指针的区别是什么？\" class=\"headerlink\" title=\"3. 与函数指针的区别是什么？\"></a>3. 与函数指针的区别是什么？</h4><h4 id=\"lambda表达式内部无法修改值传递的值，因为lambda表达式内部仿函数实现时，-重载函数默认是const的\"><a href=\"#lambda表达式内部无法修改值传递的值，因为lambda表达式内部仿函数实现时，-重载函数默认是const的\" class=\"headerlink\" title=\"lambda表达式内部无法修改值传递的值，因为lambda表达式内部仿函数实现时，()重载函数默认是const的\"></a>lambda表达式内部无法修改<u>值传递</u>的值，因为lambda表达式内部仿函数实现时，()重载函数默认是<code>const</code>的</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;父作用域的a的内存位置：&quot;</span> &lt;&lt; &amp;a &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> girls = <span class=\"number\">3</span>, boys = <span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> totalChild = [a](<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)-&gt;<span class=\"keyword\">int</span> &#123;</span><br><span class=\"line\">        a = <span class=\"number\">2</span>; <span class=\"comment\">//编译器报错，表达式不是可修改的左值</span></span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;lambda作用域中a的内存位置：&quot;</span> &lt;&lt; &amp;a &lt;&lt; endl;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x + y + a;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"built_in\">totalChild</span>(girls, boys) &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果要修改，需要加<code>mutable</code>取消()重载函数的常量性</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> totalChild = [a](<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)<span class=\"keyword\">mutable</span>-&gt;<span class=\"keyword\">int</span> &#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"lambda表达式是不能赋值的\"><a href=\"#lambda表达式是不能赋值的\" class=\"headerlink\" title=\"lambda表达式是不能赋值的\"></a>lambda表达式是不能赋值的</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> a = [] &#123; cout &lt;&lt; <span class=\"string\">&quot;A&quot;</span> &lt;&lt; endl; &#125;;</span><br><span class=\"line\"><span class=\"keyword\">auto</span> b = [] &#123; cout &lt;&lt; <span class=\"string\">&quot;B&quot;</span> &lt;&lt; endl; &#125;;</span><br><span class=\"line\">a = b;   <span class=\"comment\">// 非法，lambda无法赋值</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> c = a;   <span class=\"comment\">// 合法，生成一个副本</span></span><br></pre></td></tr></table></figure>\n\n<p>a、b的类型都是<code>lambda []void()-&gt;void</code>，但是不能赋值，因为lambda表达式内部实现禁用了赋值运算符（=delete）。但是没有禁用拷贝构造函数，所以可以用一个lambda表达式去初始化另一个lambda表达式</p>\n"},{"_content":"成员初始化的顺序不是初始化列表中的顺序，而是按照成员在类中声明的顺序\n\n类中的**引用**和**const**成员变量必须放到初始化列表中进行初始化，不能放到构造函数体中进行“赋值”\n\n因为赋值和初始化是不同的，构造函数体中是先开辟空间，然后进行赋值。而初始化列表中开辟内存和初始化是同时进行的\n\n引用和const都是不能被赋值的，所以只能放到初始化列表中 ","source":"_posts/C++/C++11/初始化列表.md","raw":"成员初始化的顺序不是初始化列表中的顺序，而是按照成员在类中声明的顺序\n\n类中的**引用**和**const**成员变量必须放到初始化列表中进行初始化，不能放到构造函数体中进行“赋值”\n\n因为赋值和初始化是不同的，构造函数体中是先开辟空间，然后进行赋值。而初始化列表中开辟内存和初始化是同时进行的\n\n引用和const都是不能被赋值的，所以只能放到初始化列表中 ","slug":"C++/C++11/初始化列表","published":1,"date":"2022-04-09T08:14:31.778Z","updated":"2022-04-09T08:45:31.858Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0kxj000upcu3azi59543","content":"<p>成员初始化的顺序不是初始化列表中的顺序，而是按照成员在类中声明的顺序</p>\n<p>类中的<strong>引用</strong>和<strong>const</strong>成员变量必须放到初始化列表中进行初始化，不能放到构造函数体中进行“赋值”</p>\n<p>因为赋值和初始化是不同的，构造函数体中是先开辟空间，然后进行赋值。而初始化列表中开辟内存和初始化是同时进行的</p>\n<p>引用和const都是不能被赋值的，所以只能放到初始化列表中 </p>\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<p>成员初始化的顺序不是初始化列表中的顺序，而是按照成员在类中声明的顺序</p>\n<p>类中的<strong>引用</strong>和<strong>const</strong>成员变量必须放到初始化列表中进行初始化，不能放到构造函数体中进行“赋值”</p>\n<p>因为赋值和初始化是不同的，构造函数体中是先开辟空间，然后进行赋值。而初始化列表中开辟内存和初始化是同时进行的</p>\n<p>引用和const都是不能被赋值的，所以只能放到初始化列表中 </p>\n"},{"_content":"### 1. 三种智能指针\n\n`shared_ptr`允许多个指针指向同一个对象\n\n`unique_ptr`独占所指向的对象\n\n`weak_ptr`是一种弱引用\n\n这三种类型都定义在`memory`头文件\n\n类似于`vector`，智能指针也是模板，需要在**尖括号**中提供“指针可以指向的类型”信息\n\n```cpp\nshared_ptr<string> p1;\nshared_ptr<list<int>> p2;\n```\n\n默认初始化的智能指针中保存着一个空指针，解引用一个智能指针返回它所指向的对象\n\n```cpp\nif(p1 && p1->empty())   // 判断 p1 是不是空（指向一个空指针），如果 p1 不为空，则它指向一个 string，调用 string 的 empty 函数判断这个 string 是不是个空字符串\n    *p1 = \"hi\";   // 如果 p1 指向一个空字符串，则解引用 p1，将一个新值赋予 p1\n```\n\n`shared_ptr`和`unique_ptr`都支持的操作（表12.1）：\n\n![image-20211221163543360](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211221163543360.png)\n\n`shared_ptr`独有的操作（表12.2）：\n\n![image-20211221163802706](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211221163802706.png)\n\n### 2. `make_shared`函数\n\n此函数在动态内存中分配一个对象并初始化它，<u>返回指向此对象的`shared_ptr`</u>，`make_shared`同样定义在`memory`头文件中\n\n```cpp\nshared_ptr<int> p3 = make_shared<int>(42);   // 指向一个值为 42 的 int 的 shared_ptr\nshared_ptr<string> p4 = make_shared<string>(10, '9');  // p4 指向一个值为\"999999999\"的string\nshared_ptr<int> p5 = make_shared<int>(); \t\t\t   // p5 指向一个值初始化的int\n```\n\n类似于顺序容器的`emplace`，`make_shared`用它的参数来**构造**给定类型的对象，例如，调用`make_shared<string>`时传递的参数必须与`string`的某个构造函数相匹配，如果不传递参数，就会**值初始化**\n\n利用`auto`：\n\n```cpp\nauto p6 = make_shared<vector<string>>();\t\t// p6指向一个动态分配的空vector<string>\n```\n\n### 3. 和`new`结合使用\n\n可以用 `new` 返回的指针来初始化智能指针\n\n```cpp\nshared_ptr<int> p2(new int(42));   \t\t\t\t// p2 指向一个值为 42 的 int\n```\n\n 接受指针参数的智能指针的构造函数是 explicit 的，因此，**不能**将一个**内置指针隐式转换**为一个智能指针，必须使用**直接初始化**形式来初始化一个智能指针\n\n```cpp\nshared_ptr<int> p1 = new int(1024); \t\t\t// 错误，无法隐式转换，必须使用直接初始化的形式\nshared_ptr<int> p2(new int(1024));\t\t\t\t// 正确，直接初始化\n```\n\n```cpp\nshared_ptr<int> clone(int p) {\n    return new int(p);\t\t\t\t\t\t\t// 错误，不能隐式转换\n    return shared_ptr<int>(new int(p));\t\t\t// 正确\n}\n```\n\n### 4. shared_ptr的引用计数\n\n每个 `shared_ptr` 都有一个关联的计数器，无论何时我们**拷贝**一个 `shared_ptr`，计数器都会递增。\n\n```cpp\nauto p = make_shared<int>(42); \t\t\t\t// p 指向的对象只有 p 一个引用者\nauto q(p);\t\t\t\t\t\t\t\t\t// p 和 q 指向相同的对象，此对象有两个引用者\n```\n\n这三种情况都会使计数器**递增**：\n\n1. 用一个 `shared_ptr` 初始化另一个 `shared_ptr`\n2. 将它作为参数传递给一个函数\n3. 作为函数的返回值\n\n当我们给 `shared_ptr` 赋予一个新值，或是 `shared_ptr` 被销毁，计数器就会**递减**\n\n一旦一个 `shared_ptr` 的计数器变为 0，它就会**自动释放**自己所管理的对象\n\n```cpp\nauto r = make_shared<int>(42);  \t\t// r 指向的 int 只有一个引用者\nr = q; \t\t\t\t\t\t\t\t\t// 递减 r 原来指向的对象的引用计数，r 原来所指向的对象已经没有引用者，会自动释放\n\t\t\t\t\t\t\t\t\t\t// 递增 q 指向的对象的引用计数\n```\n\n`shared_ptr` 常用成员函数：\n\n- use_count()\n- reset()\n- release()\n\n### 5. weak_ptr\n\n`weak_ptr` 用来解决 `shared_ptr` 相互引用时的死锁问题，如果两个 `shared_ptr` 相互引用，那么这两个指针的引用计数永远不可能下降为 0，资源永远不会释放\n\n`weak_ptr` 是对对象的一种弱引用，不会增加对象的引用计数\n\n死锁举例：\n\n```cpp\nclass B;\nclass A\n{\npublic:\n    shared_ptr<B> pb_;\n    ~A()\n    {\n        cout<<\"A delete\\n\";\n    }\n};\nclass B\n{\npublic:\n    shared_ptr<A> pa_;\n    ~B()\n    {\n        cout<<\"B delete\\n\";\n    }\n};\n \nvoid fun()\n{\n    shared_ptr<B> pb(new B());    // 指向 B 的智能指针\n    shared_ptr<A> pa(new A());\t  // 指向 A 的智能指针\n    pb->pa_ = pa;\n    pa->pb_ = pb;\n    cout<<pb.use_count()<<endl;\n    cout<<pa.use_count()<<endl;\n}\n \nint main()\n{\n    fun();\n    return 0;\n}\n```\n\n![image-20211225170641418](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211225170641418.png)\n\n`fun` 函数中 `pa`，`pb` 之间互相引用，两个资源的引用计数为 `2`，当要跳出函数时，智能指针 `pa`，`pb` 析构时两个资源引用计数会减一，但是两者引用计数还是为 `1`，导致跳出函数时资源没有被释放（A，B的析构函数没有被调用），如果把其中一个改为 `weak_ptr` 就可以了，我们把类 A 里面的 `shared_ptr<B> pb_ ;` 改为 `weak_ptr<B> pb_;` \n\n这样的话，资源 B 的引用开始就只有 1，当 `pb` 析构时，B 的计数变为 0，B 得到释放，B 释放的同时也会使 A 的计数减一，同时 pa 析构时使 A 的计数减一，那么 A 的计数为0，A 得到释放。\n\n### 6. 简单实现一个 `shared_ptr`\n\n","source":"_posts/C++/C++11/智能指针.md","raw":"### 1. 三种智能指针\n\n`shared_ptr`允许多个指针指向同一个对象\n\n`unique_ptr`独占所指向的对象\n\n`weak_ptr`是一种弱引用\n\n这三种类型都定义在`memory`头文件\n\n类似于`vector`，智能指针也是模板，需要在**尖括号**中提供“指针可以指向的类型”信息\n\n```cpp\nshared_ptr<string> p1;\nshared_ptr<list<int>> p2;\n```\n\n默认初始化的智能指针中保存着一个空指针，解引用一个智能指针返回它所指向的对象\n\n```cpp\nif(p1 && p1->empty())   // 判断 p1 是不是空（指向一个空指针），如果 p1 不为空，则它指向一个 string，调用 string 的 empty 函数判断这个 string 是不是个空字符串\n    *p1 = \"hi\";   // 如果 p1 指向一个空字符串，则解引用 p1，将一个新值赋予 p1\n```\n\n`shared_ptr`和`unique_ptr`都支持的操作（表12.1）：\n\n![image-20211221163543360](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211221163543360.png)\n\n`shared_ptr`独有的操作（表12.2）：\n\n![image-20211221163802706](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211221163802706.png)\n\n### 2. `make_shared`函数\n\n此函数在动态内存中分配一个对象并初始化它，<u>返回指向此对象的`shared_ptr`</u>，`make_shared`同样定义在`memory`头文件中\n\n```cpp\nshared_ptr<int> p3 = make_shared<int>(42);   // 指向一个值为 42 的 int 的 shared_ptr\nshared_ptr<string> p4 = make_shared<string>(10, '9');  // p4 指向一个值为\"999999999\"的string\nshared_ptr<int> p5 = make_shared<int>(); \t\t\t   // p5 指向一个值初始化的int\n```\n\n类似于顺序容器的`emplace`，`make_shared`用它的参数来**构造**给定类型的对象，例如，调用`make_shared<string>`时传递的参数必须与`string`的某个构造函数相匹配，如果不传递参数，就会**值初始化**\n\n利用`auto`：\n\n```cpp\nauto p6 = make_shared<vector<string>>();\t\t// p6指向一个动态分配的空vector<string>\n```\n\n### 3. 和`new`结合使用\n\n可以用 `new` 返回的指针来初始化智能指针\n\n```cpp\nshared_ptr<int> p2(new int(42));   \t\t\t\t// p2 指向一个值为 42 的 int\n```\n\n 接受指针参数的智能指针的构造函数是 explicit 的，因此，**不能**将一个**内置指针隐式转换**为一个智能指针，必须使用**直接初始化**形式来初始化一个智能指针\n\n```cpp\nshared_ptr<int> p1 = new int(1024); \t\t\t// 错误，无法隐式转换，必须使用直接初始化的形式\nshared_ptr<int> p2(new int(1024));\t\t\t\t// 正确，直接初始化\n```\n\n```cpp\nshared_ptr<int> clone(int p) {\n    return new int(p);\t\t\t\t\t\t\t// 错误，不能隐式转换\n    return shared_ptr<int>(new int(p));\t\t\t// 正确\n}\n```\n\n### 4. shared_ptr的引用计数\n\n每个 `shared_ptr` 都有一个关联的计数器，无论何时我们**拷贝**一个 `shared_ptr`，计数器都会递增。\n\n```cpp\nauto p = make_shared<int>(42); \t\t\t\t// p 指向的对象只有 p 一个引用者\nauto q(p);\t\t\t\t\t\t\t\t\t// p 和 q 指向相同的对象，此对象有两个引用者\n```\n\n这三种情况都会使计数器**递增**：\n\n1. 用一个 `shared_ptr` 初始化另一个 `shared_ptr`\n2. 将它作为参数传递给一个函数\n3. 作为函数的返回值\n\n当我们给 `shared_ptr` 赋予一个新值，或是 `shared_ptr` 被销毁，计数器就会**递减**\n\n一旦一个 `shared_ptr` 的计数器变为 0，它就会**自动释放**自己所管理的对象\n\n```cpp\nauto r = make_shared<int>(42);  \t\t// r 指向的 int 只有一个引用者\nr = q; \t\t\t\t\t\t\t\t\t// 递减 r 原来指向的对象的引用计数，r 原来所指向的对象已经没有引用者，会自动释放\n\t\t\t\t\t\t\t\t\t\t// 递增 q 指向的对象的引用计数\n```\n\n`shared_ptr` 常用成员函数：\n\n- use_count()\n- reset()\n- release()\n\n### 5. weak_ptr\n\n`weak_ptr` 用来解决 `shared_ptr` 相互引用时的死锁问题，如果两个 `shared_ptr` 相互引用，那么这两个指针的引用计数永远不可能下降为 0，资源永远不会释放\n\n`weak_ptr` 是对对象的一种弱引用，不会增加对象的引用计数\n\n死锁举例：\n\n```cpp\nclass B;\nclass A\n{\npublic:\n    shared_ptr<B> pb_;\n    ~A()\n    {\n        cout<<\"A delete\\n\";\n    }\n};\nclass B\n{\npublic:\n    shared_ptr<A> pa_;\n    ~B()\n    {\n        cout<<\"B delete\\n\";\n    }\n};\n \nvoid fun()\n{\n    shared_ptr<B> pb(new B());    // 指向 B 的智能指针\n    shared_ptr<A> pa(new A());\t  // 指向 A 的智能指针\n    pb->pa_ = pa;\n    pa->pb_ = pb;\n    cout<<pb.use_count()<<endl;\n    cout<<pa.use_count()<<endl;\n}\n \nint main()\n{\n    fun();\n    return 0;\n}\n```\n\n![image-20211225170641418](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211225170641418.png)\n\n`fun` 函数中 `pa`，`pb` 之间互相引用，两个资源的引用计数为 `2`，当要跳出函数时，智能指针 `pa`，`pb` 析构时两个资源引用计数会减一，但是两者引用计数还是为 `1`，导致跳出函数时资源没有被释放（A，B的析构函数没有被调用），如果把其中一个改为 `weak_ptr` 就可以了，我们把类 A 里面的 `shared_ptr<B> pb_ ;` 改为 `weak_ptr<B> pb_;` \n\n这样的话，资源 B 的引用开始就只有 1，当 `pb` 析构时，B 的计数变为 0，B 得到释放，B 释放的同时也会使 A 的计数减一，同时 pa 析构时使 A 的计数减一，那么 A 的计数为0，A 得到释放。\n\n### 6. 简单实现一个 `shared_ptr`\n\n","slug":"C++/C++11/智能指针","published":1,"date":"2021-12-31T02:09:01.533Z","updated":"2022-03-29T11:43:07.079Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0kxk000vpcu374x0c5m8","content":"<h3 id=\"1-三种智能指针\"><a href=\"#1-三种智能指针\" class=\"headerlink\" title=\"1. 三种智能指针\"></a>1. 三种智能指针</h3><p><code>shared_ptr</code>允许多个指针指向同一个对象</p>\n<p><code>unique_ptr</code>独占所指向的对象</p>\n<p><code>weak_ptr</code>是一种弱引用</p>\n<p>这三种类型都定义在<code>memory</code>头文件</p>\n<p>类似于<code>vector</code>，智能指针也是模板，需要在<strong>尖括号</strong>中提供“指针可以指向的类型”信息</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shared_ptr&lt;string&gt; p1;</span><br><span class=\"line\">shared_ptr&lt;list&lt;<span class=\"keyword\">int</span>&gt;&gt; p2;</span><br></pre></td></tr></table></figure>\n\n<p>默认初始化的智能指针中保存着一个空指针，解引用一个智能指针返回它所指向的对象</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(p1 &amp;&amp; p1-&gt;<span class=\"built_in\">empty</span>())   <span class=\"comment\">// 判断 p1 是不是空（指向一个空指针），如果 p1 不为空，则它指向一个 string，调用 string 的 empty 函数判断这个 string 是不是个空字符串</span></span><br><span class=\"line\">    *p1 = <span class=\"string\">&quot;hi&quot;</span>;   <span class=\"comment\">// 如果 p1 指向一个空字符串，则解引用 p1，将一个新值赋予 p1</span></span><br></pre></td></tr></table></figure>\n\n<p><code>shared_ptr</code>和<code>unique_ptr</code>都支持的操作（表12.1）：</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211221163543360.png\" alt=\"image-20211221163543360\"></p>\n<p><code>shared_ptr</code>独有的操作（表12.2）：</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211221163802706.png\" alt=\"image-20211221163802706\"></p>\n<h3 id=\"2-make-shared函数\"><a href=\"#2-make-shared函数\" class=\"headerlink\" title=\"2. make_shared函数\"></a>2. <code>make_shared</code>函数</h3><p>此函数在动态内存中分配一个对象并初始化它，<u>返回指向此对象的<code>shared_ptr</code></u>，<code>make_shared</code>同样定义在<code>memory</code>头文件中</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shared_ptr&lt;<span class=\"keyword\">int</span>&gt; p3 = make_shared&lt;<span class=\"keyword\">int</span>&gt;(<span class=\"number\">42</span>);   <span class=\"comment\">// 指向一个值为 42 的 int 的 shared_ptr</span></span><br><span class=\"line\">shared_ptr&lt;string&gt; p4 = make_shared&lt;string&gt;(<span class=\"number\">10</span>, <span class=\"string\">&#x27;9&#x27;</span>);  <span class=\"comment\">// p4 指向一个值为&quot;999999999&quot;的string</span></span><br><span class=\"line\">shared_ptr&lt;<span class=\"keyword\">int</span>&gt; p5 = make_shared&lt;<span class=\"keyword\">int</span>&gt;(); \t\t\t   <span class=\"comment\">// p5 指向一个值初始化的int</span></span><br></pre></td></tr></table></figure>\n\n<p>类似于顺序容器的<code>emplace</code>，<code>make_shared</code>用它的参数来<strong>构造</strong>给定类型的对象，例如，调用<code>make_shared&lt;string&gt;</code>时传递的参数必须与<code>string</code>的某个构造函数相匹配，如果不传递参数，就会<strong>值初始化</strong></p>\n<p>利用<code>auto</code>：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> p6 = make_shared&lt;vector&lt;string&gt;&gt;();\t\t<span class=\"comment\">// p6指向一个动态分配的空vector&lt;string&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-和new结合使用\"><a href=\"#3-和new结合使用\" class=\"headerlink\" title=\"3. 和new结合使用\"></a>3. 和<code>new</code>结合使用</h3><p>可以用 <code>new</code> 返回的指针来初始化智能指针</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">shared_ptr&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">p2</span><span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"number\">42</span>))</span></span>;   \t\t\t\t<span class=\"comment\">// p2 指向一个值为 42 的 int</span></span><br></pre></td></tr></table></figure>\n\n<p> 接受指针参数的智能指针的构造函数是 explicit 的，因此，<strong>不能</strong>将一个<strong>内置指针隐式转换</strong>为一个智能指针，必须使用<strong>直接初始化</strong>形式来初始化一个智能指针</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shared_ptr&lt;<span class=\"keyword\">int</span>&gt; p1 = <span class=\"keyword\">new</span> <span class=\"built_in\"><span class=\"keyword\">int</span></span>(<span class=\"number\">1024</span>); \t\t\t<span class=\"comment\">// 错误，无法隐式转换，必须使用直接初始化的形式</span></span><br><span class=\"line\"><span class=\"function\">shared_ptr&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">p2</span><span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"number\">1024</span>))</span></span>;\t\t\t\t<span class=\"comment\">// 正确，直接初始化</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">shared_ptr&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">clone</span><span class=\"params\">(<span class=\"keyword\">int</span> p)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\"><span class=\"keyword\">int</span></span>(p);\t\t\t\t\t\t\t<span class=\"comment\">// 错误，不能隐式转换</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> shared_ptr&lt;<span class=\"keyword\">int</span>&gt;(<span class=\"keyword\">new</span> <span class=\"built_in\"><span class=\"keyword\">int</span></span>(p));\t\t\t<span class=\"comment\">// 正确</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-shared-ptr的引用计数\"><a href=\"#4-shared-ptr的引用计数\" class=\"headerlink\" title=\"4. shared_ptr的引用计数\"></a>4. shared_ptr的引用计数</h3><p>每个 <code>shared_ptr</code> 都有一个关联的计数器，无论何时我们<strong>拷贝</strong>一个 <code>shared_ptr</code>，计数器都会递增。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> p = make_shared&lt;<span class=\"keyword\">int</span>&gt;(<span class=\"number\">42</span>); \t\t\t\t<span class=\"comment\">// p 指向的对象只有 p 一个引用者</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">auto</span> <span class=\"title\">q</span><span class=\"params\">(p)</span></span>;\t\t\t\t\t\t\t\t\t<span class=\"comment\">// p 和 q 指向相同的对象，此对象有两个引用者</span></span><br></pre></td></tr></table></figure>\n\n<p>这三种情况都会使计数器<strong>递增</strong>：</p>\n<ol>\n<li>用一个 <code>shared_ptr</code> 初始化另一个 <code>shared_ptr</code></li>\n<li>将它作为参数传递给一个函数</li>\n<li>作为函数的返回值</li>\n</ol>\n<p>当我们给 <code>shared_ptr</code> 赋予一个新值，或是 <code>shared_ptr</code> 被销毁，计数器就会<strong>递减</strong></p>\n<p>一旦一个 <code>shared_ptr</code> 的计数器变为 0，它就会<strong>自动释放</strong>自己所管理的对象</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> r = make_shared&lt;<span class=\"keyword\">int</span>&gt;(<span class=\"number\">42</span>);  \t\t<span class=\"comment\">// r 指向的 int 只有一个引用者</span></span><br><span class=\"line\">r = q; \t\t\t\t\t\t\t\t\t<span class=\"comment\">// 递减 r 原来指向的对象的引用计数，r 原来所指向的对象已经没有引用者，会自动释放</span></span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">// 递增 q 指向的对象的引用计数</span></span><br></pre></td></tr></table></figure>\n\n<p><code>shared_ptr</code> 常用成员函数：</p>\n<ul>\n<li>use_count()</li>\n<li>reset()</li>\n<li>release()</li>\n</ul>\n<h3 id=\"5-weak-ptr\"><a href=\"#5-weak-ptr\" class=\"headerlink\" title=\"5. weak_ptr\"></a>5. weak_ptr</h3><p><code>weak_ptr</code> 用来解决 <code>shared_ptr</code> 相互引用时的死锁问题，如果两个 <code>shared_ptr</code> 相互引用，那么这两个指针的引用计数永远不可能下降为 0，资源永远不会释放</p>\n<p><code>weak_ptr</code> 是对对象的一种弱引用，不会增加对象的引用计数</p>\n<p>死锁举例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    shared_ptr&lt;B&gt; pb_;</span><br><span class=\"line\">    ~<span class=\"built_in\">A</span>()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;A delete\\n&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    shared_ptr&lt;A&gt; pa_;</span><br><span class=\"line\">    ~<span class=\"built_in\">B</span>()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;B delete\\n&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fun</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">shared_ptr&lt;B&gt; <span class=\"title\">pb</span><span class=\"params\">(<span class=\"keyword\">new</span> B())</span></span>;    <span class=\"comment\">// 指向 B 的智能指针</span></span><br><span class=\"line\">    <span class=\"function\">shared_ptr&lt;A&gt; <span class=\"title\">pa</span><span class=\"params\">(<span class=\"keyword\">new</span> A())</span></span>;\t  <span class=\"comment\">// 指向 A 的智能指针</span></span><br><span class=\"line\">    pb-&gt;pa_ = pa;</span><br><span class=\"line\">    pa-&gt;pb_ = pb;</span><br><span class=\"line\">    cout&lt;&lt;pb.<span class=\"built_in\">use_count</span>()&lt;&lt;endl;</span><br><span class=\"line\">    cout&lt;&lt;pa.<span class=\"built_in\">use_count</span>()&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">fun</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211225170641418.png\" alt=\"image-20211225170641418\"></p>\n<p><code>fun</code> 函数中 <code>pa</code>，<code>pb</code> 之间互相引用，两个资源的引用计数为 <code>2</code>，当要跳出函数时，智能指针 <code>pa</code>，<code>pb</code> 析构时两个资源引用计数会减一，但是两者引用计数还是为 <code>1</code>，导致跳出函数时资源没有被释放（A，B的析构函数没有被调用），如果把其中一个改为 <code>weak_ptr</code> 就可以了，我们把类 A 里面的 <code>shared_ptr&lt;B&gt; pb_ ;</code> 改为 <code>weak_ptr&lt;B&gt; pb_;</code> </p>\n<p>这样的话，资源 B 的引用开始就只有 1，当 <code>pb</code> 析构时，B 的计数变为 0，B 得到释放，B 释放的同时也会使 A 的计数减一，同时 pa 析构时使 A 的计数减一，那么 A 的计数为0，A 得到释放。</p>\n<h3 id=\"6-简单实现一个-shared-ptr\"><a href=\"#6-简单实现一个-shared-ptr\" class=\"headerlink\" title=\"6. 简单实现一个 shared_ptr\"></a>6. 简单实现一个 <code>shared_ptr</code></h3>","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<h3 id=\"1-三种智能指针\"><a href=\"#1-三种智能指针\" class=\"headerlink\" title=\"1. 三种智能指针\"></a>1. 三种智能指针</h3><p><code>shared_ptr</code>允许多个指针指向同一个对象</p>\n<p><code>unique_ptr</code>独占所指向的对象</p>\n<p><code>weak_ptr</code>是一种弱引用</p>\n<p>这三种类型都定义在<code>memory</code>头文件</p>\n<p>类似于<code>vector</code>，智能指针也是模板，需要在<strong>尖括号</strong>中提供“指针可以指向的类型”信息</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shared_ptr&lt;string&gt; p1;</span><br><span class=\"line\">shared_ptr&lt;list&lt;<span class=\"keyword\">int</span>&gt;&gt; p2;</span><br></pre></td></tr></table></figure>\n\n<p>默认初始化的智能指针中保存着一个空指针，解引用一个智能指针返回它所指向的对象</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(p1 &amp;&amp; p1-&gt;<span class=\"built_in\">empty</span>())   <span class=\"comment\">// 判断 p1 是不是空（指向一个空指针），如果 p1 不为空，则它指向一个 string，调用 string 的 empty 函数判断这个 string 是不是个空字符串</span></span><br><span class=\"line\">    *p1 = <span class=\"string\">&quot;hi&quot;</span>;   <span class=\"comment\">// 如果 p1 指向一个空字符串，则解引用 p1，将一个新值赋予 p1</span></span><br></pre></td></tr></table></figure>\n\n<p><code>shared_ptr</code>和<code>unique_ptr</code>都支持的操作（表12.1）：</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211221163543360.png\" alt=\"image-20211221163543360\"></p>\n<p><code>shared_ptr</code>独有的操作（表12.2）：</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211221163802706.png\" alt=\"image-20211221163802706\"></p>\n<h3 id=\"2-make-shared函数\"><a href=\"#2-make-shared函数\" class=\"headerlink\" title=\"2. make_shared函数\"></a>2. <code>make_shared</code>函数</h3><p>此函数在动态内存中分配一个对象并初始化它，<u>返回指向此对象的<code>shared_ptr</code></u>，<code>make_shared</code>同样定义在<code>memory</code>头文件中</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shared_ptr&lt;<span class=\"keyword\">int</span>&gt; p3 = make_shared&lt;<span class=\"keyword\">int</span>&gt;(<span class=\"number\">42</span>);   <span class=\"comment\">// 指向一个值为 42 的 int 的 shared_ptr</span></span><br><span class=\"line\">shared_ptr&lt;string&gt; p4 = make_shared&lt;string&gt;(<span class=\"number\">10</span>, <span class=\"string\">&#x27;9&#x27;</span>);  <span class=\"comment\">// p4 指向一个值为&quot;999999999&quot;的string</span></span><br><span class=\"line\">shared_ptr&lt;<span class=\"keyword\">int</span>&gt; p5 = make_shared&lt;<span class=\"keyword\">int</span>&gt;(); \t\t\t   <span class=\"comment\">// p5 指向一个值初始化的int</span></span><br></pre></td></tr></table></figure>\n\n<p>类似于顺序容器的<code>emplace</code>，<code>make_shared</code>用它的参数来<strong>构造</strong>给定类型的对象，例如，调用<code>make_shared&lt;string&gt;</code>时传递的参数必须与<code>string</code>的某个构造函数相匹配，如果不传递参数，就会<strong>值初始化</strong></p>\n<p>利用<code>auto</code>：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> p6 = make_shared&lt;vector&lt;string&gt;&gt;();\t\t<span class=\"comment\">// p6指向一个动态分配的空vector&lt;string&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-和new结合使用\"><a href=\"#3-和new结合使用\" class=\"headerlink\" title=\"3. 和new结合使用\"></a>3. 和<code>new</code>结合使用</h3><p>可以用 <code>new</code> 返回的指针来初始化智能指针</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">shared_ptr&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">p2</span><span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"number\">42</span>))</span></span>;   \t\t\t\t<span class=\"comment\">// p2 指向一个值为 42 的 int</span></span><br></pre></td></tr></table></figure>\n\n<p> 接受指针参数的智能指针的构造函数是 explicit 的，因此，<strong>不能</strong>将一个<strong>内置指针隐式转换</strong>为一个智能指针，必须使用<strong>直接初始化</strong>形式来初始化一个智能指针</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shared_ptr&lt;<span class=\"keyword\">int</span>&gt; p1 = <span class=\"keyword\">new</span> <span class=\"built_in\"><span class=\"keyword\">int</span></span>(<span class=\"number\">1024</span>); \t\t\t<span class=\"comment\">// 错误，无法隐式转换，必须使用直接初始化的形式</span></span><br><span class=\"line\"><span class=\"function\">shared_ptr&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">p2</span><span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"number\">1024</span>))</span></span>;\t\t\t\t<span class=\"comment\">// 正确，直接初始化</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">shared_ptr&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">clone</span><span class=\"params\">(<span class=\"keyword\">int</span> p)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\"><span class=\"keyword\">int</span></span>(p);\t\t\t\t\t\t\t<span class=\"comment\">// 错误，不能隐式转换</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> shared_ptr&lt;<span class=\"keyword\">int</span>&gt;(<span class=\"keyword\">new</span> <span class=\"built_in\"><span class=\"keyword\">int</span></span>(p));\t\t\t<span class=\"comment\">// 正确</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-shared-ptr的引用计数\"><a href=\"#4-shared-ptr的引用计数\" class=\"headerlink\" title=\"4. shared_ptr的引用计数\"></a>4. shared_ptr的引用计数</h3><p>每个 <code>shared_ptr</code> 都有一个关联的计数器，无论何时我们<strong>拷贝</strong>一个 <code>shared_ptr</code>，计数器都会递增。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> p = make_shared&lt;<span class=\"keyword\">int</span>&gt;(<span class=\"number\">42</span>); \t\t\t\t<span class=\"comment\">// p 指向的对象只有 p 一个引用者</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">auto</span> <span class=\"title\">q</span><span class=\"params\">(p)</span></span>;\t\t\t\t\t\t\t\t\t<span class=\"comment\">// p 和 q 指向相同的对象，此对象有两个引用者</span></span><br></pre></td></tr></table></figure>\n\n<p>这三种情况都会使计数器<strong>递增</strong>：</p>\n<ol>\n<li>用一个 <code>shared_ptr</code> 初始化另一个 <code>shared_ptr</code></li>\n<li>将它作为参数传递给一个函数</li>\n<li>作为函数的返回值</li>\n</ol>\n<p>当我们给 <code>shared_ptr</code> 赋予一个新值，或是 <code>shared_ptr</code> 被销毁，计数器就会<strong>递减</strong></p>\n<p>一旦一个 <code>shared_ptr</code> 的计数器变为 0，它就会<strong>自动释放</strong>自己所管理的对象</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> r = make_shared&lt;<span class=\"keyword\">int</span>&gt;(<span class=\"number\">42</span>);  \t\t<span class=\"comment\">// r 指向的 int 只有一个引用者</span></span><br><span class=\"line\">r = q; \t\t\t\t\t\t\t\t\t<span class=\"comment\">// 递减 r 原来指向的对象的引用计数，r 原来所指向的对象已经没有引用者，会自动释放</span></span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">// 递增 q 指向的对象的引用计数</span></span><br></pre></td></tr></table></figure>\n\n<p><code>shared_ptr</code> 常用成员函数：</p>\n<ul>\n<li>use_count()</li>\n<li>reset()</li>\n<li>release()</li>\n</ul>\n<h3 id=\"5-weak-ptr\"><a href=\"#5-weak-ptr\" class=\"headerlink\" title=\"5. weak_ptr\"></a>5. weak_ptr</h3><p><code>weak_ptr</code> 用来解决 <code>shared_ptr</code> 相互引用时的死锁问题，如果两个 <code>shared_ptr</code> 相互引用，那么这两个指针的引用计数永远不可能下降为 0，资源永远不会释放</p>\n<p><code>weak_ptr</code> 是对对象的一种弱引用，不会增加对象的引用计数</p>\n<p>死锁举例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    shared_ptr&lt;B&gt; pb_;</span><br><span class=\"line\">    ~<span class=\"built_in\">A</span>()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;A delete\\n&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    shared_ptr&lt;A&gt; pa_;</span><br><span class=\"line\">    ~<span class=\"built_in\">B</span>()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;B delete\\n&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fun</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">shared_ptr&lt;B&gt; <span class=\"title\">pb</span><span class=\"params\">(<span class=\"keyword\">new</span> B())</span></span>;    <span class=\"comment\">// 指向 B 的智能指针</span></span><br><span class=\"line\">    <span class=\"function\">shared_ptr&lt;A&gt; <span class=\"title\">pa</span><span class=\"params\">(<span class=\"keyword\">new</span> A())</span></span>;\t  <span class=\"comment\">// 指向 A 的智能指针</span></span><br><span class=\"line\">    pb-&gt;pa_ = pa;</span><br><span class=\"line\">    pa-&gt;pb_ = pb;</span><br><span class=\"line\">    cout&lt;&lt;pb.<span class=\"built_in\">use_count</span>()&lt;&lt;endl;</span><br><span class=\"line\">    cout&lt;&lt;pa.<span class=\"built_in\">use_count</span>()&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">fun</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211225170641418.png\" alt=\"image-20211225170641418\"></p>\n<p><code>fun</code> 函数中 <code>pa</code>，<code>pb</code> 之间互相引用，两个资源的引用计数为 <code>2</code>，当要跳出函数时，智能指针 <code>pa</code>，<code>pb</code> 析构时两个资源引用计数会减一，但是两者引用计数还是为 <code>1</code>，导致跳出函数时资源没有被释放（A，B的析构函数没有被调用），如果把其中一个改为 <code>weak_ptr</code> 就可以了，我们把类 A 里面的 <code>shared_ptr&lt;B&gt; pb_ ;</code> 改为 <code>weak_ptr&lt;B&gt; pb_;</code> </p>\n<p>这样的话，资源 B 的引用开始就只有 1，当 <code>pb</code> 析构时，B 的计数变为 0，B 得到释放，B 释放的同时也会使 A 的计数减一，同时 pa 析构时使 A 的计数减一，那么 A 的计数为0，A 得到释放。</p>\n<h3 id=\"6-简单实现一个-shared-ptr\"><a href=\"#6-简单实现一个-shared-ptr\" class=\"headerlink\" title=\"6. 简单实现一个 shared_ptr\"></a>6. 简单实现一个 <code>shared_ptr</code></h3>"},{"_content":"# 1. C++移动语义的前世今生\n\n## 1.1 浅拷贝与深拷贝\n\n深拷贝可以解决浅拷贝中会产生的悬挂指针的问题，但也增大了开销。默认的拷贝构造函数执行的是浅拷贝，需要自己实现深拷贝的拷贝构造函数。\n\n## 1.2 临时对象\n\n在某些情况下，一些依赖于深拷贝的临时对象的产生与销毁会带来一些不必要的开销，为了解决这个问题，引入移动语义\n\n## 1.3 左值、右值与右值引用\n\n左值：有名字，能取地址\n\n右值：没有名字，没有地址，一些临时量，lambda表达式\n\n![6FED5766DA66F67A18C061E3A45686DF](https://raw.githubusercontent.com/Vio1ette/blog-img/main/6FED5766DA66F67A18C061E3A45686DF.png)\n\n## 1.4 std::move\n\n面试题：移动语义是先浅拷贝，再将被拷贝过的指针置空，如果是这样的话，那么仅仅定义一个普通的函数也可以做到这一点（先浅拷贝指针，然后再将被拷贝过的指针置空），那么移动语义存在的意义是什么？\n\n> 为什么要将源对象的指针置空？\n>\n> 要防止源对象析构时对其指针进行delete操作把移动后的不属于它的资源给释放掉了\n\n首先，移动语义要解决的问题是<u>临时对象的重复拷贝、销毁所带来的额外开销</u>，所以其函数参数是<u>右值引用</u>，仅接受右值作为传入参数，而是拷贝构造函数的常量左值引用\n\n> 拷贝构造函数和移动构造函数同时存在的话，如果参数为右值，将会优先调用移动构造函数\n\n<u>常量左值引用可以接受右值（临时对象），可以实现这个移动语义</u>。但如果把拷贝构造函数实现为移动语义就相当于所有（临时/非临时）资源都会进行移动，而非深拷贝，这完全消灭了深拷贝。深拷贝时，对新分配的内存空间进行操作不会影响到源内存空间，这是移动语义做不到的，所以不能完全消灭深拷贝\n\n移动构造函数只接受非常量右值，对临时资源的移动是需要的，但是对于非临时资源，深拷贝是需要的\n","source":"_posts/C++/C++11/移动语义.md","raw":"# 1. C++移动语义的前世今生\n\n## 1.1 浅拷贝与深拷贝\n\n深拷贝可以解决浅拷贝中会产生的悬挂指针的问题，但也增大了开销。默认的拷贝构造函数执行的是浅拷贝，需要自己实现深拷贝的拷贝构造函数。\n\n## 1.2 临时对象\n\n在某些情况下，一些依赖于深拷贝的临时对象的产生与销毁会带来一些不必要的开销，为了解决这个问题，引入移动语义\n\n## 1.3 左值、右值与右值引用\n\n左值：有名字，能取地址\n\n右值：没有名字，没有地址，一些临时量，lambda表达式\n\n![6FED5766DA66F67A18C061E3A45686DF](https://raw.githubusercontent.com/Vio1ette/blog-img/main/6FED5766DA66F67A18C061E3A45686DF.png)\n\n## 1.4 std::move\n\n面试题：移动语义是先浅拷贝，再将被拷贝过的指针置空，如果是这样的话，那么仅仅定义一个普通的函数也可以做到这一点（先浅拷贝指针，然后再将被拷贝过的指针置空），那么移动语义存在的意义是什么？\n\n> 为什么要将源对象的指针置空？\n>\n> 要防止源对象析构时对其指针进行delete操作把移动后的不属于它的资源给释放掉了\n\n首先，移动语义要解决的问题是<u>临时对象的重复拷贝、销毁所带来的额外开销</u>，所以其函数参数是<u>右值引用</u>，仅接受右值作为传入参数，而是拷贝构造函数的常量左值引用\n\n> 拷贝构造函数和移动构造函数同时存在的话，如果参数为右值，将会优先调用移动构造函数\n\n<u>常量左值引用可以接受右值（临时对象），可以实现这个移动语义</u>。但如果把拷贝构造函数实现为移动语义就相当于所有（临时/非临时）资源都会进行移动，而非深拷贝，这完全消灭了深拷贝。深拷贝时，对新分配的内存空间进行操作不会影响到源内存空间，这是移动语义做不到的，所以不能完全消灭深拷贝\n\n移动构造函数只接受非常量右值，对临时资源的移动是需要的，但是对于非临时资源，深拷贝是需要的\n","slug":"C++/C++11/移动语义","published":1,"date":"2022-03-25T13:40:09.509Z","updated":"2022-05-12T11:50:27.791Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0kxm000zpcu350m1fo6o","content":"<h1 id=\"1-C-移动语义的前世今生\"><a href=\"#1-C-移动语义的前世今生\" class=\"headerlink\" title=\"1. C++移动语义的前世今生\"></a>1. C++移动语义的前世今生</h1><h2 id=\"1-1-浅拷贝与深拷贝\"><a href=\"#1-1-浅拷贝与深拷贝\" class=\"headerlink\" title=\"1.1 浅拷贝与深拷贝\"></a>1.1 浅拷贝与深拷贝</h2><p>深拷贝可以解决浅拷贝中会产生的悬挂指针的问题，但也增大了开销。默认的拷贝构造函数执行的是浅拷贝，需要自己实现深拷贝的拷贝构造函数。</p>\n<h2 id=\"1-2-临时对象\"><a href=\"#1-2-临时对象\" class=\"headerlink\" title=\"1.2 临时对象\"></a>1.2 临时对象</h2><p>在某些情况下，一些依赖于深拷贝的临时对象的产生与销毁会带来一些不必要的开销，为了解决这个问题，引入移动语义</p>\n<h2 id=\"1-3-左值、右值与右值引用\"><a href=\"#1-3-左值、右值与右值引用\" class=\"headerlink\" title=\"1.3 左值、右值与右值引用\"></a>1.3 左值、右值与右值引用</h2><p>左值：有名字，能取地址</p>\n<p>右值：没有名字，没有地址，一些临时量，lambda表达式</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/6FED5766DA66F67A18C061E3A45686DF.png\" alt=\"6FED5766DA66F67A18C061E3A45686DF\"></p>\n<h2 id=\"1-4-std-move\"><a href=\"#1-4-std-move\" class=\"headerlink\" title=\"1.4 std::move\"></a>1.4 std::move</h2><p>面试题：移动语义是先浅拷贝，再将被拷贝过的指针置空，如果是这样的话，那么仅仅定义一个普通的函数也可以做到这一点（先浅拷贝指针，然后再将被拷贝过的指针置空），那么移动语义存在的意义是什么？</p>\n<blockquote>\n<p>为什么要将源对象的指针置空？</p>\n<p>要防止源对象析构时对其指针进行delete操作把移动后的不属于它的资源给释放掉了</p>\n</blockquote>\n<p>首先，移动语义要解决的问题是<u>临时对象的重复拷贝、销毁所带来的额外开销</u>，所以其函数参数是<u>右值引用</u>，仅接受右值作为传入参数，而是拷贝构造函数的常量左值引用</p>\n<blockquote>\n<p>拷贝构造函数和移动构造函数同时存在的话，如果参数为右值，将会优先调用移动构造函数</p>\n</blockquote>\n<p><u>常量左值引用可以接受右值（临时对象），可以实现这个移动语义</u>。但如果把拷贝构造函数实现为移动语义就相当于所有（临时/非临时）资源都会进行移动，而非深拷贝，这完全消灭了深拷贝。深拷贝时，对新分配的内存空间进行操作不会影响到源内存空间，这是移动语义做不到的，所以不能完全消灭深拷贝</p>\n<p>移动构造函数只接受非常量右值，对临时资源的移动是需要的，但是对于非临时资源，深拷贝是需要的</p>\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<h1 id=\"1-C-移动语义的前世今生\"><a href=\"#1-C-移动语义的前世今生\" class=\"headerlink\" title=\"1. C++移动语义的前世今生\"></a>1. C++移动语义的前世今生</h1><h2 id=\"1-1-浅拷贝与深拷贝\"><a href=\"#1-1-浅拷贝与深拷贝\" class=\"headerlink\" title=\"1.1 浅拷贝与深拷贝\"></a>1.1 浅拷贝与深拷贝</h2><p>深拷贝可以解决浅拷贝中会产生的悬挂指针的问题，但也增大了开销。默认的拷贝构造函数执行的是浅拷贝，需要自己实现深拷贝的拷贝构造函数。</p>\n<h2 id=\"1-2-临时对象\"><a href=\"#1-2-临时对象\" class=\"headerlink\" title=\"1.2 临时对象\"></a>1.2 临时对象</h2><p>在某些情况下，一些依赖于深拷贝的临时对象的产生与销毁会带来一些不必要的开销，为了解决这个问题，引入移动语义</p>\n<h2 id=\"1-3-左值、右值与右值引用\"><a href=\"#1-3-左值、右值与右值引用\" class=\"headerlink\" title=\"1.3 左值、右值与右值引用\"></a>1.3 左值、右值与右值引用</h2><p>左值：有名字，能取地址</p>\n<p>右值：没有名字，没有地址，一些临时量，lambda表达式</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/6FED5766DA66F67A18C061E3A45686DF.png\" alt=\"6FED5766DA66F67A18C061E3A45686DF\"></p>\n<h2 id=\"1-4-std-move\"><a href=\"#1-4-std-move\" class=\"headerlink\" title=\"1.4 std::move\"></a>1.4 std::move</h2><p>面试题：移动语义是先浅拷贝，再将被拷贝过的指针置空，如果是这样的话，那么仅仅定义一个普通的函数也可以做到这一点（先浅拷贝指针，然后再将被拷贝过的指针置空），那么移动语义存在的意义是什么？</p>\n<blockquote>\n<p>为什么要将源对象的指针置空？</p>\n<p>要防止源对象析构时对其指针进行delete操作把移动后的不属于它的资源给释放掉了</p>\n</blockquote>\n<p>首先，移动语义要解决的问题是<u>临时对象的重复拷贝、销毁所带来的额外开销</u>，所以其函数参数是<u>右值引用</u>，仅接受右值作为传入参数，而是拷贝构造函数的常量左值引用</p>\n<blockquote>\n<p>拷贝构造函数和移动构造函数同时存在的话，如果参数为右值，将会优先调用移动构造函数</p>\n</blockquote>\n<p><u>常量左值引用可以接受右值（临时对象），可以实现这个移动语义</u>。但如果把拷贝构造函数实现为移动语义就相当于所有（临时/非临时）资源都会进行移动，而非深拷贝，这完全消灭了深拷贝。深拷贝时，对新分配的内存空间进行操作不会影响到源内存空间，这是移动语义做不到的，所以不能完全消灭深拷贝</p>\n<p>移动构造函数只接受非常量右值，对临时资源的移动是需要的，但是对于非临时资源，深拷贝是需要的</p>\n"},{"_content":"inline\n\n将函数标记为内联函数，如果成功内联，在运行时就可以避免函数调用所产生的开销，但过多的内联会导致代码碰撞\n\ninline和宏函数的区别\n\n1. 宏函数在预编译阶段进行展开，而inline是在编译阶段\n2. 宏函数有可能会产生歧义，且相比inline缺少类型检测\n3. inline只是对编译器的一个内联建议，不一定真正内联\n4. ","source":"_posts/C++/C++基础/inline.md","raw":"inline\n\n将函数标记为内联函数，如果成功内联，在运行时就可以避免函数调用所产生的开销，但过多的内联会导致代码碰撞\n\ninline和宏函数的区别\n\n1. 宏函数在预编译阶段进行展开，而inline是在编译阶段\n2. 宏函数有可能会产生歧义，且相比inline缺少类型检测\n3. inline只是对编译器的一个内联建议，不一定真正内联\n4. ","slug":"C++/C++基础/inline","published":1,"date":"2022-05-03T07:10:35.638Z","updated":"2022-05-03T07:28:00.736Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0kxn0010pcu372f46jeb","content":"<p>inline</p>\n<p>将函数标记为内联函数，如果成功内联，在运行时就可以避免函数调用所产生的开销，但过多的内联会导致代码碰撞</p>\n<p>inline和宏函数的区别</p>\n<ol>\n<li>宏函数在预编译阶段进行展开，而inline是在编译阶段</li>\n<li>宏函数有可能会产生歧义，且相比inline缺少类型检测</li>\n<li>inline只是对编译器的一个内联建议，不一定真正内联</li>\n<li></li>\n</ol>\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<p>inline</p>\n<p>将函数标记为内联函数，如果成功内联，在运行时就可以避免函数调用所产生的开销，但过多的内联会导致代码碰撞</p>\n<p>inline和宏函数的区别</p>\n<ol>\n<li>宏函数在预编译阶段进行展开，而inline是在编译阶段</li>\n<li>宏函数有可能会产生歧义，且相比inline缺少类型检测</li>\n<li>inline只是对编译器的一个内联建议，不一定真正内联</li>\n<li></li>\n</ol>\n"},{"_content":"##### 1. 对于每个数据成员\n\n如果数据成员类型的长度为$M$，指定的（默认）对齐值为$N$，则实际的对齐值为$q=min(M,N)$，成员的开始地址必须为`q`的倍数\n\n##### 2. 结构体整体大小\n\n每个数据成员的内存分配完成后，检查结构体整体的大小是否为$r=min(max(M),N)$的整数倍，`r`是最大数据成员的大小和结构体默认对齐值中的较小者\n\n> C++中可用#pragma_pack(N)调整默认对齐值\n\n##### 3. 结构体中存在数组\n\n数组的对齐值为单个数组元素的对齐值，而不是数组的整体大小\n\n```cpp\nstruct {\n  char c;\n  char ary[4];\n  short s;\n};\n```\n\n假设默认对齐值比所有数据成员都大。c占1字节，ary数组元素类型为char，其对齐值为1字节，所以c和ary一共占5字节，short的对齐值为2字节，其开始地址必须为2的倍数，所以需要在ary后插入1字节的对齐数据，再安放short s。现在结构体总共占8字节，而结构体中最大的数据类型为short，即2字节，8是2的倍数，所以不需要再对齐了。\n\n##### 4. 嵌套结构体\n\n跟数组类似，嵌套结构体的对齐值跟结构体整体大小无关，而是上面提到过的`r`\n\n```cpp\nstruct sstOne{\n  char c;\t\t//1字节\n  char ary[4];  //5字节\n  short s;  \t//2字节\n};\nstruct stTwo{\n  int n; \t\t//4字节\n  stOne one;    //占用8字节，对齐值为2字节\n};\n```\n\n","source":"_posts/C++/C++基础/内存对齐.md","raw":"##### 1. 对于每个数据成员\n\n如果数据成员类型的长度为$M$，指定的（默认）对齐值为$N$，则实际的对齐值为$q=min(M,N)$，成员的开始地址必须为`q`的倍数\n\n##### 2. 结构体整体大小\n\n每个数据成员的内存分配完成后，检查结构体整体的大小是否为$r=min(max(M),N)$的整数倍，`r`是最大数据成员的大小和结构体默认对齐值中的较小者\n\n> C++中可用#pragma_pack(N)调整默认对齐值\n\n##### 3. 结构体中存在数组\n\n数组的对齐值为单个数组元素的对齐值，而不是数组的整体大小\n\n```cpp\nstruct {\n  char c;\n  char ary[4];\n  short s;\n};\n```\n\n假设默认对齐值比所有数据成员都大。c占1字节，ary数组元素类型为char，其对齐值为1字节，所以c和ary一共占5字节，short的对齐值为2字节，其开始地址必须为2的倍数，所以需要在ary后插入1字节的对齐数据，再安放short s。现在结构体总共占8字节，而结构体中最大的数据类型为short，即2字节，8是2的倍数，所以不需要再对齐了。\n\n##### 4. 嵌套结构体\n\n跟数组类似，嵌套结构体的对齐值跟结构体整体大小无关，而是上面提到过的`r`\n\n```cpp\nstruct sstOne{\n  char c;\t\t//1字节\n  char ary[4];  //5字节\n  short s;  \t//2字节\n};\nstruct stTwo{\n  int n; \t\t//4字节\n  stOne one;    //占用8字节，对齐值为2字节\n};\n```\n\n","slug":"C++/C++基础/内存对齐","published":1,"date":"2022-04-28T05:01:28.606Z","updated":"2022-04-28T06:40:28.562Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0kxo0013pcu3gny91uuc","content":"<h5 id=\"1-对于每个数据成员\"><a href=\"#1-对于每个数据成员\" class=\"headerlink\" title=\"1. 对于每个数据成员\"></a>1. 对于每个数据成员</h5><p>如果数据成员类型的长度为$M$，指定的（默认）对齐值为$N$，则实际的对齐值为$q=min(M,N)$，成员的开始地址必须为<code>q</code>的倍数</p>\n<h5 id=\"2-结构体整体大小\"><a href=\"#2-结构体整体大小\" class=\"headerlink\" title=\"2. 结构体整体大小\"></a>2. 结构体整体大小</h5><p>每个数据成员的内存分配完成后，检查结构体整体的大小是否为$r=min(max(M),N)$的整数倍，<code>r</code>是最大数据成员的大小和结构体默认对齐值中的较小者</p>\n<blockquote>\n<p>C++中可用#pragma_pack(N)调整默认对齐值</p>\n</blockquote>\n<h5 id=\"3-结构体中存在数组\"><a href=\"#3-结构体中存在数组\" class=\"headerlink\" title=\"3. 结构体中存在数组\"></a>3. 结构体中存在数组</h5><p>数组的对齐值为单个数组元素的对齐值，而不是数组的整体大小</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span> c;</span><br><span class=\"line\">  <span class=\"keyword\">char</span> ary[<span class=\"number\">4</span>];</span><br><span class=\"line\">  <span class=\"keyword\">short</span> s;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>假设默认对齐值比所有数据成员都大。c占1字节，ary数组元素类型为char，其对齐值为1字节，所以c和ary一共占5字节，short的对齐值为2字节，其开始地址必须为2的倍数，所以需要在ary后插入1字节的对齐数据，再安放short s。现在结构体总共占8字节，而结构体中最大的数据类型为short，即2字节，8是2的倍数，所以不需要再对齐了。</p>\n<h5 id=\"4-嵌套结构体\"><a href=\"#4-嵌套结构体\" class=\"headerlink\" title=\"4. 嵌套结构体\"></a>4. 嵌套结构体</h5><p>跟数组类似，嵌套结构体的对齐值跟结构体整体大小无关，而是上面提到过的<code>r</code></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sstOne</span>&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span> c;\t\t<span class=\"comment\">//1字节</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span> ary[<span class=\"number\">4</span>];  <span class=\"comment\">//5字节</span></span><br><span class=\"line\">  <span class=\"keyword\">short</span> s;  \t<span class=\"comment\">//2字节</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">stTwo</span>&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> n; \t\t<span class=\"comment\">//4字节</span></span><br><span class=\"line\">  stOne one;    <span class=\"comment\">//占用8字节，对齐值为2字节</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<h5 id=\"1-对于每个数据成员\"><a href=\"#1-对于每个数据成员\" class=\"headerlink\" title=\"1. 对于每个数据成员\"></a>1. 对于每个数据成员</h5><p>如果数据成员类型的长度为$M$，指定的（默认）对齐值为$N$，则实际的对齐值为$q=min(M,N)$，成员的开始地址必须为<code>q</code>的倍数</p>\n<h5 id=\"2-结构体整体大小\"><a href=\"#2-结构体整体大小\" class=\"headerlink\" title=\"2. 结构体整体大小\"></a>2. 结构体整体大小</h5><p>每个数据成员的内存分配完成后，检查结构体整体的大小是否为$r=min(max(M),N)$的整数倍，<code>r</code>是最大数据成员的大小和结构体默认对齐值中的较小者</p>\n<blockquote>\n<p>C++中可用#pragma_pack(N)调整默认对齐值</p>\n</blockquote>\n<h5 id=\"3-结构体中存在数组\"><a href=\"#3-结构体中存在数组\" class=\"headerlink\" title=\"3. 结构体中存在数组\"></a>3. 结构体中存在数组</h5><p>数组的对齐值为单个数组元素的对齐值，而不是数组的整体大小</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span> c;</span><br><span class=\"line\">  <span class=\"keyword\">char</span> ary[<span class=\"number\">4</span>];</span><br><span class=\"line\">  <span class=\"keyword\">short</span> s;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>假设默认对齐值比所有数据成员都大。c占1字节，ary数组元素类型为char，其对齐值为1字节，所以c和ary一共占5字节，short的对齐值为2字节，其开始地址必须为2的倍数，所以需要在ary后插入1字节的对齐数据，再安放short s。现在结构体总共占8字节，而结构体中最大的数据类型为short，即2字节，8是2的倍数，所以不需要再对齐了。</p>\n<h5 id=\"4-嵌套结构体\"><a href=\"#4-嵌套结构体\" class=\"headerlink\" title=\"4. 嵌套结构体\"></a>4. 嵌套结构体</h5><p>跟数组类似，嵌套结构体的对齐值跟结构体整体大小无关，而是上面提到过的<code>r</code></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sstOne</span>&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span> c;\t\t<span class=\"comment\">//1字节</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span> ary[<span class=\"number\">4</span>];  <span class=\"comment\">//5字节</span></span><br><span class=\"line\">  <span class=\"keyword\">short</span> s;  \t<span class=\"comment\">//2字节</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">stTwo</span>&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> n; \t\t<span class=\"comment\">//4字节</span></span><br><span class=\"line\">  stOne one;    <span class=\"comment\">//占用8字节，对齐值为2字节</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n"},{"_content":"函数调用栈帧解析\n\n%ebp是栈底指针，%esp是栈顶指针\n\n调用一个函数时，首先会将参数压栈，然后将返回地址压栈，\n\n调用指令：\n\n```assembly\ncall label; \n```","source":"_posts/C++/C++基础/函数调用栈帧解析.md","raw":"函数调用栈帧解析\n\n%ebp是栈底指针，%esp是栈顶指针\n\n调用一个函数时，首先会将参数压栈，然后将返回地址压栈，\n\n调用指令：\n\n```assembly\ncall label; \n```","slug":"C++/C++基础/函数调用栈帧解析","published":1,"date":"2022-04-27T11:57:29.630Z","updated":"2022-04-28T07:23:30.449Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0kxp0014pcu3c9w9f93c","content":"<p>函数调用栈帧解析</p>\n<p>%ebp是栈底指针，%esp是栈顶指针</p>\n<p>调用一个函数时，首先会将参数压栈，然后将返回地址压栈，</p>\n<p>调用指令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">call label; </span><br></pre></td></tr></table></figure>","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<p>函数调用栈帧解析</p>\n<p>%ebp是栈底指针，%esp是栈顶指针</p>\n<p>调用一个函数时，首先会将参数压栈，然后将返回地址压栈，</p>\n<p>调用指令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">call label; </span><br></pre></td></tr></table></figure>"},{"_content":"### 1. 声明和定义的关系\n\n声明使得<u>名字</u>为程序所知，规定了变量的类型和名字，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明\n\n定义负责<u>创建</u>与名字关联的<u>实体</u>，声明规定了变量的类型和名字，在这一点上定义与之相同。但除此之外，<u>定义还负责申请存储空间</u>，也可能会为变量赋一个初始值。\n\n如果想<u>单独声明</u>一个变量，而<u>不定义</u>它，就在变量名前添加关键字<u>extern</u>，而且<u>不要显示地初始化</u>变量\n\n```cpp\nextern int i;  //声明i而非定义i\nint j;  \t   //声明并定义j，此处虽然没有显示初始化，但已经为j分配内存了\n```\n\n定义有两种写法，第一是不加extern，第二是显示初始化，任何包含了显示初始化的声明即成为定义，即使有extern存在\n\n```cpp\nextern double pi = 3.14;   //定义\n```\n\n> <u>在函数体内部，如果试图初始化一个由extern关键字标记的变量，将引发错误</u>，extern定义的变量必须是全局的，这样才可能在其他文件中使用，所以不能再语句块里定义\n\n### 2. extern\n\n如果要在多个文件中使用外部（全局）变量，只需要在一个文件中包含该变量的定义（单定义规则），但在**使用该变量的其他所有文件中**，都必须使用关键字`extern`声明它：\n\n```cpp\n//file01.cpp\nextern int cats = 20; //定义\nint dogs = 22; \t\t  //定义\nint fleas;\t\t  \t  //还是定义，默认初始化为0\n```\n\n```cpp\n// file02.cpp\n// use cats and dogs from file01.cpp\n//非定义，仅声明\nextern int cats;\nextern int dogs;\n```\n\n```cpp\n//file98.cpp\n//use cats, dogs, and fleas from file01.cpp\nextern int cats;\nextern int dogs;\nextern int fleas;\n```\n\n> `file01.cpp` 中 `cats` 的`extern`是可以省略的，效果一样\n\n### 2. 不能在函数体内部初始化一个`extern`变量\n\n![extern](D:\\Hugo\\Sites\\Puppy's\\static\\images\\extern-大型项目工程中使用全局变量\\image-20211101202636295.png)\n\n原因：[c++ - Why does initializing an extern variable inside a function give an error? - Stack Overflow](https://stackoverflow.com/questions/17090354/why-does-initializing-an-extern-variable-inside-a-function-give-an-error)\n\n`extern`变量告诉编译器，整个项目中的所有同名`symbol`，都指的是同一个`externally defined i`，所以如果允许在函数内初始化（定义）一个被`extern`标记的变量，就会有==多重定义==的风险\n\n例如：\n\n```cpp\n#include <iostream>\nusing namespace std;\n\nextern int i; // 同一个 externally defined i\nint i = 10;\nvoid test()\n{\n    std::cout << \"Hi\" << i << std::endl;\n}\n\nint main()\n{\n    extern int i; // 这个 extern 会影响到其作用域内的所有 i，但是会被局部 i 屏蔽\n    i++;\n    test();\n}\n```\n\n","source":"_posts/C++/C++基础/变量声明、定义，extern，外部链接，内部链接，静态链接.md","raw":"### 1. 声明和定义的关系\n\n声明使得<u>名字</u>为程序所知，规定了变量的类型和名字，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明\n\n定义负责<u>创建</u>与名字关联的<u>实体</u>，声明规定了变量的类型和名字，在这一点上定义与之相同。但除此之外，<u>定义还负责申请存储空间</u>，也可能会为变量赋一个初始值。\n\n如果想<u>单独声明</u>一个变量，而<u>不定义</u>它，就在变量名前添加关键字<u>extern</u>，而且<u>不要显示地初始化</u>变量\n\n```cpp\nextern int i;  //声明i而非定义i\nint j;  \t   //声明并定义j，此处虽然没有显示初始化，但已经为j分配内存了\n```\n\n定义有两种写法，第一是不加extern，第二是显示初始化，任何包含了显示初始化的声明即成为定义，即使有extern存在\n\n```cpp\nextern double pi = 3.14;   //定义\n```\n\n> <u>在函数体内部，如果试图初始化一个由extern关键字标记的变量，将引发错误</u>，extern定义的变量必须是全局的，这样才可能在其他文件中使用，所以不能再语句块里定义\n\n### 2. extern\n\n如果要在多个文件中使用外部（全局）变量，只需要在一个文件中包含该变量的定义（单定义规则），但在**使用该变量的其他所有文件中**，都必须使用关键字`extern`声明它：\n\n```cpp\n//file01.cpp\nextern int cats = 20; //定义\nint dogs = 22; \t\t  //定义\nint fleas;\t\t  \t  //还是定义，默认初始化为0\n```\n\n```cpp\n// file02.cpp\n// use cats and dogs from file01.cpp\n//非定义，仅声明\nextern int cats;\nextern int dogs;\n```\n\n```cpp\n//file98.cpp\n//use cats, dogs, and fleas from file01.cpp\nextern int cats;\nextern int dogs;\nextern int fleas;\n```\n\n> `file01.cpp` 中 `cats` 的`extern`是可以省略的，效果一样\n\n### 2. 不能在函数体内部初始化一个`extern`变量\n\n![extern](D:\\Hugo\\Sites\\Puppy's\\static\\images\\extern-大型项目工程中使用全局变量\\image-20211101202636295.png)\n\n原因：[c++ - Why does initializing an extern variable inside a function give an error? - Stack Overflow](https://stackoverflow.com/questions/17090354/why-does-initializing-an-extern-variable-inside-a-function-give-an-error)\n\n`extern`变量告诉编译器，整个项目中的所有同名`symbol`，都指的是同一个`externally defined i`，所以如果允许在函数内初始化（定义）一个被`extern`标记的变量，就会有==多重定义==的风险\n\n例如：\n\n```cpp\n#include <iostream>\nusing namespace std;\n\nextern int i; // 同一个 externally defined i\nint i = 10;\nvoid test()\n{\n    std::cout << \"Hi\" << i << std::endl;\n}\n\nint main()\n{\n    extern int i; // 这个 extern 会影响到其作用域内的所有 i，但是会被局部 i 屏蔽\n    i++;\n    test();\n}\n```\n\n","slug":"C++/C++基础/变量声明、定义，extern，外部链接，内部链接，静态链接","published":1,"date":"2021-12-31T02:09:01.467Z","updated":"2022-03-30T07:42:13.925Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0kxp0016pcu3938x081q","content":"<h3 id=\"1-声明和定义的关系\"><a href=\"#1-声明和定义的关系\" class=\"headerlink\" title=\"1. 声明和定义的关系\"></a>1. 声明和定义的关系</h3><p>声明使得<u>名字</u>为程序所知，规定了变量的类型和名字，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明</p>\n<p>定义负责<u>创建</u>与名字关联的<u>实体</u>，声明规定了变量的类型和名字，在这一点上定义与之相同。但除此之外，<u>定义还负责申请存储空间</u>，也可能会为变量赋一个初始值。</p>\n<p>如果想<u>单独声明</u>一个变量，而<u>不定义</u>它，就在变量名前添加关键字<u>extern</u>，而且<u>不要显示地初始化</u>变量</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> i;  <span class=\"comment\">//声明i而非定义i</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> j;  \t   <span class=\"comment\">//声明并定义j，此处虽然没有显示初始化，但已经为j分配内存了</span></span><br></pre></td></tr></table></figure>\n\n<p>定义有两种写法，第一是不加extern，第二是显示初始化，任何包含了显示初始化的声明即成为定义，即使有extern存在</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">double</span> pi = <span class=\"number\">3.14</span>;   <span class=\"comment\">//定义</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><u>在函数体内部，如果试图初始化一个由extern关键字标记的变量，将引发错误</u>，extern定义的变量必须是全局的，这样才可能在其他文件中使用，所以不能再语句块里定义</p>\n</blockquote>\n<h3 id=\"2-extern\"><a href=\"#2-extern\" class=\"headerlink\" title=\"2. extern\"></a>2. extern</h3><p>如果要在多个文件中使用外部（全局）变量，只需要在一个文件中包含该变量的定义（单定义规则），但在<strong>使用该变量的其他所有文件中</strong>，都必须使用关键字<code>extern</code>声明它：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//file01.cpp</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> cats = <span class=\"number\">20</span>; <span class=\"comment\">//定义</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> dogs = <span class=\"number\">22</span>; \t\t  <span class=\"comment\">//定义</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> fleas;\t\t  \t  <span class=\"comment\">//还是定义，默认初始化为0</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// file02.cpp</span></span><br><span class=\"line\"><span class=\"comment\">// use cats and dogs from file01.cpp</span></span><br><span class=\"line\"><span class=\"comment\">//非定义，仅声明</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> cats;</span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> dogs;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//file98.cpp</span></span><br><span class=\"line\"><span class=\"comment\">//use cats, dogs, and fleas from file01.cpp</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> cats;</span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> dogs;</span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> fleas;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>file01.cpp</code> 中 <code>cats</code> 的<code>extern</code>是可以省略的，效果一样</p>\n</blockquote>\n<h3 id=\"2-不能在函数体内部初始化一个extern变量\"><a href=\"#2-不能在函数体内部初始化一个extern变量\" class=\"headerlink\" title=\"2. 不能在函数体内部初始化一个extern变量\"></a>2. 不能在函数体内部初始化一个<code>extern</code>变量</h3><p><img src=\"D:\\Hugo\\Sites\\Puppy's\\static\\images\\extern-大型项目工程中使用全局变量\\image-20211101202636295.png\" alt=\"extern\"></p>\n<p>原因：<a href=\"https://stackoverflow.com/questions/17090354/why-does-initializing-an-extern-variable-inside-a-function-give-an-error\">c++ - Why does initializing an extern variable inside a function give an error? - Stack Overflow</a></p>\n<p><code>extern</code>变量告诉编译器，整个项目中的所有同名<code>symbol</code>，都指的是同一个<code>externally defined i</code>，所以如果允许在函数内初始化（定义）一个被<code>extern</code>标记的变量，就会有==多重定义==的风险</p>\n<p>例如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> i; <span class=\"comment\">// 同一个 externally defined i</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Hi&quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> i; <span class=\"comment\">// 这个 extern 会影响到其作用域内的所有 i，但是会被局部 i 屏蔽</span></span><br><span class=\"line\">    i++;</span><br><span class=\"line\">    <span class=\"built_in\">test</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<h3 id=\"1-声明和定义的关系\"><a href=\"#1-声明和定义的关系\" class=\"headerlink\" title=\"1. 声明和定义的关系\"></a>1. 声明和定义的关系</h3><p>声明使得<u>名字</u>为程序所知，规定了变量的类型和名字，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明</p>\n<p>定义负责<u>创建</u>与名字关联的<u>实体</u>，声明规定了变量的类型和名字，在这一点上定义与之相同。但除此之外，<u>定义还负责申请存储空间</u>，也可能会为变量赋一个初始值。</p>\n<p>如果想<u>单独声明</u>一个变量，而<u>不定义</u>它，就在变量名前添加关键字<u>extern</u>，而且<u>不要显示地初始化</u>变量</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> i;  <span class=\"comment\">//声明i而非定义i</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> j;  \t   <span class=\"comment\">//声明并定义j，此处虽然没有显示初始化，但已经为j分配内存了</span></span><br></pre></td></tr></table></figure>\n\n<p>定义有两种写法，第一是不加extern，第二是显示初始化，任何包含了显示初始化的声明即成为定义，即使有extern存在</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">double</span> pi = <span class=\"number\">3.14</span>;   <span class=\"comment\">//定义</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><u>在函数体内部，如果试图初始化一个由extern关键字标记的变量，将引发错误</u>，extern定义的变量必须是全局的，这样才可能在其他文件中使用，所以不能再语句块里定义</p>\n</blockquote>\n<h3 id=\"2-extern\"><a href=\"#2-extern\" class=\"headerlink\" title=\"2. extern\"></a>2. extern</h3><p>如果要在多个文件中使用外部（全局）变量，只需要在一个文件中包含该变量的定义（单定义规则），但在<strong>使用该变量的其他所有文件中</strong>，都必须使用关键字<code>extern</code>声明它：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//file01.cpp</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> cats = <span class=\"number\">20</span>; <span class=\"comment\">//定义</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> dogs = <span class=\"number\">22</span>; \t\t  <span class=\"comment\">//定义</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> fleas;\t\t  \t  <span class=\"comment\">//还是定义，默认初始化为0</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// file02.cpp</span></span><br><span class=\"line\"><span class=\"comment\">// use cats and dogs from file01.cpp</span></span><br><span class=\"line\"><span class=\"comment\">//非定义，仅声明</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> cats;</span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> dogs;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//file98.cpp</span></span><br><span class=\"line\"><span class=\"comment\">//use cats, dogs, and fleas from file01.cpp</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> cats;</span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> dogs;</span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> fleas;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>file01.cpp</code> 中 <code>cats</code> 的<code>extern</code>是可以省略的，效果一样</p>\n</blockquote>\n<h3 id=\"2-不能在函数体内部初始化一个extern变量\"><a href=\"#2-不能在函数体内部初始化一个extern变量\" class=\"headerlink\" title=\"2. 不能在函数体内部初始化一个extern变量\"></a>2. 不能在函数体内部初始化一个<code>extern</code>变量</h3><p><img src=\"D:\\Hugo\\Sites\\Puppy's\\static\\images\\extern-大型项目工程中使用全局变量\\image-20211101202636295.png\" alt=\"extern\"></p>\n<p>原因：<a href=\"https://stackoverflow.com/questions/17090354/why-does-initializing-an-extern-variable-inside-a-function-give-an-error\">c++ - Why does initializing an extern variable inside a function give an error? - Stack Overflow</a></p>\n<p><code>extern</code>变量告诉编译器，整个项目中的所有同名<code>symbol</code>，都指的是同一个<code>externally defined i</code>，所以如果允许在函数内初始化（定义）一个被<code>extern</code>标记的变量，就会有==多重定义==的风险</p>\n<p>例如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> i; <span class=\"comment\">// 同一个 externally defined i</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Hi&quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> i; <span class=\"comment\">// 这个 extern 会影响到其作用域内的所有 i，但是会被局部 i 屏蔽</span></span><br><span class=\"line\">    i++;</span><br><span class=\"line\">    <span class=\"built_in\">test</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"_content":"数组名和指针的区别\n\n```cpp\nint a = 0;\nint* p = &a;\nint c[] = {1,2,3};\n```\n\n1. 数组名是常量，不能进行自增自减操作，而指针可以\n\n2. 将数组名作为函数参数时，其会退化为一个指针\n\n   > 注意`sizeof`不是函数，而是操作符，所以`sizeof(c)`的值 = 元素个数*每个元素所占的字节大小\n   >\n   > 而`sizeof(p)`的值是固定的，32位机器上是4字节，64位机器上是8字节\n\n   \n\n   \n\n   ","source":"_posts/C++/C++基础/数组名和指针的区别.md","raw":"数组名和指针的区别\n\n```cpp\nint a = 0;\nint* p = &a;\nint c[] = {1,2,3};\n```\n\n1. 数组名是常量，不能进行自增自减操作，而指针可以\n\n2. 将数组名作为函数参数时，其会退化为一个指针\n\n   > 注意`sizeof`不是函数，而是操作符，所以`sizeof(c)`的值 = 元素个数*每个元素所占的字节大小\n   >\n   > 而`sizeof(p)`的值是固定的，32位机器上是4字节，64位机器上是8字节\n\n   \n\n   \n\n   ","slug":"C++/C++基础/数组名和指针的区别","published":1,"date":"2022-05-01T08:44:06.394Z","updated":"2022-05-01T08:44:08.372Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0kxt0017pcu37ny4hb7u","content":"<p>数组名和指针的区别</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span>* p = &amp;a;</span><br><span class=\"line\"><span class=\"keyword\">int</span> c[] = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>数组名是常量，不能进行自增自减操作，而指针可以</p>\n</li>\n<li><p>将数组名作为函数参数时，其会退化为一个指针</p>\n<blockquote>\n<p>注意<code>sizeof</code>不是函数，而是操作符，所以<code>sizeof(c)</code>的值 = 元素个数*每个元素所占的字节大小</p>\n<p>而<code>sizeof(p)</code>的值是固定的，32位机器上是4字节，64位机器上是8字节</p>\n</blockquote>\n</li>\n</ol>\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<p>数组名和指针的区别</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span>* p = &amp;a;</span><br><span class=\"line\"><span class=\"keyword\">int</span> c[] = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>数组名是常量，不能进行自增自减操作，而指针可以</p>\n</li>\n<li><p>将数组名作为函数参数时，其会退化为一个指针</p>\n<blockquote>\n<p>注意<code>sizeof</code>不是函数，而是操作符，所以<code>sizeof(c)</code>的值 = 元素个数*每个元素所占的字节大小</p>\n<p>而<code>sizeof(p)</code>的值是固定的，32位机器上是4字节，64位机器上是8字节</p>\n</blockquote>\n</li>\n</ol>\n"},{"_content":"编译过程\n\n1. 预处理阶段\n2. 编译阶段\n3. 汇编阶段\n4. 链接阶段\n\n#### 1. 预处理阶段\n\n处理所有#include、#define、条件编译、删除注释等\n\n#### 2. 编译阶段\n\n经过词法分析、语法分析、语义分析、优化后生成汇编代码\n\n##### 词法分析\n\n将源程序字符串分割为一个个Token，例如，标识符，操作符，常数\n\n##### 语法分析\n\n在词法分析的基础上，将Token串识别成语法单位，例如，赋值语句，算术表达式，生成<u>语法树</u>\n\n##### 语义分析\n\n分析语句的静态语义，例如类型匹配，算数语义\n\n##### 优化\n\n##### 生成汇编代码\n\n#### 3. 汇编阶段\n\n汇编器，将汇编代码转换为机器指令\n\n#### 4. 链接\n\n将一些库，链接到程序，分为静态链接和动态链接，最终生成可执行文件\n\n\n\n","source":"_posts/C++/C++基础/程序编译过程.md","raw":"编译过程\n\n1. 预处理阶段\n2. 编译阶段\n3. 汇编阶段\n4. 链接阶段\n\n#### 1. 预处理阶段\n\n处理所有#include、#define、条件编译、删除注释等\n\n#### 2. 编译阶段\n\n经过词法分析、语法分析、语义分析、优化后生成汇编代码\n\n##### 词法分析\n\n将源程序字符串分割为一个个Token，例如，标识符，操作符，常数\n\n##### 语法分析\n\n在词法分析的基础上，将Token串识别成语法单位，例如，赋值语句，算术表达式，生成<u>语法树</u>\n\n##### 语义分析\n\n分析语句的静态语义，例如类型匹配，算数语义\n\n##### 优化\n\n##### 生成汇编代码\n\n#### 3. 汇编阶段\n\n汇编器，将汇编代码转换为机器指令\n\n#### 4. 链接\n\n将一些库，链接到程序，分为静态链接和动态链接，最终生成可执行文件\n\n\n\n","slug":"C++/C++基础/程序编译过程","published":1,"date":"2022-05-02T03:03:15.964Z","updated":"2022-05-02T03:40:40.322Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0kxu0018pcu35a8tefjb","content":"<p>编译过程</p>\n<ol>\n<li>预处理阶段</li>\n<li>编译阶段</li>\n<li>汇编阶段</li>\n<li>链接阶段</li>\n</ol>\n<h4 id=\"1-预处理阶段\"><a href=\"#1-预处理阶段\" class=\"headerlink\" title=\"1. 预处理阶段\"></a>1. 预处理阶段</h4><p>处理所有#include、#define、条件编译、删除注释等</p>\n<h4 id=\"2-编译阶段\"><a href=\"#2-编译阶段\" class=\"headerlink\" title=\"2. 编译阶段\"></a>2. 编译阶段</h4><p>经过词法分析、语法分析、语义分析、优化后生成汇编代码</p>\n<h5 id=\"词法分析\"><a href=\"#词法分析\" class=\"headerlink\" title=\"词法分析\"></a>词法分析</h5><p>将源程序字符串分割为一个个Token，例如，标识符，操作符，常数</p>\n<h5 id=\"语法分析\"><a href=\"#语法分析\" class=\"headerlink\" title=\"语法分析\"></a>语法分析</h5><p>在词法分析的基础上，将Token串识别成语法单位，例如，赋值语句，算术表达式，生成<u>语法树</u></p>\n<h5 id=\"语义分析\"><a href=\"#语义分析\" class=\"headerlink\" title=\"语义分析\"></a>语义分析</h5><p>分析语句的静态语义，例如类型匹配，算数语义</p>\n<h5 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h5><h5 id=\"生成汇编代码\"><a href=\"#生成汇编代码\" class=\"headerlink\" title=\"生成汇编代码\"></a>生成汇编代码</h5><h4 id=\"3-汇编阶段\"><a href=\"#3-汇编阶段\" class=\"headerlink\" title=\"3. 汇编阶段\"></a>3. 汇编阶段</h4><p>汇编器，将汇编代码转换为机器指令</p>\n<h4 id=\"4-链接\"><a href=\"#4-链接\" class=\"headerlink\" title=\"4. 链接\"></a>4. 链接</h4><p>将一些库，链接到程序，分为静态链接和动态链接，最终生成可执行文件</p>\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<p>编译过程</p>\n<ol>\n<li>预处理阶段</li>\n<li>编译阶段</li>\n<li>汇编阶段</li>\n<li>链接阶段</li>\n</ol>\n<h4 id=\"1-预处理阶段\"><a href=\"#1-预处理阶段\" class=\"headerlink\" title=\"1. 预处理阶段\"></a>1. 预处理阶段</h4><p>处理所有#include、#define、条件编译、删除注释等</p>\n<h4 id=\"2-编译阶段\"><a href=\"#2-编译阶段\" class=\"headerlink\" title=\"2. 编译阶段\"></a>2. 编译阶段</h4><p>经过词法分析、语法分析、语义分析、优化后生成汇编代码</p>\n<h5 id=\"词法分析\"><a href=\"#词法分析\" class=\"headerlink\" title=\"词法分析\"></a>词法分析</h5><p>将源程序字符串分割为一个个Token，例如，标识符，操作符，常数</p>\n<h5 id=\"语法分析\"><a href=\"#语法分析\" class=\"headerlink\" title=\"语法分析\"></a>语法分析</h5><p>在词法分析的基础上，将Token串识别成语法单位，例如，赋值语句，算术表达式，生成<u>语法树</u></p>\n<h5 id=\"语义分析\"><a href=\"#语义分析\" class=\"headerlink\" title=\"语义分析\"></a>语义分析</h5><p>分析语句的静态语义，例如类型匹配，算数语义</p>\n<h5 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h5><h5 id=\"生成汇编代码\"><a href=\"#生成汇编代码\" class=\"headerlink\" title=\"生成汇编代码\"></a>生成汇编代码</h5><h4 id=\"3-汇编阶段\"><a href=\"#3-汇编阶段\" class=\"headerlink\" title=\"3. 汇编阶段\"></a>3. 汇编阶段</h4><p>汇编器，将汇编代码转换为机器指令</p>\n<h4 id=\"4-链接\"><a href=\"#4-链接\" class=\"headerlink\" title=\"4. 链接\"></a>4. 链接</h4><p>将一些库，链接到程序，分为静态链接和动态链接，最终生成可执行文件</p>\n"},{"_content":"new操作符的执行过程：\n\n1. 调用operator new分配内存（底层调用malloc()函数）\n2. 调用构造函数\n3. 返回相应类型的指针 \n\n#### delete\n\n操作符的执行过程：\n\n1. 调用析构函数\n2. 调用operator delete释放对象内存，底层调用free()函数\n\n调用析构函数只是释放对象管理的资源，而 operator delete 释放对象本身的资源。例如 vector 可能的内存布局如下：\n\n![image-20220519104008938](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220519104008938.png)\n\n栈中就是对象本身，而堆中就是 vector 对象管理的资源，析构函数释放的是堆资源，operator delete 释放的是栈资源\n\n​\t\n\ndelete this\n\ndelete this如果发生在析构函数中，delete会调用析构函数，析构函数中有会执行delete，则会导致无限循环，使栈内存溢出\n\ndelete this如果在普通函数中，则delete this之后不能再使用到成员资源（比如某个成员变量或者虚函数），否则就会报错\n\n","source":"_posts/C++/C++内存管理/new、delete.md","raw":"new操作符的执行过程：\n\n1. 调用operator new分配内存（底层调用malloc()函数）\n2. 调用构造函数\n3. 返回相应类型的指针 \n\n#### delete\n\n操作符的执行过程：\n\n1. 调用析构函数\n2. 调用operator delete释放对象内存，底层调用free()函数\n\n调用析构函数只是释放对象管理的资源，而 operator delete 释放对象本身的资源。例如 vector 可能的内存布局如下：\n\n![image-20220519104008938](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220519104008938.png)\n\n栈中就是对象本身，而堆中就是 vector 对象管理的资源，析构函数释放的是堆资源，operator delete 释放的是栈资源\n\n​\t\n\ndelete this\n\ndelete this如果发生在析构函数中，delete会调用析构函数，析构函数中有会执行delete，则会导致无限循环，使栈内存溢出\n\ndelete this如果在普通函数中，则delete this之后不能再使用到成员资源（比如某个成员变量或者虚函数），否则就会报错\n\n","slug":"C++/C++内存管理/new、delete","published":1,"date":"2022-05-05T12:14:48.235Z","updated":"2022-06-08T04:05:14.683Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0kxv0019pcu3053z46pu","content":"<p>new操作符的执行过程：</p>\n<ol>\n<li>调用operator new分配内存（底层调用malloc()函数）</li>\n<li>调用构造函数</li>\n<li>返回相应类型的指针 </li>\n</ol>\n<h4 id=\"delete\"><a href=\"#delete\" class=\"headerlink\" title=\"delete\"></a>delete</h4><p>操作符的执行过程：</p>\n<ol>\n<li>调用析构函数</li>\n<li>调用operator delete释放对象内存，底层调用free()函数</li>\n</ol>\n<p>调用析构函数只是释放对象管理的资源，而 operator delete 释放对象本身的资源。例如 vector 可能的内存布局如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220519104008938.png\" alt=\"image-20220519104008938\"></p>\n<p>栈中就是对象本身，而堆中就是 vector 对象管理的资源，析构函数释放的是堆资源，operator delete 释放的是栈资源</p>\n<p>​    </p>\n<p>delete this</p>\n<p>delete this如果发生在析构函数中，delete会调用析构函数，析构函数中有会执行delete，则会导致无限循环，使栈内存溢出</p>\n<p>delete this如果在普通函数中，则delete this之后不能再使用到成员资源（比如某个成员变量或者虚函数），否则就会报错</p>\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<p>new操作符的执行过程：</p>\n<ol>\n<li>调用operator new分配内存（底层调用malloc()函数）</li>\n<li>调用构造函数</li>\n<li>返回相应类型的指针 </li>\n</ol>\n<h4 id=\"delete\"><a href=\"#delete\" class=\"headerlink\" title=\"delete\"></a>delete</h4><p>操作符的执行过程：</p>\n<ol>\n<li>调用析构函数</li>\n<li>调用operator delete释放对象内存，底层调用free()函数</li>\n</ol>\n<p>调用析构函数只是释放对象管理的资源，而 operator delete 释放对象本身的资源。例如 vector 可能的内存布局如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220519104008938.png\" alt=\"image-20220519104008938\"></p>\n<p>栈中就是对象本身，而堆中就是 vector 对象管理的资源，析构函数释放的是堆资源，operator delete 释放的是栈资源</p>\n<p>​    </p>\n<p>delete this</p>\n<p>delete this如果发生在析构函数中，delete会调用析构函数，析构函数中有会执行delete，则会导致无限循环，使栈内存溢出</p>\n<p>delete this如果在普通函数中，则delete this之后不能再使用到成员资源（比如某个成员变量或者虚函数），否则就会报错</p>\n"},{"_content":"## 1. why？（背景）\n\n有了new/delete，malloc/free，为什么要还要用内存池？\n\n操作系统默认的内存管理函数的设计是<u>通用</u>的，为了维护通用性，会考虑许多情况下的内存分配方式，所以会有一些额外开销。而在具体的应用程序中，可以预先给应用程序一块适当大小的连续内存（内存池），然后<u>由应用程序自己来管理内存池</u>，仅当应用程序需要更多内存池时，才需要调用操作系统的内存分配函数。\n\n## 2. what？（原理）\n\n内存池是一块连续内存，可以分类为单线程内存池或多线程内存池，还可分类为固定内存池和可变内存池。\n\n固定内存池原理图：\n\n![QQ图片20220416112041](https://raw.githubusercontent.com/Vio1ette/blog-img/main/QQ%E5%9B%BE%E7%89%8720220416112041.jpg)\n\n内存池头指针指向应用程序申请的第一块内存池，后续申请的内存池也由链表连接，内存池块的大小固定，每一块内存池块包含一个块头和一些内存单元，使用某一块内存池时，根据其块头信息，查询空闲的内存单元，然后返回空闲单元的地址。\n\n内存池性能优化方面的优点：\n\n- 针对特殊情况，可以摒弃通用的内存分配算法和多线程保护\n- 一块内存池是连续的地址空间，所以增强了局部性\n- 没有内存碎片的问题\n\n## 3. how？（实现）\n\n","source":"_posts/C++/C++内存管理/内存池.md","raw":"## 1. why？（背景）\n\n有了new/delete，malloc/free，为什么要还要用内存池？\n\n操作系统默认的内存管理函数的设计是<u>通用</u>的，为了维护通用性，会考虑许多情况下的内存分配方式，所以会有一些额外开销。而在具体的应用程序中，可以预先给应用程序一块适当大小的连续内存（内存池），然后<u>由应用程序自己来管理内存池</u>，仅当应用程序需要更多内存池时，才需要调用操作系统的内存分配函数。\n\n## 2. what？（原理）\n\n内存池是一块连续内存，可以分类为单线程内存池或多线程内存池，还可分类为固定内存池和可变内存池。\n\n固定内存池原理图：\n\n![QQ图片20220416112041](https://raw.githubusercontent.com/Vio1ette/blog-img/main/QQ%E5%9B%BE%E7%89%8720220416112041.jpg)\n\n内存池头指针指向应用程序申请的第一块内存池，后续申请的内存池也由链表连接，内存池块的大小固定，每一块内存池块包含一个块头和一些内存单元，使用某一块内存池时，根据其块头信息，查询空闲的内存单元，然后返回空闲单元的地址。\n\n内存池性能优化方面的优点：\n\n- 针对特殊情况，可以摒弃通用的内存分配算法和多线程保护\n- 一块内存池是连续的地址空间，所以增强了局部性\n- 没有内存碎片的问题\n\n## 3. how？（实现）\n\n","slug":"C++/C++内存管理/内存池","published":1,"date":"2022-04-16T02:39:09.242Z","updated":"2022-04-18T00:54:41.813Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0kxv001apcu3b99949ta","content":"<h2 id=\"1-why？（背景）\"><a href=\"#1-why？（背景）\" class=\"headerlink\" title=\"1. why？（背景）\"></a>1. why？（背景）</h2><p>有了new/delete，malloc/free，为什么要还要用内存池？</p>\n<p>操作系统默认的内存管理函数的设计是<u>通用</u>的，为了维护通用性，会考虑许多情况下的内存分配方式，所以会有一些额外开销。而在具体的应用程序中，可以预先给应用程序一块适当大小的连续内存（内存池），然后<u>由应用程序自己来管理内存池</u>，仅当应用程序需要更多内存池时，才需要调用操作系统的内存分配函数。</p>\n<h2 id=\"2-what？（原理）\"><a href=\"#2-what？（原理）\" class=\"headerlink\" title=\"2. what？（原理）\"></a>2. what？（原理）</h2><p>内存池是一块连续内存，可以分类为单线程内存池或多线程内存池，还可分类为固定内存池和可变内存池。</p>\n<p>固定内存池原理图：</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/QQ%E5%9B%BE%E7%89%8720220416112041.jpg\" alt=\"QQ图片20220416112041\"></p>\n<p>内存池头指针指向应用程序申请的第一块内存池，后续申请的内存池也由链表连接，内存池块的大小固定，每一块内存池块包含一个块头和一些内存单元，使用某一块内存池时，根据其块头信息，查询空闲的内存单元，然后返回空闲单元的地址。</p>\n<p>内存池性能优化方面的优点：</p>\n<ul>\n<li>针对特殊情况，可以摒弃通用的内存分配算法和多线程保护</li>\n<li>一块内存池是连续的地址空间，所以增强了局部性</li>\n<li>没有内存碎片的问题</li>\n</ul>\n<h2 id=\"3-how？（实现）\"><a href=\"#3-how？（实现）\" class=\"headerlink\" title=\"3. how？（实现）\"></a>3. how？（实现）</h2>","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<h2 id=\"1-why？（背景）\"><a href=\"#1-why？（背景）\" class=\"headerlink\" title=\"1. why？（背景）\"></a>1. why？（背景）</h2><p>有了new/delete，malloc/free，为什么要还要用内存池？</p>\n<p>操作系统默认的内存管理函数的设计是<u>通用</u>的，为了维护通用性，会考虑许多情况下的内存分配方式，所以会有一些额外开销。而在具体的应用程序中，可以预先给应用程序一块适当大小的连续内存（内存池），然后<u>由应用程序自己来管理内存池</u>，仅当应用程序需要更多内存池时，才需要调用操作系统的内存分配函数。</p>\n<h2 id=\"2-what？（原理）\"><a href=\"#2-what？（原理）\" class=\"headerlink\" title=\"2. what？（原理）\"></a>2. what？（原理）</h2><p>内存池是一块连续内存，可以分类为单线程内存池或多线程内存池，还可分类为固定内存池和可变内存池。</p>\n<p>固定内存池原理图：</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/QQ%E5%9B%BE%E7%89%8720220416112041.jpg\" alt=\"QQ图片20220416112041\"></p>\n<p>内存池头指针指向应用程序申请的第一块内存池，后续申请的内存池也由链表连接，内存池块的大小固定，每一块内存池块包含一个块头和一些内存单元，使用某一块内存池时，根据其块头信息，查询空闲的内存单元，然后返回空闲单元的地址。</p>\n<p>内存池性能优化方面的优点：</p>\n<ul>\n<li>针对特殊情况，可以摒弃通用的内存分配算法和多线程保护</li>\n<li>一块内存池是连续的地址空间，所以增强了局部性</li>\n<li>没有内存碎片的问题</li>\n</ul>\n<h2 id=\"3-how？（实现）\"><a href=\"#3-how？（实现）\" class=\"headerlink\" title=\"3. how？（实现）\"></a>3. how？（实现）</h2>"},{"_content":"模板的实例化\n\n用具体类型取代模板类型参数的过程叫做“实例化”\n\n两阶段编译检查\n\n模板是被分两步编译的\n\n1. 模板定义阶段，模板的检查不包含类型参数的检查，只包含\n\n   - 语法检查\n\n2. 模板实例化阶段\n\n   ","source":"_posts/C++/C++模板/模板基础.md","raw":"模板的实例化\n\n用具体类型取代模板类型参数的过程叫做“实例化”\n\n两阶段编译检查\n\n模板是被分两步编译的\n\n1. 模板定义阶段，模板的检查不包含类型参数的检查，只包含\n\n   - 语法检查\n\n2. 模板实例化阶段\n\n   ","slug":"C++/C++模板/模板基础","published":1,"date":"2022-05-12T14:08:27.510Z","updated":"2022-05-12T14:13:34.956Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0kxw001bpcu3a8u5hc3g","content":"<p>模板的实例化</p>\n<p>用具体类型取代模板类型参数的过程叫做“实例化”</p>\n<p>两阶段编译检查</p>\n<p>模板是被分两步编译的</p>\n<ol>\n<li><p>模板定义阶段，模板的检查不包含类型参数的检查，只包含</p>\n<ul>\n<li>语法检查</li>\n</ul>\n</li>\n<li><p>模板实例化阶段</p>\n</li>\n</ol>\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<p>模板的实例化</p>\n<p>用具体类型取代模板类型参数的过程叫做“实例化”</p>\n<p>两阶段编译检查</p>\n<p>模板是被分两步编译的</p>\n<ol>\n<li><p>模板定义阶段，模板的检查不包含类型参数的检查，只包含</p>\n<ul>\n<li>语法检查</li>\n</ul>\n</li>\n<li><p>模板实例化阶段</p>\n</li>\n</ol>\n"},{"_content":"### 有序容器(map, set, multimap, multiset)自定义比较器\n\n#### 1. 函数指针\n\n```c++\nbool my_fun(const my_Class &a, const my_Class &b){\n    return a.length() < b.length();\n}\nint main(){\n    set<my_Class, decltype(my_fun)*> st(my_fun); // 构造函数的参数也可以写为 st(&my_fun)\n    return 0;\n}\n```\n\n> 定义 set 的第二个参数应该是函数指针\n\n```c++\ndecltype(my_fun)*  //decltype的结果仅仅是函数类型，只有加上 * 才能获得函数指针\n```\n\n用 `my_fun` 或 `&my_fun` 作为构造函数的参数\n\n> 对函数名来讲，加不加星号（都表示函数类型），取不取地址（都表示函数地址，函数指针类型），没区别\n\n#### 2. 仿函数\n\n#### 3. Lambda表达式\n\n","source":"_posts/C++/STL/自定义比较器.md","raw":"### 有序容器(map, set, multimap, multiset)自定义比较器\n\n#### 1. 函数指针\n\n```c++\nbool my_fun(const my_Class &a, const my_Class &b){\n    return a.length() < b.length();\n}\nint main(){\n    set<my_Class, decltype(my_fun)*> st(my_fun); // 构造函数的参数也可以写为 st(&my_fun)\n    return 0;\n}\n```\n\n> 定义 set 的第二个参数应该是函数指针\n\n```c++\ndecltype(my_fun)*  //decltype的结果仅仅是函数类型，只有加上 * 才能获得函数指针\n```\n\n用 `my_fun` 或 `&my_fun` 作为构造函数的参数\n\n> 对函数名来讲，加不加星号（都表示函数类型），取不取地址（都表示函数地址，函数指针类型），没区别\n\n#### 2. 仿函数\n\n#### 3. Lambda表达式\n\n","slug":"C++/STL/自定义比较器","published":1,"date":"2021-12-31T02:09:01.548Z","updated":"2021-11-13T11:43:11.375Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0kxx001cpcu3gti4g15r","content":"<h3 id=\"有序容器-map-set-multimap-multiset-自定义比较器\"><a href=\"#有序容器-map-set-multimap-multiset-自定义比较器\" class=\"headerlink\" title=\"有序容器(map, set, multimap, multiset)自定义比较器\"></a>有序容器(map, set, multimap, multiset)自定义比较器</h3><h4 id=\"1-函数指针\"><a href=\"#1-函数指针\" class=\"headerlink\" title=\"1. 函数指针\"></a>1. 函数指针</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">my_fun</span><span class=\"params\">(<span class=\"keyword\">const</span> my_Class &amp;a, <span class=\"keyword\">const</span> my_Class &amp;b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a.<span class=\"built_in\">length</span>() &lt; b.<span class=\"built_in\">length</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">set&lt;my_Class, <span class=\"title\">decltype</span><span class=\"params\">(my_fun)</span>*&gt; <span class=\"title\">st</span><span class=\"params\">(my_fun)</span></span>; <span class=\"comment\">// 构造函数的参数也可以写为 st(&amp;my_fun)</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>定义 set 的第二个参数应该是函数指针</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">decltype</span>(my_fun)*  <span class=\"comment\">//decltype的结果仅仅是函数类型，只有加上 * 才能获得函数指针</span></span><br></pre></td></tr></table></figure>\n\n<p>用 <code>my_fun</code> 或 <code>&amp;my_fun</code> 作为构造函数的参数</p>\n<blockquote>\n<p>对函数名来讲，加不加星号（都表示函数类型），取不取地址（都表示函数地址，函数指针类型），没区别</p>\n</blockquote>\n<h4 id=\"2-仿函数\"><a href=\"#2-仿函数\" class=\"headerlink\" title=\"2. 仿函数\"></a>2. 仿函数</h4><h4 id=\"3-Lambda表达式\"><a href=\"#3-Lambda表达式\" class=\"headerlink\" title=\"3. Lambda表达式\"></a>3. Lambda表达式</h4>","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<h3 id=\"有序容器-map-set-multimap-multiset-自定义比较器\"><a href=\"#有序容器-map-set-multimap-multiset-自定义比较器\" class=\"headerlink\" title=\"有序容器(map, set, multimap, multiset)自定义比较器\"></a>有序容器(map, set, multimap, multiset)自定义比较器</h3><h4 id=\"1-函数指针\"><a href=\"#1-函数指针\" class=\"headerlink\" title=\"1. 函数指针\"></a>1. 函数指针</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">my_fun</span><span class=\"params\">(<span class=\"keyword\">const</span> my_Class &amp;a, <span class=\"keyword\">const</span> my_Class &amp;b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a.<span class=\"built_in\">length</span>() &lt; b.<span class=\"built_in\">length</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">set&lt;my_Class, <span class=\"title\">decltype</span><span class=\"params\">(my_fun)</span>*&gt; <span class=\"title\">st</span><span class=\"params\">(my_fun)</span></span>; <span class=\"comment\">// 构造函数的参数也可以写为 st(&amp;my_fun)</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>定义 set 的第二个参数应该是函数指针</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">decltype</span>(my_fun)*  <span class=\"comment\">//decltype的结果仅仅是函数类型，只有加上 * 才能获得函数指针</span></span><br></pre></td></tr></table></figure>\n\n<p>用 <code>my_fun</code> 或 <code>&amp;my_fun</code> 作为构造函数的参数</p>\n<blockquote>\n<p>对函数名来讲，加不加星号（都表示函数类型），取不取地址（都表示函数地址，函数指针类型），没区别</p>\n</blockquote>\n<h4 id=\"2-仿函数\"><a href=\"#2-仿函数\" class=\"headerlink\" title=\"2. 仿函数\"></a>2. 仿函数</h4><h4 id=\"3-Lambda表达式\"><a href=\"#3-Lambda表达式\" class=\"headerlink\" title=\"3. Lambda表达式\"></a>3. Lambda表达式</h4>"},{"_content":"```cpp\ntemplate <class T>\nclass NamedPtr{\npublic:\n    NamedPtr(const string& initName, T* initPtr);\n    ...\nprivate:\n    string name;\n    T* ptr;\n};\n```\n\n初始化列表：\n\n```cpp\ntemplate <class T>\nNamedPtr<T>::NamedPtr(const string& initName, T* initPtr):name(initName),ptr(initPtr){}\n```\n\n构造函数体内赋值：\n\n```cpp\ntemplate <class T>\nNamedPtr<T>::NamedPtr(const string& initName, T* initPtr){\n    name = initName;\n    ptr = initPtr;\n}\n```\n\n#### 用初始化列表的好处：\n\n1. 有些情况下必须用初始化列表，比如`const`或<u>引用</u>数据成员，只能被初始化，不能被赋值\n2. 提升效率，使用初始化列表时，只有一个`string`成员函数被调用，而在构造函数里赋值时，将有两个被调用。\n\n对象的创建分为两步，（1）数据成员初始化（2）执行被调用构造函数体内的动作。这意味着，对于`NamedPtr`类来说，<u>其类对象`string name`的构造函数总是在程序执行到`NamedPtr`的构造函数体之前就已经被调用了（在初始化阶段）。</u>但`string`的哪个构造函数会被调用呢？这取决于`NamedPtr`的类的成员初始化列表，如果没有为`name`指定初始化参数，`string`的默认构造函数将会被调用。然后在`NamedPtr`的构造函数体中，`name`的`operator=`函数会被调用。这样在数据成员初始化阶段和构造函数体执行阶段都会调用`string`的成员函数，一次是默认构造函数，一次是拷贝赋值运算符函数。而如果单纯使用初始化列表来初始化name，就只会调用name的拷贝构造函数，从而减少了一次函数调用。\n\n#### 初始化顺序\n\n类成员是按照它们在类里被声明的顺序进行初始化的，和它们在成员初始化列表中列出的顺序没有关系","source":"_posts/C++/《effective C++ 第三版》读书笔记/初始化列表.md","raw":"```cpp\ntemplate <class T>\nclass NamedPtr{\npublic:\n    NamedPtr(const string& initName, T* initPtr);\n    ...\nprivate:\n    string name;\n    T* ptr;\n};\n```\n\n初始化列表：\n\n```cpp\ntemplate <class T>\nNamedPtr<T>::NamedPtr(const string& initName, T* initPtr):name(initName),ptr(initPtr){}\n```\n\n构造函数体内赋值：\n\n```cpp\ntemplate <class T>\nNamedPtr<T>::NamedPtr(const string& initName, T* initPtr){\n    name = initName;\n    ptr = initPtr;\n}\n```\n\n#### 用初始化列表的好处：\n\n1. 有些情况下必须用初始化列表，比如`const`或<u>引用</u>数据成员，只能被初始化，不能被赋值\n2. 提升效率，使用初始化列表时，只有一个`string`成员函数被调用，而在构造函数里赋值时，将有两个被调用。\n\n对象的创建分为两步，（1）数据成员初始化（2）执行被调用构造函数体内的动作。这意味着，对于`NamedPtr`类来说，<u>其类对象`string name`的构造函数总是在程序执行到`NamedPtr`的构造函数体之前就已经被调用了（在初始化阶段）。</u>但`string`的哪个构造函数会被调用呢？这取决于`NamedPtr`的类的成员初始化列表，如果没有为`name`指定初始化参数，`string`的默认构造函数将会被调用。然后在`NamedPtr`的构造函数体中，`name`的`operator=`函数会被调用。这样在数据成员初始化阶段和构造函数体执行阶段都会调用`string`的成员函数，一次是默认构造函数，一次是拷贝赋值运算符函数。而如果单纯使用初始化列表来初始化name，就只会调用name的拷贝构造函数，从而减少了一次函数调用。\n\n#### 初始化顺序\n\n类成员是按照它们在类里被声明的顺序进行初始化的，和它们在成员初始化列表中列出的顺序没有关系","slug":"C++/《effective C++ 第三版》读书笔记/初始化列表","published":1,"date":"2022-05-05T08:33:56.732Z","updated":"2022-05-05T12:14:24.938Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0kxx001dpcu3f91wh5aa","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NamedPtr</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">NamedPtr</span>(<span class=\"keyword\">const</span> string&amp; initName, T* initPtr);</span><br><span class=\"line\">    ...</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    string name;</span><br><span class=\"line\">    T* ptr;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>初始化列表：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\">NamedPtr&lt;T&gt;::<span class=\"built_in\">NamedPtr</span>(<span class=\"keyword\">const</span> string&amp; initName, T* initPtr):<span class=\"built_in\">name</span>(initName),<span class=\"built_in\">ptr</span>(initPtr)&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>构造函数体内赋值：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\">NamedPtr&lt;T&gt;::<span class=\"built_in\">NamedPtr</span>(<span class=\"keyword\">const</span> string&amp; initName, T* initPtr)&#123;</span><br><span class=\"line\">    name = initName;</span><br><span class=\"line\">    ptr = initPtr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"用初始化列表的好处：\"><a href=\"#用初始化列表的好处：\" class=\"headerlink\" title=\"用初始化列表的好处：\"></a>用初始化列表的好处：</h4><ol>\n<li>有些情况下必须用初始化列表，比如<code>const</code>或<u>引用</u>数据成员，只能被初始化，不能被赋值</li>\n<li>提升效率，使用初始化列表时，只有一个<code>string</code>成员函数被调用，而在构造函数里赋值时，将有两个被调用。</li>\n</ol>\n<p>对象的创建分为两步，（1）数据成员初始化（2）执行被调用构造函数体内的动作。这意味着，对于<code>NamedPtr</code>类来说，<u>其类对象<code>string name</code>的构造函数总是在程序执行到<code>NamedPtr</code>的构造函数体之前就已经被调用了（在初始化阶段）。</u>但<code>string</code>的哪个构造函数会被调用呢？这取决于<code>NamedPtr</code>的类的成员初始化列表，如果没有为<code>name</code>指定初始化参数，<code>string</code>的默认构造函数将会被调用。然后在<code>NamedPtr</code>的构造函数体中，<code>name</code>的<code>operator=</code>函数会被调用。这样在数据成员初始化阶段和构造函数体执行阶段都会调用<code>string</code>的成员函数，一次是默认构造函数，一次是拷贝赋值运算符函数。而如果单纯使用初始化列表来初始化name，就只会调用name的拷贝构造函数，从而减少了一次函数调用。</p>\n<h4 id=\"初始化顺序\"><a href=\"#初始化顺序\" class=\"headerlink\" title=\"初始化顺序\"></a>初始化顺序</h4><p>类成员是按照它们在类里被声明的顺序进行初始化的，和它们在成员初始化列表中列出的顺序没有关系</p>\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NamedPtr</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">NamedPtr</span>(<span class=\"keyword\">const</span> string&amp; initName, T* initPtr);</span><br><span class=\"line\">    ...</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    string name;</span><br><span class=\"line\">    T* ptr;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>初始化列表：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\">NamedPtr&lt;T&gt;::<span class=\"built_in\">NamedPtr</span>(<span class=\"keyword\">const</span> string&amp; initName, T* initPtr):<span class=\"built_in\">name</span>(initName),<span class=\"built_in\">ptr</span>(initPtr)&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>构造函数体内赋值：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\">NamedPtr&lt;T&gt;::<span class=\"built_in\">NamedPtr</span>(<span class=\"keyword\">const</span> string&amp; initName, T* initPtr)&#123;</span><br><span class=\"line\">    name = initName;</span><br><span class=\"line\">    ptr = initPtr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"用初始化列表的好处：\"><a href=\"#用初始化列表的好处：\" class=\"headerlink\" title=\"用初始化列表的好处：\"></a>用初始化列表的好处：</h4><ol>\n<li>有些情况下必须用初始化列表，比如<code>const</code>或<u>引用</u>数据成员，只能被初始化，不能被赋值</li>\n<li>提升效率，使用初始化列表时，只有一个<code>string</code>成员函数被调用，而在构造函数里赋值时，将有两个被调用。</li>\n</ol>\n<p>对象的创建分为两步，（1）数据成员初始化（2）执行被调用构造函数体内的动作。这意味着，对于<code>NamedPtr</code>类来说，<u>其类对象<code>string name</code>的构造函数总是在程序执行到<code>NamedPtr</code>的构造函数体之前就已经被调用了（在初始化阶段）。</u>但<code>string</code>的哪个构造函数会被调用呢？这取决于<code>NamedPtr</code>的类的成员初始化列表，如果没有为<code>name</code>指定初始化参数，<code>string</code>的默认构造函数将会被调用。然后在<code>NamedPtr</code>的构造函数体中，<code>name</code>的<code>operator=</code>函数会被调用。这样在数据成员初始化阶段和构造函数体执行阶段都会调用<code>string</code>的成员函数，一次是默认构造函数，一次是拷贝赋值运算符函数。而如果单纯使用初始化列表来初始化name，就只会调用name的拷贝构造函数，从而减少了一次函数调用。</p>\n<h4 id=\"初始化顺序\"><a href=\"#初始化顺序\" class=\"headerlink\" title=\"初始化顺序\"></a>初始化顺序</h4><p>类成员是按照它们在类里被声明的顺序进行初始化的，和它们在成员初始化列表中列出的顺序没有关系</p>\n"},{"_content":"线程基础\n\n首先要`#include <thread>`头文件，然后用std::thread来创建一个线程，创建线程的时候需要一个参数，参数为函数指针，被创建出来的线程会执行那个函数\n\n> 主线程的执行函数是main()\n\n```cpp\n#include <iostream>\n#include <thread>\nvoid hello()\n{\n    std::cout<<\"Hello Concurrent World\\n\";\n}\n\nint main()\n{\n    std::thread t(hello); //创建一个线程，执行函数hello\n    t.join(); \t\t\t  //让主线程等待子线程\n    return 0;\n}\n```\n\n#### 1. 启动线程\n\n使用C++线程库来启动线程，本质上就是构造`std::thread`对象，创建对象时可以传入参数，来指定执行函数，可以用函数指针、函数对象（仿函数）、lambda表达式。传入的函数也可有其自己参数，函数自己的参数作为`std:thread`构造函数的附加参数\n\n> 注意用函数对象有可能产生的歧义问题，例如有一个函数对象类background_task\n>\n> ```cpp\n> class background_task{\n>   public:\n>     void operator()()const{\n>         //do some thing...\n>     }\n> };\n> std::thread my_thread(background_task()); //本意是想传递一个临时函数对象，但语法上被识别为声明了一个 my_thread的函数，这个函数返回一个thread对象，且有一个参数，参数类型为函数指针，函数指针指向没有参数且返回值为background_task对象的函数\n> ```\n\n线程汇入（joined）\n\n主线程等待子线程结束。调用`join()`会清理线程相关的内存，所以`std::thread`对象只能进行一次`join()`\n\n> `joinable()`指明该线程是否能进行`join()`，已经`join()`过的线程对象不能`join()`，`detach()`过的线程不能`join()`，它们的`joinable()`会返回`false`\n\n线程分离（detached）\n\n主线程不等待子线程，主线程结束后，子线程还在运行，此时要保证子线程能访问的数据是有效的。detach会让线程在后台运行，称为守护线程，主线程不能和其交互，\n\n线程标识\n\n线程标识为std::thread::id类型，标识符可以复用，id相同，则两个线程是同一个线程\n\n\n\n原子操作就是不可分割的操作\n\n#### 原子类型 \n\n标准原子类型定义在头文件`<atomic>`中，对原子类型的操作都是原子的。可以通过特化`std::atomic<>`来得到特定的原子类型\n\n#### C++11线程库\n\nD.2 `<condition_variable>`头文件\n\n条件变量，允许被阻塞的线程在某些条件达成或超时时，解除阻塞继续执行\n\nD.3 `<atomic>`头文件\n\n提供一组基础的原子类型，对原子类型的操作都是原子操作\n\nD.5 `<mutex>`头文件\n\n提供互斥工具：互斥类型，锁类型，确保操作只执行一次\n\n`std::mutex`提供了锁，互斥量上锁要调用`lock()`，解锁要调用`unlock()`\n\nD.7 `<thread>`头文件\n\n`<thread>`提供了线程管理的方法，比如线程的id，joinable()，detach()\n\n","source":"_posts/C++/多线程/原子操作和原子类型.md","raw":"线程基础\n\n首先要`#include <thread>`头文件，然后用std::thread来创建一个线程，创建线程的时候需要一个参数，参数为函数指针，被创建出来的线程会执行那个函数\n\n> 主线程的执行函数是main()\n\n```cpp\n#include <iostream>\n#include <thread>\nvoid hello()\n{\n    std::cout<<\"Hello Concurrent World\\n\";\n}\n\nint main()\n{\n    std::thread t(hello); //创建一个线程，执行函数hello\n    t.join(); \t\t\t  //让主线程等待子线程\n    return 0;\n}\n```\n\n#### 1. 启动线程\n\n使用C++线程库来启动线程，本质上就是构造`std::thread`对象，创建对象时可以传入参数，来指定执行函数，可以用函数指针、函数对象（仿函数）、lambda表达式。传入的函数也可有其自己参数，函数自己的参数作为`std:thread`构造函数的附加参数\n\n> 注意用函数对象有可能产生的歧义问题，例如有一个函数对象类background_task\n>\n> ```cpp\n> class background_task{\n>   public:\n>     void operator()()const{\n>         //do some thing...\n>     }\n> };\n> std::thread my_thread(background_task()); //本意是想传递一个临时函数对象，但语法上被识别为声明了一个 my_thread的函数，这个函数返回一个thread对象，且有一个参数，参数类型为函数指针，函数指针指向没有参数且返回值为background_task对象的函数\n> ```\n\n线程汇入（joined）\n\n主线程等待子线程结束。调用`join()`会清理线程相关的内存，所以`std::thread`对象只能进行一次`join()`\n\n> `joinable()`指明该线程是否能进行`join()`，已经`join()`过的线程对象不能`join()`，`detach()`过的线程不能`join()`，它们的`joinable()`会返回`false`\n\n线程分离（detached）\n\n主线程不等待子线程，主线程结束后，子线程还在运行，此时要保证子线程能访问的数据是有效的。detach会让线程在后台运行，称为守护线程，主线程不能和其交互，\n\n线程标识\n\n线程标识为std::thread::id类型，标识符可以复用，id相同，则两个线程是同一个线程\n\n\n\n原子操作就是不可分割的操作\n\n#### 原子类型 \n\n标准原子类型定义在头文件`<atomic>`中，对原子类型的操作都是原子的。可以通过特化`std::atomic<>`来得到特定的原子类型\n\n#### C++11线程库\n\nD.2 `<condition_variable>`头文件\n\n条件变量，允许被阻塞的线程在某些条件达成或超时时，解除阻塞继续执行\n\nD.3 `<atomic>`头文件\n\n提供一组基础的原子类型，对原子类型的操作都是原子操作\n\nD.5 `<mutex>`头文件\n\n提供互斥工具：互斥类型，锁类型，确保操作只执行一次\n\n`std::mutex`提供了锁，互斥量上锁要调用`lock()`，解锁要调用`unlock()`\n\nD.7 `<thread>`头文件\n\n`<thread>`提供了线程管理的方法，比如线程的id，joinable()，detach()\n\n","slug":"C++/多线程/原子操作和原子类型","published":1,"date":"2022-05-12T08:35:16.532Z","updated":"2022-05-12T13:40:49.433Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0kxy001epcu38bvf4z29","content":"<p>线程基础</p>\n<p>首先要<code>#include &lt;thread&gt;</code>头文件，然后用std::thread来创建一个线程，创建线程的时候需要一个参数，参数为函数指针，被创建出来的线程会执行那个函数</p>\n<blockquote>\n<p>主线程的执行函数是main()</p>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;thread&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">hello</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    std::cout&lt;&lt;<span class=\"string\">&quot;Hello Concurrent World\\n&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">std::thread <span class=\"title\">t</span><span class=\"params\">(hello)</span></span>; <span class=\"comment\">//创建一个线程，执行函数hello</span></span><br><span class=\"line\">    t.<span class=\"built_in\">join</span>(); \t\t\t  <span class=\"comment\">//让主线程等待子线程</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-启动线程\"><a href=\"#1-启动线程\" class=\"headerlink\" title=\"1. 启动线程\"></a>1. 启动线程</h4><p>使用C++线程库来启动线程，本质上就是构造<code>std::thread</code>对象，创建对象时可以传入参数，来指定执行函数，可以用函数指针、函数对象（仿函数）、lambda表达式。传入的函数也可有其自己参数，函数自己的参数作为<code>std:thread</code>构造函数的附加参数</p>\n<blockquote>\n<p>注意用函数对象有可能产生的歧义问题，例如有一个函数对象类background_task</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">background_task</span>&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">()</span><span class=\"keyword\">const</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//do some thing...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\">std::thread <span class=\"title\">my_thread</span><span class=\"params\">(background_task())</span></span>; <span class=\"comment\">//本意是想传递一个临时函数对象，但语法上被识别为声明了一个 my_thread的函数，这个函数返回一个thread对象，且有一个参数，参数类型为函数指针，函数指针指向没有参数且返回值为background_task对象的函数</span></span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>线程汇入（joined）</p>\n<p>主线程等待子线程结束。调用<code>join()</code>会清理线程相关的内存，所以<code>std::thread</code>对象只能进行一次<code>join()</code></p>\n<blockquote>\n<p><code>joinable()</code>指明该线程是否能进行<code>join()</code>，已经<code>join()</code>过的线程对象不能<code>join()</code>，<code>detach()</code>过的线程不能<code>join()</code>，它们的<code>joinable()</code>会返回<code>false</code></p>\n</blockquote>\n<p>线程分离（detached）</p>\n<p>主线程不等待子线程，主线程结束后，子线程还在运行，此时要保证子线程能访问的数据是有效的。detach会让线程在后台运行，称为守护线程，主线程不能和其交互，</p>\n<p>线程标识</p>\n<p>线程标识为std::thread::id类型，标识符可以复用，id相同，则两个线程是同一个线程</p>\n<p>原子操作就是不可分割的操作</p>\n<h4 id=\"原子类型\"><a href=\"#原子类型\" class=\"headerlink\" title=\"原子类型\"></a>原子类型</h4><p>标准原子类型定义在头文件<code>&lt;atomic&gt;</code>中，对原子类型的操作都是原子的。可以通过特化<code>std::atomic&lt;&gt;</code>来得到特定的原子类型</p>\n<h4 id=\"C-11线程库\"><a href=\"#C-11线程库\" class=\"headerlink\" title=\"C++11线程库\"></a>C++11线程库</h4><p>D.2 <code>&lt;condition_variable&gt;</code>头文件</p>\n<p>条件变量，允许被阻塞的线程在某些条件达成或超时时，解除阻塞继续执行</p>\n<p>D.3 <code>&lt;atomic&gt;</code>头文件</p>\n<p>提供一组基础的原子类型，对原子类型的操作都是原子操作</p>\n<p>D.5 <code>&lt;mutex&gt;</code>头文件</p>\n<p>提供互斥工具：互斥类型，锁类型，确保操作只执行一次</p>\n<p><code>std::mutex</code>提供了锁，互斥量上锁要调用<code>lock()</code>，解锁要调用<code>unlock()</code></p>\n<p>D.7 <code>&lt;thread&gt;</code>头文件</p>\n<p><code>&lt;thread&gt;</code>提供了线程管理的方法，比如线程的id，joinable()，detach()</p>\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<p>线程基础</p>\n<p>首先要<code>#include &lt;thread&gt;</code>头文件，然后用std::thread来创建一个线程，创建线程的时候需要一个参数，参数为函数指针，被创建出来的线程会执行那个函数</p>\n<blockquote>\n<p>主线程的执行函数是main()</p>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;thread&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">hello</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    std::cout&lt;&lt;<span class=\"string\">&quot;Hello Concurrent World\\n&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">std::thread <span class=\"title\">t</span><span class=\"params\">(hello)</span></span>; <span class=\"comment\">//创建一个线程，执行函数hello</span></span><br><span class=\"line\">    t.<span class=\"built_in\">join</span>(); \t\t\t  <span class=\"comment\">//让主线程等待子线程</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-启动线程\"><a href=\"#1-启动线程\" class=\"headerlink\" title=\"1. 启动线程\"></a>1. 启动线程</h4><p>使用C++线程库来启动线程，本质上就是构造<code>std::thread</code>对象，创建对象时可以传入参数，来指定执行函数，可以用函数指针、函数对象（仿函数）、lambda表达式。传入的函数也可有其自己参数，函数自己的参数作为<code>std:thread</code>构造函数的附加参数</p>\n<blockquote>\n<p>注意用函数对象有可能产生的歧义问题，例如有一个函数对象类background_task</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">background_task</span>&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">()</span><span class=\"keyword\">const</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//do some thing...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\">std::thread <span class=\"title\">my_thread</span><span class=\"params\">(background_task())</span></span>; <span class=\"comment\">//本意是想传递一个临时函数对象，但语法上被识别为声明了一个 my_thread的函数，这个函数返回一个thread对象，且有一个参数，参数类型为函数指针，函数指针指向没有参数且返回值为background_task对象的函数</span></span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>线程汇入（joined）</p>\n<p>主线程等待子线程结束。调用<code>join()</code>会清理线程相关的内存，所以<code>std::thread</code>对象只能进行一次<code>join()</code></p>\n<blockquote>\n<p><code>joinable()</code>指明该线程是否能进行<code>join()</code>，已经<code>join()</code>过的线程对象不能<code>join()</code>，<code>detach()</code>过的线程不能<code>join()</code>，它们的<code>joinable()</code>会返回<code>false</code></p>\n</blockquote>\n<p>线程分离（detached）</p>\n<p>主线程不等待子线程，主线程结束后，子线程还在运行，此时要保证子线程能访问的数据是有效的。detach会让线程在后台运行，称为守护线程，主线程不能和其交互，</p>\n<p>线程标识</p>\n<p>线程标识为std::thread::id类型，标识符可以复用，id相同，则两个线程是同一个线程</p>\n<p>原子操作就是不可分割的操作</p>\n<h4 id=\"原子类型\"><a href=\"#原子类型\" class=\"headerlink\" title=\"原子类型\"></a>原子类型</h4><p>标准原子类型定义在头文件<code>&lt;atomic&gt;</code>中，对原子类型的操作都是原子的。可以通过特化<code>std::atomic&lt;&gt;</code>来得到特定的原子类型</p>\n<h4 id=\"C-11线程库\"><a href=\"#C-11线程库\" class=\"headerlink\" title=\"C++11线程库\"></a>C++11线程库</h4><p>D.2 <code>&lt;condition_variable&gt;</code>头文件</p>\n<p>条件变量，允许被阻塞的线程在某些条件达成或超时时，解除阻塞继续执行</p>\n<p>D.3 <code>&lt;atomic&gt;</code>头文件</p>\n<p>提供一组基础的原子类型，对原子类型的操作都是原子操作</p>\n<p>D.5 <code>&lt;mutex&gt;</code>头文件</p>\n<p>提供互斥工具：互斥类型，锁类型，确保操作只执行一次</p>\n<p><code>std::mutex</code>提供了锁，互斥量上锁要调用<code>lock()</code>，解锁要调用<code>unlock()</code></p>\n<p>D.7 <code>&lt;thread&gt;</code>头文件</p>\n<p><code>&lt;thread&gt;</code>提供了线程管理的方法，比如线程的id，joinable()，detach()</p>\n"},{"title":"拷贝初始化那些事儿","date":"2021-11-23T16:00:00.000Z","draft":false,"_content":"\n### 拷贝构造函数\n\n要么只有一个参数，此参数是自身类类型的常引用，要么多个参数，第一个参数为自身类类型的常引用，其他参数都有默认值\n\n```cpp\nclass Foo {\npublic:\n    Foo();\n    Foo(const  Foo&);  //可以用初始化列表，或在花括号里一一拷贝\n};\n```\n\n### 合成拷贝构造函数\n\n如果用户没有为类定义一个拷贝构造函数，编译器会自动生成一个，执行**浅拷贝**，依次拷贝每个非 `static` 成员\n\n### 直接初始化（无`=`号）\n\n匹配最佳的构造函数（注意也有可能匹配上拷贝构造函数）\n\n### 拷贝初始化\n\n使用拷贝初始化的常见四种情况：\n\n1. `=`号\n2. 函数非引用形参\n3. 函数非引用返回类型 \n4. 用花括号列表初始化一个数组中的元素或一个聚合类中的成员\n\n\n\n拷贝初始化有时候会使用**移动构造函数**而非**拷贝构造函数**\n\n```cpp\nclass Foo{\npublic:\n    Foo(Foo &&f){} //移动构造函数\n    Foo& operator=(Foo f){} //普通左值既可以接受左值也可以接受右值，反正都是要拷贝的\n    //注意上面这个不是拷贝赋值运算符，拷贝赋值运算符要求参数为常引用\n};\n```\n\n观察：\n\n```cpp\n    Foo& operator=(Foo f){} //单一的赋值运算符实现了拷贝赋值运算符和移动赋值运算符两种可能\n```\n\n此运算符有一个<u>非引用</u>参数，所以要进行<u>拷贝初始化</u>\n\n依赖于实参的类型，拷贝初始化要么使用拷贝构造函数，要么使用移动构造函数——<u>左值</u>被拷贝，<u>右值</u>被移动\n\n```cpp\nhp = hp2; \t\t\t\t//拷贝构造函数来拷贝hp2\nhp = std::move(hp2);    //移动构造函数移动hp2\n```\n\n> 有点奇怪，按理说=号赋值应该调用拷贝赋值运算符，这里却调用那个非拷贝赋值运算符？\n\n### 为什么拷贝构造函数自己的参数必须是引用类型？\n\n如果不是引用，则会调用拷贝构造函数，形成拷贝构造函数调用拷贝构造函数的死循环\n\n### 编译器可以绕过拷贝/移动构造函数\n\n拷贝初始化中，编译器可以选择跳过拷贝/移动构造函数，直接创建对象\n\n```cpp\nstring null_book = \"9999\"; //拷贝初始化\n```\n\n> **隐式类型转换（转换构造函数）**：只接受一个实参，或者其他参数都有默认参数\n>\n> 在需要类对象的时候，编译器可以根据已经有的一个参数，调用转换构造函数，自动创建一个（临时）对象\n\n正常来讲，字符串字面值`\"9999\"` 是`const char*`类型，由于要进行拷贝初始化，`=`号右边需要一个`string`对象，所以根据**隐式类型转换**，在需要`string`对象的时候，可以调用相应的**转换构造函数**，自动创建一个临时`string`对象：\n\n```cpp\nstring (const char* s); //from c-string (4)\t转换构造函数\n```\n\n有了临时`string`对象后，按理说要调用拷贝构造函数，完成对`null_book`的拷贝初始化\n\n然而，这里**并没有**调用拷贝构造函数，经测试**也没有**调用移动构造函数，原因是编译器对拷贝初始化表达式进行了改写\n\n把\n\n```cpp\nstring null_book = \"9999\"; //拷贝初始化\n```\n\n改写为\n\n```cpp\nstring null_book(\"9999\"); // 使临时对象成为要创建的对象\n```\n\n按理说被改写后应该属于（调用拷贝构造函数的）直接初始化\n\n但是在利用转换构造函数生成临时`string`对象后\n\n编译器直接使临时对象成为要创建的对象（编译器优化），所以没有调用拷贝/移动构造函数\n\n其他例子：\n\n```cpp\nclass Foo {\npublic:\n    Foo() = default;\n    Foo(const Foo& other) :len(other.len) { cout << \"拷贝构造函数！\" << endl; }  //拷贝构造函数\n    Foo(int length) :len(length) { cout << \"转换构造函数\" << endl; } \t\t       //转换构造函数\n    Foo(Foo&&) { cout << \"移动构造函数\" << endl; } \t\t\t\t\t\t\t   //移动构造函数\n    Foo& temp_f(Foo temp) {\n        return *this;\n    }\nprivate:\n    int len;\n};\n\nint main() {\n    Foo c1 = 10; //本身为拷贝初始化，编译器将其改写为下一行的语句，不会调用拷贝/移动构造函数！\n    Foo c(10);  //不会调用拷贝/移动构造函数！只会调用转换构造函数\n    c.temp_f(10); // 虽然形参非引用，但是也不会调用拷贝/移动构造函数！\n    return 0;\n}\n```\n\n解析一下这个：\n\n```cpp\nc.temp_f(10); // 虽然形参非引用，但是也不会调用拷贝/移动构造函数！\n```\n\n形参非引用，参数`10`被作为参数传入，先会调用转换构造函数，使`10`被隐式转换为一个`Foo临时对象`\n\n注意，这个对象是临时的，临时量具有<u>常量性</u>（`const`属性）\n\n<u>常量性</u>意味着：\n\n1. 如果`temp_f`的形参是`左值引用&`，将会报错，左值<u>引用</u>不能接受一个`const`值，左值引用也不能接受一个右值\n\n2. 如果`temp_f`的形参是`常量左值引用const &`或`右值引用&&`，不会报错，因为它们都可以接受一个右值，而且因为是引用了，所以也不会调用拷贝构造函数\n\n3. 如果`temp_f`的形参是`普通左值`：\n\n   ```cpp\n   Foo& temp_f(Foo temp);\n   ```\n\n   普通左值可以接受`const值`或`右值`，因为这就直接<u>拷贝</u>了，`const值`或`右值`没有被改变的风险\n\n   例如：\n\n   ```cpp\n   int i = 42;const int ci = i;int j = ci;  // ci的常量特征仅仅在执行改变ci的操作时才会发挥作用，一旦拷贝完成，新的对象就和原来的对象没什么关系了\n   ```\n\n   然后按理来说，函数形参非引用，应该是个拷贝初始化，调用拷贝构造函数\n\n   但是没有！因为传给 temp_f 是一个**匿名临时对象**！\n\n   只有一个对象对另一个同类型的对象进行初始化才会调用拷贝构造函数，但是<u>匿名对象对另一个同类型的对象初始化**不会**调用拷贝构造函数</u>，因为c++**编译器**对这种情况进行**优化**，<u>直接将匿名对象转化为该对象</u>，不需要进行额外的内存分配，提高了效率；\n\n   编译器在此时进行了优化，<u>绕过了拷贝/移动构造函数</u>，将`Foo临时对象`直接创建了`Foo对象`作为形参，所以并没有调用拷贝/移动构造函数！\n\n   参考解析：https://blog.csdn.net/weicao1990/article/details/81629955\n\n   > 即使编译器略过了拷贝/移动构造函数，但在这个程序点上，拷贝/移动构造函数必须是可存在且可访问的（必须是`public`的，不能是`private`）\n\n\n### 拷贝赋值运算符\n\n注意区分赋值和初始化\n\n返回类型为<u>引用</u>，形参为<u>常引用</u>：\n\n```cpp\nclass Foo {\npublic:\n    Foo& operator=(const Foo&); //赋值运算符\n}\n```\n\n> 拷贝赋值运算符=重载赋值运算符\n>\n> 重载赋值运算符的参数表示运算符的**运算对象**\n>\n> 如果一个运算符是成员函数（**赋值运算符必须定义为成员函数**），则其第一个参数肯定是**隐式this参数**，这也是该运算符的（**左侧**）运算对象\n>\n> - 如果是一元运算符，就只有这一个运算对象\n> - 如果是二元运算符（例如赋值运算符），其**右侧**运算对象作为**显示**参数传递\n\n如果类没有定义自己的拷贝赋值运算符，编译器会自动合成一个合成拷贝赋值运算符\n\n但是**合成拷贝赋值运算符**实行**浅**拷贝，当对象中存在指针成员变量时，存在如下问题：\n\n![原生赋值运算符](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211124194517073.png)\n\n所以当对象中存在指针成员变量， 应该自定义新的拷贝赋值构造函数，执行**深**拷贝\n\n### 2. 对象移动\n\n#### 2.1 右值引用\n\n符号：`&&`\n\n**右值引用**只能绑定到一个将要销毁的对象（临时对象）\n\n**左值引用**不能被绑定到要求转换的表达式，字面常量或是返回右值的表达式，但<u>右值引用可以</u>，但不能将一个右值引用直接绑定到一个左值上\n\n- 返回左值的表达式（可以被`左值引用`绑定）：返回左值引用的函数，包括赋值、下标、解引用和前置递增/递减运算符\n- 返回右值的表达式（可以被`const左值引用`、`右值引用&&`绑定）：返回非引用类型的函数，包括算数、关系、位以及后置递增/递减运算符\n\n变量是持久的，包括右值引用类型的左值，所以<u>不能将一个右值引用绑定到一个右值引用类型的变量上</u>：\n\n```cpp\nint &&rr1 = 42;\nint &&rr2 = rr1; //错误！变量表达式 rr1 是左值\n```\n\n`std::move`显示地将左值转变为右值\n\n#### 2.2 移动构造函数（移动语义）\n\n以移动而非深拷贝的方式初始化含有指针成员的类对象\n\n移动构造函数的第一个参数为右值引用，任何额外的参数都必须有默认实参\n\n1. 指针资源交接\n2. 原来的指针应该指向`nullptr`\n\n浅拷贝+销毁=移动\n\n```cpp\n#include <iostream>\nusing namespace std;\nclass demo{\npublic:\n    demo():num(new int(0)){\n        cout<<\"construct!\"<<endl;\n    }\n    demo(const demo &d):num(new int(*d.num)){\n        cout<<\"copy construct!\"<<endl;\n    }\n    //添加移动构造函数\n    demo(demo &&d):num(d.num){\n        d.num = NULL;\n        cout<<\"move construct!\"<<endl;\n    }\n    ~demo(){\n        cout<<\"class destruct!\"<<endl;\n    }\nprivate:\n    int *num;\n};\ndemo get_demo(){\n    return demo();\n}\nint main(){\n    demo a = get_demo();\n    return 0;\n}\n\n//结果：为 demo 类添加移动构造函数之后，使用临时对象初始化 a 对象过程中产生的 2 次拷贝操作，都由移动构造函数完成\n```\n\n> 当类中同时包含拷贝构造函数和移动构造函数时，如果使用**临时对象**初始化当前类的对象，编译器会**优先调用移动构造函数**来完成此操作。\n>\n> 只有当类中没有合适的移动构造函数时，编译器才会退而求其次，用拷贝构造函数**代替**移动构造函数（赋值运算符的情况类类似）\n\n#### 2.3 移动赋值运算符\n\n```cpp\nStrVec& StrVec::operator=(StrVec &&rhs) {\n    //直接检测自赋值\n    if (this != &rhs) { //rhs是个右值引用变量表达式，所以它是个左值，所以可以对它取地址\n        free();    \t\t//释放已有元素\n        elements = rhs.elements; // 从rhs接管资源\n        first_free = rhs.first_free;\n        cap = rhs.cap;\n        // 将rhs置于可析构状态\n        rhs.elements = rhs.first_free = rhs.cap = nullptr;\n    }\n    return *this;\n}\n```\n\n#### 2.4 合成的移动操作\n\n如果一个类定义了自己的拷贝构造函数、拷贝赋值运算符或者析构函数，编译器就**不会自动合成**移动构造函数和移动赋值运算符\n\n仅当一个类没有定义任何自己版本的拷贝控制成员（三大件），且类的每个非static数据成员都可以移动时，编译器才会自动合成移动构造函数或移动赋值运算符\n\n可移动：\n\n- 内置类型总是可移动的\n- 类类型，要求该类有对应的移动操作\n\n```cpp\n//编译器会为X和hasX合成移动操作\nstruct X {\n    int i;  \t\t\t//内置类型可以移动\n    std::string s; \t\t//string定义了自己的移动操作\n};\nstruct hasX {\n    X mem;\t\t\t\t// X有合成的移动操作\n};\nX x, x2 = std::move(x); \t  //使用合成的移动构造操作\nhasX hx, hx2 = std::move(hx); //使用合成的移动构造函数\n```\n\n\n\n\n\n","source":"_posts/C++/拷贝控制/拷贝初始化.md","raw":"---\ntitle: \"拷贝初始化那些事儿\"\ndate: 2021-11-24\ndraft: false\ntags: [\"C/C++\"]\ncategories: [\"我为什么这么菜~~\"]\n\n---\n\n### 拷贝构造函数\n\n要么只有一个参数，此参数是自身类类型的常引用，要么多个参数，第一个参数为自身类类型的常引用，其他参数都有默认值\n\n```cpp\nclass Foo {\npublic:\n    Foo();\n    Foo(const  Foo&);  //可以用初始化列表，或在花括号里一一拷贝\n};\n```\n\n### 合成拷贝构造函数\n\n如果用户没有为类定义一个拷贝构造函数，编译器会自动生成一个，执行**浅拷贝**，依次拷贝每个非 `static` 成员\n\n### 直接初始化（无`=`号）\n\n匹配最佳的构造函数（注意也有可能匹配上拷贝构造函数）\n\n### 拷贝初始化\n\n使用拷贝初始化的常见四种情况：\n\n1. `=`号\n2. 函数非引用形参\n3. 函数非引用返回类型 \n4. 用花括号列表初始化一个数组中的元素或一个聚合类中的成员\n\n\n\n拷贝初始化有时候会使用**移动构造函数**而非**拷贝构造函数**\n\n```cpp\nclass Foo{\npublic:\n    Foo(Foo &&f){} //移动构造函数\n    Foo& operator=(Foo f){} //普通左值既可以接受左值也可以接受右值，反正都是要拷贝的\n    //注意上面这个不是拷贝赋值运算符，拷贝赋值运算符要求参数为常引用\n};\n```\n\n观察：\n\n```cpp\n    Foo& operator=(Foo f){} //单一的赋值运算符实现了拷贝赋值运算符和移动赋值运算符两种可能\n```\n\n此运算符有一个<u>非引用</u>参数，所以要进行<u>拷贝初始化</u>\n\n依赖于实参的类型，拷贝初始化要么使用拷贝构造函数，要么使用移动构造函数——<u>左值</u>被拷贝，<u>右值</u>被移动\n\n```cpp\nhp = hp2; \t\t\t\t//拷贝构造函数来拷贝hp2\nhp = std::move(hp2);    //移动构造函数移动hp2\n```\n\n> 有点奇怪，按理说=号赋值应该调用拷贝赋值运算符，这里却调用那个非拷贝赋值运算符？\n\n### 为什么拷贝构造函数自己的参数必须是引用类型？\n\n如果不是引用，则会调用拷贝构造函数，形成拷贝构造函数调用拷贝构造函数的死循环\n\n### 编译器可以绕过拷贝/移动构造函数\n\n拷贝初始化中，编译器可以选择跳过拷贝/移动构造函数，直接创建对象\n\n```cpp\nstring null_book = \"9999\"; //拷贝初始化\n```\n\n> **隐式类型转换（转换构造函数）**：只接受一个实参，或者其他参数都有默认参数\n>\n> 在需要类对象的时候，编译器可以根据已经有的一个参数，调用转换构造函数，自动创建一个（临时）对象\n\n正常来讲，字符串字面值`\"9999\"` 是`const char*`类型，由于要进行拷贝初始化，`=`号右边需要一个`string`对象，所以根据**隐式类型转换**，在需要`string`对象的时候，可以调用相应的**转换构造函数**，自动创建一个临时`string`对象：\n\n```cpp\nstring (const char* s); //from c-string (4)\t转换构造函数\n```\n\n有了临时`string`对象后，按理说要调用拷贝构造函数，完成对`null_book`的拷贝初始化\n\n然而，这里**并没有**调用拷贝构造函数，经测试**也没有**调用移动构造函数，原因是编译器对拷贝初始化表达式进行了改写\n\n把\n\n```cpp\nstring null_book = \"9999\"; //拷贝初始化\n```\n\n改写为\n\n```cpp\nstring null_book(\"9999\"); // 使临时对象成为要创建的对象\n```\n\n按理说被改写后应该属于（调用拷贝构造函数的）直接初始化\n\n但是在利用转换构造函数生成临时`string`对象后\n\n编译器直接使临时对象成为要创建的对象（编译器优化），所以没有调用拷贝/移动构造函数\n\n其他例子：\n\n```cpp\nclass Foo {\npublic:\n    Foo() = default;\n    Foo(const Foo& other) :len(other.len) { cout << \"拷贝构造函数！\" << endl; }  //拷贝构造函数\n    Foo(int length) :len(length) { cout << \"转换构造函数\" << endl; } \t\t       //转换构造函数\n    Foo(Foo&&) { cout << \"移动构造函数\" << endl; } \t\t\t\t\t\t\t   //移动构造函数\n    Foo& temp_f(Foo temp) {\n        return *this;\n    }\nprivate:\n    int len;\n};\n\nint main() {\n    Foo c1 = 10; //本身为拷贝初始化，编译器将其改写为下一行的语句，不会调用拷贝/移动构造函数！\n    Foo c(10);  //不会调用拷贝/移动构造函数！只会调用转换构造函数\n    c.temp_f(10); // 虽然形参非引用，但是也不会调用拷贝/移动构造函数！\n    return 0;\n}\n```\n\n解析一下这个：\n\n```cpp\nc.temp_f(10); // 虽然形参非引用，但是也不会调用拷贝/移动构造函数！\n```\n\n形参非引用，参数`10`被作为参数传入，先会调用转换构造函数，使`10`被隐式转换为一个`Foo临时对象`\n\n注意，这个对象是临时的，临时量具有<u>常量性</u>（`const`属性）\n\n<u>常量性</u>意味着：\n\n1. 如果`temp_f`的形参是`左值引用&`，将会报错，左值<u>引用</u>不能接受一个`const`值，左值引用也不能接受一个右值\n\n2. 如果`temp_f`的形参是`常量左值引用const &`或`右值引用&&`，不会报错，因为它们都可以接受一个右值，而且因为是引用了，所以也不会调用拷贝构造函数\n\n3. 如果`temp_f`的形参是`普通左值`：\n\n   ```cpp\n   Foo& temp_f(Foo temp);\n   ```\n\n   普通左值可以接受`const值`或`右值`，因为这就直接<u>拷贝</u>了，`const值`或`右值`没有被改变的风险\n\n   例如：\n\n   ```cpp\n   int i = 42;const int ci = i;int j = ci;  // ci的常量特征仅仅在执行改变ci的操作时才会发挥作用，一旦拷贝完成，新的对象就和原来的对象没什么关系了\n   ```\n\n   然后按理来说，函数形参非引用，应该是个拷贝初始化，调用拷贝构造函数\n\n   但是没有！因为传给 temp_f 是一个**匿名临时对象**！\n\n   只有一个对象对另一个同类型的对象进行初始化才会调用拷贝构造函数，但是<u>匿名对象对另一个同类型的对象初始化**不会**调用拷贝构造函数</u>，因为c++**编译器**对这种情况进行**优化**，<u>直接将匿名对象转化为该对象</u>，不需要进行额外的内存分配，提高了效率；\n\n   编译器在此时进行了优化，<u>绕过了拷贝/移动构造函数</u>，将`Foo临时对象`直接创建了`Foo对象`作为形参，所以并没有调用拷贝/移动构造函数！\n\n   参考解析：https://blog.csdn.net/weicao1990/article/details/81629955\n\n   > 即使编译器略过了拷贝/移动构造函数，但在这个程序点上，拷贝/移动构造函数必须是可存在且可访问的（必须是`public`的，不能是`private`）\n\n\n### 拷贝赋值运算符\n\n注意区分赋值和初始化\n\n返回类型为<u>引用</u>，形参为<u>常引用</u>：\n\n```cpp\nclass Foo {\npublic:\n    Foo& operator=(const Foo&); //赋值运算符\n}\n```\n\n> 拷贝赋值运算符=重载赋值运算符\n>\n> 重载赋值运算符的参数表示运算符的**运算对象**\n>\n> 如果一个运算符是成员函数（**赋值运算符必须定义为成员函数**），则其第一个参数肯定是**隐式this参数**，这也是该运算符的（**左侧**）运算对象\n>\n> - 如果是一元运算符，就只有这一个运算对象\n> - 如果是二元运算符（例如赋值运算符），其**右侧**运算对象作为**显示**参数传递\n\n如果类没有定义自己的拷贝赋值运算符，编译器会自动合成一个合成拷贝赋值运算符\n\n但是**合成拷贝赋值运算符**实行**浅**拷贝，当对象中存在指针成员变量时，存在如下问题：\n\n![原生赋值运算符](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211124194517073.png)\n\n所以当对象中存在指针成员变量， 应该自定义新的拷贝赋值构造函数，执行**深**拷贝\n\n### 2. 对象移动\n\n#### 2.1 右值引用\n\n符号：`&&`\n\n**右值引用**只能绑定到一个将要销毁的对象（临时对象）\n\n**左值引用**不能被绑定到要求转换的表达式，字面常量或是返回右值的表达式，但<u>右值引用可以</u>，但不能将一个右值引用直接绑定到一个左值上\n\n- 返回左值的表达式（可以被`左值引用`绑定）：返回左值引用的函数，包括赋值、下标、解引用和前置递增/递减运算符\n- 返回右值的表达式（可以被`const左值引用`、`右值引用&&`绑定）：返回非引用类型的函数，包括算数、关系、位以及后置递增/递减运算符\n\n变量是持久的，包括右值引用类型的左值，所以<u>不能将一个右值引用绑定到一个右值引用类型的变量上</u>：\n\n```cpp\nint &&rr1 = 42;\nint &&rr2 = rr1; //错误！变量表达式 rr1 是左值\n```\n\n`std::move`显示地将左值转变为右值\n\n#### 2.2 移动构造函数（移动语义）\n\n以移动而非深拷贝的方式初始化含有指针成员的类对象\n\n移动构造函数的第一个参数为右值引用，任何额外的参数都必须有默认实参\n\n1. 指针资源交接\n2. 原来的指针应该指向`nullptr`\n\n浅拷贝+销毁=移动\n\n```cpp\n#include <iostream>\nusing namespace std;\nclass demo{\npublic:\n    demo():num(new int(0)){\n        cout<<\"construct!\"<<endl;\n    }\n    demo(const demo &d):num(new int(*d.num)){\n        cout<<\"copy construct!\"<<endl;\n    }\n    //添加移动构造函数\n    demo(demo &&d):num(d.num){\n        d.num = NULL;\n        cout<<\"move construct!\"<<endl;\n    }\n    ~demo(){\n        cout<<\"class destruct!\"<<endl;\n    }\nprivate:\n    int *num;\n};\ndemo get_demo(){\n    return demo();\n}\nint main(){\n    demo a = get_demo();\n    return 0;\n}\n\n//结果：为 demo 类添加移动构造函数之后，使用临时对象初始化 a 对象过程中产生的 2 次拷贝操作，都由移动构造函数完成\n```\n\n> 当类中同时包含拷贝构造函数和移动构造函数时，如果使用**临时对象**初始化当前类的对象，编译器会**优先调用移动构造函数**来完成此操作。\n>\n> 只有当类中没有合适的移动构造函数时，编译器才会退而求其次，用拷贝构造函数**代替**移动构造函数（赋值运算符的情况类类似）\n\n#### 2.3 移动赋值运算符\n\n```cpp\nStrVec& StrVec::operator=(StrVec &&rhs) {\n    //直接检测自赋值\n    if (this != &rhs) { //rhs是个右值引用变量表达式，所以它是个左值，所以可以对它取地址\n        free();    \t\t//释放已有元素\n        elements = rhs.elements; // 从rhs接管资源\n        first_free = rhs.first_free;\n        cap = rhs.cap;\n        // 将rhs置于可析构状态\n        rhs.elements = rhs.first_free = rhs.cap = nullptr;\n    }\n    return *this;\n}\n```\n\n#### 2.4 合成的移动操作\n\n如果一个类定义了自己的拷贝构造函数、拷贝赋值运算符或者析构函数，编译器就**不会自动合成**移动构造函数和移动赋值运算符\n\n仅当一个类没有定义任何自己版本的拷贝控制成员（三大件），且类的每个非static数据成员都可以移动时，编译器才会自动合成移动构造函数或移动赋值运算符\n\n可移动：\n\n- 内置类型总是可移动的\n- 类类型，要求该类有对应的移动操作\n\n```cpp\n//编译器会为X和hasX合成移动操作\nstruct X {\n    int i;  \t\t\t//内置类型可以移动\n    std::string s; \t\t//string定义了自己的移动操作\n};\nstruct hasX {\n    X mem;\t\t\t\t// X有合成的移动操作\n};\nX x, x2 = std::move(x); \t  //使用合成的移动构造操作\nhasX hx, hx2 = std::move(hx); //使用合成的移动构造函数\n```\n\n\n\n\n\n","slug":"C++/拷贝控制/拷贝初始化","published":1,"updated":"2022-03-02T02:32:56.249Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0kxy001fpcu36eaq54cb","content":"<h3 id=\"拷贝构造函数\"><a href=\"#拷贝构造函数\" class=\"headerlink\" title=\"拷贝构造函数\"></a>拷贝构造函数</h3><p>要么只有一个参数，此参数是自身类类型的常引用，要么多个参数，第一个参数为自身类类型的常引用，其他参数都有默认值</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Foo</span>();</span><br><span class=\"line\">    <span class=\"built_in\">Foo</span>(<span class=\"keyword\">const</span>  Foo&amp;);  <span class=\"comment\">//可以用初始化列表，或在花括号里一一拷贝</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"合成拷贝构造函数\"><a href=\"#合成拷贝构造函数\" class=\"headerlink\" title=\"合成拷贝构造函数\"></a>合成拷贝构造函数</h3><p>如果用户没有为类定义一个拷贝构造函数，编译器会自动生成一个，执行<strong>浅拷贝</strong>，依次拷贝每个非 <code>static</code> 成员</p>\n<h3 id=\"直接初始化（无-号）\"><a href=\"#直接初始化（无-号）\" class=\"headerlink\" title=\"直接初始化（无=号）\"></a>直接初始化（无<code>=</code>号）</h3><p>匹配最佳的构造函数（注意也有可能匹配上拷贝构造函数）</p>\n<h3 id=\"拷贝初始化\"><a href=\"#拷贝初始化\" class=\"headerlink\" title=\"拷贝初始化\"></a>拷贝初始化</h3><p>使用拷贝初始化的常见四种情况：</p>\n<ol>\n<li><code>=</code>号</li>\n<li>函数非引用形参</li>\n<li>函数非引用返回类型 </li>\n<li>用花括号列表初始化一个数组中的元素或一个聚合类中的成员</li>\n</ol>\n<p>拷贝初始化有时候会使用<strong>移动构造函数</strong>而非<strong>拷贝构造函数</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Foo</span>(Foo &amp;&amp;f)&#123;&#125; <span class=\"comment\">//移动构造函数</span></span><br><span class=\"line\">    Foo&amp; <span class=\"keyword\">operator</span>=(Foo f)&#123;&#125; <span class=\"comment\">//普通左值既可以接受左值也可以接受右值，反正都是要拷贝的</span></span><br><span class=\"line\">    <span class=\"comment\">//注意上面这个不是拷贝赋值运算符，拷贝赋值运算符要求参数为常引用</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>观察：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Foo&amp; <span class=\"keyword\">operator</span>=(Foo f)&#123;&#125; <span class=\"comment\">//单一的赋值运算符实现了拷贝赋值运算符和移动赋值运算符两种可能</span></span><br></pre></td></tr></table></figure>\n\n<p>此运算符有一个<u>非引用</u>参数，所以要进行<u>拷贝初始化</u></p>\n<p>依赖于实参的类型，拷贝初始化要么使用拷贝构造函数，要么使用移动构造函数——<u>左值</u>被拷贝，<u>右值</u>被移动</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hp = hp2; \t\t\t\t<span class=\"comment\">//拷贝构造函数来拷贝hp2</span></span><br><span class=\"line\">hp = std::<span class=\"built_in\">move</span>(hp2);    <span class=\"comment\">//移动构造函数移动hp2</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>有点奇怪，按理说=号赋值应该调用拷贝赋值运算符，这里却调用那个非拷贝赋值运算符？</p>\n</blockquote>\n<h3 id=\"为什么拷贝构造函数自己的参数必须是引用类型？\"><a href=\"#为什么拷贝构造函数自己的参数必须是引用类型？\" class=\"headerlink\" title=\"为什么拷贝构造函数自己的参数必须是引用类型？\"></a>为什么拷贝构造函数自己的参数必须是引用类型？</h3><p>如果不是引用，则会调用拷贝构造函数，形成拷贝构造函数调用拷贝构造函数的死循环</p>\n<h3 id=\"编译器可以绕过拷贝-移动构造函数\"><a href=\"#编译器可以绕过拷贝-移动构造函数\" class=\"headerlink\" title=\"编译器可以绕过拷贝/移动构造函数\"></a>编译器可以绕过拷贝/移动构造函数</h3><p>拷贝初始化中，编译器可以选择跳过拷贝/移动构造函数，直接创建对象</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string null_book = <span class=\"string\">&quot;9999&quot;</span>; <span class=\"comment\">//拷贝初始化</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><strong>隐式类型转换（转换构造函数）</strong>：只接受一个实参，或者其他参数都有默认参数</p>\n<p>在需要类对象的时候，编译器可以根据已经有的一个参数，调用转换构造函数，自动创建一个（临时）对象</p>\n</blockquote>\n<p>正常来讲，字符串字面值<code>&quot;9999&quot;</code> 是<code>const char*</code>类型，由于要进行拷贝初始化，<code>=</code>号右边需要一个<code>string</code>对象，所以根据<strong>隐式类型转换</strong>，在需要<code>string</code>对象的时候，可以调用相应的<strong>转换构造函数</strong>，自动创建一个临时<code>string</code>对象：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">string</span> (<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* s); <span class=\"comment\">//from c-string (4)\t转换构造函数</span></span><br></pre></td></tr></table></figure>\n\n<p>有了临时<code>string</code>对象后，按理说要调用拷贝构造函数，完成对<code>null_book</code>的拷贝初始化</p>\n<p>然而，这里<strong>并没有</strong>调用拷贝构造函数，经测试<strong>也没有</strong>调用移动构造函数，原因是编译器对拷贝初始化表达式进行了改写</p>\n<p>把</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string null_book = <span class=\"string\">&quot;9999&quot;</span>; <span class=\"comment\">//拷贝初始化</span></span><br></pre></td></tr></table></figure>\n\n<p>改写为</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">string <span class=\"title\">null_book</span><span class=\"params\">(<span class=\"string\">&quot;9999&quot;</span>)</span></span>; <span class=\"comment\">// 使临时对象成为要创建的对象</span></span><br></pre></td></tr></table></figure>\n\n<p>按理说被改写后应该属于（调用拷贝构造函数的）直接初始化</p>\n<p>但是在利用转换构造函数生成临时<code>string</code>对象后</p>\n<p>编译器直接使临时对象成为要创建的对象（编译器优化），所以没有调用拷贝/移动构造函数</p>\n<p>其他例子：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Foo</span>() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\">    <span class=\"built_in\">Foo</span>(<span class=\"keyword\">const</span> Foo&amp; other) :<span class=\"built_in\">len</span>(other.len) &#123; cout &lt;&lt; <span class=\"string\">&quot;拷贝构造函数！&quot;</span> &lt;&lt; endl; &#125;  <span class=\"comment\">//拷贝构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">Foo</span>(<span class=\"keyword\">int</span> length) :<span class=\"built_in\">len</span>(length) &#123; cout &lt;&lt; <span class=\"string\">&quot;转换构造函数&quot;</span> &lt;&lt; endl; &#125; \t\t       <span class=\"comment\">//转换构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">Foo</span>(Foo&amp;&amp;) &#123; cout &lt;&lt; <span class=\"string\">&quot;移动构造函数&quot;</span> &lt;&lt; endl; &#125; \t\t\t\t\t\t\t   <span class=\"comment\">//移动构造函数</span></span><br><span class=\"line\">    <span class=\"function\">Foo&amp; <span class=\"title\">temp_f</span><span class=\"params\">(Foo temp)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Foo c1 = <span class=\"number\">10</span>; <span class=\"comment\">//本身为拷贝初始化，编译器将其改写为下一行的语句，不会调用拷贝/移动构造函数！</span></span><br><span class=\"line\">    <span class=\"function\">Foo <span class=\"title\">c</span><span class=\"params\">(<span class=\"number\">10</span>)</span></span>;  <span class=\"comment\">//不会调用拷贝/移动构造函数！只会调用转换构造函数</span></span><br><span class=\"line\">    c.<span class=\"built_in\">temp_f</span>(<span class=\"number\">10</span>); <span class=\"comment\">// 虽然形参非引用，但是也不会调用拷贝/移动构造函数！</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>解析一下这个：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">c.<span class=\"built_in\">temp_f</span>(<span class=\"number\">10</span>); <span class=\"comment\">// 虽然形参非引用，但是也不会调用拷贝/移动构造函数！</span></span><br></pre></td></tr></table></figure>\n\n<p>形参非引用，参数<code>10</code>被作为参数传入，先会调用转换构造函数，使<code>10</code>被隐式转换为一个<code>Foo临时对象</code></p>\n<p>注意，这个对象是临时的，临时量具有<u>常量性</u>（<code>const</code>属性）</p>\n<p><u>常量性</u>意味着：</p>\n<ol>\n<li><p>如果<code>temp_f</code>的形参是<code>左值引用&amp;</code>，将会报错，左值<u>引用</u>不能接受一个<code>const</code>值，左值引用也不能接受一个右值</p>\n</li>\n<li><p>如果<code>temp_f</code>的形参是<code>常量左值引用const &amp;</code>或<code>右值引用&amp;&amp;</code>，不会报错，因为它们都可以接受一个右值，而且因为是引用了，所以也不会调用拷贝构造函数</p>\n</li>\n<li><p>如果<code>temp_f</code>的形参是<code>普通左值</code>：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Foo&amp; <span class=\"title\">temp_f</span><span class=\"params\">(Foo temp)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>普通左值可以接受<code>const值</code>或<code>右值</code>，因为这就直接<u>拷贝</u>了，<code>const值</code>或<code>右值</code>没有被改变的风险</p>\n<p>例如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">42</span>;<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> ci = i;<span class=\"keyword\">int</span> j = ci;  <span class=\"comment\">// ci的常量特征仅仅在执行改变ci的操作时才会发挥作用，一旦拷贝完成，新的对象就和原来的对象没什么关系了</span></span><br></pre></td></tr></table></figure>\n\n<p>然后按理来说，函数形参非引用，应该是个拷贝初始化，调用拷贝构造函数</p>\n<p>但是没有！因为传给 temp_f 是一个<strong>匿名临时对象</strong>！</p>\n<p>只有一个对象对另一个同类型的对象进行初始化才会调用拷贝构造函数，但是<u>匿名对象对另一个同类型的对象初始化<strong>不会</strong>调用拷贝构造函数</u>，因为c++<strong>编译器</strong>对这种情况进行<strong>优化</strong>，<u>直接将匿名对象转化为该对象</u>，不需要进行额外的内存分配，提高了效率；</p>\n<p>编译器在此时进行了优化，<u>绕过了拷贝/移动构造函数</u>，将<code>Foo临时对象</code>直接创建了<code>Foo对象</code>作为形参，所以并没有调用拷贝/移动构造函数！</p>\n<p>参考解析：<a href=\"https://blog.csdn.net/weicao1990/article/details/81629955\">https://blog.csdn.net/weicao1990/article/details/81629955</a></p>\n<blockquote>\n<p>即使编译器略过了拷贝/移动构造函数，但在这个程序点上，拷贝/移动构造函数必须是可存在且可访问的（必须是<code>public</code>的，不能是<code>private</code>）</p>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"拷贝赋值运算符\"><a href=\"#拷贝赋值运算符\" class=\"headerlink\" title=\"拷贝赋值运算符\"></a>拷贝赋值运算符</h3><p>注意区分赋值和初始化</p>\n<p>返回类型为<u>引用</u>，形参为<u>常引用</u>：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Foo&amp; <span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> Foo&amp;); <span class=\"comment\">//赋值运算符</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>拷贝赋值运算符=重载赋值运算符</p>\n<p>重载赋值运算符的参数表示运算符的<strong>运算对象</strong></p>\n<p>如果一个运算符是成员函数（<strong>赋值运算符必须定义为成员函数</strong>），则其第一个参数肯定是<strong>隐式this参数</strong>，这也是该运算符的（<strong>左侧</strong>）运算对象</p>\n<ul>\n<li>如果是一元运算符，就只有这一个运算对象</li>\n<li>如果是二元运算符（例如赋值运算符），其<strong>右侧</strong>运算对象作为<strong>显示</strong>参数传递</li>\n</ul>\n</blockquote>\n<p>如果类没有定义自己的拷贝赋值运算符，编译器会自动合成一个合成拷贝赋值运算符</p>\n<p>但是<strong>合成拷贝赋值运算符</strong>实行<strong>浅</strong>拷贝，当对象中存在指针成员变量时，存在如下问题：</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211124194517073.png\" alt=\"原生赋值运算符\"></p>\n<p>所以当对象中存在指针成员变量， 应该自定义新的拷贝赋值构造函数，执行<strong>深</strong>拷贝</p>\n<h3 id=\"2-对象移动\"><a href=\"#2-对象移动\" class=\"headerlink\" title=\"2. 对象移动\"></a>2. 对象移动</h3><h4 id=\"2-1-右值引用\"><a href=\"#2-1-右值引用\" class=\"headerlink\" title=\"2.1 右值引用\"></a>2.1 右值引用</h4><p>符号：<code>&amp;&amp;</code></p>\n<p><strong>右值引用</strong>只能绑定到一个将要销毁的对象（临时对象）</p>\n<p><strong>左值引用</strong>不能被绑定到要求转换的表达式，字面常量或是返回右值的表达式，但<u>右值引用可以</u>，但不能将一个右值引用直接绑定到一个左值上</p>\n<ul>\n<li>返回左值的表达式（可以被<code>左值引用</code>绑定）：返回左值引用的函数，包括赋值、下标、解引用和前置递增/递减运算符</li>\n<li>返回右值的表达式（可以被<code>const左值引用</code>、<code>右值引用&amp;&amp;</code>绑定）：返回非引用类型的函数，包括算数、关系、位以及后置递增/递减运算符</li>\n</ul>\n<p>变量是持久的，包括右值引用类型的左值，所以<u>不能将一个右值引用绑定到一个右值引用类型的变量上</u>：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> &amp;&amp;rr1 = <span class=\"number\">42</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> &amp;&amp;rr2 = rr1; <span class=\"comment\">//错误！变量表达式 rr1 是左值</span></span><br></pre></td></tr></table></figure>\n\n<p><code>std::move</code>显示地将左值转变为右值</p>\n<h4 id=\"2-2-移动构造函数（移动语义）\"><a href=\"#2-2-移动构造函数（移动语义）\" class=\"headerlink\" title=\"2.2 移动构造函数（移动语义）\"></a>2.2 移动构造函数（移动语义）</h4><p>以移动而非深拷贝的方式初始化含有指针成员的类对象</p>\n<p>移动构造函数的第一个参数为右值引用，任何额外的参数都必须有默认实参</p>\n<ol>\n<li>指针资源交接</li>\n<li>原来的指针应该指向<code>nullptr</code></li>\n</ol>\n<p>浅拷贝+销毁=移动</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">demo</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">demo</span>():<span class=\"built_in\">num</span>(<span class=\"keyword\">new</span> <span class=\"built_in\"><span class=\"keyword\">int</span></span>(<span class=\"number\">0</span>))&#123;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;construct!&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">demo</span>(<span class=\"keyword\">const</span> demo &amp;d):<span class=\"built_in\">num</span>(<span class=\"keyword\">new</span> <span class=\"built_in\"><span class=\"keyword\">int</span></span>(*d.num))&#123;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;copy construct!&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//添加移动构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">demo</span>(demo &amp;&amp;d):<span class=\"built_in\">num</span>(d.num)&#123;</span><br><span class=\"line\">        d.num = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;move construct!&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ~<span class=\"built_in\">demo</span>()&#123;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;class destruct!&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *num;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\">demo <span class=\"title\">get_demo</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">demo</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    demo a = <span class=\"built_in\">get_demo</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//结果：为 demo 类添加移动构造函数之后，使用临时对象初始化 a 对象过程中产生的 2 次拷贝操作，都由移动构造函数完成</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>当类中同时包含拷贝构造函数和移动构造函数时，如果使用<strong>临时对象</strong>初始化当前类的对象，编译器会<strong>优先调用移动构造函数</strong>来完成此操作。</p>\n<p>只有当类中没有合适的移动构造函数时，编译器才会退而求其次，用拷贝构造函数<strong>代替</strong>移动构造函数（赋值运算符的情况类类似）</p>\n</blockquote>\n<h4 id=\"2-3-移动赋值运算符\"><a href=\"#2-3-移动赋值运算符\" class=\"headerlink\" title=\"2.3 移动赋值运算符\"></a>2.3 移动赋值运算符</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">StrVec&amp; StrVec::<span class=\"keyword\">operator</span>=(StrVec &amp;&amp;rhs) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//直接检测自赋值</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> != &amp;rhs) &#123; <span class=\"comment\">//rhs是个右值引用变量表达式，所以它是个左值，所以可以对它取地址</span></span><br><span class=\"line\">        <span class=\"built_in\">free</span>();    \t\t<span class=\"comment\">//释放已有元素</span></span><br><span class=\"line\">        elements = rhs.elements; <span class=\"comment\">// 从rhs接管资源</span></span><br><span class=\"line\">        first_free = rhs.first_free;</span><br><span class=\"line\">        cap = rhs.cap;</span><br><span class=\"line\">        <span class=\"comment\">// 将rhs置于可析构状态</span></span><br><span class=\"line\">        rhs.elements = rhs.first_free = rhs.cap = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-4-合成的移动操作\"><a href=\"#2-4-合成的移动操作\" class=\"headerlink\" title=\"2.4 合成的移动操作\"></a>2.4 合成的移动操作</h4><p>如果一个类定义了自己的拷贝构造函数、拷贝赋值运算符或者析构函数，编译器就<strong>不会自动合成</strong>移动构造函数和移动赋值运算符</p>\n<p>仅当一个类没有定义任何自己版本的拷贝控制成员（三大件），且类的每个非static数据成员都可以移动时，编译器才会自动合成移动构造函数或移动赋值运算符</p>\n<p>可移动：</p>\n<ul>\n<li>内置类型总是可移动的</li>\n<li>类类型，要求该类有对应的移动操作</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//编译器会为X和hasX合成移动操作</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">X</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;  \t\t\t<span class=\"comment\">//内置类型可以移动</span></span><br><span class=\"line\">    std::string s; \t\t<span class=\"comment\">//string定义了自己的移动操作</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">hasX</span> &#123;</span></span><br><span class=\"line\">    X mem;\t\t\t\t<span class=\"comment\">// X有合成的移动操作</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">X x, x2 = std::<span class=\"built_in\">move</span>(x); \t  <span class=\"comment\">//使用合成的移动构造操作</span></span><br><span class=\"line\">hasX hx, hx2 = std::<span class=\"built_in\">move</span>(hx); <span class=\"comment\">//使用合成的移动构造函数</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<h3 id=\"拷贝构造函数\"><a href=\"#拷贝构造函数\" class=\"headerlink\" title=\"拷贝构造函数\"></a>拷贝构造函数</h3><p>要么只有一个参数，此参数是自身类类型的常引用，要么多个参数，第一个参数为自身类类型的常引用，其他参数都有默认值</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Foo</span>();</span><br><span class=\"line\">    <span class=\"built_in\">Foo</span>(<span class=\"keyword\">const</span>  Foo&amp;);  <span class=\"comment\">//可以用初始化列表，或在花括号里一一拷贝</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"合成拷贝构造函数\"><a href=\"#合成拷贝构造函数\" class=\"headerlink\" title=\"合成拷贝构造函数\"></a>合成拷贝构造函数</h3><p>如果用户没有为类定义一个拷贝构造函数，编译器会自动生成一个，执行<strong>浅拷贝</strong>，依次拷贝每个非 <code>static</code> 成员</p>\n<h3 id=\"直接初始化（无-号）\"><a href=\"#直接初始化（无-号）\" class=\"headerlink\" title=\"直接初始化（无=号）\"></a>直接初始化（无<code>=</code>号）</h3><p>匹配最佳的构造函数（注意也有可能匹配上拷贝构造函数）</p>\n<h3 id=\"拷贝初始化\"><a href=\"#拷贝初始化\" class=\"headerlink\" title=\"拷贝初始化\"></a>拷贝初始化</h3><p>使用拷贝初始化的常见四种情况：</p>\n<ol>\n<li><code>=</code>号</li>\n<li>函数非引用形参</li>\n<li>函数非引用返回类型 </li>\n<li>用花括号列表初始化一个数组中的元素或一个聚合类中的成员</li>\n</ol>\n<p>拷贝初始化有时候会使用<strong>移动构造函数</strong>而非<strong>拷贝构造函数</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Foo</span>(Foo &amp;&amp;f)&#123;&#125; <span class=\"comment\">//移动构造函数</span></span><br><span class=\"line\">    Foo&amp; <span class=\"keyword\">operator</span>=(Foo f)&#123;&#125; <span class=\"comment\">//普通左值既可以接受左值也可以接受右值，反正都是要拷贝的</span></span><br><span class=\"line\">    <span class=\"comment\">//注意上面这个不是拷贝赋值运算符，拷贝赋值运算符要求参数为常引用</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>观察：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Foo&amp; <span class=\"keyword\">operator</span>=(Foo f)&#123;&#125; <span class=\"comment\">//单一的赋值运算符实现了拷贝赋值运算符和移动赋值运算符两种可能</span></span><br></pre></td></tr></table></figure>\n\n<p>此运算符有一个<u>非引用</u>参数，所以要进行<u>拷贝初始化</u></p>\n<p>依赖于实参的类型，拷贝初始化要么使用拷贝构造函数，要么使用移动构造函数——<u>左值</u>被拷贝，<u>右值</u>被移动</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hp = hp2; \t\t\t\t<span class=\"comment\">//拷贝构造函数来拷贝hp2</span></span><br><span class=\"line\">hp = std::<span class=\"built_in\">move</span>(hp2);    <span class=\"comment\">//移动构造函数移动hp2</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>有点奇怪，按理说=号赋值应该调用拷贝赋值运算符，这里却调用那个非拷贝赋值运算符？</p>\n</blockquote>\n<h3 id=\"为什么拷贝构造函数自己的参数必须是引用类型？\"><a href=\"#为什么拷贝构造函数自己的参数必须是引用类型？\" class=\"headerlink\" title=\"为什么拷贝构造函数自己的参数必须是引用类型？\"></a>为什么拷贝构造函数自己的参数必须是引用类型？</h3><p>如果不是引用，则会调用拷贝构造函数，形成拷贝构造函数调用拷贝构造函数的死循环</p>\n<h3 id=\"编译器可以绕过拷贝-移动构造函数\"><a href=\"#编译器可以绕过拷贝-移动构造函数\" class=\"headerlink\" title=\"编译器可以绕过拷贝/移动构造函数\"></a>编译器可以绕过拷贝/移动构造函数</h3><p>拷贝初始化中，编译器可以选择跳过拷贝/移动构造函数，直接创建对象</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string null_book = <span class=\"string\">&quot;9999&quot;</span>; <span class=\"comment\">//拷贝初始化</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><strong>隐式类型转换（转换构造函数）</strong>：只接受一个实参，或者其他参数都有默认参数</p>\n<p>在需要类对象的时候，编译器可以根据已经有的一个参数，调用转换构造函数，自动创建一个（临时）对象</p>\n</blockquote>\n<p>正常来讲，字符串字面值<code>&quot;9999&quot;</code> 是<code>const char*</code>类型，由于要进行拷贝初始化，<code>=</code>号右边需要一个<code>string</code>对象，所以根据<strong>隐式类型转换</strong>，在需要<code>string</code>对象的时候，可以调用相应的<strong>转换构造函数</strong>，自动创建一个临时<code>string</code>对象：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">string</span> (<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* s); <span class=\"comment\">//from c-string (4)\t转换构造函数</span></span><br></pre></td></tr></table></figure>\n\n<p>有了临时<code>string</code>对象后，按理说要调用拷贝构造函数，完成对<code>null_book</code>的拷贝初始化</p>\n<p>然而，这里<strong>并没有</strong>调用拷贝构造函数，经测试<strong>也没有</strong>调用移动构造函数，原因是编译器对拷贝初始化表达式进行了改写</p>\n<p>把</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string null_book = <span class=\"string\">&quot;9999&quot;</span>; <span class=\"comment\">//拷贝初始化</span></span><br></pre></td></tr></table></figure>\n\n<p>改写为</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">string <span class=\"title\">null_book</span><span class=\"params\">(<span class=\"string\">&quot;9999&quot;</span>)</span></span>; <span class=\"comment\">// 使临时对象成为要创建的对象</span></span><br></pre></td></tr></table></figure>\n\n<p>按理说被改写后应该属于（调用拷贝构造函数的）直接初始化</p>\n<p>但是在利用转换构造函数生成临时<code>string</code>对象后</p>\n<p>编译器直接使临时对象成为要创建的对象（编译器优化），所以没有调用拷贝/移动构造函数</p>\n<p>其他例子：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Foo</span>() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\">    <span class=\"built_in\">Foo</span>(<span class=\"keyword\">const</span> Foo&amp; other) :<span class=\"built_in\">len</span>(other.len) &#123; cout &lt;&lt; <span class=\"string\">&quot;拷贝构造函数！&quot;</span> &lt;&lt; endl; &#125;  <span class=\"comment\">//拷贝构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">Foo</span>(<span class=\"keyword\">int</span> length) :<span class=\"built_in\">len</span>(length) &#123; cout &lt;&lt; <span class=\"string\">&quot;转换构造函数&quot;</span> &lt;&lt; endl; &#125; \t\t       <span class=\"comment\">//转换构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">Foo</span>(Foo&amp;&amp;) &#123; cout &lt;&lt; <span class=\"string\">&quot;移动构造函数&quot;</span> &lt;&lt; endl; &#125; \t\t\t\t\t\t\t   <span class=\"comment\">//移动构造函数</span></span><br><span class=\"line\">    <span class=\"function\">Foo&amp; <span class=\"title\">temp_f</span><span class=\"params\">(Foo temp)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Foo c1 = <span class=\"number\">10</span>; <span class=\"comment\">//本身为拷贝初始化，编译器将其改写为下一行的语句，不会调用拷贝/移动构造函数！</span></span><br><span class=\"line\">    <span class=\"function\">Foo <span class=\"title\">c</span><span class=\"params\">(<span class=\"number\">10</span>)</span></span>;  <span class=\"comment\">//不会调用拷贝/移动构造函数！只会调用转换构造函数</span></span><br><span class=\"line\">    c.<span class=\"built_in\">temp_f</span>(<span class=\"number\">10</span>); <span class=\"comment\">// 虽然形参非引用，但是也不会调用拷贝/移动构造函数！</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>解析一下这个：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">c.<span class=\"built_in\">temp_f</span>(<span class=\"number\">10</span>); <span class=\"comment\">// 虽然形参非引用，但是也不会调用拷贝/移动构造函数！</span></span><br></pre></td></tr></table></figure>\n\n<p>形参非引用，参数<code>10</code>被作为参数传入，先会调用转换构造函数，使<code>10</code>被隐式转换为一个<code>Foo临时对象</code></p>\n<p>注意，这个对象是临时的，临时量具有<u>常量性</u>（<code>const</code>属性）</p>\n<p><u>常量性</u>意味着：</p>\n<ol>\n<li><p>如果<code>temp_f</code>的形参是<code>左值引用&amp;</code>，将会报错，左值<u>引用</u>不能接受一个<code>const</code>值，左值引用也不能接受一个右值</p>\n</li>\n<li><p>如果<code>temp_f</code>的形参是<code>常量左值引用const &amp;</code>或<code>右值引用&amp;&amp;</code>，不会报错，因为它们都可以接受一个右值，而且因为是引用了，所以也不会调用拷贝构造函数</p>\n</li>\n<li><p>如果<code>temp_f</code>的形参是<code>普通左值</code>：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Foo&amp; <span class=\"title\">temp_f</span><span class=\"params\">(Foo temp)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>普通左值可以接受<code>const值</code>或<code>右值</code>，因为这就直接<u>拷贝</u>了，<code>const值</code>或<code>右值</code>没有被改变的风险</p>\n<p>例如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">42</span>;<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> ci = i;<span class=\"keyword\">int</span> j = ci;  <span class=\"comment\">// ci的常量特征仅仅在执行改变ci的操作时才会发挥作用，一旦拷贝完成，新的对象就和原来的对象没什么关系了</span></span><br></pre></td></tr></table></figure>\n\n<p>然后按理来说，函数形参非引用，应该是个拷贝初始化，调用拷贝构造函数</p>\n<p>但是没有！因为传给 temp_f 是一个<strong>匿名临时对象</strong>！</p>\n<p>只有一个对象对另一个同类型的对象进行初始化才会调用拷贝构造函数，但是<u>匿名对象对另一个同类型的对象初始化<strong>不会</strong>调用拷贝构造函数</u>，因为c++<strong>编译器</strong>对这种情况进行<strong>优化</strong>，<u>直接将匿名对象转化为该对象</u>，不需要进行额外的内存分配，提高了效率；</p>\n<p>编译器在此时进行了优化，<u>绕过了拷贝/移动构造函数</u>，将<code>Foo临时对象</code>直接创建了<code>Foo对象</code>作为形参，所以并没有调用拷贝/移动构造函数！</p>\n<p>参考解析：<a href=\"https://blog.csdn.net/weicao1990/article/details/81629955\">https://blog.csdn.net/weicao1990/article/details/81629955</a></p>\n<blockquote>\n<p>即使编译器略过了拷贝/移动构造函数，但在这个程序点上，拷贝/移动构造函数必须是可存在且可访问的（必须是<code>public</code>的，不能是<code>private</code>）</p>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"拷贝赋值运算符\"><a href=\"#拷贝赋值运算符\" class=\"headerlink\" title=\"拷贝赋值运算符\"></a>拷贝赋值运算符</h3><p>注意区分赋值和初始化</p>\n<p>返回类型为<u>引用</u>，形参为<u>常引用</u>：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Foo&amp; <span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> Foo&amp;); <span class=\"comment\">//赋值运算符</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>拷贝赋值运算符=重载赋值运算符</p>\n<p>重载赋值运算符的参数表示运算符的<strong>运算对象</strong></p>\n<p>如果一个运算符是成员函数（<strong>赋值运算符必须定义为成员函数</strong>），则其第一个参数肯定是<strong>隐式this参数</strong>，这也是该运算符的（<strong>左侧</strong>）运算对象</p>\n<ul>\n<li>如果是一元运算符，就只有这一个运算对象</li>\n<li>如果是二元运算符（例如赋值运算符），其<strong>右侧</strong>运算对象作为<strong>显示</strong>参数传递</li>\n</ul>\n</blockquote>\n<p>如果类没有定义自己的拷贝赋值运算符，编译器会自动合成一个合成拷贝赋值运算符</p>\n<p>但是<strong>合成拷贝赋值运算符</strong>实行<strong>浅</strong>拷贝，当对象中存在指针成员变量时，存在如下问题：</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211124194517073.png\" alt=\"原生赋值运算符\"></p>\n<p>所以当对象中存在指针成员变量， 应该自定义新的拷贝赋值构造函数，执行<strong>深</strong>拷贝</p>\n<h3 id=\"2-对象移动\"><a href=\"#2-对象移动\" class=\"headerlink\" title=\"2. 对象移动\"></a>2. 对象移动</h3><h4 id=\"2-1-右值引用\"><a href=\"#2-1-右值引用\" class=\"headerlink\" title=\"2.1 右值引用\"></a>2.1 右值引用</h4><p>符号：<code>&amp;&amp;</code></p>\n<p><strong>右值引用</strong>只能绑定到一个将要销毁的对象（临时对象）</p>\n<p><strong>左值引用</strong>不能被绑定到要求转换的表达式，字面常量或是返回右值的表达式，但<u>右值引用可以</u>，但不能将一个右值引用直接绑定到一个左值上</p>\n<ul>\n<li>返回左值的表达式（可以被<code>左值引用</code>绑定）：返回左值引用的函数，包括赋值、下标、解引用和前置递增/递减运算符</li>\n<li>返回右值的表达式（可以被<code>const左值引用</code>、<code>右值引用&amp;&amp;</code>绑定）：返回非引用类型的函数，包括算数、关系、位以及后置递增/递减运算符</li>\n</ul>\n<p>变量是持久的，包括右值引用类型的左值，所以<u>不能将一个右值引用绑定到一个右值引用类型的变量上</u>：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> &amp;&amp;rr1 = <span class=\"number\">42</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> &amp;&amp;rr2 = rr1; <span class=\"comment\">//错误！变量表达式 rr1 是左值</span></span><br></pre></td></tr></table></figure>\n\n<p><code>std::move</code>显示地将左值转变为右值</p>\n<h4 id=\"2-2-移动构造函数（移动语义）\"><a href=\"#2-2-移动构造函数（移动语义）\" class=\"headerlink\" title=\"2.2 移动构造函数（移动语义）\"></a>2.2 移动构造函数（移动语义）</h4><p>以移动而非深拷贝的方式初始化含有指针成员的类对象</p>\n<p>移动构造函数的第一个参数为右值引用，任何额外的参数都必须有默认实参</p>\n<ol>\n<li>指针资源交接</li>\n<li>原来的指针应该指向<code>nullptr</code></li>\n</ol>\n<p>浅拷贝+销毁=移动</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">demo</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">demo</span>():<span class=\"built_in\">num</span>(<span class=\"keyword\">new</span> <span class=\"built_in\"><span class=\"keyword\">int</span></span>(<span class=\"number\">0</span>))&#123;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;construct!&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">demo</span>(<span class=\"keyword\">const</span> demo &amp;d):<span class=\"built_in\">num</span>(<span class=\"keyword\">new</span> <span class=\"built_in\"><span class=\"keyword\">int</span></span>(*d.num))&#123;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;copy construct!&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//添加移动构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">demo</span>(demo &amp;&amp;d):<span class=\"built_in\">num</span>(d.num)&#123;</span><br><span class=\"line\">        d.num = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;move construct!&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ~<span class=\"built_in\">demo</span>()&#123;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;class destruct!&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *num;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\">demo <span class=\"title\">get_demo</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">demo</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    demo a = <span class=\"built_in\">get_demo</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//结果：为 demo 类添加移动构造函数之后，使用临时对象初始化 a 对象过程中产生的 2 次拷贝操作，都由移动构造函数完成</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>当类中同时包含拷贝构造函数和移动构造函数时，如果使用<strong>临时对象</strong>初始化当前类的对象，编译器会<strong>优先调用移动构造函数</strong>来完成此操作。</p>\n<p>只有当类中没有合适的移动构造函数时，编译器才会退而求其次，用拷贝构造函数<strong>代替</strong>移动构造函数（赋值运算符的情况类类似）</p>\n</blockquote>\n<h4 id=\"2-3-移动赋值运算符\"><a href=\"#2-3-移动赋值运算符\" class=\"headerlink\" title=\"2.3 移动赋值运算符\"></a>2.3 移动赋值运算符</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">StrVec&amp; StrVec::<span class=\"keyword\">operator</span>=(StrVec &amp;&amp;rhs) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//直接检测自赋值</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> != &amp;rhs) &#123; <span class=\"comment\">//rhs是个右值引用变量表达式，所以它是个左值，所以可以对它取地址</span></span><br><span class=\"line\">        <span class=\"built_in\">free</span>();    \t\t<span class=\"comment\">//释放已有元素</span></span><br><span class=\"line\">        elements = rhs.elements; <span class=\"comment\">// 从rhs接管资源</span></span><br><span class=\"line\">        first_free = rhs.first_free;</span><br><span class=\"line\">        cap = rhs.cap;</span><br><span class=\"line\">        <span class=\"comment\">// 将rhs置于可析构状态</span></span><br><span class=\"line\">        rhs.elements = rhs.first_free = rhs.cap = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-4-合成的移动操作\"><a href=\"#2-4-合成的移动操作\" class=\"headerlink\" title=\"2.4 合成的移动操作\"></a>2.4 合成的移动操作</h4><p>如果一个类定义了自己的拷贝构造函数、拷贝赋值运算符或者析构函数，编译器就<strong>不会自动合成</strong>移动构造函数和移动赋值运算符</p>\n<p>仅当一个类没有定义任何自己版本的拷贝控制成员（三大件），且类的每个非static数据成员都可以移动时，编译器才会自动合成移动构造函数或移动赋值运算符</p>\n<p>可移动：</p>\n<ul>\n<li>内置类型总是可移动的</li>\n<li>类类型，要求该类有对应的移动操作</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//编译器会为X和hasX合成移动操作</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">X</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;  \t\t\t<span class=\"comment\">//内置类型可以移动</span></span><br><span class=\"line\">    std::string s; \t\t<span class=\"comment\">//string定义了自己的移动操作</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">hasX</span> &#123;</span></span><br><span class=\"line\">    X mem;\t\t\t\t<span class=\"comment\">// X有合成的移动操作</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">X x, x2 = std::<span class=\"built_in\">move</span>(x); \t  <span class=\"comment\">//使用合成的移动构造操作</span></span><br><span class=\"line\">hasX hx, hx2 = std::<span class=\"built_in\">move</span>(hx); <span class=\"comment\">//使用合成的移动构造函数</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n"},{"_content":"## 继承中的类作用域\n\n如果一个名字在派生类作用域内无法正确解析，则编译器将在外层的基类作用域中寻找该名字的定义：\n\n![image-20211202155500117](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211202155500117.png)\n\n正因为类作用域有这种继承嵌套的关系，所以派生类才能像使用自己的成员一样使用基类的成员（所以虽然放在派生类那里，实际上还是基类的成员）\n\n### 1. 重载 vs. 覆盖 vs. 隐藏\n\n#### 1.1 重载\n\n1. 在同一个类中（与继承关系无关）\n2. `函数名`一样，`形参列表`（数目、类型、排列顺序）**不**一样\n3. 返回类型**随便**\n\n#### 1.2 覆盖\n\n1. 基类和派生类的关系\n\n2. 要求基类的是虚函数（如果虚函数被继承，则所有派生类中它都是虚函数）\n\n3. 函数名、形参列表**相同**\n\n4. 返回类型要么**相同**，要么可以自动类型转换\n\n   > 如果 `D` 由 `B` 派生得到，则基类的虚函数可以返回 `B*` 而派生类的对应函数可以返回 `D*`（要求从 `D` 到 `B` 的类型转换是可访问的）\n\n#### 1.3 隐藏\n\n不仅仅是函数，普通类成员也可以隐藏\n\n1. 基类和派生类的关系\n2. **同名** & **排除**覆盖的情况\n\n### 2. 名字查找与继承\n\n假定我们调用 `p->mem()` 或 `obj.mem()`，则依次执行以下4个步骤\n\n1. 首先确定 `p` 的静态类型\n\n2. 在 p 中的静态类型对应的类中查找 `mem`。\n\n   > - 查找名字，编译器从静态类型开始向上查找，直到找到就停止，或者到达继承链的顶端还没有找到，则编译器报错\n   >\n   > - 我们能使用哪些成员仍然是由静态类型决定的\n\n3. 一旦找到了 `mem`，就进行常规的类型检查，以确认对于当前找到的 mem，本次调用是否合法\n\n4. 假设调用合法，则编译器将根据调用的**是否是虚函数**而产生不同的代码：\n\n   - 如果**是虚函数**，且我们是**通过引用或指针**进行调用，则编译器产生的代码将进行动态绑定，在运行时确定到底运行该虚函数的哪个版本，依据对象的动态类型\n   - 如果**不是虚函数**，或者我们是**通过对象（而非引用或指针）**进行的调用，则编译器将产生一个常规的函数调用\n\n\n\n","source":"_posts/C++/类/名字查找与继承.md","raw":"## 继承中的类作用域\n\n如果一个名字在派生类作用域内无法正确解析，则编译器将在外层的基类作用域中寻找该名字的定义：\n\n![image-20211202155500117](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211202155500117.png)\n\n正因为类作用域有这种继承嵌套的关系，所以派生类才能像使用自己的成员一样使用基类的成员（所以虽然放在派生类那里，实际上还是基类的成员）\n\n### 1. 重载 vs. 覆盖 vs. 隐藏\n\n#### 1.1 重载\n\n1. 在同一个类中（与继承关系无关）\n2. `函数名`一样，`形参列表`（数目、类型、排列顺序）**不**一样\n3. 返回类型**随便**\n\n#### 1.2 覆盖\n\n1. 基类和派生类的关系\n\n2. 要求基类的是虚函数（如果虚函数被继承，则所有派生类中它都是虚函数）\n\n3. 函数名、形参列表**相同**\n\n4. 返回类型要么**相同**，要么可以自动类型转换\n\n   > 如果 `D` 由 `B` 派生得到，则基类的虚函数可以返回 `B*` 而派生类的对应函数可以返回 `D*`（要求从 `D` 到 `B` 的类型转换是可访问的）\n\n#### 1.3 隐藏\n\n不仅仅是函数，普通类成员也可以隐藏\n\n1. 基类和派生类的关系\n2. **同名** & **排除**覆盖的情况\n\n### 2. 名字查找与继承\n\n假定我们调用 `p->mem()` 或 `obj.mem()`，则依次执行以下4个步骤\n\n1. 首先确定 `p` 的静态类型\n\n2. 在 p 中的静态类型对应的类中查找 `mem`。\n\n   > - 查找名字，编译器从静态类型开始向上查找，直到找到就停止，或者到达继承链的顶端还没有找到，则编译器报错\n   >\n   > - 我们能使用哪些成员仍然是由静态类型决定的\n\n3. 一旦找到了 `mem`，就进行常规的类型检查，以确认对于当前找到的 mem，本次调用是否合法\n\n4. 假设调用合法，则编译器将根据调用的**是否是虚函数**而产生不同的代码：\n\n   - 如果**是虚函数**，且我们是**通过引用或指针**进行调用，则编译器产生的代码将进行动态绑定，在运行时确定到底运行该虚函数的哪个版本，依据对象的动态类型\n   - 如果**不是虚函数**，或者我们是**通过对象（而非引用或指针）**进行的调用，则编译器将产生一个常规的函数调用\n\n\n\n","slug":"C++/类/名字查找与继承","published":1,"date":"2021-12-31T02:09:01.608Z","updated":"2022-03-10T07:05:43.367Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0kxz001gpcu3e5pre32l","content":"<h2 id=\"继承中的类作用域\"><a href=\"#继承中的类作用域\" class=\"headerlink\" title=\"继承中的类作用域\"></a>继承中的类作用域</h2><p>如果一个名字在派生类作用域内无法正确解析，则编译器将在外层的基类作用域中寻找该名字的定义：</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211202155500117.png\" alt=\"image-20211202155500117\"></p>\n<p>正因为类作用域有这种继承嵌套的关系，所以派生类才能像使用自己的成员一样使用基类的成员（所以虽然放在派生类那里，实际上还是基类的成员）</p>\n<h3 id=\"1-重载-vs-覆盖-vs-隐藏\"><a href=\"#1-重载-vs-覆盖-vs-隐藏\" class=\"headerlink\" title=\"1. 重载 vs. 覆盖 vs. 隐藏\"></a>1. 重载 vs. 覆盖 vs. 隐藏</h3><h4 id=\"1-1-重载\"><a href=\"#1-1-重载\" class=\"headerlink\" title=\"1.1 重载\"></a>1.1 重载</h4><ol>\n<li>在同一个类中（与继承关系无关）</li>\n<li><code>函数名</code>一样，<code>形参列表</code>（数目、类型、排列顺序）<strong>不</strong>一样</li>\n<li>返回类型<strong>随便</strong></li>\n</ol>\n<h4 id=\"1-2-覆盖\"><a href=\"#1-2-覆盖\" class=\"headerlink\" title=\"1.2 覆盖\"></a>1.2 覆盖</h4><ol>\n<li><p>基类和派生类的关系</p>\n</li>\n<li><p>要求基类的是虚函数（如果虚函数被继承，则所有派生类中它都是虚函数）</p>\n</li>\n<li><p>函数名、形参列表<strong>相同</strong></p>\n</li>\n<li><p>返回类型要么<strong>相同</strong>，要么可以自动类型转换</p>\n<blockquote>\n<p>如果 <code>D</code> 由 <code>B</code> 派生得到，则基类的虚函数可以返回 <code>B*</code> 而派生类的对应函数可以返回 <code>D*</code>（要求从 <code>D</code> 到 <code>B</code> 的类型转换是可访问的）</p>\n</blockquote>\n</li>\n</ol>\n<h4 id=\"1-3-隐藏\"><a href=\"#1-3-隐藏\" class=\"headerlink\" title=\"1.3 隐藏\"></a>1.3 隐藏</h4><p>不仅仅是函数，普通类成员也可以隐藏</p>\n<ol>\n<li>基类和派生类的关系</li>\n<li><strong>同名</strong> &amp; <strong>排除</strong>覆盖的情况</li>\n</ol>\n<h3 id=\"2-名字查找与继承\"><a href=\"#2-名字查找与继承\" class=\"headerlink\" title=\"2. 名字查找与继承\"></a>2. 名字查找与继承</h3><p>假定我们调用 <code>p-&gt;mem()</code> 或 <code>obj.mem()</code>，则依次执行以下4个步骤</p>\n<ol>\n<li><p>首先确定 <code>p</code> 的静态类型</p>\n</li>\n<li><p>在 p 中的静态类型对应的类中查找 <code>mem</code>。</p>\n<blockquote>\n<ul>\n<li><p>查找名字，编译器从静态类型开始向上查找，直到找到就停止，或者到达继承链的顶端还没有找到，则编译器报错</p>\n</li>\n<li><p>我们能使用哪些成员仍然是由静态类型决定的</p>\n</li>\n</ul>\n</blockquote>\n</li>\n<li><p>一旦找到了 <code>mem</code>，就进行常规的类型检查，以确认对于当前找到的 mem，本次调用是否合法</p>\n</li>\n<li><p>假设调用合法，则编译器将根据调用的<strong>是否是虚函数</strong>而产生不同的代码：</p>\n<ul>\n<li>如果<strong>是虚函数</strong>，且我们是<strong>通过引用或指针</strong>进行调用，则编译器产生的代码将进行动态绑定，在运行时确定到底运行该虚函数的哪个版本，依据对象的动态类型</li>\n<li>如果<strong>不是虚函数</strong>，或者我们是<strong>通过对象（而非引用或指针）</strong>进行的调用，则编译器将产生一个常规的函数调用</li>\n</ul>\n</li>\n</ol>\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<h2 id=\"继承中的类作用域\"><a href=\"#继承中的类作用域\" class=\"headerlink\" title=\"继承中的类作用域\"></a>继承中的类作用域</h2><p>如果一个名字在派生类作用域内无法正确解析，则编译器将在外层的基类作用域中寻找该名字的定义：</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211202155500117.png\" alt=\"image-20211202155500117\"></p>\n<p>正因为类作用域有这种继承嵌套的关系，所以派生类才能像使用自己的成员一样使用基类的成员（所以虽然放在派生类那里，实际上还是基类的成员）</p>\n<h3 id=\"1-重载-vs-覆盖-vs-隐藏\"><a href=\"#1-重载-vs-覆盖-vs-隐藏\" class=\"headerlink\" title=\"1. 重载 vs. 覆盖 vs. 隐藏\"></a>1. 重载 vs. 覆盖 vs. 隐藏</h3><h4 id=\"1-1-重载\"><a href=\"#1-1-重载\" class=\"headerlink\" title=\"1.1 重载\"></a>1.1 重载</h4><ol>\n<li>在同一个类中（与继承关系无关）</li>\n<li><code>函数名</code>一样，<code>形参列表</code>（数目、类型、排列顺序）<strong>不</strong>一样</li>\n<li>返回类型<strong>随便</strong></li>\n</ol>\n<h4 id=\"1-2-覆盖\"><a href=\"#1-2-覆盖\" class=\"headerlink\" title=\"1.2 覆盖\"></a>1.2 覆盖</h4><ol>\n<li><p>基类和派生类的关系</p>\n</li>\n<li><p>要求基类的是虚函数（如果虚函数被继承，则所有派生类中它都是虚函数）</p>\n</li>\n<li><p>函数名、形参列表<strong>相同</strong></p>\n</li>\n<li><p>返回类型要么<strong>相同</strong>，要么可以自动类型转换</p>\n<blockquote>\n<p>如果 <code>D</code> 由 <code>B</code> 派生得到，则基类的虚函数可以返回 <code>B*</code> 而派生类的对应函数可以返回 <code>D*</code>（要求从 <code>D</code> 到 <code>B</code> 的类型转换是可访问的）</p>\n</blockquote>\n</li>\n</ol>\n<h4 id=\"1-3-隐藏\"><a href=\"#1-3-隐藏\" class=\"headerlink\" title=\"1.3 隐藏\"></a>1.3 隐藏</h4><p>不仅仅是函数，普通类成员也可以隐藏</p>\n<ol>\n<li>基类和派生类的关系</li>\n<li><strong>同名</strong> &amp; <strong>排除</strong>覆盖的情况</li>\n</ol>\n<h3 id=\"2-名字查找与继承\"><a href=\"#2-名字查找与继承\" class=\"headerlink\" title=\"2. 名字查找与继承\"></a>2. 名字查找与继承</h3><p>假定我们调用 <code>p-&gt;mem()</code> 或 <code>obj.mem()</code>，则依次执行以下4个步骤</p>\n<ol>\n<li><p>首先确定 <code>p</code> 的静态类型</p>\n</li>\n<li><p>在 p 中的静态类型对应的类中查找 <code>mem</code>。</p>\n<blockquote>\n<ul>\n<li><p>查找名字，编译器从静态类型开始向上查找，直到找到就停止，或者到达继承链的顶端还没有找到，则编译器报错</p>\n</li>\n<li><p>我们能使用哪些成员仍然是由静态类型决定的</p>\n</li>\n</ul>\n</blockquote>\n</li>\n<li><p>一旦找到了 <code>mem</code>，就进行常规的类型检查，以确认对于当前找到的 mem，本次调用是否合法</p>\n</li>\n<li><p>假设调用合法，则编译器将根据调用的<strong>是否是虚函数</strong>而产生不同的代码：</p>\n<ul>\n<li>如果<strong>是虚函数</strong>，且我们是<strong>通过引用或指针</strong>进行调用，则编译器产生的代码将进行动态绑定，在运行时确定到底运行该虚函数的哪个版本，依据对象的动态类型</li>\n<li>如果<strong>不是虚函数</strong>，或者我们是<strong>通过对象（而非引用或指针）</strong>进行的调用，则编译器将产生一个常规的函数调用</li>\n</ul>\n</li>\n</ol>\n"},{"_content":"### \n\n\n\n### 1. 访问控制初探\n\n| 修饰符  | 类内成员函数、友元（类的实现者） | 类对象（普通用户） |\n| ------- | -------------------------------- | ------------------ |\n| public  | :heavy_check_mark:               | :heavy_check_mark: |\n| private | :heavy_check_mark:               | ❌                  |\n| protect | :heavy_check_mark:               | ❌                  |\n\n### 2. 友元函数\n\n```cpp\nclass Box\n{\npublic:\n   friend void printWidth(Box box);\n   void setWidth( double wid );\nprivate:\n   double width;    \n};\n\nvoid printWidth(Box box)\n{\n   /* 因为 printWidth() 是 Box 的友元，它可以直接访问该类的任何成员 */\n   cout << \"Width of box : \" << box.width <<endl;\n}\n```\n\n1. 友元函数**定义在类的外部**\n2. **有权访问**类的<u>所有**私有（private）**和**保护（protected）**成员</u>\n\n> `Box` 类对象作为 `printWidth` 的参数，然后友元函数定义中直接使用 `box.width`，因为有了友元，类的用户（类对象）也能直接访问 `private` 成员了\n\n### 3. protected\n\n对于基类的 protected 成员\n\n- <u>基类的用户（对象）</u>**不**可访问 `protected` 成员（类似于 `private`）\n\n- 基类的成员和友元当然能访问基类的 `protected` 成员\n\n- 派生类的成员和友元也能访问基类的 `protected` 成员（这里没有说明继承方式的影响）\n\n- 派生类的成员或友元只能访问**派生类对象**的**基类部分**的 `protected` 成员，**不能**通过**基类对象**访问 `protected` 成员\n\n  ```cpp\n  class Base {\n  public:\n      void pub_mem() {\n          cout << prot_mem << endl;\n      }\n  protected:\n      int prot_mem;\n  private:\n      char priv_mem;\n  };\n  \n  class Sneaky :public Base {\n  public:\n      \n      void clobber(Sneaky& s) {\n          cout << s.prot_mem << endl; //可以通过派生类对象访问该对象基类部分的 protected 成员\n          prot_mem = 1;\t\t\t    //这里可以理解为：通过this对象（仍是派生类对象）访问该对象基类部分的 protected 成员\n      }\n  \n      void cloober(Base& b) {\n          cout << b.prot_mem << endl; //错误，不能访问基类对象的 protected 成员\n          b.pub_mem();\n      }\n  };\n  ```\n\n  不论 `void cloober(Base& b)` 是派生类的成员或友元，它都**不能**访问**基类对象**的 protected 成员\n\n  > 注意在 `cloober` 中使用 `b.prot_mem` 理解为<u>`cloober`访问基类对象的 `protected` 成员</u>，而不是理解为<u>基类对象访问基类的 `protected` 成员</u>\n  >\n  > 如果 `b.prot_mem` 不在 `Sneaky` 的成员/友元函数中，而是在 `main` 函数中，那也是错误的“类对象不能访问类的 protected 成员\n\n  可以这样理解：因为对于一个**基类对象**而言，它本身就有“类对象不能访问类的 protected 成员“ 这个限制，而且基类对象的眼中是没有派生的概念的，所以凭什么一个派生类的成员/友元遇到它就要搞特殊啊，所以派生类对于<u>一个基类对象的 protected 成员</u>没有任何访问特权\n\n### 4. 公有、私有和受保护继承\n\n> 如果访问说明符被忽略掉了，则关键字`class`对应的默认访问说明符是`private`，关键字`struct`对应的`public`\n\n#### 1. `继承方式`（`派生访问说明符`）对于`派生类的成员/友元`能否访问其`直接基类的成员`<u>没有什么影响</u>，对基类成员的访问权限**只与**`基类中的访问说明符`有关\n\n#### 2. `继承方式`的目的是控制`派生类对象`（包括派生类的派生类在内——孙子）对于`基类成员`的访问权限\n\n```cpp\nclass Base {\npublic:\n    void pub_mem();\nprotected:\n    int prot_mem;\nprivate:\n    char priv_mem;\n};\n\nstruct Pub_Derv :public Base {\n    int f() { return prot_mem; }  //正确，派生类能访问protected成员\n\tchar g() { return priv_mem; } //错误，派生类无权访问private成员，即使priv_mem继承下来了\n    //（我有个想法，既然priv_mem继承下来了，给Pub_Derv自己也复制了一份，Pub_Derv类的成员/友元应该能访问自己的piv_mem，即使它是private的，但是事实是它不行!）\n    //继承的是基类的成员，它还是 Base::priv_mem，只是说位置在派生类的内存地址范围内，但是其前缀还是 Base:: 还是属于基类！所以派生类不能访问它——基类的private\n};\n\nstruct Priv_Derv :private Base {\n    int f() { return prot_mem; } //private的继承方式不影响派生类的访问权限\n\n};\n\nPub_Derv d1;   \t\t//继承自Base的成员是public的\nPriv_Derv d2; \t\t//继承自Base的成员是private的\nd1.pub_mem(); \t\t//正确，pub_mem()在派生类中是public的\nd2.pub_mem();\t\t//错误，pub_mem()在派生类中是private的\n```\n\n- `公有继承` ：派生类成员将遵循其原有的访问说明符（该是啥还是啥）\n- `私有继承`：继承过来的东西都是私有的，派生类对象不能直接访问\n- `保护继承`：基类的`public`成员将变为`protected`，其他两个不变\n\n> 继承方式类似于规定一种`上限`，任何超过这个上限的都要降级为这个上限。规定上限对于已经在上限中的元素是无影响的\n\n#### 3. 孙子的访问权限\n\n继承方式（派生类访问说明符）还可以控制继承自派生类的新类的访问权限\n\n```cpp\nstruct Derived_from_Public : public Pub_Derv {\n    int use_base() { return prot_mem; }  //正确，Base::prot_mem在Pub_Derv中仍然是protected的，所以Pub_Derv的儿子可以访问\n}\n\nstruct Derived_from_Private : public Priv_Derv {\n\tint use_base() { return prot_mem; } //错误，Base::prot_mem在Priv_Derv中是private的（由于private继承），所以Priv_Derv的儿子无权访问它直接基类的private成员\n}\n```\n\n### 5. 派生类向基类转换的可访问性\n\n即动态绑定，假定 `D` 继承自 `B`：\n\n- 仅当 `D` **公有继承** B 时，用户代码（main函数中）才能使用派生类向基类的转换；如果 `D` **受保护继承**或**私有继承**于 `B`，用户代码**不能**使用该转换\n- 不论 `D` 以什么方式继承 `B`，`D` 的<u>成员/友元</u>**总是能**使用派生类向基类的转换\n- 对于 `B` 的孙子，如果 `D` 继承 `B` 的方式是 `public` 的或 `protected`，则 <u>`D` 的派生类</u>的成员/友元可以使用 `D` 向 `B` 的类型转换。反之，如果 `D` 继承 `B` 的方式是 `private` 的，则不能使用 \n\n","source":"_posts/C++/类/访问控制与继承.md","raw":"### \n\n\n\n### 1. 访问控制初探\n\n| 修饰符  | 类内成员函数、友元（类的实现者） | 类对象（普通用户） |\n| ------- | -------------------------------- | ------------------ |\n| public  | :heavy_check_mark:               | :heavy_check_mark: |\n| private | :heavy_check_mark:               | ❌                  |\n| protect | :heavy_check_mark:               | ❌                  |\n\n### 2. 友元函数\n\n```cpp\nclass Box\n{\npublic:\n   friend void printWidth(Box box);\n   void setWidth( double wid );\nprivate:\n   double width;    \n};\n\nvoid printWidth(Box box)\n{\n   /* 因为 printWidth() 是 Box 的友元，它可以直接访问该类的任何成员 */\n   cout << \"Width of box : \" << box.width <<endl;\n}\n```\n\n1. 友元函数**定义在类的外部**\n2. **有权访问**类的<u>所有**私有（private）**和**保护（protected）**成员</u>\n\n> `Box` 类对象作为 `printWidth` 的参数，然后友元函数定义中直接使用 `box.width`，因为有了友元，类的用户（类对象）也能直接访问 `private` 成员了\n\n### 3. protected\n\n对于基类的 protected 成员\n\n- <u>基类的用户（对象）</u>**不**可访问 `protected` 成员（类似于 `private`）\n\n- 基类的成员和友元当然能访问基类的 `protected` 成员\n\n- 派生类的成员和友元也能访问基类的 `protected` 成员（这里没有说明继承方式的影响）\n\n- 派生类的成员或友元只能访问**派生类对象**的**基类部分**的 `protected` 成员，**不能**通过**基类对象**访问 `protected` 成员\n\n  ```cpp\n  class Base {\n  public:\n      void pub_mem() {\n          cout << prot_mem << endl;\n      }\n  protected:\n      int prot_mem;\n  private:\n      char priv_mem;\n  };\n  \n  class Sneaky :public Base {\n  public:\n      \n      void clobber(Sneaky& s) {\n          cout << s.prot_mem << endl; //可以通过派生类对象访问该对象基类部分的 protected 成员\n          prot_mem = 1;\t\t\t    //这里可以理解为：通过this对象（仍是派生类对象）访问该对象基类部分的 protected 成员\n      }\n  \n      void cloober(Base& b) {\n          cout << b.prot_mem << endl; //错误，不能访问基类对象的 protected 成员\n          b.pub_mem();\n      }\n  };\n  ```\n\n  不论 `void cloober(Base& b)` 是派生类的成员或友元，它都**不能**访问**基类对象**的 protected 成员\n\n  > 注意在 `cloober` 中使用 `b.prot_mem` 理解为<u>`cloober`访问基类对象的 `protected` 成员</u>，而不是理解为<u>基类对象访问基类的 `protected` 成员</u>\n  >\n  > 如果 `b.prot_mem` 不在 `Sneaky` 的成员/友元函数中，而是在 `main` 函数中，那也是错误的“类对象不能访问类的 protected 成员\n\n  可以这样理解：因为对于一个**基类对象**而言，它本身就有“类对象不能访问类的 protected 成员“ 这个限制，而且基类对象的眼中是没有派生的概念的，所以凭什么一个派生类的成员/友元遇到它就要搞特殊啊，所以派生类对于<u>一个基类对象的 protected 成员</u>没有任何访问特权\n\n### 4. 公有、私有和受保护继承\n\n> 如果访问说明符被忽略掉了，则关键字`class`对应的默认访问说明符是`private`，关键字`struct`对应的`public`\n\n#### 1. `继承方式`（`派生访问说明符`）对于`派生类的成员/友元`能否访问其`直接基类的成员`<u>没有什么影响</u>，对基类成员的访问权限**只与**`基类中的访问说明符`有关\n\n#### 2. `继承方式`的目的是控制`派生类对象`（包括派生类的派生类在内——孙子）对于`基类成员`的访问权限\n\n```cpp\nclass Base {\npublic:\n    void pub_mem();\nprotected:\n    int prot_mem;\nprivate:\n    char priv_mem;\n};\n\nstruct Pub_Derv :public Base {\n    int f() { return prot_mem; }  //正确，派生类能访问protected成员\n\tchar g() { return priv_mem; } //错误，派生类无权访问private成员，即使priv_mem继承下来了\n    //（我有个想法，既然priv_mem继承下来了，给Pub_Derv自己也复制了一份，Pub_Derv类的成员/友元应该能访问自己的piv_mem，即使它是private的，但是事实是它不行!）\n    //继承的是基类的成员，它还是 Base::priv_mem，只是说位置在派生类的内存地址范围内，但是其前缀还是 Base:: 还是属于基类！所以派生类不能访问它——基类的private\n};\n\nstruct Priv_Derv :private Base {\n    int f() { return prot_mem; } //private的继承方式不影响派生类的访问权限\n\n};\n\nPub_Derv d1;   \t\t//继承自Base的成员是public的\nPriv_Derv d2; \t\t//继承自Base的成员是private的\nd1.pub_mem(); \t\t//正确，pub_mem()在派生类中是public的\nd2.pub_mem();\t\t//错误，pub_mem()在派生类中是private的\n```\n\n- `公有继承` ：派生类成员将遵循其原有的访问说明符（该是啥还是啥）\n- `私有继承`：继承过来的东西都是私有的，派生类对象不能直接访问\n- `保护继承`：基类的`public`成员将变为`protected`，其他两个不变\n\n> 继承方式类似于规定一种`上限`，任何超过这个上限的都要降级为这个上限。规定上限对于已经在上限中的元素是无影响的\n\n#### 3. 孙子的访问权限\n\n继承方式（派生类访问说明符）还可以控制继承自派生类的新类的访问权限\n\n```cpp\nstruct Derived_from_Public : public Pub_Derv {\n    int use_base() { return prot_mem; }  //正确，Base::prot_mem在Pub_Derv中仍然是protected的，所以Pub_Derv的儿子可以访问\n}\n\nstruct Derived_from_Private : public Priv_Derv {\n\tint use_base() { return prot_mem; } //错误，Base::prot_mem在Priv_Derv中是private的（由于private继承），所以Priv_Derv的儿子无权访问它直接基类的private成员\n}\n```\n\n### 5. 派生类向基类转换的可访问性\n\n即动态绑定，假定 `D` 继承自 `B`：\n\n- 仅当 `D` **公有继承** B 时，用户代码（main函数中）才能使用派生类向基类的转换；如果 `D` **受保护继承**或**私有继承**于 `B`，用户代码**不能**使用该转换\n- 不论 `D` 以什么方式继承 `B`，`D` 的<u>成员/友元</u>**总是能**使用派生类向基类的转换\n- 对于 `B` 的孙子，如果 `D` 继承 `B` 的方式是 `public` 的或 `protected`，则 <u>`D` 的派生类</u>的成员/友元可以使用 `D` 向 `B` 的类型转换。反之，如果 `D` 继承 `B` 的方式是 `private` 的，则不能使用 \n\n","slug":"C++/类/访问控制与继承","published":1,"date":"2021-12-31T02:09:01.624Z","updated":"2021-12-21T07:57:22.107Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0ky0001jpcu39aapfanl","content":"<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><h3 id=\"1-访问控制初探\"><a href=\"#1-访问控制初探\" class=\"headerlink\" title=\"1. 访问控制初探\"></a>1. 访问控制初探</h3><table>\n<thead>\n<tr>\n<th>修饰符</th>\n<th>类内成员函数、友元（类的实现者）</th>\n<th>类对象（普通用户）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>public</td>\n<td>:heavy_check_mark:</td>\n<td>:heavy_check_mark:</td>\n</tr>\n<tr>\n<td>private</td>\n<td>:heavy_check_mark:</td>\n<td>❌</td>\n</tr>\n<tr>\n<td>protect</td>\n<td>:heavy_check_mark:</td>\n<td>❌</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-友元函数\"><a href=\"#2-友元函数\" class=\"headerlink\" title=\"2. 友元函数\"></a>2. 友元函数</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Box</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">friend</span> <span class=\"keyword\">void</span> <span class=\"title\">printWidth</span><span class=\"params\">(Box box)</span></span>;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setWidth</span><span class=\"params\">( <span class=\"keyword\">double</span> wid )</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">   <span class=\"keyword\">double</span> width;    </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printWidth</span><span class=\"params\">(Box box)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">/* 因为 printWidth() 是 Box 的友元，它可以直接访问该类的任何成员 */</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Width of box : &quot;</span> &lt;&lt; box.width &lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>友元函数<strong>定义在类的外部</strong></li>\n<li><strong>有权访问</strong>类的<u>所有<strong>私有（private）</strong>和<strong>保护（protected）</strong>成员</u></li>\n</ol>\n<blockquote>\n<p><code>Box</code> 类对象作为 <code>printWidth</code> 的参数，然后友元函数定义中直接使用 <code>box.width</code>，因为有了友元，类的用户（类对象）也能直接访问 <code>private</code> 成员了</p>\n</blockquote>\n<h3 id=\"3-protected\"><a href=\"#3-protected\" class=\"headerlink\" title=\"3. protected\"></a>3. protected</h3><p>对于基类的 protected 成员</p>\n<ul>\n<li><p><u>基类的用户（对象）</u><strong>不</strong>可访问 <code>protected</code> 成员（类似于 <code>private</code>）</p>\n</li>\n<li><p>基类的成员和友元当然能访问基类的 <code>protected</code> 成员</p>\n</li>\n<li><p>派生类的成员和友元也能访问基类的 <code>protected</code> 成员（这里没有说明继承方式的影响）</p>\n</li>\n<li><p>派生类的成员或友元只能访问<strong>派生类对象</strong>的<strong>基类部分</strong>的 <code>protected</code> 成员，<strong>不能</strong>通过<strong>基类对象</strong>访问 <code>protected</code> 成员</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pub_mem</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        cout &lt;&lt; prot_mem &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> prot_mem;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">char</span> priv_mem;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sneaky</span> :</span><span class=\"keyword\">public</span> Base &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">clobber</span><span class=\"params\">(Sneaky&amp; s)</span> </span>&#123;</span><br><span class=\"line\">        cout &lt;&lt; s.prot_mem &lt;&lt; endl; <span class=\"comment\">//可以通过派生类对象访问该对象基类部分的 protected 成员</span></span><br><span class=\"line\">        prot_mem = <span class=\"number\">1</span>;\t\t\t    <span class=\"comment\">//这里可以理解为：通过this对象（仍是派生类对象）访问该对象基类部分的 protected 成员</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">cloober</span><span class=\"params\">(Base&amp; b)</span> </span>&#123;</span><br><span class=\"line\">        cout &lt;&lt; b.prot_mem &lt;&lt; endl; <span class=\"comment\">//错误，不能访问基类对象的 protected 成员</span></span><br><span class=\"line\">        b.<span class=\"built_in\">pub_mem</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>不论 <code>void cloober(Base&amp; b)</code> 是派生类的成员或友元，它都<strong>不能</strong>访问<strong>基类对象</strong>的 protected 成员</p>\n<blockquote>\n<p>注意在 <code>cloober</code> 中使用 <code>b.prot_mem</code> 理解为<u><code>cloober</code>访问基类对象的 <code>protected</code> 成员</u>，而不是理解为<u>基类对象访问基类的 <code>protected</code> 成员</u></p>\n<p>如果 <code>b.prot_mem</code> 不在 <code>Sneaky</code> 的成员/友元函数中，而是在 <code>main</code> 函数中，那也是错误的“类对象不能访问类的 protected 成员</p>\n</blockquote>\n<p>可以这样理解：因为对于一个<strong>基类对象</strong>而言，它本身就有“类对象不能访问类的 protected 成员“ 这个限制，而且基类对象的眼中是没有派生的概念的，所以凭什么一个派生类的成员/友元遇到它就要搞特殊啊，所以派生类对于<u>一个基类对象的 protected 成员</u>没有任何访问特权</p>\n</li>\n</ul>\n<h3 id=\"4-公有、私有和受保护继承\"><a href=\"#4-公有、私有和受保护继承\" class=\"headerlink\" title=\"4. 公有、私有和受保护继承\"></a>4. 公有、私有和受保护继承</h3><blockquote>\n<p>如果访问说明符被忽略掉了，则关键字<code>class</code>对应的默认访问说明符是<code>private</code>，关键字<code>struct</code>对应的<code>public</code></p>\n</blockquote>\n<h4 id=\"1-继承方式（派生访问说明符）对于派生类的成员-友元能否访问其直接基类的成员没有什么影响，对基类成员的访问权限只与基类中的访问说明符有关\"><a href=\"#1-继承方式（派生访问说明符）对于派生类的成员-友元能否访问其直接基类的成员没有什么影响，对基类成员的访问权限只与基类中的访问说明符有关\" class=\"headerlink\" title=\"1. 继承方式（派生访问说明符）对于派生类的成员/友元能否访问其直接基类的成员没有什么影响，对基类成员的访问权限只与基类中的访问说明符有关\"></a>1. <code>继承方式</code>（<code>派生访问说明符</code>）对于<code>派生类的成员/友元</code>能否访问其<code>直接基类的成员</code><u>没有什么影响</u>，对基类成员的访问权限<strong>只与</strong><code>基类中的访问说明符</code>有关</h4><h4 id=\"2-继承方式的目的是控制派生类对象（包括派生类的派生类在内——孙子）对于基类成员的访问权限\"><a href=\"#2-继承方式的目的是控制派生类对象（包括派生类的派生类在内——孙子）对于基类成员的访问权限\" class=\"headerlink\" title=\"2. 继承方式的目的是控制派生类对象（包括派生类的派生类在内——孙子）对于基类成员的访问权限\"></a>2. <code>继承方式</code>的目的是控制<code>派生类对象</code>（包括派生类的派生类在内——孙子）对于<code>基类成员</code>的访问权限</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pub_mem</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> prot_mem;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">char</span> priv_mem;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Pub_Derv</span> :</span><span class=\"keyword\">public</span> Base &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">f</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> prot_mem; &#125;  <span class=\"comment\">//正确，派生类能访问protected成员</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">char</span> <span class=\"title\">g</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> priv_mem; &#125; <span class=\"comment\">//错误，派生类无权访问private成员，即使priv_mem继承下来了</span></span><br><span class=\"line\">    <span class=\"comment\">//（我有个想法，既然priv_mem继承下来了，给Pub_Derv自己也复制了一份，Pub_Derv类的成员/友元应该能访问自己的piv_mem，即使它是private的，但是事实是它不行!）</span></span><br><span class=\"line\">    <span class=\"comment\">//继承的是基类的成员，它还是 Base::priv_mem，只是说位置在派生类的内存地址范围内，但是其前缀还是 Base:: 还是属于基类！所以派生类不能访问它——基类的private</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Priv_Derv</span> :</span><span class=\"keyword\">private</span> Base &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">f</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> prot_mem; &#125; <span class=\"comment\">//private的继承方式不影响派生类的访问权限</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Pub_Derv d1;   \t\t<span class=\"comment\">//继承自Base的成员是public的</span></span><br><span class=\"line\">Priv_Derv d2; \t\t<span class=\"comment\">//继承自Base的成员是private的</span></span><br><span class=\"line\">d1.<span class=\"built_in\">pub_mem</span>(); \t\t<span class=\"comment\">//正确，pub_mem()在派生类中是public的</span></span><br><span class=\"line\">d2.<span class=\"built_in\">pub_mem</span>();\t\t<span class=\"comment\">//错误，pub_mem()在派生类中是private的</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>公有继承</code> ：派生类成员将遵循其原有的访问说明符（该是啥还是啥）</li>\n<li><code>私有继承</code>：继承过来的东西都是私有的，派生类对象不能直接访问</li>\n<li><code>保护继承</code>：基类的<code>public</code>成员将变为<code>protected</code>，其他两个不变</li>\n</ul>\n<blockquote>\n<p>继承方式类似于规定一种<code>上限</code>，任何超过这个上限的都要降级为这个上限。规定上限对于已经在上限中的元素是无影响的</p>\n</blockquote>\n<h4 id=\"3-孙子的访问权限\"><a href=\"#3-孙子的访问权限\" class=\"headerlink\" title=\"3. 孙子的访问权限\"></a>3. 孙子的访问权限</h4><p>继承方式（派生类访问说明符）还可以控制继承自派生类的新类的访问权限</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Derived_from_Public</span> :</span> <span class=\"keyword\">public</span> Pub_Derv &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">use_base</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> prot_mem; &#125;  <span class=\"comment\">//正确，Base::prot_mem在Pub_Derv中仍然是protected的，所以Pub_Derv的儿子可以访问</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Derived_from_Private</span> :</span> <span class=\"keyword\">public</span> Priv_Derv &#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">use_base</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> prot_mem; &#125; <span class=\"comment\">//错误，Base::prot_mem在Priv_Derv中是private的（由于private继承），所以Priv_Derv的儿子无权访问它直接基类的private成员</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-派生类向基类转换的可访问性\"><a href=\"#5-派生类向基类转换的可访问性\" class=\"headerlink\" title=\"5. 派生类向基类转换的可访问性\"></a>5. 派生类向基类转换的可访问性</h3><p>即动态绑定，假定 <code>D</code> 继承自 <code>B</code>：</p>\n<ul>\n<li>仅当 <code>D</code> <strong>公有继承</strong> B 时，用户代码（main函数中）才能使用派生类向基类的转换；如果 <code>D</code> <strong>受保护继承</strong>或<strong>私有继承</strong>于 <code>B</code>，用户代码<strong>不能</strong>使用该转换</li>\n<li>不论 <code>D</code> 以什么方式继承 <code>B</code>，<code>D</code> 的<u>成员/友元</u><strong>总是能</strong>使用派生类向基类的转换</li>\n<li>对于 <code>B</code> 的孙子，如果 <code>D</code> 继承 <code>B</code> 的方式是 <code>public</code> 的或 <code>protected</code>，则 <u><code>D</code> 的派生类</u>的成员/友元可以使用 <code>D</code> 向 <code>B</code> 的类型转换。反之，如果 <code>D</code> 继承 <code>B</code> 的方式是 <code>private</code> 的，则不能使用 </li>\n</ul>\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><h3 id=\"1-访问控制初探\"><a href=\"#1-访问控制初探\" class=\"headerlink\" title=\"1. 访问控制初探\"></a>1. 访问控制初探</h3><table>\n<thead>\n<tr>\n<th>修饰符</th>\n<th>类内成员函数、友元（类的实现者）</th>\n<th>类对象（普通用户）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>public</td>\n<td>:heavy_check_mark:</td>\n<td>:heavy_check_mark:</td>\n</tr>\n<tr>\n<td>private</td>\n<td>:heavy_check_mark:</td>\n<td>❌</td>\n</tr>\n<tr>\n<td>protect</td>\n<td>:heavy_check_mark:</td>\n<td>❌</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-友元函数\"><a href=\"#2-友元函数\" class=\"headerlink\" title=\"2. 友元函数\"></a>2. 友元函数</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Box</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">friend</span> <span class=\"keyword\">void</span> <span class=\"title\">printWidth</span><span class=\"params\">(Box box)</span></span>;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setWidth</span><span class=\"params\">( <span class=\"keyword\">double</span> wid )</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">   <span class=\"keyword\">double</span> width;    </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printWidth</span><span class=\"params\">(Box box)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">/* 因为 printWidth() 是 Box 的友元，它可以直接访问该类的任何成员 */</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Width of box : &quot;</span> &lt;&lt; box.width &lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>友元函数<strong>定义在类的外部</strong></li>\n<li><strong>有权访问</strong>类的<u>所有<strong>私有（private）</strong>和<strong>保护（protected）</strong>成员</u></li>\n</ol>\n<blockquote>\n<p><code>Box</code> 类对象作为 <code>printWidth</code> 的参数，然后友元函数定义中直接使用 <code>box.width</code>，因为有了友元，类的用户（类对象）也能直接访问 <code>private</code> 成员了</p>\n</blockquote>\n<h3 id=\"3-protected\"><a href=\"#3-protected\" class=\"headerlink\" title=\"3. protected\"></a>3. protected</h3><p>对于基类的 protected 成员</p>\n<ul>\n<li><p><u>基类的用户（对象）</u><strong>不</strong>可访问 <code>protected</code> 成员（类似于 <code>private</code>）</p>\n</li>\n<li><p>基类的成员和友元当然能访问基类的 <code>protected</code> 成员</p>\n</li>\n<li><p>派生类的成员和友元也能访问基类的 <code>protected</code> 成员（这里没有说明继承方式的影响）</p>\n</li>\n<li><p>派生类的成员或友元只能访问<strong>派生类对象</strong>的<strong>基类部分</strong>的 <code>protected</code> 成员，<strong>不能</strong>通过<strong>基类对象</strong>访问 <code>protected</code> 成员</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pub_mem</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        cout &lt;&lt; prot_mem &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> prot_mem;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">char</span> priv_mem;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sneaky</span> :</span><span class=\"keyword\">public</span> Base &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">clobber</span><span class=\"params\">(Sneaky&amp; s)</span> </span>&#123;</span><br><span class=\"line\">        cout &lt;&lt; s.prot_mem &lt;&lt; endl; <span class=\"comment\">//可以通过派生类对象访问该对象基类部分的 protected 成员</span></span><br><span class=\"line\">        prot_mem = <span class=\"number\">1</span>;\t\t\t    <span class=\"comment\">//这里可以理解为：通过this对象（仍是派生类对象）访问该对象基类部分的 protected 成员</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">cloober</span><span class=\"params\">(Base&amp; b)</span> </span>&#123;</span><br><span class=\"line\">        cout &lt;&lt; b.prot_mem &lt;&lt; endl; <span class=\"comment\">//错误，不能访问基类对象的 protected 成员</span></span><br><span class=\"line\">        b.<span class=\"built_in\">pub_mem</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>不论 <code>void cloober(Base&amp; b)</code> 是派生类的成员或友元，它都<strong>不能</strong>访问<strong>基类对象</strong>的 protected 成员</p>\n<blockquote>\n<p>注意在 <code>cloober</code> 中使用 <code>b.prot_mem</code> 理解为<u><code>cloober</code>访问基类对象的 <code>protected</code> 成员</u>，而不是理解为<u>基类对象访问基类的 <code>protected</code> 成员</u></p>\n<p>如果 <code>b.prot_mem</code> 不在 <code>Sneaky</code> 的成员/友元函数中，而是在 <code>main</code> 函数中，那也是错误的“类对象不能访问类的 protected 成员</p>\n</blockquote>\n<p>可以这样理解：因为对于一个<strong>基类对象</strong>而言，它本身就有“类对象不能访问类的 protected 成员“ 这个限制，而且基类对象的眼中是没有派生的概念的，所以凭什么一个派生类的成员/友元遇到它就要搞特殊啊，所以派生类对于<u>一个基类对象的 protected 成员</u>没有任何访问特权</p>\n</li>\n</ul>\n<h3 id=\"4-公有、私有和受保护继承\"><a href=\"#4-公有、私有和受保护继承\" class=\"headerlink\" title=\"4. 公有、私有和受保护继承\"></a>4. 公有、私有和受保护继承</h3><blockquote>\n<p>如果访问说明符被忽略掉了，则关键字<code>class</code>对应的默认访问说明符是<code>private</code>，关键字<code>struct</code>对应的<code>public</code></p>\n</blockquote>\n<h4 id=\"1-继承方式（派生访问说明符）对于派生类的成员-友元能否访问其直接基类的成员没有什么影响，对基类成员的访问权限只与基类中的访问说明符有关\"><a href=\"#1-继承方式（派生访问说明符）对于派生类的成员-友元能否访问其直接基类的成员没有什么影响，对基类成员的访问权限只与基类中的访问说明符有关\" class=\"headerlink\" title=\"1. 继承方式（派生访问说明符）对于派生类的成员/友元能否访问其直接基类的成员没有什么影响，对基类成员的访问权限只与基类中的访问说明符有关\"></a>1. <code>继承方式</code>（<code>派生访问说明符</code>）对于<code>派生类的成员/友元</code>能否访问其<code>直接基类的成员</code><u>没有什么影响</u>，对基类成员的访问权限<strong>只与</strong><code>基类中的访问说明符</code>有关</h4><h4 id=\"2-继承方式的目的是控制派生类对象（包括派生类的派生类在内——孙子）对于基类成员的访问权限\"><a href=\"#2-继承方式的目的是控制派生类对象（包括派生类的派生类在内——孙子）对于基类成员的访问权限\" class=\"headerlink\" title=\"2. 继承方式的目的是控制派生类对象（包括派生类的派生类在内——孙子）对于基类成员的访问权限\"></a>2. <code>继承方式</code>的目的是控制<code>派生类对象</code>（包括派生类的派生类在内——孙子）对于<code>基类成员</code>的访问权限</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pub_mem</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> prot_mem;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">char</span> priv_mem;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Pub_Derv</span> :</span><span class=\"keyword\">public</span> Base &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">f</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> prot_mem; &#125;  <span class=\"comment\">//正确，派生类能访问protected成员</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">char</span> <span class=\"title\">g</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> priv_mem; &#125; <span class=\"comment\">//错误，派生类无权访问private成员，即使priv_mem继承下来了</span></span><br><span class=\"line\">    <span class=\"comment\">//（我有个想法，既然priv_mem继承下来了，给Pub_Derv自己也复制了一份，Pub_Derv类的成员/友元应该能访问自己的piv_mem，即使它是private的，但是事实是它不行!）</span></span><br><span class=\"line\">    <span class=\"comment\">//继承的是基类的成员，它还是 Base::priv_mem，只是说位置在派生类的内存地址范围内，但是其前缀还是 Base:: 还是属于基类！所以派生类不能访问它——基类的private</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Priv_Derv</span> :</span><span class=\"keyword\">private</span> Base &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">f</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> prot_mem; &#125; <span class=\"comment\">//private的继承方式不影响派生类的访问权限</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Pub_Derv d1;   \t\t<span class=\"comment\">//继承自Base的成员是public的</span></span><br><span class=\"line\">Priv_Derv d2; \t\t<span class=\"comment\">//继承自Base的成员是private的</span></span><br><span class=\"line\">d1.<span class=\"built_in\">pub_mem</span>(); \t\t<span class=\"comment\">//正确，pub_mem()在派生类中是public的</span></span><br><span class=\"line\">d2.<span class=\"built_in\">pub_mem</span>();\t\t<span class=\"comment\">//错误，pub_mem()在派生类中是private的</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>公有继承</code> ：派生类成员将遵循其原有的访问说明符（该是啥还是啥）</li>\n<li><code>私有继承</code>：继承过来的东西都是私有的，派生类对象不能直接访问</li>\n<li><code>保护继承</code>：基类的<code>public</code>成员将变为<code>protected</code>，其他两个不变</li>\n</ul>\n<blockquote>\n<p>继承方式类似于规定一种<code>上限</code>，任何超过这个上限的都要降级为这个上限。规定上限对于已经在上限中的元素是无影响的</p>\n</blockquote>\n<h4 id=\"3-孙子的访问权限\"><a href=\"#3-孙子的访问权限\" class=\"headerlink\" title=\"3. 孙子的访问权限\"></a>3. 孙子的访问权限</h4><p>继承方式（派生类访问说明符）还可以控制继承自派生类的新类的访问权限</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Derived_from_Public</span> :</span> <span class=\"keyword\">public</span> Pub_Derv &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">use_base</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> prot_mem; &#125;  <span class=\"comment\">//正确，Base::prot_mem在Pub_Derv中仍然是protected的，所以Pub_Derv的儿子可以访问</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Derived_from_Private</span> :</span> <span class=\"keyword\">public</span> Priv_Derv &#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">use_base</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> prot_mem; &#125; <span class=\"comment\">//错误，Base::prot_mem在Priv_Derv中是private的（由于private继承），所以Priv_Derv的儿子无权访问它直接基类的private成员</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-派生类向基类转换的可访问性\"><a href=\"#5-派生类向基类转换的可访问性\" class=\"headerlink\" title=\"5. 派生类向基类转换的可访问性\"></a>5. 派生类向基类转换的可访问性</h3><p>即动态绑定，假定 <code>D</code> 继承自 <code>B</code>：</p>\n<ul>\n<li>仅当 <code>D</code> <strong>公有继承</strong> B 时，用户代码（main函数中）才能使用派生类向基类的转换；如果 <code>D</code> <strong>受保护继承</strong>或<strong>私有继承</strong>于 <code>B</code>，用户代码<strong>不能</strong>使用该转换</li>\n<li>不论 <code>D</code> 以什么方式继承 <code>B</code>，<code>D</code> 的<u>成员/友元</u><strong>总是能</strong>使用派生类向基类的转换</li>\n<li>对于 <code>B</code> 的孙子，如果 <code>D</code> 继承 <code>B</code> 的方式是 <code>public</code> 的或 <code>protected</code>，则 <u><code>D</code> 的派生类</u>的成员/友元可以使用 <code>D</code> 向 <code>B</code> 的类型转换。反之，如果 <code>D</code> 继承 <code>B</code> 的方式是 <code>private</code> 的，则不能使用 </li>\n</ul>\n"},{"_content":"\n\n参考资料：\n\n1. 《effective C++ 第三版》\n2. 《C++ Primer 第五版》\n3. 《C++编程思想》\n4. 《深入探索C++对象模型》\n5. 利用 visual studio 查看 C++ 类内存布局：https://www.cnblogs.com/jerry19880126/p/3616999.html\n6.  \n\n### 1. 静态类型 vs. 动态类型 \n\n静态类型：编译时已知，是变量声明时的类型或表达式生成的类型\n\n动态类型：直到运行时才可知，变量或表达式在内存中的对象的类型\n\n> 如果表达式**不是指针/引用**，则其动态类型与静态类型**一致**\n\n不存在**从基类到派生类**的隐式类型转换，因为基类有可能不是派生类的一部分\n\n即使一个基类指针/引用绑定在一个派生类对象上，我们也不能执行从基类向派生类的**自动**转换：\n\n```cpp\nC_derived child;  \t\t\t\t\t//派生类对象\nC *father = &child;\t\t\t\t\t//\t\nC_derived *cc = father;\t\t\t\t//错误，不能将基类自动转换为派生类\n```\n\n虽然这个转换是安全的，但是<u>过不了编译器静态时的安全检查</u>，编译器只能通过检查指针/引用的静态类型来推断该转换是否合法\n\n如果基类中有虚函数，可以用 `dynamic_cast`，执行**运行时**的安全检查\n\n> 如果确认基类向派生类的转换是安全的，可以使用 `static_cast` 来强制覆盖掉编译器的检查工作\n\n因为基类的拷贝/移动操作的参数是引用，所以可以给基类的拷贝/移动构造函数传递一个派生类对象，仅处理（拷贝/赋值）该派生类对象中的基类自己的部分，该派生类对象中的其他部分相当于被**切掉（sliced down）**了\n\n### 2. 虚函数\n\n使用基类的引用/指针调用一个虚函数时会执行动态绑定，编译器直到运行时才能确定应该调用哪个版本的虚函数，被调用的函数是与绑定到指针/引用上的对象的动态类型相匹配\n\n> 所有虚函数都必须定义，不管它是否被用到了，因为连编译器也无法确定到底会使用哪个虚函数\n\n##### 2.1 派生类中的虚函数\n\n- 一旦某个函数被声明成虚函数，则在所有派生类中它都是虚函数\n\n- 派生类中**覆盖**基类虚函数，要求形参类型一致，返回类型要么一致，要么可自动转换\n\n- 虚函数的**默认实参**由本次调用的**静态类型**决定\n\n##### 2.2 抽象基类\n\n- 用`=0`声明一个纯虚函数，一个纯虚函数无需定义（也可以有定义，但**必须定义在类外部**）\n- 含有纯虚函数的类是抽象基类，**不能**直接创建一个抽象基类的对象\n\n##### 2.3 构造/析构函数与虚函数\n\n1. 基类的析构函数一般是虚函数\n\n   派生类的析构函数也因此是虚函数。基类指针指向派生类对象，那么 delete 该指针的时候，会实际调用派生类的析构函数，派生类析构完成之后，再调用基类的析构函数。如果基类的析构函数不是虚函数，那么 delete <u>基类</u>指针的时候，只会调用基类的析构函数，因此子类无法正常析构。\n\n2. 构造函数不能是虚函数\n   - 从`vptr`角度解释：虚函数的调用是通过虚函数表来查找的，而虚函数表由类的实例化对象的`vptr`指针指向。该指针存放在对象的内部空间中，需要调用构造函数完成初始化。如果构造函数是虚函数，那么调用构造函数就需要去找`vptr`，但此时`vptr`还没有初始化！\n   - 从多态角度解释【挖坑】\n\n**定义派生类的拷贝或移动构造函数**\n\n```cpp\nclass Base { /*..*/};\nclass D: public Base {\npublic:\n\t//默认情况下，基类的默认构造函数初始化对象的基类部分\n    //要想使用拷贝或移动构造函数，必须在构造函数初始值列表中显示地调用该构造函数\n    D(const D& d): Base(d)           //拷贝基类成员\n    \t\t\t/* D的成员的初始值 */  {/*...*/}\n    D(D&& d): Base(std::move(d))     //移动基类成员\n                /* D的成员的初始值 */  {/*...*/}\n}\n```\n\n`Base(d)` 匹配 `Base` 的拷贝构造函数，然后 `Base` 的拷贝构造函数负责将 <u>`d` 的基类部分</u>拷贝给要创建的对象\n\n##### 2.4 名字查找和继承 \n\n查找名字和确定调用哪个虚函数是分开的\n\n![image-20220311115032636](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220311115032636.png)\n\n##### 2.5 怎么根据虚函数的名字找到最终要调用的函数地址？\n\n每一个含有虚函数的类都有自己的虚表，它是一个静态指针数组，由编译器在编译时填好。虚表中每个条目都对应一个虚函数的地址（函数指针），指向此类可以访问到的 `most-derived` 虚函数。\n\n每个对象中都存在一个隐藏指针（`*__vptr`），指向整个虚表，当一个对象被创建时，`*__vptr`会由构造函数进行初始化，决定它指向哪张虚表。所以每个对象的占用内存会偏大，因为其中也存储了`*__vptr`\n\n每个多态 class object 身上会有额外两个 members：\n\n1. RTTI 信息，用于在运行时确定对象的实际类型\n2. 虚表指针+虚表\n\n为了完成多态，编译器完成两项工作：\n\n1. 构造虚表，填好虚表中的地址\n2. 确定好每个虚函数的偏移\n\n现在有这样的式子：`ptr->z();`表示一个虚函数调用，如何确定要调用的`z()`地址？由于：\n\n（1）所有类的虚表已经在编译时确定\n\n（2）`z()`在虚表中的偏移在编译时已经设定好且固定了，这里假设偏移为`4`\n\n所以该式子可以被转化为：`(*ptr->vptr[4])(ptr)`，虚表已知，偏移已知，需要在<u>运行时</u>让构造函数对`vptr`进行初始化，确定该`vptr`应该指向哪一个虚表，再利用已知的偏移信息，就可以找到正确的虚函数的地址\n\n> 运行时，对于`ptr->z()`这个函数调用，`ptr`的首地址，即`this`的地址会被压栈，`this`的地址实际上也是`vptr`的位置，根据`vptr`找到虚表，根据偏移取出函数地址，执行`call`指令 \n\n##### 2.6 虚表指针放在什么位置\n\n通常放在对象开头，到底能不能放在对象最后呢？这个还没有查到靠谱的资料，在《深入探索C++对象模型》书中说到`*__vptr`曾经有被放在对象尾部（为了兼容C）\n\n### 3. 多继承中的虚函数\n\n```cpp\nclass Base\n{\n    int a;\n    int b;\npublic:\n    void CommonFunction();\n    void virtual VirtualFunction();\n};\n\nclass DerivedClass1 : public Base\n{\n    int c;\npublic:\n    void DerivedCommonFunction();\n    void virtual VirtualFunction();\n};\n\nclass DerivedClass2 : public Base\n{\n    int d;\npublic:\n    void DerivedCommonFunction();\n    void virtual VirtualFunction();\n};\n\nclass DerivedDerivedClass : public DerivedClass1, public DerivedClass2\n{\n   \tint e;\npublic:\n    void DerivedDerivedCommonFunction();\n    void virtual VirtualFunction();\n};\n```\n\n多重继承情况下，（没有虚继承 ），`DerivedDerivedClass`的内存布局会是怎样的？\n\n![image-20220523100657194](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220523100657194.png)\n\n可以看到，`DerivedDerivedClass`的两个基类按顺序排布，两份`Base`类内存，有两个虚表指针，第二个虚表指针的偏移为`24`。由于多继承，同一个 object 的地址会出现不一样的情况：\n\n```cpp\n    DerivedDerivedClass* d = new DerivedDerivedClass;\n    DerivedClass1* a = d;\n    DerivedClass2* b = d;\n\t// a 和 b 的值会不一样，就像是 d 有两份地址一样\n    cout << a << endl;\n    cout << b << endl;\n```\n\n`DerivedDerivedClass`的虚表结构：\n\n![image-20220523104144845](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220523104144845.png)\n\n可以看到这里有两张虚表了，第二张虚表中的`-24`表示指向这张虚表的`*__vptr`偏移，这正是`DerivedDerivedClass`内存布局中第二个`*__vptr`的位置偏移\n\n### 4. 虚继承中的虚函数\n\n虚基类的偏移量在运行时才可以确定 【】\n\n引入虚继承后\n\n```cpp\n```\n\n\n\n","source":"_posts/C++/类/虚函数专题.md","raw":"\n\n参考资料：\n\n1. 《effective C++ 第三版》\n2. 《C++ Primer 第五版》\n3. 《C++编程思想》\n4. 《深入探索C++对象模型》\n5. 利用 visual studio 查看 C++ 类内存布局：https://www.cnblogs.com/jerry19880126/p/3616999.html\n6.  \n\n### 1. 静态类型 vs. 动态类型 \n\n静态类型：编译时已知，是变量声明时的类型或表达式生成的类型\n\n动态类型：直到运行时才可知，变量或表达式在内存中的对象的类型\n\n> 如果表达式**不是指针/引用**，则其动态类型与静态类型**一致**\n\n不存在**从基类到派生类**的隐式类型转换，因为基类有可能不是派生类的一部分\n\n即使一个基类指针/引用绑定在一个派生类对象上，我们也不能执行从基类向派生类的**自动**转换：\n\n```cpp\nC_derived child;  \t\t\t\t\t//派生类对象\nC *father = &child;\t\t\t\t\t//\t\nC_derived *cc = father;\t\t\t\t//错误，不能将基类自动转换为派生类\n```\n\n虽然这个转换是安全的，但是<u>过不了编译器静态时的安全检查</u>，编译器只能通过检查指针/引用的静态类型来推断该转换是否合法\n\n如果基类中有虚函数，可以用 `dynamic_cast`，执行**运行时**的安全检查\n\n> 如果确认基类向派生类的转换是安全的，可以使用 `static_cast` 来强制覆盖掉编译器的检查工作\n\n因为基类的拷贝/移动操作的参数是引用，所以可以给基类的拷贝/移动构造函数传递一个派生类对象，仅处理（拷贝/赋值）该派生类对象中的基类自己的部分，该派生类对象中的其他部分相当于被**切掉（sliced down）**了\n\n### 2. 虚函数\n\n使用基类的引用/指针调用一个虚函数时会执行动态绑定，编译器直到运行时才能确定应该调用哪个版本的虚函数，被调用的函数是与绑定到指针/引用上的对象的动态类型相匹配\n\n> 所有虚函数都必须定义，不管它是否被用到了，因为连编译器也无法确定到底会使用哪个虚函数\n\n##### 2.1 派生类中的虚函数\n\n- 一旦某个函数被声明成虚函数，则在所有派生类中它都是虚函数\n\n- 派生类中**覆盖**基类虚函数，要求形参类型一致，返回类型要么一致，要么可自动转换\n\n- 虚函数的**默认实参**由本次调用的**静态类型**决定\n\n##### 2.2 抽象基类\n\n- 用`=0`声明一个纯虚函数，一个纯虚函数无需定义（也可以有定义，但**必须定义在类外部**）\n- 含有纯虚函数的类是抽象基类，**不能**直接创建一个抽象基类的对象\n\n##### 2.3 构造/析构函数与虚函数\n\n1. 基类的析构函数一般是虚函数\n\n   派生类的析构函数也因此是虚函数。基类指针指向派生类对象，那么 delete 该指针的时候，会实际调用派生类的析构函数，派生类析构完成之后，再调用基类的析构函数。如果基类的析构函数不是虚函数，那么 delete <u>基类</u>指针的时候，只会调用基类的析构函数，因此子类无法正常析构。\n\n2. 构造函数不能是虚函数\n   - 从`vptr`角度解释：虚函数的调用是通过虚函数表来查找的，而虚函数表由类的实例化对象的`vptr`指针指向。该指针存放在对象的内部空间中，需要调用构造函数完成初始化。如果构造函数是虚函数，那么调用构造函数就需要去找`vptr`，但此时`vptr`还没有初始化！\n   - 从多态角度解释【挖坑】\n\n**定义派生类的拷贝或移动构造函数**\n\n```cpp\nclass Base { /*..*/};\nclass D: public Base {\npublic:\n\t//默认情况下，基类的默认构造函数初始化对象的基类部分\n    //要想使用拷贝或移动构造函数，必须在构造函数初始值列表中显示地调用该构造函数\n    D(const D& d): Base(d)           //拷贝基类成员\n    \t\t\t/* D的成员的初始值 */  {/*...*/}\n    D(D&& d): Base(std::move(d))     //移动基类成员\n                /* D的成员的初始值 */  {/*...*/}\n}\n```\n\n`Base(d)` 匹配 `Base` 的拷贝构造函数，然后 `Base` 的拷贝构造函数负责将 <u>`d` 的基类部分</u>拷贝给要创建的对象\n\n##### 2.4 名字查找和继承 \n\n查找名字和确定调用哪个虚函数是分开的\n\n![image-20220311115032636](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220311115032636.png)\n\n##### 2.5 怎么根据虚函数的名字找到最终要调用的函数地址？\n\n每一个含有虚函数的类都有自己的虚表，它是一个静态指针数组，由编译器在编译时填好。虚表中每个条目都对应一个虚函数的地址（函数指针），指向此类可以访问到的 `most-derived` 虚函数。\n\n每个对象中都存在一个隐藏指针（`*__vptr`），指向整个虚表，当一个对象被创建时，`*__vptr`会由构造函数进行初始化，决定它指向哪张虚表。所以每个对象的占用内存会偏大，因为其中也存储了`*__vptr`\n\n每个多态 class object 身上会有额外两个 members：\n\n1. RTTI 信息，用于在运行时确定对象的实际类型\n2. 虚表指针+虚表\n\n为了完成多态，编译器完成两项工作：\n\n1. 构造虚表，填好虚表中的地址\n2. 确定好每个虚函数的偏移\n\n现在有这样的式子：`ptr->z();`表示一个虚函数调用，如何确定要调用的`z()`地址？由于：\n\n（1）所有类的虚表已经在编译时确定\n\n（2）`z()`在虚表中的偏移在编译时已经设定好且固定了，这里假设偏移为`4`\n\n所以该式子可以被转化为：`(*ptr->vptr[4])(ptr)`，虚表已知，偏移已知，需要在<u>运行时</u>让构造函数对`vptr`进行初始化，确定该`vptr`应该指向哪一个虚表，再利用已知的偏移信息，就可以找到正确的虚函数的地址\n\n> 运行时，对于`ptr->z()`这个函数调用，`ptr`的首地址，即`this`的地址会被压栈，`this`的地址实际上也是`vptr`的位置，根据`vptr`找到虚表，根据偏移取出函数地址，执行`call`指令 \n\n##### 2.6 虚表指针放在什么位置\n\n通常放在对象开头，到底能不能放在对象最后呢？这个还没有查到靠谱的资料，在《深入探索C++对象模型》书中说到`*__vptr`曾经有被放在对象尾部（为了兼容C）\n\n### 3. 多继承中的虚函数\n\n```cpp\nclass Base\n{\n    int a;\n    int b;\npublic:\n    void CommonFunction();\n    void virtual VirtualFunction();\n};\n\nclass DerivedClass1 : public Base\n{\n    int c;\npublic:\n    void DerivedCommonFunction();\n    void virtual VirtualFunction();\n};\n\nclass DerivedClass2 : public Base\n{\n    int d;\npublic:\n    void DerivedCommonFunction();\n    void virtual VirtualFunction();\n};\n\nclass DerivedDerivedClass : public DerivedClass1, public DerivedClass2\n{\n   \tint e;\npublic:\n    void DerivedDerivedCommonFunction();\n    void virtual VirtualFunction();\n};\n```\n\n多重继承情况下，（没有虚继承 ），`DerivedDerivedClass`的内存布局会是怎样的？\n\n![image-20220523100657194](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220523100657194.png)\n\n可以看到，`DerivedDerivedClass`的两个基类按顺序排布，两份`Base`类内存，有两个虚表指针，第二个虚表指针的偏移为`24`。由于多继承，同一个 object 的地址会出现不一样的情况：\n\n```cpp\n    DerivedDerivedClass* d = new DerivedDerivedClass;\n    DerivedClass1* a = d;\n    DerivedClass2* b = d;\n\t// a 和 b 的值会不一样，就像是 d 有两份地址一样\n    cout << a << endl;\n    cout << b << endl;\n```\n\n`DerivedDerivedClass`的虚表结构：\n\n![image-20220523104144845](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220523104144845.png)\n\n可以看到这里有两张虚表了，第二张虚表中的`-24`表示指向这张虚表的`*__vptr`偏移，这正是`DerivedDerivedClass`内存布局中第二个`*__vptr`的位置偏移\n\n### 4. 虚继承中的虚函数\n\n虚基类的偏移量在运行时才可以确定 【】\n\n引入虚继承后\n\n```cpp\n```\n\n\n\n","slug":"C++/类/虚函数专题","published":1,"date":"2021-12-31T02:09:01.616Z","updated":"2022-05-23T03:15:49.057Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0ky0001kpcu31ohn7nkl","content":"<p>参考资料：</p>\n<ol>\n<li>《effective C++ 第三版》</li>\n<li>《C++ Primer 第五版》</li>\n<li>《C++编程思想》</li>\n<li>《深入探索C++对象模型》</li>\n<li>利用 visual studio 查看 C++ 类内存布局：<a href=\"https://www.cnblogs.com/jerry19880126/p/3616999.html\">https://www.cnblogs.com/jerry19880126/p/3616999.html</a></li>\n<li></li>\n</ol>\n<h3 id=\"1-静态类型-vs-动态类型\"><a href=\"#1-静态类型-vs-动态类型\" class=\"headerlink\" title=\"1. 静态类型 vs. 动态类型\"></a>1. 静态类型 vs. 动态类型</h3><p>静态类型：编译时已知，是变量声明时的类型或表达式生成的类型</p>\n<p>动态类型：直到运行时才可知，变量或表达式在内存中的对象的类型</p>\n<blockquote>\n<p>如果表达式<strong>不是指针/引用</strong>，则其动态类型与静态类型<strong>一致</strong></p>\n</blockquote>\n<p>不存在<strong>从基类到派生类</strong>的隐式类型转换，因为基类有可能不是派生类的一部分</p>\n<p>即使一个基类指针/引用绑定在一个派生类对象上，我们也不能执行从基类向派生类的<strong>自动</strong>转换：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C_derived child;  \t\t\t\t\t<span class=\"comment\">//派生类对象</span></span><br><span class=\"line\">C *father = &amp;child;\t\t\t\t\t<span class=\"comment\">//\t</span></span><br><span class=\"line\">C_derived *cc = father;\t\t\t\t<span class=\"comment\">//错误，不能将基类自动转换为派生类</span></span><br></pre></td></tr></table></figure>\n\n<p>虽然这个转换是安全的，但是<u>过不了编译器静态时的安全检查</u>，编译器只能通过检查指针/引用的静态类型来推断该转换是否合法</p>\n<p>如果基类中有虚函数，可以用 <code>dynamic_cast</code>，执行<strong>运行时</strong>的安全检查</p>\n<blockquote>\n<p>如果确认基类向派生类的转换是安全的，可以使用 <code>static_cast</code> 来强制覆盖掉编译器的检查工作</p>\n</blockquote>\n<p>因为基类的拷贝/移动操作的参数是引用，所以可以给基类的拷贝/移动构造函数传递一个派生类对象，仅处理（拷贝/赋值）该派生类对象中的基类自己的部分，该派生类对象中的其他部分相当于被<strong>切掉（sliced down）</strong>了</p>\n<h3 id=\"2-虚函数\"><a href=\"#2-虚函数\" class=\"headerlink\" title=\"2. 虚函数\"></a>2. 虚函数</h3><p>使用基类的引用/指针调用一个虚函数时会执行动态绑定，编译器直到运行时才能确定应该调用哪个版本的虚函数，被调用的函数是与绑定到指针/引用上的对象的动态类型相匹配</p>\n<blockquote>\n<p>所有虚函数都必须定义，不管它是否被用到了，因为连编译器也无法确定到底会使用哪个虚函数</p>\n</blockquote>\n<h5 id=\"2-1-派生类中的虚函数\"><a href=\"#2-1-派生类中的虚函数\" class=\"headerlink\" title=\"2.1 派生类中的虚函数\"></a>2.1 派生类中的虚函数</h5><ul>\n<li><p>一旦某个函数被声明成虚函数，则在所有派生类中它都是虚函数</p>\n</li>\n<li><p>派生类中<strong>覆盖</strong>基类虚函数，要求形参类型一致，返回类型要么一致，要么可自动转换</p>\n</li>\n<li><p>虚函数的<strong>默认实参</strong>由本次调用的<strong>静态类型</strong>决定</p>\n</li>\n</ul>\n<h5 id=\"2-2-抽象基类\"><a href=\"#2-2-抽象基类\" class=\"headerlink\" title=\"2.2 抽象基类\"></a>2.2 抽象基类</h5><ul>\n<li>用<code>=0</code>声明一个纯虚函数，一个纯虚函数无需定义（也可以有定义，但<strong>必须定义在类外部</strong>）</li>\n<li>含有纯虚函数的类是抽象基类，<strong>不能</strong>直接创建一个抽象基类的对象</li>\n</ul>\n<h5 id=\"2-3-构造-析构函数与虚函数\"><a href=\"#2-3-构造-析构函数与虚函数\" class=\"headerlink\" title=\"2.3 构造/析构函数与虚函数\"></a>2.3 构造/析构函数与虚函数</h5><ol>\n<li><p>基类的析构函数一般是虚函数</p>\n<p>派生类的析构函数也因此是虚函数。基类指针指向派生类对象，那么 delete 该指针的时候，会实际调用派生类的析构函数，派生类析构完成之后，再调用基类的析构函数。如果基类的析构函数不是虚函数，那么 delete <u>基类</u>指针的时候，只会调用基类的析构函数，因此子类无法正常析构。</p>\n</li>\n<li><p>构造函数不能是虚函数</p>\n<ul>\n<li>从<code>vptr</code>角度解释：虚函数的调用是通过虚函数表来查找的，而虚函数表由类的实例化对象的<code>vptr</code>指针指向。该指针存放在对象的内部空间中，需要调用构造函数完成初始化。如果构造函数是虚函数，那么调用构造函数就需要去找<code>vptr</code>，但此时<code>vptr</code>还没有初始化！</li>\n<li>从多态角度解释【挖坑】</li>\n</ul>\n</li>\n</ol>\n<p><strong>定义派生类的拷贝或移动构造函数</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span> &#123;</span> <span class=\"comment\">/*..*/</span>&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">D</span>:</span> <span class=\"keyword\">public</span> Base &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"comment\">//默认情况下，基类的默认构造函数初始化对象的基类部分</span></span><br><span class=\"line\">    <span class=\"comment\">//要想使用拷贝或移动构造函数，必须在构造函数初始值列表中显示地调用该构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">D</span>(<span class=\"keyword\">const</span> D&amp; d): <span class=\"built_in\">Base</span>(d)           <span class=\"comment\">//拷贝基类成员</span></span><br><span class=\"line\">    \t\t\t<span class=\"comment\">/* D的成员的初始值 */</span>  &#123;<span class=\"comment\">/*...*/</span>&#125;</span><br><span class=\"line\">    <span class=\"built_in\">D</span>(D&amp;&amp; d): <span class=\"built_in\">Base</span>(std::<span class=\"built_in\">move</span>(d))     <span class=\"comment\">//移动基类成员</span></span><br><span class=\"line\">                <span class=\"comment\">/* D的成员的初始值 */</span>  &#123;<span class=\"comment\">/*...*/</span>&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>Base(d)</code> 匹配 <code>Base</code> 的拷贝构造函数，然后 <code>Base</code> 的拷贝构造函数负责将 <u><code>d</code> 的基类部分</u>拷贝给要创建的对象</p>\n<h5 id=\"2-4-名字查找和继承\"><a href=\"#2-4-名字查找和继承\" class=\"headerlink\" title=\"2.4 名字查找和继承\"></a>2.4 名字查找和继承</h5><p>查找名字和确定调用哪个虚函数是分开的</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220311115032636.png\" alt=\"image-20220311115032636\"></p>\n<h5 id=\"2-5-怎么根据虚函数的名字找到最终要调用的函数地址？\"><a href=\"#2-5-怎么根据虚函数的名字找到最终要调用的函数地址？\" class=\"headerlink\" title=\"2.5 怎么根据虚函数的名字找到最终要调用的函数地址？\"></a>2.5 怎么根据虚函数的名字找到最终要调用的函数地址？</h5><p>每一个含有虚函数的类都有自己的虚表，它是一个静态指针数组，由编译器在编译时填好。虚表中每个条目都对应一个虚函数的地址（函数指针），指向此类可以访问到的 <code>most-derived</code> 虚函数。</p>\n<p>每个对象中都存在一个隐藏指针（<code>*__vptr</code>），指向整个虚表，当一个对象被创建时，<code>*__vptr</code>会由构造函数进行初始化，决定它指向哪张虚表。所以每个对象的占用内存会偏大，因为其中也存储了<code>*__vptr</code></p>\n<p>每个多态 class object 身上会有额外两个 members：</p>\n<ol>\n<li>RTTI 信息，用于在运行时确定对象的实际类型</li>\n<li>虚表指针+虚表</li>\n</ol>\n<p>为了完成多态，编译器完成两项工作：</p>\n<ol>\n<li>构造虚表，填好虚表中的地址</li>\n<li>确定好每个虚函数的偏移</li>\n</ol>\n<p>现在有这样的式子：<code>ptr-&gt;z();</code>表示一个虚函数调用，如何确定要调用的<code>z()</code>地址？由于：</p>\n<p>（1）所有类的虚表已经在编译时确定</p>\n<p>（2）<code>z()</code>在虚表中的偏移在编译时已经设定好且固定了，这里假设偏移为<code>4</code></p>\n<p>所以该式子可以被转化为：<code>(*ptr-&gt;vptr[4])(ptr)</code>，虚表已知，偏移已知，需要在<u>运行时</u>让构造函数对<code>vptr</code>进行初始化，确定该<code>vptr</code>应该指向哪一个虚表，再利用已知的偏移信息，就可以找到正确的虚函数的地址</p>\n<blockquote>\n<p>运行时，对于<code>ptr-&gt;z()</code>这个函数调用，<code>ptr</code>的首地址，即<code>this</code>的地址会被压栈，<code>this</code>的地址实际上也是<code>vptr</code>的位置，根据<code>vptr</code>找到虚表，根据偏移取出函数地址，执行<code>call</code>指令 </p>\n</blockquote>\n<h5 id=\"2-6-虚表指针放在什么位置\"><a href=\"#2-6-虚表指针放在什么位置\" class=\"headerlink\" title=\"2.6 虚表指针放在什么位置\"></a>2.6 虚表指针放在什么位置</h5><p>通常放在对象开头，到底能不能放在对象最后呢？这个还没有查到靠谱的资料，在《深入探索C++对象模型》书中说到<code>*__vptr</code>曾经有被放在对象尾部（为了兼容C）</p>\n<h3 id=\"3-多继承中的虚函数\"><a href=\"#3-多继承中的虚函数\" class=\"headerlink\" title=\"3. 多继承中的虚函数\"></a>3. 多继承中的虚函数</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">CommonFunction</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"keyword\">virtual</span> <span class=\"title\">VirtualFunction</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DerivedClass1</span> :</span> <span class=\"keyword\">public</span> Base</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DerivedCommonFunction</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"keyword\">virtual</span> <span class=\"title\">VirtualFunction</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DerivedClass2</span> :</span> <span class=\"keyword\">public</span> Base</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> d;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DerivedCommonFunction</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"keyword\">virtual</span> <span class=\"title\">VirtualFunction</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DerivedDerivedClass</span> :</span> <span class=\"keyword\">public</span> DerivedClass1, <span class=\"keyword\">public</span> DerivedClass2</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   \t<span class=\"keyword\">int</span> e;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DerivedDerivedCommonFunction</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"keyword\">virtual</span> <span class=\"title\">VirtualFunction</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>多重继承情况下，（没有虚继承 ），<code>DerivedDerivedClass</code>的内存布局会是怎样的？</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220523100657194.png\" alt=\"image-20220523100657194\"></p>\n<p>可以看到，<code>DerivedDerivedClass</code>的两个基类按顺序排布，两份<code>Base</code>类内存，有两个虚表指针，第二个虚表指针的偏移为<code>24</code>。由于多继承，同一个 object 的地址会出现不一样的情况：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   DerivedDerivedClass* d = <span class=\"keyword\">new</span> DerivedDerivedClass;</span><br><span class=\"line\">   DerivedClass1* a = d;</span><br><span class=\"line\">   DerivedClass2* b = d;</span><br><span class=\"line\"><span class=\"comment\">// a 和 b 的值会不一样，就像是 d 有两份地址一样</span></span><br><span class=\"line\">   cout &lt;&lt; a &lt;&lt; endl;</span><br><span class=\"line\">   cout &lt;&lt; b &lt;&lt; endl;</span><br></pre></td></tr></table></figure>\n\n<p><code>DerivedDerivedClass</code>的虚表结构：</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220523104144845.png\" alt=\"image-20220523104144845\"></p>\n<p>可以看到这里有两张虚表了，第二张虚表中的<code>-24</code>表示指向这张虚表的<code>*__vptr</code>偏移，这正是<code>DerivedDerivedClass</code>内存布局中第二个<code>*__vptr</code>的位置偏移</p>\n<h3 id=\"4-虚继承中的虚函数\"><a href=\"#4-虚继承中的虚函数\" class=\"headerlink\" title=\"4. 虚继承中的虚函数\"></a>4. 虚继承中的虚函数</h3><p>虚基类的偏移量在运行时才可以确定 【】</p>\n<p>引入虚继承后</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<p>参考资料：</p>\n<ol>\n<li>《effective C++ 第三版》</li>\n<li>《C++ Primer 第五版》</li>\n<li>《C++编程思想》</li>\n<li>《深入探索C++对象模型》</li>\n<li>利用 visual studio 查看 C++ 类内存布局：<a href=\"https://www.cnblogs.com/jerry19880126/p/3616999.html\">https://www.cnblogs.com/jerry19880126/p/3616999.html</a></li>\n<li></li>\n</ol>\n<h3 id=\"1-静态类型-vs-动态类型\"><a href=\"#1-静态类型-vs-动态类型\" class=\"headerlink\" title=\"1. 静态类型 vs. 动态类型\"></a>1. 静态类型 vs. 动态类型</h3><p>静态类型：编译时已知，是变量声明时的类型或表达式生成的类型</p>\n<p>动态类型：直到运行时才可知，变量或表达式在内存中的对象的类型</p>\n<blockquote>\n<p>如果表达式<strong>不是指针/引用</strong>，则其动态类型与静态类型<strong>一致</strong></p>\n</blockquote>\n<p>不存在<strong>从基类到派生类</strong>的隐式类型转换，因为基类有可能不是派生类的一部分</p>\n<p>即使一个基类指针/引用绑定在一个派生类对象上，我们也不能执行从基类向派生类的<strong>自动</strong>转换：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C_derived child;  \t\t\t\t\t<span class=\"comment\">//派生类对象</span></span><br><span class=\"line\">C *father = &amp;child;\t\t\t\t\t<span class=\"comment\">//\t</span></span><br><span class=\"line\">C_derived *cc = father;\t\t\t\t<span class=\"comment\">//错误，不能将基类自动转换为派生类</span></span><br></pre></td></tr></table></figure>\n\n<p>虽然这个转换是安全的，但是<u>过不了编译器静态时的安全检查</u>，编译器只能通过检查指针/引用的静态类型来推断该转换是否合法</p>\n<p>如果基类中有虚函数，可以用 <code>dynamic_cast</code>，执行<strong>运行时</strong>的安全检查</p>\n<blockquote>\n<p>如果确认基类向派生类的转换是安全的，可以使用 <code>static_cast</code> 来强制覆盖掉编译器的检查工作</p>\n</blockquote>\n<p>因为基类的拷贝/移动操作的参数是引用，所以可以给基类的拷贝/移动构造函数传递一个派生类对象，仅处理（拷贝/赋值）该派生类对象中的基类自己的部分，该派生类对象中的其他部分相当于被<strong>切掉（sliced down）</strong>了</p>\n<h3 id=\"2-虚函数\"><a href=\"#2-虚函数\" class=\"headerlink\" title=\"2. 虚函数\"></a>2. 虚函数</h3><p>使用基类的引用/指针调用一个虚函数时会执行动态绑定，编译器直到运行时才能确定应该调用哪个版本的虚函数，被调用的函数是与绑定到指针/引用上的对象的动态类型相匹配</p>\n<blockquote>\n<p>所有虚函数都必须定义，不管它是否被用到了，因为连编译器也无法确定到底会使用哪个虚函数</p>\n</blockquote>\n<h5 id=\"2-1-派生类中的虚函数\"><a href=\"#2-1-派生类中的虚函数\" class=\"headerlink\" title=\"2.1 派生类中的虚函数\"></a>2.1 派生类中的虚函数</h5><ul>\n<li><p>一旦某个函数被声明成虚函数，则在所有派生类中它都是虚函数</p>\n</li>\n<li><p>派生类中<strong>覆盖</strong>基类虚函数，要求形参类型一致，返回类型要么一致，要么可自动转换</p>\n</li>\n<li><p>虚函数的<strong>默认实参</strong>由本次调用的<strong>静态类型</strong>决定</p>\n</li>\n</ul>\n<h5 id=\"2-2-抽象基类\"><a href=\"#2-2-抽象基类\" class=\"headerlink\" title=\"2.2 抽象基类\"></a>2.2 抽象基类</h5><ul>\n<li>用<code>=0</code>声明一个纯虚函数，一个纯虚函数无需定义（也可以有定义，但<strong>必须定义在类外部</strong>）</li>\n<li>含有纯虚函数的类是抽象基类，<strong>不能</strong>直接创建一个抽象基类的对象</li>\n</ul>\n<h5 id=\"2-3-构造-析构函数与虚函数\"><a href=\"#2-3-构造-析构函数与虚函数\" class=\"headerlink\" title=\"2.3 构造/析构函数与虚函数\"></a>2.3 构造/析构函数与虚函数</h5><ol>\n<li><p>基类的析构函数一般是虚函数</p>\n<p>派生类的析构函数也因此是虚函数。基类指针指向派生类对象，那么 delete 该指针的时候，会实际调用派生类的析构函数，派生类析构完成之后，再调用基类的析构函数。如果基类的析构函数不是虚函数，那么 delete <u>基类</u>指针的时候，只会调用基类的析构函数，因此子类无法正常析构。</p>\n</li>\n<li><p>构造函数不能是虚函数</p>\n<ul>\n<li>从<code>vptr</code>角度解释：虚函数的调用是通过虚函数表来查找的，而虚函数表由类的实例化对象的<code>vptr</code>指针指向。该指针存放在对象的内部空间中，需要调用构造函数完成初始化。如果构造函数是虚函数，那么调用构造函数就需要去找<code>vptr</code>，但此时<code>vptr</code>还没有初始化！</li>\n<li>从多态角度解释【挖坑】</li>\n</ul>\n</li>\n</ol>\n<p><strong>定义派生类的拷贝或移动构造函数</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span> &#123;</span> <span class=\"comment\">/*..*/</span>&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">D</span>:</span> <span class=\"keyword\">public</span> Base &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"comment\">//默认情况下，基类的默认构造函数初始化对象的基类部分</span></span><br><span class=\"line\">    <span class=\"comment\">//要想使用拷贝或移动构造函数，必须在构造函数初始值列表中显示地调用该构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">D</span>(<span class=\"keyword\">const</span> D&amp; d): <span class=\"built_in\">Base</span>(d)           <span class=\"comment\">//拷贝基类成员</span></span><br><span class=\"line\">    \t\t\t<span class=\"comment\">/* D的成员的初始值 */</span>  &#123;<span class=\"comment\">/*...*/</span>&#125;</span><br><span class=\"line\">    <span class=\"built_in\">D</span>(D&amp;&amp; d): <span class=\"built_in\">Base</span>(std::<span class=\"built_in\">move</span>(d))     <span class=\"comment\">//移动基类成员</span></span><br><span class=\"line\">                <span class=\"comment\">/* D的成员的初始值 */</span>  &#123;<span class=\"comment\">/*...*/</span>&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>Base(d)</code> 匹配 <code>Base</code> 的拷贝构造函数，然后 <code>Base</code> 的拷贝构造函数负责将 <u><code>d</code> 的基类部分</u>拷贝给要创建的对象</p>\n<h5 id=\"2-4-名字查找和继承\"><a href=\"#2-4-名字查找和继承\" class=\"headerlink\" title=\"2.4 名字查找和继承\"></a>2.4 名字查找和继承</h5><p>查找名字和确定调用哪个虚函数是分开的</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220311115032636.png\" alt=\"image-20220311115032636\"></p>\n<h5 id=\"2-5-怎么根据虚函数的名字找到最终要调用的函数地址？\"><a href=\"#2-5-怎么根据虚函数的名字找到最终要调用的函数地址？\" class=\"headerlink\" title=\"2.5 怎么根据虚函数的名字找到最终要调用的函数地址？\"></a>2.5 怎么根据虚函数的名字找到最终要调用的函数地址？</h5><p>每一个含有虚函数的类都有自己的虚表，它是一个静态指针数组，由编译器在编译时填好。虚表中每个条目都对应一个虚函数的地址（函数指针），指向此类可以访问到的 <code>most-derived</code> 虚函数。</p>\n<p>每个对象中都存在一个隐藏指针（<code>*__vptr</code>），指向整个虚表，当一个对象被创建时，<code>*__vptr</code>会由构造函数进行初始化，决定它指向哪张虚表。所以每个对象的占用内存会偏大，因为其中也存储了<code>*__vptr</code></p>\n<p>每个多态 class object 身上会有额外两个 members：</p>\n<ol>\n<li>RTTI 信息，用于在运行时确定对象的实际类型</li>\n<li>虚表指针+虚表</li>\n</ol>\n<p>为了完成多态，编译器完成两项工作：</p>\n<ol>\n<li>构造虚表，填好虚表中的地址</li>\n<li>确定好每个虚函数的偏移</li>\n</ol>\n<p>现在有这样的式子：<code>ptr-&gt;z();</code>表示一个虚函数调用，如何确定要调用的<code>z()</code>地址？由于：</p>\n<p>（1）所有类的虚表已经在编译时确定</p>\n<p>（2）<code>z()</code>在虚表中的偏移在编译时已经设定好且固定了，这里假设偏移为<code>4</code></p>\n<p>所以该式子可以被转化为：<code>(*ptr-&gt;vptr[4])(ptr)</code>，虚表已知，偏移已知，需要在<u>运行时</u>让构造函数对<code>vptr</code>进行初始化，确定该<code>vptr</code>应该指向哪一个虚表，再利用已知的偏移信息，就可以找到正确的虚函数的地址</p>\n<blockquote>\n<p>运行时，对于<code>ptr-&gt;z()</code>这个函数调用，<code>ptr</code>的首地址，即<code>this</code>的地址会被压栈，<code>this</code>的地址实际上也是<code>vptr</code>的位置，根据<code>vptr</code>找到虚表，根据偏移取出函数地址，执行<code>call</code>指令 </p>\n</blockquote>\n<h5 id=\"2-6-虚表指针放在什么位置\"><a href=\"#2-6-虚表指针放在什么位置\" class=\"headerlink\" title=\"2.6 虚表指针放在什么位置\"></a>2.6 虚表指针放在什么位置</h5><p>通常放在对象开头，到底能不能放在对象最后呢？这个还没有查到靠谱的资料，在《深入探索C++对象模型》书中说到<code>*__vptr</code>曾经有被放在对象尾部（为了兼容C）</p>\n<h3 id=\"3-多继承中的虚函数\"><a href=\"#3-多继承中的虚函数\" class=\"headerlink\" title=\"3. 多继承中的虚函数\"></a>3. 多继承中的虚函数</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">CommonFunction</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"keyword\">virtual</span> <span class=\"title\">VirtualFunction</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DerivedClass1</span> :</span> <span class=\"keyword\">public</span> Base</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DerivedCommonFunction</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"keyword\">virtual</span> <span class=\"title\">VirtualFunction</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DerivedClass2</span> :</span> <span class=\"keyword\">public</span> Base</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> d;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DerivedCommonFunction</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"keyword\">virtual</span> <span class=\"title\">VirtualFunction</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DerivedDerivedClass</span> :</span> <span class=\"keyword\">public</span> DerivedClass1, <span class=\"keyword\">public</span> DerivedClass2</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   \t<span class=\"keyword\">int</span> e;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DerivedDerivedCommonFunction</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"keyword\">virtual</span> <span class=\"title\">VirtualFunction</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>多重继承情况下，（没有虚继承 ），<code>DerivedDerivedClass</code>的内存布局会是怎样的？</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220523100657194.png\" alt=\"image-20220523100657194\"></p>\n<p>可以看到，<code>DerivedDerivedClass</code>的两个基类按顺序排布，两份<code>Base</code>类内存，有两个虚表指针，第二个虚表指针的偏移为<code>24</code>。由于多继承，同一个 object 的地址会出现不一样的情况：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   DerivedDerivedClass* d = <span class=\"keyword\">new</span> DerivedDerivedClass;</span><br><span class=\"line\">   DerivedClass1* a = d;</span><br><span class=\"line\">   DerivedClass2* b = d;</span><br><span class=\"line\"><span class=\"comment\">// a 和 b 的值会不一样，就像是 d 有两份地址一样</span></span><br><span class=\"line\">   cout &lt;&lt; a &lt;&lt; endl;</span><br><span class=\"line\">   cout &lt;&lt; b &lt;&lt; endl;</span><br></pre></td></tr></table></figure>\n\n<p><code>DerivedDerivedClass</code>的虚表结构：</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220523104144845.png\" alt=\"image-20220523104144845\"></p>\n<p>可以看到这里有两张虚表了，第二张虚表中的<code>-24</code>表示指向这张虚表的<code>*__vptr</code>偏移，这正是<code>DerivedDerivedClass</code>内存布局中第二个<code>*__vptr</code>的位置偏移</p>\n<h3 id=\"4-虚继承中的虚函数\"><a href=\"#4-虚继承中的虚函数\" class=\"headerlink\" title=\"4. 虚继承中的虚函数\"></a>4. 虚继承中的虚函数</h3><p>虚基类的偏移量在运行时才可以确定 【】</p>\n<p>引入虚继承后</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n"},{"_content":"隐式类型转换\n\n转换构造函数：只接受一个实参，或者其他参数都有默认参数【】\n\n```c++\nclass Sale_data {\npublic:\n\tSale_data() = default;\n\tSale_data(const string& s) :bookNo(s) { } //转换构造函数\n\tSale_data(const Sale_data& temp) :bookNo(temp.bookNo), units_sold(temp.units_sold), revenue(temp.revenue) { cout << \"拷构\" << endl; }//拷贝构造函数\n\t...\n\tSale_data& combine( const Sale_data temp&) {\n\t\treturn ;\n\t}\nprivate:\n\tstring bookNo;\n\tunsigned units_sold = 0;\n\tdouble revenue = 0.0;\n};\n\nint main()\n{\n\tSale_data item;\n\tstring null_book = \"999\"; //这有一次 string 的拷贝构造函数调用\n\t//Sale_data tt;\n\titem.combine(null_book);\n\t//cout <<<< endl;\n\treturn 0;\n}\n```\n\n\n\n","source":"_posts/C++/类/隐式类型转换.md","raw":"隐式类型转换\n\n转换构造函数：只接受一个实参，或者其他参数都有默认参数【】\n\n```c++\nclass Sale_data {\npublic:\n\tSale_data() = default;\n\tSale_data(const string& s) :bookNo(s) { } //转换构造函数\n\tSale_data(const Sale_data& temp) :bookNo(temp.bookNo), units_sold(temp.units_sold), revenue(temp.revenue) { cout << \"拷构\" << endl; }//拷贝构造函数\n\t...\n\tSale_data& combine( const Sale_data temp&) {\n\t\treturn ;\n\t}\nprivate:\n\tstring bookNo;\n\tunsigned units_sold = 0;\n\tdouble revenue = 0.0;\n};\n\nint main()\n{\n\tSale_data item;\n\tstring null_book = \"999\"; //这有一次 string 的拷贝构造函数调用\n\t//Sale_data tt;\n\titem.combine(null_book);\n\t//cout <<<< endl;\n\treturn 0;\n}\n```\n\n\n\n","slug":"C++/类/隐式类型转换","published":1,"date":"2021-12-31T02:09:01.631Z","updated":"2022-05-19T03:05:53.861Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0ky1001lpcu3aedfcsnq","content":"<p>隐式类型转换</p>\n<p>转换构造函数：只接受一个实参，或者其他参数都有默认参数【】</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sale_data</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">Sale_data</span>() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">Sale_data</span>(<span class=\"keyword\">const</span> string&amp; s) :<span class=\"built_in\">bookNo</span>(s) &#123; &#125; <span class=\"comment\">//转换构造函数</span></span><br><span class=\"line\">\t<span class=\"built_in\">Sale_data</span>(<span class=\"keyword\">const</span> Sale_data&amp; temp) :<span class=\"built_in\">bookNo</span>(temp.bookNo), <span class=\"built_in\">units_sold</span>(temp.units_sold), <span class=\"built_in\">revenue</span>(temp.revenue) &#123; cout &lt;&lt; <span class=\"string\">&quot;拷构&quot;</span> &lt;&lt; endl; &#125;<span class=\"comment\">//拷贝构造函数</span></span><br><span class=\"line\">\t...</span><br><span class=\"line\">\t<span class=\"function\">Sale_data&amp; <span class=\"title\">combine</span><span class=\"params\">( <span class=\"keyword\">const</span> Sale_data temp&amp;)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\tstring bookNo;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> units_sold = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">double</span> revenue = <span class=\"number\">0.0</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tSale_data item;</span><br><span class=\"line\">\tstring null_book = <span class=\"string\">&quot;999&quot;</span>; <span class=\"comment\">//这有一次 string 的拷贝构造函数调用</span></span><br><span class=\"line\">\t<span class=\"comment\">//Sale_data tt;</span></span><br><span class=\"line\">\titem.<span class=\"built_in\">combine</span>(null_book);</span><br><span class=\"line\">\t<span class=\"comment\">//cout &lt;&lt;&lt;&lt; endl;</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<p>隐式类型转换</p>\n<p>转换构造函数：只接受一个实参，或者其他参数都有默认参数【】</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sale_data</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">Sale_data</span>() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">Sale_data</span>(<span class=\"keyword\">const</span> string&amp; s) :<span class=\"built_in\">bookNo</span>(s) &#123; &#125; <span class=\"comment\">//转换构造函数</span></span><br><span class=\"line\">\t<span class=\"built_in\">Sale_data</span>(<span class=\"keyword\">const</span> Sale_data&amp; temp) :<span class=\"built_in\">bookNo</span>(temp.bookNo), <span class=\"built_in\">units_sold</span>(temp.units_sold), <span class=\"built_in\">revenue</span>(temp.revenue) &#123; cout &lt;&lt; <span class=\"string\">&quot;拷构&quot;</span> &lt;&lt; endl; &#125;<span class=\"comment\">//拷贝构造函数</span></span><br><span class=\"line\">\t...</span><br><span class=\"line\">\t<span class=\"function\">Sale_data&amp; <span class=\"title\">combine</span><span class=\"params\">( <span class=\"keyword\">const</span> Sale_data temp&amp;)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\tstring bookNo;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> units_sold = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">double</span> revenue = <span class=\"number\">0.0</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tSale_data item;</span><br><span class=\"line\">\tstring null_book = <span class=\"string\">&quot;999&quot;</span>; <span class=\"comment\">//这有一次 string 的拷贝构造函数调用</span></span><br><span class=\"line\">\t<span class=\"comment\">//Sale_data tt;</span></span><br><span class=\"line\">\titem.<span class=\"built_in\">combine</span>(null_book);</span><br><span class=\"line\">\t<span class=\"comment\">//cout &lt;&lt;&lt;&lt; endl;</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n"},{"_content":"享元模式\n\n使用共享以高效地支持大量的细粒度对象，例如大量的树木、地形瓦片的渲染\n\nwhat？\n\n享元模式通过将对象数据切分为两种类型来解决问题。第一种类型数据是那些不属于单一实例对象并且能够被所有对象共享的数据。GoF将其称为<u>内部状态（the intrinsic state）</u>，或称为“上下文无关状态”状态。其他数据便是<u>外部状态（the extrinsic state）</u>，对于每一个实例，它们都是唯一的。享元模式通过在每一个对象实例之间共享内部状态数据来节省内存。\n\n应用场景\n\n1.1 森林\n\n一棵树的数据结构：\n\n```cpp\nclass Tree\n{\nprivate:\n    Mesh mesh_;\t\t\t//多边形网格\n    Texture bark_;\t\t//树皮纹理\n    Texture leaves_;\t//树叶纹理\n    Vector position_;\t//位置\n    double height_;\t\t//高度\n    double thickness_;\t//厚度\n    Color barkTint;\t\t//颜色\n    Color leafTint;\n};\n```\n\n当然，实际中不可能在一帧内将这么大的数据量传给GPU。其实大量的树木看起来都差不多，比如它们的网格、使用的纹理数据都是一致的，即可以让所有树木都共享相同的网格、纹理数据，这样只需要给GPU传一份网格、纹理数据就行了，如图：\n\n![image-20220423152058269](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220423152058269.png)\n\n**TreeModel类**\n\n将所有树木对象分割成两个独立的类，一个类专门存放共享数据，另一个类存放其他独特性数据\n\n```cpp\nclass TreeModel\n{\nprivate:\n    Mesh mesh_;\n    Texture bark_;\n    Texture leaves_;\n};\n```\n\n**Tree类**\n\n游戏中每棵树的实例都有一个指向共享的`TreeModel`的引用，`Tree`类中的其他额外数据成员记录着一些独特性数据：\n\n```cpp\nclass Tree\n{\nprivate:\n    TreeModel* model_;\n    \n    vector position_;\n    double height_;\n    ...\n};\n```\n\n![image-20220423152743047](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220423152743047.png)\n\n——4棵树的实例共享着同一份数据模型\n\nGPU中的存储\n\nCPU将渲染所需数据发送给GPU，可以将共享数据只发送一次，再单独将每棵树实例的特有数据发送给GPU，告诉GPU使用那个共享模型来渲染每个树实例。\n\n扎根之地【第二个例子，以后补吧】\n\n","source":"_posts/C++/设计模式/享元模式.md","raw":"享元模式\n\n使用共享以高效地支持大量的细粒度对象，例如大量的树木、地形瓦片的渲染\n\nwhat？\n\n享元模式通过将对象数据切分为两种类型来解决问题。第一种类型数据是那些不属于单一实例对象并且能够被所有对象共享的数据。GoF将其称为<u>内部状态（the intrinsic state）</u>，或称为“上下文无关状态”状态。其他数据便是<u>外部状态（the extrinsic state）</u>，对于每一个实例，它们都是唯一的。享元模式通过在每一个对象实例之间共享内部状态数据来节省内存。\n\n应用场景\n\n1.1 森林\n\n一棵树的数据结构：\n\n```cpp\nclass Tree\n{\nprivate:\n    Mesh mesh_;\t\t\t//多边形网格\n    Texture bark_;\t\t//树皮纹理\n    Texture leaves_;\t//树叶纹理\n    Vector position_;\t//位置\n    double height_;\t\t//高度\n    double thickness_;\t//厚度\n    Color barkTint;\t\t//颜色\n    Color leafTint;\n};\n```\n\n当然，实际中不可能在一帧内将这么大的数据量传给GPU。其实大量的树木看起来都差不多，比如它们的网格、使用的纹理数据都是一致的，即可以让所有树木都共享相同的网格、纹理数据，这样只需要给GPU传一份网格、纹理数据就行了，如图：\n\n![image-20220423152058269](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220423152058269.png)\n\n**TreeModel类**\n\n将所有树木对象分割成两个独立的类，一个类专门存放共享数据，另一个类存放其他独特性数据\n\n```cpp\nclass TreeModel\n{\nprivate:\n    Mesh mesh_;\n    Texture bark_;\n    Texture leaves_;\n};\n```\n\n**Tree类**\n\n游戏中每棵树的实例都有一个指向共享的`TreeModel`的引用，`Tree`类中的其他额外数据成员记录着一些独特性数据：\n\n```cpp\nclass Tree\n{\nprivate:\n    TreeModel* model_;\n    \n    vector position_;\n    double height_;\n    ...\n};\n```\n\n![image-20220423152743047](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220423152743047.png)\n\n——4棵树的实例共享着同一份数据模型\n\nGPU中的存储\n\nCPU将渲染所需数据发送给GPU，可以将共享数据只发送一次，再单独将每棵树实例的特有数据发送给GPU，告诉GPU使用那个共享模型来渲染每个树实例。\n\n扎根之地【第二个例子，以后补吧】\n\n","slug":"C++/设计模式/享元模式","published":1,"date":"2022-04-23T07:09:41.411Z","updated":"2022-05-04T02:34:52.827Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0ky1001npcu355ig77vp","content":"<p>享元模式</p>\n<p>使用共享以高效地支持大量的细粒度对象，例如大量的树木、地形瓦片的渲染</p>\n<p>what？</p>\n<p>享元模式通过将对象数据切分为两种类型来解决问题。第一种类型数据是那些不属于单一实例对象并且能够被所有对象共享的数据。GoF将其称为<u>内部状态（the intrinsic state）</u>，或称为“上下文无关状态”状态。其他数据便是<u>外部状态（the extrinsic state）</u>，对于每一个实例，它们都是唯一的。享元模式通过在每一个对象实例之间共享内部状态数据来节省内存。</p>\n<p>应用场景</p>\n<p>1.1 森林</p>\n<p>一棵树的数据结构：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Tree</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    Mesh mesh_;\t\t\t<span class=\"comment\">//多边形网格</span></span><br><span class=\"line\">    Texture bark_;\t\t<span class=\"comment\">//树皮纹理</span></span><br><span class=\"line\">    Texture leaves_;\t<span class=\"comment\">//树叶纹理</span></span><br><span class=\"line\">    Vector position_;\t<span class=\"comment\">//位置</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> height_;\t\t<span class=\"comment\">//高度</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> thickness_;\t<span class=\"comment\">//厚度</span></span><br><span class=\"line\">    Color barkTint;\t\t<span class=\"comment\">//颜色</span></span><br><span class=\"line\">    Color leafTint;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>当然，实际中不可能在一帧内将这么大的数据量传给GPU。其实大量的树木看起来都差不多，比如它们的网格、使用的纹理数据都是一致的，即可以让所有树木都共享相同的网格、纹理数据，这样只需要给GPU传一份网格、纹理数据就行了，如图：</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220423152058269.png\" alt=\"image-20220423152058269\"></p>\n<p><strong>TreeModel类</strong></p>\n<p>将所有树木对象分割成两个独立的类，一个类专门存放共享数据，另一个类存放其他独特性数据</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TreeModel</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    Mesh mesh_;</span><br><span class=\"line\">    Texture bark_;</span><br><span class=\"line\">    Texture leaves_;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Tree类</strong></p>\n<p>游戏中每棵树的实例都有一个指向共享的<code>TreeModel</code>的引用，<code>Tree</code>类中的其他额外数据成员记录着一些独特性数据：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Tree</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    TreeModel* model_;</span><br><span class=\"line\">    </span><br><span class=\"line\">    vector position_;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> height_;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220423152743047.png\" alt=\"image-20220423152743047\"></p>\n<p>——4棵树的实例共享着同一份数据模型</p>\n<p>GPU中的存储</p>\n<p>CPU将渲染所需数据发送给GPU，可以将共享数据只发送一次，再单独将每棵树实例的特有数据发送给GPU，告诉GPU使用那个共享模型来渲染每个树实例。</p>\n<p>扎根之地【第二个例子，以后补吧】</p>\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<p>享元模式</p>\n<p>使用共享以高效地支持大量的细粒度对象，例如大量的树木、地形瓦片的渲染</p>\n<p>what？</p>\n<p>享元模式通过将对象数据切分为两种类型来解决问题。第一种类型数据是那些不属于单一实例对象并且能够被所有对象共享的数据。GoF将其称为<u>内部状态（the intrinsic state）</u>，或称为“上下文无关状态”状态。其他数据便是<u>外部状态（the extrinsic state）</u>，对于每一个实例，它们都是唯一的。享元模式通过在每一个对象实例之间共享内部状态数据来节省内存。</p>\n<p>应用场景</p>\n<p>1.1 森林</p>\n<p>一棵树的数据结构：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Tree</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    Mesh mesh_;\t\t\t<span class=\"comment\">//多边形网格</span></span><br><span class=\"line\">    Texture bark_;\t\t<span class=\"comment\">//树皮纹理</span></span><br><span class=\"line\">    Texture leaves_;\t<span class=\"comment\">//树叶纹理</span></span><br><span class=\"line\">    Vector position_;\t<span class=\"comment\">//位置</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> height_;\t\t<span class=\"comment\">//高度</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> thickness_;\t<span class=\"comment\">//厚度</span></span><br><span class=\"line\">    Color barkTint;\t\t<span class=\"comment\">//颜色</span></span><br><span class=\"line\">    Color leafTint;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>当然，实际中不可能在一帧内将这么大的数据量传给GPU。其实大量的树木看起来都差不多，比如它们的网格、使用的纹理数据都是一致的，即可以让所有树木都共享相同的网格、纹理数据，这样只需要给GPU传一份网格、纹理数据就行了，如图：</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220423152058269.png\" alt=\"image-20220423152058269\"></p>\n<p><strong>TreeModel类</strong></p>\n<p>将所有树木对象分割成两个独立的类，一个类专门存放共享数据，另一个类存放其他独特性数据</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TreeModel</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    Mesh mesh_;</span><br><span class=\"line\">    Texture bark_;</span><br><span class=\"line\">    Texture leaves_;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Tree类</strong></p>\n<p>游戏中每棵树的实例都有一个指向共享的<code>TreeModel</code>的引用，<code>Tree</code>类中的其他额外数据成员记录着一些独特性数据：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Tree</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    TreeModel* model_;</span><br><span class=\"line\">    </span><br><span class=\"line\">    vector position_;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> height_;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220423152743047.png\" alt=\"image-20220423152743047\"></p>\n<p>——4棵树的实例共享着同一份数据模型</p>\n<p>GPU中的存储</p>\n<p>CPU将渲染所需数据发送给GPU，可以将共享数据只发送一次，再单独将每棵树实例的特有数据发送给GPU，告诉GPU使用那个共享模型来渲染每个树实例。</p>\n<p>扎根之地【第二个例子，以后补吧】</p>\n"},{"_content":"构造函数非公用\n\n单例模式限制其类实例只能有一个，所以要把构造函数设为非公有，来保证其不会被用户调用\n\n```cpp\nSingleton {\npublic:\n    static Singleton& Instance(){\n        if(singleton==nullptr){\n            singleton = new Singleton();\n        }\n        return *singleton;\n    }\nprivate:\n    static Singleton* singleton;\n\tSingleton(){}\n    Singleton(const Singleton&){}\n    Singleton& operator==(const Singleton&){}\n};\n```\n\n","source":"_posts/C++/设计模式/单例模式.md","raw":"构造函数非公用\n\n单例模式限制其类实例只能有一个，所以要把构造函数设为非公有，来保证其不会被用户调用\n\n```cpp\nSingleton {\npublic:\n    static Singleton& Instance(){\n        if(singleton==nullptr){\n            singleton = new Singleton();\n        }\n        return *singleton;\n    }\nprivate:\n    static Singleton* singleton;\n\tSingleton(){}\n    Singleton(const Singleton&){}\n    Singleton& operator==(const Singleton&){}\n};\n```\n\n","slug":"C++/设计模式/单例模式","published":1,"date":"2022-04-14T11:20:57.928Z","updated":"2022-05-04T02:10:01.002Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0ky2001opcu38gju0fu5","content":"<p>构造函数非公用</p>\n<p>单例模式限制其类实例只能有一个，所以要把构造函数设为非公有，来保证其不会被用户调用</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Singleton &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> Singleton&amp; <span class=\"title\">Instance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(singleton==<span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">            singleton = <span class=\"keyword\">new</span> <span class=\"built_in\">Singleton</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> *singleton;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">static</span> Singleton* singleton;</span><br><span class=\"line\">\t<span class=\"built_in\">Singleton</span>()&#123;&#125;</span><br><span class=\"line\">    <span class=\"built_in\">Singleton</span>(<span class=\"keyword\">const</span> Singleton&amp;)&#123;&#125;</span><br><span class=\"line\">    Singleton&amp; <span class=\"keyword\">operator</span>==(<span class=\"keyword\">const</span> Singleton&amp;)&#123;&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<p>构造函数非公用</p>\n<p>单例模式限制其类实例只能有一个，所以要把构造函数设为非公有，来保证其不会被用户调用</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Singleton &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> Singleton&amp; <span class=\"title\">Instance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(singleton==<span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">            singleton = <span class=\"keyword\">new</span> <span class=\"built_in\">Singleton</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> *singleton;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">static</span> Singleton* singleton;</span><br><span class=\"line\">\t<span class=\"built_in\">Singleton</span>()&#123;&#125;</span><br><span class=\"line\">    <span class=\"built_in\">Singleton</span>(<span class=\"keyword\">const</span> Singleton&amp;)&#123;&#125;</span><br><span class=\"line\">    Singleton&amp; <span class=\"keyword\">operator</span>==(<span class=\"keyword\">const</span> Singleton&amp;)&#123;&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n"},{"_content":"参考资料：《设计模式—可复用面向对象软件的基础》\n\nDecorator装饰模式——对象结构模式\n\n可以动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式比生成子类更加灵活。\n\nwhy？\n\n有时希望给某个对象而不是整个类添加一些功能。例如，一个图形用户界面工具箱允许你对任意一个用户界面组件添加一些特性，例如边框、窗口滚动。\n\n使用继承机制可以有效添加功能，但是这种方法不够灵活，因为边框的选择是静态的，用户不能控制对组件加边框的方式和时机。\n\n> 继承下来就有了边框，但有时不想加边框怎么办？所以”继承“不够灵活\n\n一种较为灵活的方式是将组件嵌入另一个对象中，给这个对象添加边框，它对使用该组件的客户透明。它将客户请求转发给组件，并且可能在转发前后执行一些额外的动作（例如画一个边框，即生成组件）。透明性使得可以递归嵌套多个装饰，从而添加任意多的功能。\n\n![image-20220422215912681](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220422215912681.png)","source":"_posts/C++/设计模式/装饰模式.md","raw":"参考资料：《设计模式—可复用面向对象软件的基础》\n\nDecorator装饰模式——对象结构模式\n\n可以动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式比生成子类更加灵活。\n\nwhy？\n\n有时希望给某个对象而不是整个类添加一些功能。例如，一个图形用户界面工具箱允许你对任意一个用户界面组件添加一些特性，例如边框、窗口滚动。\n\n使用继承机制可以有效添加功能，但是这种方法不够灵活，因为边框的选择是静态的，用户不能控制对组件加边框的方式和时机。\n\n> 继承下来就有了边框，但有时不想加边框怎么办？所以”继承“不够灵活\n\n一种较为灵活的方式是将组件嵌入另一个对象中，给这个对象添加边框，它对使用该组件的客户透明。它将客户请求转发给组件，并且可能在转发前后执行一些额外的动作（例如画一个边框，即生成组件）。透明性使得可以递归嵌套多个装饰，从而添加任意多的功能。\n\n![image-20220422215912681](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220422215912681.png)","slug":"C++/设计模式/装饰模式","published":1,"date":"2022-04-22T13:37:03.810Z","updated":"2022-04-22T14:09:34.617Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0ky3001qpcu39r1e7npr","content":"<p>参考资料：《设计模式—可复用面向对象软件的基础》</p>\n<p>Decorator装饰模式——对象结构模式</p>\n<p>可以动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式比生成子类更加灵活。</p>\n<p>why？</p>\n<p>有时希望给某个对象而不是整个类添加一些功能。例如，一个图形用户界面工具箱允许你对任意一个用户界面组件添加一些特性，例如边框、窗口滚动。</p>\n<p>使用继承机制可以有效添加功能，但是这种方法不够灵活，因为边框的选择是静态的，用户不能控制对组件加边框的方式和时机。</p>\n<blockquote>\n<p>继承下来就有了边框，但有时不想加边框怎么办？所以”继承“不够灵活</p>\n</blockquote>\n<p>一种较为灵活的方式是将组件嵌入另一个对象中，给这个对象添加边框，它对使用该组件的客户透明。它将客户请求转发给组件，并且可能在转发前后执行一些额外的动作（例如画一个边框，即生成组件）。透明性使得可以递归嵌套多个装饰，从而添加任意多的功能。</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220422215912681.png\" alt=\"image-20220422215912681\"></p>\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<p>参考资料：《设计模式—可复用面向对象软件的基础》</p>\n<p>Decorator装饰模式——对象结构模式</p>\n<p>可以动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式比生成子类更加灵活。</p>\n<p>why？</p>\n<p>有时希望给某个对象而不是整个类添加一些功能。例如，一个图形用户界面工具箱允许你对任意一个用户界面组件添加一些特性，例如边框、窗口滚动。</p>\n<p>使用继承机制可以有效添加功能，但是这种方法不够灵活，因为边框的选择是静态的，用户不能控制对组件加边框的方式和时机。</p>\n<blockquote>\n<p>继承下来就有了边框，但有时不想加边框怎么办？所以”继承“不够灵活</p>\n</blockquote>\n<p>一种较为灵活的方式是将组件嵌入另一个对象中，给这个对象添加边框，它对使用该组件的客户透明。它将客户请求转发给组件，并且可能在转发前后执行一些额外的动作（例如画一个边框，即生成组件）。透明性使得可以递归嵌套多个装饰，从而添加任意多的功能。</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220422215912681.png\" alt=\"image-20220422215912681\"></p>\n"},{"_content":"命令模式\n\n将一个请求（request）封装成一个对象，从而允许你使用不同的请求、队列或日志将客户端参数化，同时支持请求操作的撤销与恢复。\n\n","source":"_posts/C++/设计模式/命令模式.md","raw":"命令模式\n\n将一个请求（request）封装成一个对象，从而允许你使用不同的请求、队列或日志将客户端参数化，同时支持请求操作的撤销与恢复。\n\n","slug":"C++/设计模式/命令模式","published":1,"date":"2022-04-23T06:26:05.135Z","updated":"2022-04-23T07:09:37.181Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0ky3001rpcu35f8r3ws9","content":"<p>命令模式</p>\n<p>将一个请求（request）封装成一个对象，从而允许你使用不同的请求、队列或日志将客户端参数化，同时支持请求操作的撤销与恢复。</p>\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<p>命令模式</p>\n<p>将一个请求（request）封装成一个对象，从而允许你使用不同的请求、队列或日志将客户端参数化，同时支持请求操作的撤销与恢复。</p>\n"},{"_content":"参考资料：\n\n《设计模式—可复用面向对象软件的基础》\n\n《深入设计模式》\n\n### 工厂模式—创建型设计模式\n\n其在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型。使一个类的实例化延迟到其子类。\n\nwhy？\n\n应用场景：对于物流管理应用，最初版本只能处理卡车运输，所以大部分代码都位于名为卡车的类中，但是后续如何支持轮船以及其他更多的运输工具呢？\n\n工厂方法<u>将创建产品的代码与实际使用产品的代码分离</u>，从而能在不影响其他代码的情况下扩展产品创建部分代码。\n\n例如，如果需要向应用中添加一种新产品，你只需要开发新的创建者子类，然后重写其工厂方法即可。\n\nhow？\n\n用特殊的工厂方法代替直接使用new来构造对象\n\n![image-20220422222103813](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220422222103813.png)\n\n> 仅当这些产品具有共同的基类或者接口时，子类才能返回不同类型的产品，同时基类中的工厂方法，例如`createTransport()`，其返回类型\n\n![image-20220422222430551](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220422222430551.png)\n\n不同的子类对象以不同的方式实现同一接口，产品类实现了共同的接口，用户通过`createTransport()`获得类实例，不同的类型实例有相同的接口，用户无需额外的数据，不关心其具体的实现方式\n\n> 可以将工厂方法声明为抽象方法，强制要求每个子类以不同的方式实现该方法\n\n![image-20220423102205614](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220423102205614.png)\n\nCreator是工厂类，与用户直接打交道。实际new实例的动作由具体的子类完成。Product声明通用接口\n\n工厂方法模式\n\n参考资料：https://www.zhihu.com/question/27125796\n\n引子\n\n宠物店，号称什么宠物都有\n\n构建宠物的<u>工厂</u>\n\n```java\n// 号称什么宠物都有\npublic interface AnimalFactory {\n\n\t// 可以获取任何的宠物\n\tAnimal createAnimal();\n}\n```\n\n> 这里将创建者实现为接口，有些人也将创建者实现为抽象类\n\n构建猫、狗的工厂：\n\n```java\n// 继承着宠物工厂\npublic class CatFactory implements AnimalFactory {\n    @Override\n    // 创建猫\n    public Animal createAnimal() {\n        return new Cat();\n    }\n}\n```\n\n```java\n// 继承着宠物工厂\npublic class DogFactory implements AnimalFactory {\n\n\t// 创建狗\n\t@Override\n\tpublic Animal createAnimal() {\n\t\treturn new Dog();\n\t}\n}\n```\n\n动物<u>实体类</u>：\n\n```java\npublic abstract class Animal {\n\n\t// 所有的动物都会吃东西\n\tpublic abstract void eat();\n}\n```\n\n> 很奇怪的是，这里存放着抽象操作，按理说应该用接口来实现会更方便一点，不知道作者为什么这样实现。。。\n\n猫、狗实体类：\n\n```java\npublic class Cat extends Animal {\n\t// 猫喜欢吃鱼\n\t@Override\n\tpublic void eat() {\n\t\tSystem.out.println(\"猫吃鱼\");\n\t}\n}\n\npublic class Dog extends Animal {\n\t// 狗喜欢吃肉\n\t@Override\n\tpublic void eat() {\n\t\tSystem.out.println(\"狗吃肉\");\n\t}\n}\n```\n\n怎么获得猫的实例？\n\n```java\n//创建猫工厂的实例，然后调用猫工厂的工厂方法创建猫实体\n    AnimalFactory ff = new CatFactory();\n    Animal aa = ff.createAnimal();\n\n    aa.eat();\n```\n\n如果要添加新的动物，比如兔子，只需要做两件事：\n\n- 添加构建兔子的工厂类（继承实现宠物构建工厂）\n- 添加兔子实体类（继承实现动物实体类）\n\n![image-20220423112912248](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220423112912248.png)\n\n","source":"_posts/C++/设计模式/工厂模式.md","raw":"参考资料：\n\n《设计模式—可复用面向对象软件的基础》\n\n《深入设计模式》\n\n### 工厂模式—创建型设计模式\n\n其在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型。使一个类的实例化延迟到其子类。\n\nwhy？\n\n应用场景：对于物流管理应用，最初版本只能处理卡车运输，所以大部分代码都位于名为卡车的类中，但是后续如何支持轮船以及其他更多的运输工具呢？\n\n工厂方法<u>将创建产品的代码与实际使用产品的代码分离</u>，从而能在不影响其他代码的情况下扩展产品创建部分代码。\n\n例如，如果需要向应用中添加一种新产品，你只需要开发新的创建者子类，然后重写其工厂方法即可。\n\nhow？\n\n用特殊的工厂方法代替直接使用new来构造对象\n\n![image-20220422222103813](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220422222103813.png)\n\n> 仅当这些产品具有共同的基类或者接口时，子类才能返回不同类型的产品，同时基类中的工厂方法，例如`createTransport()`，其返回类型\n\n![image-20220422222430551](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220422222430551.png)\n\n不同的子类对象以不同的方式实现同一接口，产品类实现了共同的接口，用户通过`createTransport()`获得类实例，不同的类型实例有相同的接口，用户无需额外的数据，不关心其具体的实现方式\n\n> 可以将工厂方法声明为抽象方法，强制要求每个子类以不同的方式实现该方法\n\n![image-20220423102205614](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220423102205614.png)\n\nCreator是工厂类，与用户直接打交道。实际new实例的动作由具体的子类完成。Product声明通用接口\n\n工厂方法模式\n\n参考资料：https://www.zhihu.com/question/27125796\n\n引子\n\n宠物店，号称什么宠物都有\n\n构建宠物的<u>工厂</u>\n\n```java\n// 号称什么宠物都有\npublic interface AnimalFactory {\n\n\t// 可以获取任何的宠物\n\tAnimal createAnimal();\n}\n```\n\n> 这里将创建者实现为接口，有些人也将创建者实现为抽象类\n\n构建猫、狗的工厂：\n\n```java\n// 继承着宠物工厂\npublic class CatFactory implements AnimalFactory {\n    @Override\n    // 创建猫\n    public Animal createAnimal() {\n        return new Cat();\n    }\n}\n```\n\n```java\n// 继承着宠物工厂\npublic class DogFactory implements AnimalFactory {\n\n\t// 创建狗\n\t@Override\n\tpublic Animal createAnimal() {\n\t\treturn new Dog();\n\t}\n}\n```\n\n动物<u>实体类</u>：\n\n```java\npublic abstract class Animal {\n\n\t// 所有的动物都会吃东西\n\tpublic abstract void eat();\n}\n```\n\n> 很奇怪的是，这里存放着抽象操作，按理说应该用接口来实现会更方便一点，不知道作者为什么这样实现。。。\n\n猫、狗实体类：\n\n```java\npublic class Cat extends Animal {\n\t// 猫喜欢吃鱼\n\t@Override\n\tpublic void eat() {\n\t\tSystem.out.println(\"猫吃鱼\");\n\t}\n}\n\npublic class Dog extends Animal {\n\t// 狗喜欢吃肉\n\t@Override\n\tpublic void eat() {\n\t\tSystem.out.println(\"狗吃肉\");\n\t}\n}\n```\n\n怎么获得猫的实例？\n\n```java\n//创建猫工厂的实例，然后调用猫工厂的工厂方法创建猫实体\n    AnimalFactory ff = new CatFactory();\n    Animal aa = ff.createAnimal();\n\n    aa.eat();\n```\n\n如果要添加新的动物，比如兔子，只需要做两件事：\n\n- 添加构建兔子的工厂类（继承实现宠物构建工厂）\n- 添加兔子实体类（继承实现动物实体类）\n\n![image-20220423112912248](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220423112912248.png)\n\n","slug":"C++/设计模式/工厂模式","published":1,"date":"2022-04-22T14:09:51.504Z","updated":"2022-05-04T02:16:09.670Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0ky4001spcu309vu6i1c","content":"<p>参考资料：</p>\n<p>《设计模式—可复用面向对象软件的基础》</p>\n<p>《深入设计模式》</p>\n<h3 id=\"工厂模式—创建型设计模式\"><a href=\"#工厂模式—创建型设计模式\" class=\"headerlink\" title=\"工厂模式—创建型设计模式\"></a>工厂模式—创建型设计模式</h3><p>其在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型。使一个类的实例化延迟到其子类。</p>\n<p>why？</p>\n<p>应用场景：对于物流管理应用，最初版本只能处理卡车运输，所以大部分代码都位于名为卡车的类中，但是后续如何支持轮船以及其他更多的运输工具呢？</p>\n<p>工厂方法<u>将创建产品的代码与实际使用产品的代码分离</u>，从而能在不影响其他代码的情况下扩展产品创建部分代码。</p>\n<p>例如，如果需要向应用中添加一种新产品，你只需要开发新的创建者子类，然后重写其工厂方法即可。</p>\n<p>how？</p>\n<p>用特殊的工厂方法代替直接使用new来构造对象</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220422222103813.png\" alt=\"image-20220422222103813\"></p>\n<blockquote>\n<p>仅当这些产品具有共同的基类或者接口时，子类才能返回不同类型的产品，同时基类中的工厂方法，例如<code>createTransport()</code>，其返回类型</p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220422222430551.png\" alt=\"image-20220422222430551\"></p>\n<p>不同的子类对象以不同的方式实现同一接口，产品类实现了共同的接口，用户通过<code>createTransport()</code>获得类实例，不同的类型实例有相同的接口，用户无需额外的数据，不关心其具体的实现方式</p>\n<blockquote>\n<p>可以将工厂方法声明为抽象方法，强制要求每个子类以不同的方式实现该方法</p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220423102205614.png\" alt=\"image-20220423102205614\"></p>\n<p>Creator是工厂类，与用户直接打交道。实际new实例的动作由具体的子类完成。Product声明通用接口</p>\n<p>工厂方法模式</p>\n<p>参考资料：<a href=\"https://www.zhihu.com/question/27125796\">https://www.zhihu.com/question/27125796</a></p>\n<p>引子</p>\n<p>宠物店，号称什么宠物都有</p>\n<p>构建宠物的<u>工厂</u></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 号称什么宠物都有</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">AnimalFactory</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 可以获取任何的宠物</span></span><br><span class=\"line\">\t<span class=\"function\">Animal <span class=\"title\">createAnimal</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这里将创建者实现为接口，有些人也将创建者实现为抽象类</p>\n</blockquote>\n<p>构建猫、狗的工厂：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 继承着宠物工厂</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CatFactory</span> <span class=\"keyword\">implements</span> <span class=\"title\">AnimalFactory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"comment\">// 创建猫</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Animal <span class=\"title\">createAnimal</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Cat();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 继承着宠物工厂</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DogFactory</span> <span class=\"keyword\">implements</span> <span class=\"title\">AnimalFactory</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 创建狗</span></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Animal <span class=\"title\">createAnimal</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Dog();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>动物<u>实体类</u>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 所有的动物都会吃东西</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">eat</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>很奇怪的是，这里存放着抽象操作，按理说应该用接口来实现会更方便一点，不知道作者为什么这样实现。。。</p>\n</blockquote>\n<p>猫、狗实体类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cat</span> <span class=\"keyword\">extends</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 猫喜欢吃鱼</span></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">eat</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;猫吃鱼&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span> <span class=\"keyword\">extends</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 狗喜欢吃肉</span></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">eat</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;狗吃肉&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>怎么获得猫的实例？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建猫工厂的实例，然后调用猫工厂的工厂方法创建猫实体</span></span><br><span class=\"line\">    AnimalFactory ff = <span class=\"keyword\">new</span> CatFactory();</span><br><span class=\"line\">    Animal aa = ff.createAnimal();</span><br><span class=\"line\"></span><br><span class=\"line\">    aa.eat();</span><br></pre></td></tr></table></figure>\n\n<p>如果要添加新的动物，比如兔子，只需要做两件事：</p>\n<ul>\n<li>添加构建兔子的工厂类（继承实现宠物构建工厂）</li>\n<li>添加兔子实体类（继承实现动物实体类）</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220423112912248.png\" alt=\"image-20220423112912248\"></p>\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<p>参考资料：</p>\n<p>《设计模式—可复用面向对象软件的基础》</p>\n<p>《深入设计模式》</p>\n<h3 id=\"工厂模式—创建型设计模式\"><a href=\"#工厂模式—创建型设计模式\" class=\"headerlink\" title=\"工厂模式—创建型设计模式\"></a>工厂模式—创建型设计模式</h3><p>其在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型。使一个类的实例化延迟到其子类。</p>\n<p>why？</p>\n<p>应用场景：对于物流管理应用，最初版本只能处理卡车运输，所以大部分代码都位于名为卡车的类中，但是后续如何支持轮船以及其他更多的运输工具呢？</p>\n<p>工厂方法<u>将创建产品的代码与实际使用产品的代码分离</u>，从而能在不影响其他代码的情况下扩展产品创建部分代码。</p>\n<p>例如，如果需要向应用中添加一种新产品，你只需要开发新的创建者子类，然后重写其工厂方法即可。</p>\n<p>how？</p>\n<p>用特殊的工厂方法代替直接使用new来构造对象</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220422222103813.png\" alt=\"image-20220422222103813\"></p>\n<blockquote>\n<p>仅当这些产品具有共同的基类或者接口时，子类才能返回不同类型的产品，同时基类中的工厂方法，例如<code>createTransport()</code>，其返回类型</p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220422222430551.png\" alt=\"image-20220422222430551\"></p>\n<p>不同的子类对象以不同的方式实现同一接口，产品类实现了共同的接口，用户通过<code>createTransport()</code>获得类实例，不同的类型实例有相同的接口，用户无需额外的数据，不关心其具体的实现方式</p>\n<blockquote>\n<p>可以将工厂方法声明为抽象方法，强制要求每个子类以不同的方式实现该方法</p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220423102205614.png\" alt=\"image-20220423102205614\"></p>\n<p>Creator是工厂类，与用户直接打交道。实际new实例的动作由具体的子类完成。Product声明通用接口</p>\n<p>工厂方法模式</p>\n<p>参考资料：<a href=\"https://www.zhihu.com/question/27125796\">https://www.zhihu.com/question/27125796</a></p>\n<p>引子</p>\n<p>宠物店，号称什么宠物都有</p>\n<p>构建宠物的<u>工厂</u></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 号称什么宠物都有</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">AnimalFactory</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 可以获取任何的宠物</span></span><br><span class=\"line\">\t<span class=\"function\">Animal <span class=\"title\">createAnimal</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这里将创建者实现为接口，有些人也将创建者实现为抽象类</p>\n</blockquote>\n<p>构建猫、狗的工厂：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 继承着宠物工厂</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CatFactory</span> <span class=\"keyword\">implements</span> <span class=\"title\">AnimalFactory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"comment\">// 创建猫</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Animal <span class=\"title\">createAnimal</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Cat();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 继承着宠物工厂</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DogFactory</span> <span class=\"keyword\">implements</span> <span class=\"title\">AnimalFactory</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 创建狗</span></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Animal <span class=\"title\">createAnimal</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Dog();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>动物<u>实体类</u>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 所有的动物都会吃东西</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">eat</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>很奇怪的是，这里存放着抽象操作，按理说应该用接口来实现会更方便一点，不知道作者为什么这样实现。。。</p>\n</blockquote>\n<p>猫、狗实体类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cat</span> <span class=\"keyword\">extends</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 猫喜欢吃鱼</span></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">eat</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;猫吃鱼&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span> <span class=\"keyword\">extends</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 狗喜欢吃肉</span></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">eat</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;狗吃肉&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>怎么获得猫的实例？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建猫工厂的实例，然后调用猫工厂的工厂方法创建猫实体</span></span><br><span class=\"line\">    AnimalFactory ff = <span class=\"keyword\">new</span> CatFactory();</span><br><span class=\"line\">    Animal aa = ff.createAnimal();</span><br><span class=\"line\"></span><br><span class=\"line\">    aa.eat();</span><br></pre></td></tr></table></figure>\n\n<p>如果要添加新的动物，比如兔子，只需要做两件事：</p>\n<ul>\n<li>添加构建兔子的工厂类（继承实现宠物构建工厂）</li>\n<li>添加兔子实体类（继承实现动物实体类）</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220423112912248.png\" alt=\"image-20220423112912248\"></p>\n"},{"_content":"观察者模式\n\n定义对象间的一种一对多的依赖关系，当一个对象的状态 发生改变时，所有依赖于它的对象都得到通知并被自动更新\n\nwhy？\n\n考虑观察者模式的典型应用场景：游戏中的成就系统\n\n游戏角色从桥上掉下去，可以解锁“从桥上掉下”成就，判断角色是否从桥上掉下去，是物理引擎要做的事情，而为了实现成就系统，是否意味着要在物理引擎的代码部分添加解锁成就相关的逻辑？这看起来十分不优美\n\n如何**解耦**成就系统与物理引擎代码部分？\n\n> 成就在游戏的不同层面被触发，怎么解耦成就系统和其他部分\n\n观察者模式可以很好地解决这个问题，物理引擎的观察者代码部分只需发出通知，而无需关心谁是接收者\n\nhow?\n\n有物理代码处理重力，追踪哪些物体待在地表，哪些坠入深渊。 为了实现“桥上掉落”的徽章，我们可以直接把成就代码放在那里，但那就会一团糟。 相反，可以这样做：\n\n```cpp\nvoid Physics::updateEntity(Entity& entity)\n{\n  bool wasOnSurface = entity.isOnSurface();\n  entity.accelerate(GRAVITY);\n  entity.update();\n  if (wasOnSurface && !entity.isOnSurface()) //掉下桥\n  {\n    notify(entity, EVENT_START_FALL);  //通知\n  }\n}\n```\n\n这样看起来很简洁\n\n成就系统注册它自己为观察者，\n\n#### 观察者\n\n```cpp\nclass Observer\n{\npublic:\n  virtual ~Observer() {}\n  virtual void onNotify(const Entity& entity, Event event) = 0;\n};\n```\n\n这是个抽象基类，任何派生了Observer的类都成为了观察者，对于成就系统：\n\n```cpp\nclass Achievements : public Observer\n{\npublic:\n  virtual void onNotify(const Entity& entity, Event event) //实现onNotify\n  {\n    switch (event)\n    {\n    case EVENT_ENTITY_FELL:\n      if (entity.isHero() && heroIsOnBridge_)\n      {\n        unlock(ACHIEVEMENT_FELL_OFF_BRIDGE);\n      }\n      break;\n\n      // 处理其他事件，更新heroIsOnBridge_变量……\n    }\n  }\n\nprivate:\n  void unlock(Achievement achievement)\n  {\n    // 如果还没有解锁，那就解锁成就……\n  }\n\n  bool heroIsOnBridge_;\n};\n```\n\n#### 被观察者\n\n被观察者有发送通知的函数，还维护了一个<u>观察者列表</u>，而非只支持单一观察者，列表中的所有观察者都可以接收到通知\n\n```cpp\nclass Subject\n{\nprivate:\n  Observer* observers_[MAX_OBSERVERS];\n  int numObservers_;\n};\n```\n\n被观察者提供了公开的API来对列表进行修改，这就允许了外界代码控制了谁接收通知\n\n```cpp\nclass Subject\n{\npublic:\n  void addObserver(Observer* observer)\n  {\n    // 添加到数组中……\n  }\n\n  void removeObserver(Observer* observer)\n  {\n    // 从数组中移除……\n  }\n\n  // 其他代码……\n};\n```\n\n被观察者发送通知：\n\n```cpp\nclass Subject\n{\nprotected:\n  void notify(const Entity& entity, Event event) //注意notify是protected的，意味着派生了可以访问，而外部代码不能访问\n  {\n    for (int i = 0; i < numObservers_; i++)\n    {\n      observers_[i]->onNotify(entity, event);\n    }\n  }\n\n  // 其他代码…………\n};\n```\n\n#### 可被观察的物理引擎\n\n物理引擎派生被观察者类，可以在有趣的时间点发出通知\n\n```cpp\nclass Physics : public Subject\n{\npublic:\n  void updateEntity(Entity& entity);\n};\n```\n\n","source":"_posts/C++/设计模式/观察者模式.md","raw":"观察者模式\n\n定义对象间的一种一对多的依赖关系，当一个对象的状态 发生改变时，所有依赖于它的对象都得到通知并被自动更新\n\nwhy？\n\n考虑观察者模式的典型应用场景：游戏中的成就系统\n\n游戏角色从桥上掉下去，可以解锁“从桥上掉下”成就，判断角色是否从桥上掉下去，是物理引擎要做的事情，而为了实现成就系统，是否意味着要在物理引擎的代码部分添加解锁成就相关的逻辑？这看起来十分不优美\n\n如何**解耦**成就系统与物理引擎代码部分？\n\n> 成就在游戏的不同层面被触发，怎么解耦成就系统和其他部分\n\n观察者模式可以很好地解决这个问题，物理引擎的观察者代码部分只需发出通知，而无需关心谁是接收者\n\nhow?\n\n有物理代码处理重力，追踪哪些物体待在地表，哪些坠入深渊。 为了实现“桥上掉落”的徽章，我们可以直接把成就代码放在那里，但那就会一团糟。 相反，可以这样做：\n\n```cpp\nvoid Physics::updateEntity(Entity& entity)\n{\n  bool wasOnSurface = entity.isOnSurface();\n  entity.accelerate(GRAVITY);\n  entity.update();\n  if (wasOnSurface && !entity.isOnSurface()) //掉下桥\n  {\n    notify(entity, EVENT_START_FALL);  //通知\n  }\n}\n```\n\n这样看起来很简洁\n\n成就系统注册它自己为观察者，\n\n#### 观察者\n\n```cpp\nclass Observer\n{\npublic:\n  virtual ~Observer() {}\n  virtual void onNotify(const Entity& entity, Event event) = 0;\n};\n```\n\n这是个抽象基类，任何派生了Observer的类都成为了观察者，对于成就系统：\n\n```cpp\nclass Achievements : public Observer\n{\npublic:\n  virtual void onNotify(const Entity& entity, Event event) //实现onNotify\n  {\n    switch (event)\n    {\n    case EVENT_ENTITY_FELL:\n      if (entity.isHero() && heroIsOnBridge_)\n      {\n        unlock(ACHIEVEMENT_FELL_OFF_BRIDGE);\n      }\n      break;\n\n      // 处理其他事件，更新heroIsOnBridge_变量……\n    }\n  }\n\nprivate:\n  void unlock(Achievement achievement)\n  {\n    // 如果还没有解锁，那就解锁成就……\n  }\n\n  bool heroIsOnBridge_;\n};\n```\n\n#### 被观察者\n\n被观察者有发送通知的函数，还维护了一个<u>观察者列表</u>，而非只支持单一观察者，列表中的所有观察者都可以接收到通知\n\n```cpp\nclass Subject\n{\nprivate:\n  Observer* observers_[MAX_OBSERVERS];\n  int numObservers_;\n};\n```\n\n被观察者提供了公开的API来对列表进行修改，这就允许了外界代码控制了谁接收通知\n\n```cpp\nclass Subject\n{\npublic:\n  void addObserver(Observer* observer)\n  {\n    // 添加到数组中……\n  }\n\n  void removeObserver(Observer* observer)\n  {\n    // 从数组中移除……\n  }\n\n  // 其他代码……\n};\n```\n\n被观察者发送通知：\n\n```cpp\nclass Subject\n{\nprotected:\n  void notify(const Entity& entity, Event event) //注意notify是protected的，意味着派生了可以访问，而外部代码不能访问\n  {\n    for (int i = 0; i < numObservers_; i++)\n    {\n      observers_[i]->onNotify(entity, event);\n    }\n  }\n\n  // 其他代码…………\n};\n```\n\n#### 可被观察的物理引擎\n\n物理引擎派生被观察者类，可以在有趣的时间点发出通知\n\n```cpp\nclass Physics : public Subject\n{\npublic:\n  void updateEntity(Entity& entity);\n};\n```\n\n","slug":"C++/设计模式/观察者模式","published":1,"date":"2022-04-18T01:19:09.613Z","updated":"2022-05-04T02:31:36.666Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0ky6001tpcu3389ueqk5","content":"<p>观察者模式</p>\n<p>定义对象间的一种一对多的依赖关系，当一个对象的状态 发生改变时，所有依赖于它的对象都得到通知并被自动更新</p>\n<p>why？</p>\n<p>考虑观察者模式的典型应用场景：游戏中的成就系统</p>\n<p>游戏角色从桥上掉下去，可以解锁“从桥上掉下”成就，判断角色是否从桥上掉下去，是物理引擎要做的事情，而为了实现成就系统，是否意味着要在物理引擎的代码部分添加解锁成就相关的逻辑？这看起来十分不优美</p>\n<p>如何<strong>解耦</strong>成就系统与物理引擎代码部分？</p>\n<blockquote>\n<p>成就在游戏的不同层面被触发，怎么解耦成就系统和其他部分</p>\n</blockquote>\n<p>观察者模式可以很好地解决这个问题，物理引擎的观察者代码部分只需发出通知，而无需关心谁是接收者</p>\n<p>how?</p>\n<p>有物理代码处理重力，追踪哪些物体待在地表，哪些坠入深渊。 为了实现“桥上掉落”的徽章，我们可以直接把成就代码放在那里，但那就会一团糟。 相反，可以这样做：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Physics::updateEntity</span><span class=\"params\">(Entity&amp; entity)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">bool</span> wasOnSurface = entity.<span class=\"built_in\">isOnSurface</span>();</span><br><span class=\"line\">  entity.<span class=\"built_in\">accelerate</span>(GRAVITY);</span><br><span class=\"line\">  entity.<span class=\"built_in\">update</span>();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (wasOnSurface &amp;&amp; !entity.<span class=\"built_in\">isOnSurface</span>()) <span class=\"comment\">//掉下桥</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"built_in\">notify</span>(entity, EVENT_START_FALL);  <span class=\"comment\">//通知</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样看起来很简洁</p>\n<p>成就系统注册它自己为观察者，</p>\n<h4 id=\"观察者\"><a href=\"#观察者\" class=\"headerlink\" title=\"观察者\"></a>观察者</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Observer</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"keyword\">virtual</span> ~<span class=\"built_in\">Observer</span>() &#123;&#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">onNotify</span><span class=\"params\">(<span class=\"keyword\">const</span> Entity&amp; entity, Event event)</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这是个抽象基类，任何派生了Observer的类都成为了观察者，对于成就系统：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Achievements</span> :</span> <span class=\"keyword\">public</span> Observer</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">onNotify</span><span class=\"params\">(<span class=\"keyword\">const</span> Entity&amp; entity, Event event)</span> <span class=\"comment\">//实现onNotify</span></span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\"><span class=\"keyword\">switch</span></span> (event)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> EVENT_ENTITY_FELL:</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (entity.<span class=\"built_in\">isHero</span>() &amp;&amp; heroIsOnBridge_)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"built_in\">unlock</span>(ACHIEVEMENT_FELL_OFF_BRIDGE);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 处理其他事件，更新heroIsOnBridge_变量……</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">unlock</span><span class=\"params\">(Achievement achievement)</span></span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果还没有解锁，那就解锁成就……</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">bool</span> heroIsOnBridge_;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"被观察者\"><a href=\"#被观察者\" class=\"headerlink\" title=\"被观察者\"></a>被观察者</h4><p>被观察者有发送通知的函数，还维护了一个<u>观察者列表</u>，而非只支持单一观察者，列表中的所有观察者都可以接收到通知</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Subject</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  Observer* observers_[MAX_OBSERVERS];</span><br><span class=\"line\">  <span class=\"keyword\">int</span> numObservers_;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>被观察者提供了公开的API来对列表进行修改，这就允许了外界代码控制了谁接收通知</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Subject</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addObserver</span><span class=\"params\">(Observer* observer)</span></span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 添加到数组中……</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">removeObserver</span><span class=\"params\">(Observer* observer)</span></span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 从数组中移除……</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 其他代码……</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>被观察者发送通知：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Subject</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">notify</span><span class=\"params\">(<span class=\"keyword\">const</span> Entity&amp; entity, Event event)</span> <span class=\"comment\">//注意notify是protected的，意味着派生了可以访问，而外部代码不能访问</span></span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numObservers_; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      observers_[i]-&gt;<span class=\"built_in\">onNotify</span>(entity, event);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 其他代码…………</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"可被观察的物理引擎\"><a href=\"#可被观察的物理引擎\" class=\"headerlink\" title=\"可被观察的物理引擎\"></a>可被观察的物理引擎</h4><p>物理引擎派生被观察者类，可以在有趣的时间点发出通知</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Physics</span> :</span> <span class=\"keyword\">public</span> Subject</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">updateEntity</span><span class=\"params\">(Entity&amp; entity)</span></span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<p>观察者模式</p>\n<p>定义对象间的一种一对多的依赖关系，当一个对象的状态 发生改变时，所有依赖于它的对象都得到通知并被自动更新</p>\n<p>why？</p>\n<p>考虑观察者模式的典型应用场景：游戏中的成就系统</p>\n<p>游戏角色从桥上掉下去，可以解锁“从桥上掉下”成就，判断角色是否从桥上掉下去，是物理引擎要做的事情，而为了实现成就系统，是否意味着要在物理引擎的代码部分添加解锁成就相关的逻辑？这看起来十分不优美</p>\n<p>如何<strong>解耦</strong>成就系统与物理引擎代码部分？</p>\n<blockquote>\n<p>成就在游戏的不同层面被触发，怎么解耦成就系统和其他部分</p>\n</blockquote>\n<p>观察者模式可以很好地解决这个问题，物理引擎的观察者代码部分只需发出通知，而无需关心谁是接收者</p>\n<p>how?</p>\n<p>有物理代码处理重力，追踪哪些物体待在地表，哪些坠入深渊。 为了实现“桥上掉落”的徽章，我们可以直接把成就代码放在那里，但那就会一团糟。 相反，可以这样做：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Physics::updateEntity</span><span class=\"params\">(Entity&amp; entity)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">bool</span> wasOnSurface = entity.<span class=\"built_in\">isOnSurface</span>();</span><br><span class=\"line\">  entity.<span class=\"built_in\">accelerate</span>(GRAVITY);</span><br><span class=\"line\">  entity.<span class=\"built_in\">update</span>();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (wasOnSurface &amp;&amp; !entity.<span class=\"built_in\">isOnSurface</span>()) <span class=\"comment\">//掉下桥</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"built_in\">notify</span>(entity, EVENT_START_FALL);  <span class=\"comment\">//通知</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样看起来很简洁</p>\n<p>成就系统注册它自己为观察者，</p>\n<h4 id=\"观察者\"><a href=\"#观察者\" class=\"headerlink\" title=\"观察者\"></a>观察者</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Observer</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"keyword\">virtual</span> ~<span class=\"built_in\">Observer</span>() &#123;&#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">onNotify</span><span class=\"params\">(<span class=\"keyword\">const</span> Entity&amp; entity, Event event)</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这是个抽象基类，任何派生了Observer的类都成为了观察者，对于成就系统：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Achievements</span> :</span> <span class=\"keyword\">public</span> Observer</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">onNotify</span><span class=\"params\">(<span class=\"keyword\">const</span> Entity&amp; entity, Event event)</span> <span class=\"comment\">//实现onNotify</span></span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\"><span class=\"keyword\">switch</span></span> (event)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> EVENT_ENTITY_FELL:</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (entity.<span class=\"built_in\">isHero</span>() &amp;&amp; heroIsOnBridge_)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"built_in\">unlock</span>(ACHIEVEMENT_FELL_OFF_BRIDGE);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 处理其他事件，更新heroIsOnBridge_变量……</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">unlock</span><span class=\"params\">(Achievement achievement)</span></span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果还没有解锁，那就解锁成就……</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">bool</span> heroIsOnBridge_;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"被观察者\"><a href=\"#被观察者\" class=\"headerlink\" title=\"被观察者\"></a>被观察者</h4><p>被观察者有发送通知的函数，还维护了一个<u>观察者列表</u>，而非只支持单一观察者，列表中的所有观察者都可以接收到通知</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Subject</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  Observer* observers_[MAX_OBSERVERS];</span><br><span class=\"line\">  <span class=\"keyword\">int</span> numObservers_;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>被观察者提供了公开的API来对列表进行修改，这就允许了外界代码控制了谁接收通知</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Subject</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addObserver</span><span class=\"params\">(Observer* observer)</span></span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 添加到数组中……</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">removeObserver</span><span class=\"params\">(Observer* observer)</span></span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 从数组中移除……</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 其他代码……</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>被观察者发送通知：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Subject</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">notify</span><span class=\"params\">(<span class=\"keyword\">const</span> Entity&amp; entity, Event event)</span> <span class=\"comment\">//注意notify是protected的，意味着派生了可以访问，而外部代码不能访问</span></span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numObservers_; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      observers_[i]-&gt;<span class=\"built_in\">onNotify</span>(entity, event);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 其他代码…………</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"可被观察的物理引擎\"><a href=\"#可被观察的物理引擎\" class=\"headerlink\" title=\"可被观察的物理引擎\"></a>可被观察的物理引擎</h4><p>物理引擎派生被观察者类，可以在有趣的时间点发出通知</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Physics</span> :</span> <span class=\"keyword\">public</span> Subject</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">updateEntity</span><span class=\"params\">(Entity&amp; entity)</span></span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n"},{"_content":"迭代器模式\n\n提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露该对象的内部表示\n\n用户使用迭代器模式，不用关心这些对象是什么，不用关心访问顺序。用户只需要调用访问接口\n\n","source":"_posts/C++/设计模式/迭代器模式.md","raw":"迭代器模式\n\n提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露该对象的内部表示\n\n用户使用迭代器模式，不用关心这些对象是什么，不用关心访问顺序。用户只需要调用访问接口\n\n","slug":"C++/设计模式/迭代器模式","published":1,"date":"2022-05-12T03:41:30.745Z","updated":"2022-05-12T11:13:57.483Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0ky7001upcu3adry1qn1","content":"<p>迭代器模式</p>\n<p>提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露该对象的内部表示</p>\n<p>用户使用迭代器模式，不用关心这些对象是什么，不用关心访问顺序。用户只需要调用访问接口</p>\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<p>迭代器模式</p>\n<p>提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露该对象的内部表示</p>\n<p>用户使用迭代器模式，不用关心这些对象是什么，不用关心访问顺序。用户只需要调用访问接口</p>\n"},{"_content":"四元数\n\nwhy?:star:\n\n为了方便地表示三维中任意的旋转\n\n且用四元数在旋转值之间插值更加平滑、自然【四元数插值】\n\nwhat\n\n顾名思义，四元数是个四维矢量，有四个分量\n$$\nq=[q_x,\\ q_y,\\ q_z,\\ q_w]\n$$\n#### 一、单位四元数\n\n<u>单位长度</u>的四元数（$q_x^2+q_y^2+q_z^2+q_w^2=1$）能表示三维旋转。四个分量是由<u>一个三维矢量</u>和<u>一个标量</u>构成\n$$\n\\begin{eqnarray}\nq&=&[qV\\quad qS]\\\\\n&=&[\\vec\\alpha\\, sin\\,\\frac{\\theta}{2}\\quad cos\\,\\frac{\\theta}{2}]\n\\end{eqnarray}\n$$\n其中$\\vec\\alpha$是旋转轴矢量，$\\theta$是旋转角度，四维表示：$[a_xsin\\frac{\\theta}{2},\\ a_ysin\\frac{\\theta}{2},\\ a_zsin\\frac{\\theta}{2},\\ cos\\frac{\\theta}{2}]$\n\n> 注意只有单位四元数才能代表三维旋转，例如两个四元数的加和并不能代表三维旋转，因为它们不是单位长度的fenbie\n\n#### 二、四元数运算（how）\n\n##### 1. 四元数乘法\n\n对于两个四元数p，q，表示为 $q=[qV\\quad qS],\\quad p=[pV\\quad pS]$，pq代表两个旋转的<u>合成旋转</u>，先旋转p，再旋转q。这里讨论的四元数乘法为格拉斯曼积\n$$\npq=[(pS*qV+qS*pV+pV\\times qV)\\quad (pS*qS-pV\\cdot qV)]\n$$\n结果仍用四元数来表示，第一个小括号里的结果是一个矢量，第二个小括号里的结果为标量\n\n##### 2. 共轭及逆四元数\n\n四元数q的逆记为$q^{-1}$，逆四元数和原四元数的乘积结果为标量1，即 $qq^{-1}=0i+0j+0k+1$，四元数$[0,0,0,1]$表示零旋转，旋转角为0。\n\n共轭四元数$q^*=[-qV\\quad qS]$，即矢量部分反向，标量部分不变\n\n逆四元数$q^{-1}$定义为：\n$$\nq^{-1}=\\frac{q^*}{|q|^2}\n$$\n分母为四元数的<u>模</u>，定义为<u>四个分量的平方和再开根号</u>，即$\\sqrt{(q_x)^2+(q_y)^2+(q_z)^2+(q_w)^2}$，单位四元数的模为1，所以其逆=共轭，$q^{-1}=q^*$\n\n积的共轭、逆：（和矩阵类似）\n$$\n(pq)^*=q^*p^*\\\\\n(pq)^{-1}=q^{-1}p^{-1}\n$$\n\n##### 3. 以四元数旋转矢量\n\n首先要把矢量写成四元数的形式，把其标量部分设为0。若有一矢量v，其对应的四元数为$V=[v\\quad0]=[v_x\\quad v_y\\quad v_z \\quad0]$，旋转后的矢量v'为：\n$$\nv'=rotate(q,v)=qvq^{-1}=qvq^*\n$$\n因为用来旋转的四元数都是单位四元数，所以用共轭和逆都可以\n\n嵌套旋转，先旋转1，再旋转2，最后旋转3，$v'=q_3q_2q_1vq_1^{-1}q_2^{-1}q_3^{-1}$\n\n##### 4. 四元数的等价矩阵\n\n任何表示三维旋转的<u>四元数</u>和<u>3X3矩阵</u>之间都可以<u>自由转换</u>，（最初学三维旋转的时候，用的表达方式就是3X3矩阵），具体公式我懒得打了，参考《游戏引擎架构 第二版》第181页\n\n##### 5. 旋转性的线性插值\n\n对四元数进行插值，可以简单地套用对四维矢量的线性插值\n\n> - 插值都需要有一个媒介作为插值参数，想下做过的以重心坐标为媒介的插值，或者以两点间距离作为媒介的插值。类推旋转就是以角度为媒介进行插值，已知旋转前角度和旋转后角度，中间的角度已知，现在可以求出中间的角度在整个角度范围中的占比（0~1）作为插值的参数\n>\n> - 对四元数的插值可以分解为对每一个分量的插值，对矢量的插值可以分解为对 x, y, z 三个分量上的插值，都可以分解到对标量进行插值，例如 a 和 b 之间的值，可以写为：`c=ta+(1-t)b`，`t`就是媒介参数\n>\n> - 突然想到，动画关键帧之间的插值可以以<u>时间</u>为媒介啊！\n\n给定两个四元数 $q_A$ 和 $q_B$，可找出在旋转 A 和旋转 B 之间 $\\beta$ 百分点的中间旋转 $q_{LERP}$\n$$\nq_{LERP}=LERP(q_A,q_B,\\beta)=\\frac{(1-\\beta)q_A+\\beta q_B}{|(1-\\beta)q_A+\\beta q_B|}=normalize\\left(\n{\\begin{bmatrix}\n(1-\\beta)q_{A_x}+\\beta q_{B_x}\\\\\n(1-\\beta)q_{A_y}+\\beta q_{B_y}\\\\\n(1-\\beta)q_{A_z}+\\beta q_{B_z}\\\\\n(1-\\beta)q_{A_w}+\\beta q_{B_w}\\\\\n\\end{bmatrix}}^T\\right)\n$$\n这里的分母跟插值无关，是用来插值后进行归一化的，从数学的角度，`LERP`函数就是对两个四元数的加权平均，权重为 $1-\\beta$ 和 $\\beta$\n\n![image-20220514160554991](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220514160554991.png)\n\n##### 6. 球面线性插值\n\n四元数其实是一个四维超球面上的点，上述`LERP`只是在超球的弦上进行插值，而不是在超球面上进行插值，在弦上插值就会引入误差，当 $\\beta$ 以恒定速率改变时，旋转动画并非以恒定角速率进行，但由于`LERP`开销比较小，效果也还行，所以也常被采用\n\n球面线性插值，`SLERP`（s表示spherical）","source":"_posts/图形学&游戏开发/动画/四元数.md","raw":"四元数\n\nwhy?:star:\n\n为了方便地表示三维中任意的旋转\n\n且用四元数在旋转值之间插值更加平滑、自然【四元数插值】\n\nwhat\n\n顾名思义，四元数是个四维矢量，有四个分量\n$$\nq=[q_x,\\ q_y,\\ q_z,\\ q_w]\n$$\n#### 一、单位四元数\n\n<u>单位长度</u>的四元数（$q_x^2+q_y^2+q_z^2+q_w^2=1$）能表示三维旋转。四个分量是由<u>一个三维矢量</u>和<u>一个标量</u>构成\n$$\n\\begin{eqnarray}\nq&=&[qV\\quad qS]\\\\\n&=&[\\vec\\alpha\\, sin\\,\\frac{\\theta}{2}\\quad cos\\,\\frac{\\theta}{2}]\n\\end{eqnarray}\n$$\n其中$\\vec\\alpha$是旋转轴矢量，$\\theta$是旋转角度，四维表示：$[a_xsin\\frac{\\theta}{2},\\ a_ysin\\frac{\\theta}{2},\\ a_zsin\\frac{\\theta}{2},\\ cos\\frac{\\theta}{2}]$\n\n> 注意只有单位四元数才能代表三维旋转，例如两个四元数的加和并不能代表三维旋转，因为它们不是单位长度的fenbie\n\n#### 二、四元数运算（how）\n\n##### 1. 四元数乘法\n\n对于两个四元数p，q，表示为 $q=[qV\\quad qS],\\quad p=[pV\\quad pS]$，pq代表两个旋转的<u>合成旋转</u>，先旋转p，再旋转q。这里讨论的四元数乘法为格拉斯曼积\n$$\npq=[(pS*qV+qS*pV+pV\\times qV)\\quad (pS*qS-pV\\cdot qV)]\n$$\n结果仍用四元数来表示，第一个小括号里的结果是一个矢量，第二个小括号里的结果为标量\n\n##### 2. 共轭及逆四元数\n\n四元数q的逆记为$q^{-1}$，逆四元数和原四元数的乘积结果为标量1，即 $qq^{-1}=0i+0j+0k+1$，四元数$[0,0,0,1]$表示零旋转，旋转角为0。\n\n共轭四元数$q^*=[-qV\\quad qS]$，即矢量部分反向，标量部分不变\n\n逆四元数$q^{-1}$定义为：\n$$\nq^{-1}=\\frac{q^*}{|q|^2}\n$$\n分母为四元数的<u>模</u>，定义为<u>四个分量的平方和再开根号</u>，即$\\sqrt{(q_x)^2+(q_y)^2+(q_z)^2+(q_w)^2}$，单位四元数的模为1，所以其逆=共轭，$q^{-1}=q^*$\n\n积的共轭、逆：（和矩阵类似）\n$$\n(pq)^*=q^*p^*\\\\\n(pq)^{-1}=q^{-1}p^{-1}\n$$\n\n##### 3. 以四元数旋转矢量\n\n首先要把矢量写成四元数的形式，把其标量部分设为0。若有一矢量v，其对应的四元数为$V=[v\\quad0]=[v_x\\quad v_y\\quad v_z \\quad0]$，旋转后的矢量v'为：\n$$\nv'=rotate(q,v)=qvq^{-1}=qvq^*\n$$\n因为用来旋转的四元数都是单位四元数，所以用共轭和逆都可以\n\n嵌套旋转，先旋转1，再旋转2，最后旋转3，$v'=q_3q_2q_1vq_1^{-1}q_2^{-1}q_3^{-1}$\n\n##### 4. 四元数的等价矩阵\n\n任何表示三维旋转的<u>四元数</u>和<u>3X3矩阵</u>之间都可以<u>自由转换</u>，（最初学三维旋转的时候，用的表达方式就是3X3矩阵），具体公式我懒得打了，参考《游戏引擎架构 第二版》第181页\n\n##### 5. 旋转性的线性插值\n\n对四元数进行插值，可以简单地套用对四维矢量的线性插值\n\n> - 插值都需要有一个媒介作为插值参数，想下做过的以重心坐标为媒介的插值，或者以两点间距离作为媒介的插值。类推旋转就是以角度为媒介进行插值，已知旋转前角度和旋转后角度，中间的角度已知，现在可以求出中间的角度在整个角度范围中的占比（0~1）作为插值的参数\n>\n> - 对四元数的插值可以分解为对每一个分量的插值，对矢量的插值可以分解为对 x, y, z 三个分量上的插值，都可以分解到对标量进行插值，例如 a 和 b 之间的值，可以写为：`c=ta+(1-t)b`，`t`就是媒介参数\n>\n> - 突然想到，动画关键帧之间的插值可以以<u>时间</u>为媒介啊！\n\n给定两个四元数 $q_A$ 和 $q_B$，可找出在旋转 A 和旋转 B 之间 $\\beta$ 百分点的中间旋转 $q_{LERP}$\n$$\nq_{LERP}=LERP(q_A,q_B,\\beta)=\\frac{(1-\\beta)q_A+\\beta q_B}{|(1-\\beta)q_A+\\beta q_B|}=normalize\\left(\n{\\begin{bmatrix}\n(1-\\beta)q_{A_x}+\\beta q_{B_x}\\\\\n(1-\\beta)q_{A_y}+\\beta q_{B_y}\\\\\n(1-\\beta)q_{A_z}+\\beta q_{B_z}\\\\\n(1-\\beta)q_{A_w}+\\beta q_{B_w}\\\\\n\\end{bmatrix}}^T\\right)\n$$\n这里的分母跟插值无关，是用来插值后进行归一化的，从数学的角度，`LERP`函数就是对两个四元数的加权平均，权重为 $1-\\beta$ 和 $\\beta$\n\n![image-20220514160554991](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220514160554991.png)\n\n##### 6. 球面线性插值\n\n四元数其实是一个四维超球面上的点，上述`LERP`只是在超球的弦上进行插值，而不是在超球面上进行插值，在弦上插值就会引入误差，当 $\\beta$ 以恒定速率改变时，旋转动画并非以恒定角速率进行，但由于`LERP`开销比较小，效果也还行，所以也常被采用\n\n球面线性插值，`SLERP`（s表示spherical）","slug":"图形学&游戏开发/动画/四元数","published":1,"date":"2022-04-22T03:28:22.976Z","updated":"2022-05-14T08:19:07.162Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0ky7001vpcu3d95d6s2y","content":"<p>四元数</p>\n<p>why?:star:</p>\n<p>为了方便地表示三维中任意的旋转</p>\n<p>且用四元数在旋转值之间插值更加平滑、自然【四元数插值】</p>\n<p>what</p>\n<p>顾名思义，四元数是个四维矢量，有四个分量<br>$$<br>q=[q_x,\\ q_y,\\ q_z,\\ q_w]<br>$$</p>\n<h4 id=\"一、单位四元数\"><a href=\"#一、单位四元数\" class=\"headerlink\" title=\"一、单位四元数\"></a>一、单位四元数</h4><p><u>单位长度</u>的四元数（$q_x^2+q_y^2+q_z^2+q_w^2=1$）能表示三维旋转。四个分量是由<u>一个三维矢量</u>和<u>一个标量</u>构成<br>$$<br>\\begin{eqnarray}<br>q&amp;=&amp;[qV\\quad qS]\\<br>&amp;=&amp;[\\vec\\alpha, sin,\\frac{\\theta}{2}\\quad cos,\\frac{\\theta}{2}]<br>\\end{eqnarray}<br>$$<br>其中$\\vec\\alpha$是旋转轴矢量，$\\theta$是旋转角度，四维表示：$[a_xsin\\frac{\\theta}{2},\\ a_ysin\\frac{\\theta}{2},\\ a_zsin\\frac{\\theta}{2},\\ cos\\frac{\\theta}{2}]$</p>\n<blockquote>\n<p>注意只有单位四元数才能代表三维旋转，例如两个四元数的加和并不能代表三维旋转，因为它们不是单位长度的fenbie</p>\n</blockquote>\n<h4 id=\"二、四元数运算（how）\"><a href=\"#二、四元数运算（how）\" class=\"headerlink\" title=\"二、四元数运算（how）\"></a>二、四元数运算（how）</h4><h5 id=\"1-四元数乘法\"><a href=\"#1-四元数乘法\" class=\"headerlink\" title=\"1. 四元数乘法\"></a>1. 四元数乘法</h5><p>对于两个四元数p，q，表示为 $q=[qV\\quad qS],\\quad p=[pV\\quad pS]$，pq代表两个旋转的<u>合成旋转</u>，先旋转p，再旋转q。这里讨论的四元数乘法为格拉斯曼积<br>$$<br>pq=[(pS<em>qV+qS</em>pV+pV\\times qV)\\quad (pS*qS-pV\\cdot qV)]<br>$$<br>结果仍用四元数来表示，第一个小括号里的结果是一个矢量，第二个小括号里的结果为标量</p>\n<h5 id=\"2-共轭及逆四元数\"><a href=\"#2-共轭及逆四元数\" class=\"headerlink\" title=\"2. 共轭及逆四元数\"></a>2. 共轭及逆四元数</h5><p>四元数q的逆记为$q^{-1}$，逆四元数和原四元数的乘积结果为标量1，即 $qq^{-1}=0i+0j+0k+1$，四元数$[0,0,0,1]$表示零旋转，旋转角为0。</p>\n<p>共轭四元数$q^*=[-qV\\quad qS]$，即矢量部分反向，标量部分不变</p>\n<p>逆四元数$q^{-1}$定义为：<br>$$<br>q^{-1}=\\frac{q^*}{|q|^2}<br>$$<br>分母为四元数的<u>模</u>，定义为<u>四个分量的平方和再开根号</u>，即$\\sqrt{(q_x)^2+(q_y)^2+(q_z)^2+(q_w)^2}$，单位四元数的模为1，所以其逆=共轭，$q^{-1}=q^*$</p>\n<p>积的共轭、逆：（和矩阵类似）<br>$$<br>(pq)^*=q^<em>p^</em>\\<br>(pq)^{-1}=q^{-1}p^{-1}<br>$$</p>\n<h5 id=\"3-以四元数旋转矢量\"><a href=\"#3-以四元数旋转矢量\" class=\"headerlink\" title=\"3. 以四元数旋转矢量\"></a>3. 以四元数旋转矢量</h5><p>首先要把矢量写成四元数的形式，把其标量部分设为0。若有一矢量v，其对应的四元数为$V=[v\\quad0]=[v_x\\quad v_y\\quad v_z \\quad0]$，旋转后的矢量v’为：<br>$$<br>v’=rotate(q,v)=qvq^{-1}=qvq^*<br>$$<br>因为用来旋转的四元数都是单位四元数，所以用共轭和逆都可以</p>\n<p>嵌套旋转，先旋转1，再旋转2，最后旋转3，$v’=q_3q_2q_1vq_1^{-1}q_2^{-1}q_3^{-1}$</p>\n<h5 id=\"4-四元数的等价矩阵\"><a href=\"#4-四元数的等价矩阵\" class=\"headerlink\" title=\"4. 四元数的等价矩阵\"></a>4. 四元数的等价矩阵</h5><p>任何表示三维旋转的<u>四元数</u>和<u>3X3矩阵</u>之间都可以<u>自由转换</u>，（最初学三维旋转的时候，用的表达方式就是3X3矩阵），具体公式我懒得打了，参考《游戏引擎架构 第二版》第181页</p>\n<h5 id=\"5-旋转性的线性插值\"><a href=\"#5-旋转性的线性插值\" class=\"headerlink\" title=\"5. 旋转性的线性插值\"></a>5. 旋转性的线性插值</h5><p>对四元数进行插值，可以简单地套用对四维矢量的线性插值</p>\n<blockquote>\n<ul>\n<li><p>插值都需要有一个媒介作为插值参数，想下做过的以重心坐标为媒介的插值，或者以两点间距离作为媒介的插值。类推旋转就是以角度为媒介进行插值，已知旋转前角度和旋转后角度，中间的角度已知，现在可以求出中间的角度在整个角度范围中的占比（0~1）作为插值的参数</p>\n</li>\n<li><p>对四元数的插值可以分解为对每一个分量的插值，对矢量的插值可以分解为对 x, y, z 三个分量上的插值，都可以分解到对标量进行插值，例如 a 和 b 之间的值，可以写为：<code>c=ta+(1-t)b</code>，<code>t</code>就是媒介参数</p>\n</li>\n<li><p>突然想到，动画关键帧之间的插值可以以<u>时间</u>为媒介啊！</p>\n</li>\n</ul>\n</blockquote>\n<p>给定两个四元数 $q_A$ 和 $q_B$，可找出在旋转 A 和旋转 B 之间 $\\beta$ 百分点的中间旋转 $q_{LERP}$<br>$$<br>q_{LERP}=LERP(q_A,q_B,\\beta)=\\frac{(1-\\beta)q_A+\\beta q_B}{|(1-\\beta)q_A+\\beta q_B|}=normalize\\left(<br>{\\begin{bmatrix}<br>(1-\\beta)q_{A_x}+\\beta q_{B_x}\\<br>(1-\\beta)q_{A_y}+\\beta q_{B_y}\\<br>(1-\\beta)q_{A_z}+\\beta q_{B_z}\\<br>(1-\\beta)q_{A_w}+\\beta q_{B_w}\\<br>\\end{bmatrix}}^T\\right)<br>$$<br>这里的分母跟插值无关，是用来插值后进行归一化的，从数学的角度，<code>LERP</code>函数就是对两个四元数的加权平均，权重为 $1-\\beta$ 和 $\\beta$</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220514160554991.png\" alt=\"image-20220514160554991\"></p>\n<h5 id=\"6-球面线性插值\"><a href=\"#6-球面线性插值\" class=\"headerlink\" title=\"6. 球面线性插值\"></a>6. 球面线性插值</h5><p>四元数其实是一个四维超球面上的点，上述<code>LERP</code>只是在超球的弦上进行插值，而不是在超球面上进行插值，在弦上插值就会引入误差，当 $\\beta$ 以恒定速率改变时，旋转动画并非以恒定角速率进行，但由于<code>LERP</code>开销比较小，效果也还行，所以也常被采用</p>\n<p>球面线性插值，<code>SLERP</code>（s表示spherical）</p>\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<p>四元数</p>\n<p>why?:star:</p>\n<p>为了方便地表示三维中任意的旋转</p>\n<p>且用四元数在旋转值之间插值更加平滑、自然【四元数插值】</p>\n<p>what</p>\n<p>顾名思义，四元数是个四维矢量，有四个分量<br>$$<br>q=[q_x,\\ q_y,\\ q_z,\\ q_w]<br>$$</p>\n<h4 id=\"一、单位四元数\"><a href=\"#一、单位四元数\" class=\"headerlink\" title=\"一、单位四元数\"></a>一、单位四元数</h4><p><u>单位长度</u>的四元数（$q_x^2+q_y^2+q_z^2+q_w^2=1$）能表示三维旋转。四个分量是由<u>一个三维矢量</u>和<u>一个标量</u>构成<br>$$<br>\\begin{eqnarray}<br>q&amp;=&amp;[qV\\quad qS]\\<br>&amp;=&amp;[\\vec\\alpha, sin,\\frac{\\theta}{2}\\quad cos,\\frac{\\theta}{2}]<br>\\end{eqnarray}<br>$$<br>其中$\\vec\\alpha$是旋转轴矢量，$\\theta$是旋转角度，四维表示：$[a_xsin\\frac{\\theta}{2},\\ a_ysin\\frac{\\theta}{2},\\ a_zsin\\frac{\\theta}{2},\\ cos\\frac{\\theta}{2}]$</p>\n<blockquote>\n<p>注意只有单位四元数才能代表三维旋转，例如两个四元数的加和并不能代表三维旋转，因为它们不是单位长度的fenbie</p>\n</blockquote>\n<h4 id=\"二、四元数运算（how）\"><a href=\"#二、四元数运算（how）\" class=\"headerlink\" title=\"二、四元数运算（how）\"></a>二、四元数运算（how）</h4><h5 id=\"1-四元数乘法\"><a href=\"#1-四元数乘法\" class=\"headerlink\" title=\"1. 四元数乘法\"></a>1. 四元数乘法</h5><p>对于两个四元数p，q，表示为 $q=[qV\\quad qS],\\quad p=[pV\\quad pS]$，pq代表两个旋转的<u>合成旋转</u>，先旋转p，再旋转q。这里讨论的四元数乘法为格拉斯曼积<br>$$<br>pq=[(pS<em>qV+qS</em>pV+pV\\times qV)\\quad (pS*qS-pV\\cdot qV)]<br>$$<br>结果仍用四元数来表示，第一个小括号里的结果是一个矢量，第二个小括号里的结果为标量</p>\n<h5 id=\"2-共轭及逆四元数\"><a href=\"#2-共轭及逆四元数\" class=\"headerlink\" title=\"2. 共轭及逆四元数\"></a>2. 共轭及逆四元数</h5><p>四元数q的逆记为$q^{-1}$，逆四元数和原四元数的乘积结果为标量1，即 $qq^{-1}=0i+0j+0k+1$，四元数$[0,0,0,1]$表示零旋转，旋转角为0。</p>\n<p>共轭四元数$q^*=[-qV\\quad qS]$，即矢量部分反向，标量部分不变</p>\n<p>逆四元数$q^{-1}$定义为：<br>$$<br>q^{-1}=\\frac{q^*}{|q|^2}<br>$$<br>分母为四元数的<u>模</u>，定义为<u>四个分量的平方和再开根号</u>，即$\\sqrt{(q_x)^2+(q_y)^2+(q_z)^2+(q_w)^2}$，单位四元数的模为1，所以其逆=共轭，$q^{-1}=q^*$</p>\n<p>积的共轭、逆：（和矩阵类似）<br>$$<br>(pq)^*=q^<em>p^</em>\\<br>(pq)^{-1}=q^{-1}p^{-1}<br>$$</p>\n<h5 id=\"3-以四元数旋转矢量\"><a href=\"#3-以四元数旋转矢量\" class=\"headerlink\" title=\"3. 以四元数旋转矢量\"></a>3. 以四元数旋转矢量</h5><p>首先要把矢量写成四元数的形式，把其标量部分设为0。若有一矢量v，其对应的四元数为$V=[v\\quad0]=[v_x\\quad v_y\\quad v_z \\quad0]$，旋转后的矢量v’为：<br>$$<br>v’=rotate(q,v)=qvq^{-1}=qvq^*<br>$$<br>因为用来旋转的四元数都是单位四元数，所以用共轭和逆都可以</p>\n<p>嵌套旋转，先旋转1，再旋转2，最后旋转3，$v’=q_3q_2q_1vq_1^{-1}q_2^{-1}q_3^{-1}$</p>\n<h5 id=\"4-四元数的等价矩阵\"><a href=\"#4-四元数的等价矩阵\" class=\"headerlink\" title=\"4. 四元数的等价矩阵\"></a>4. 四元数的等价矩阵</h5><p>任何表示三维旋转的<u>四元数</u>和<u>3X3矩阵</u>之间都可以<u>自由转换</u>，（最初学三维旋转的时候，用的表达方式就是3X3矩阵），具体公式我懒得打了，参考《游戏引擎架构 第二版》第181页</p>\n<h5 id=\"5-旋转性的线性插值\"><a href=\"#5-旋转性的线性插值\" class=\"headerlink\" title=\"5. 旋转性的线性插值\"></a>5. 旋转性的线性插值</h5><p>对四元数进行插值，可以简单地套用对四维矢量的线性插值</p>\n<blockquote>\n<ul>\n<li><p>插值都需要有一个媒介作为插值参数，想下做过的以重心坐标为媒介的插值，或者以两点间距离作为媒介的插值。类推旋转就是以角度为媒介进行插值，已知旋转前角度和旋转后角度，中间的角度已知，现在可以求出中间的角度在整个角度范围中的占比（0~1）作为插值的参数</p>\n</li>\n<li><p>对四元数的插值可以分解为对每一个分量的插值，对矢量的插值可以分解为对 x, y, z 三个分量上的插值，都可以分解到对标量进行插值，例如 a 和 b 之间的值，可以写为：<code>c=ta+(1-t)b</code>，<code>t</code>就是媒介参数</p>\n</li>\n<li><p>突然想到，动画关键帧之间的插值可以以<u>时间</u>为媒介啊！</p>\n</li>\n</ul>\n</blockquote>\n<p>给定两个四元数 $q_A$ 和 $q_B$，可找出在旋转 A 和旋转 B 之间 $\\beta$ 百分点的中间旋转 $q_{LERP}$<br>$$<br>q_{LERP}=LERP(q_A,q_B,\\beta)=\\frac{(1-\\beta)q_A+\\beta q_B}{|(1-\\beta)q_A+\\beta q_B|}=normalize\\left(<br>{\\begin{bmatrix}<br>(1-\\beta)q_{A_x}+\\beta q_{B_x}\\<br>(1-\\beta)q_{A_y}+\\beta q_{B_y}\\<br>(1-\\beta)q_{A_z}+\\beta q_{B_z}\\<br>(1-\\beta)q_{A_w}+\\beta q_{B_w}\\<br>\\end{bmatrix}}^T\\right)<br>$$<br>这里的分母跟插值无关，是用来插值后进行归一化的，从数学的角度，<code>LERP</code>函数就是对两个四元数的加权平均，权重为 $1-\\beta$ 和 $\\beta$</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220514160554991.png\" alt=\"image-20220514160554991\"></p>\n<h5 id=\"6-球面线性插值\"><a href=\"#6-球面线性插值\" class=\"headerlink\" title=\"6. 球面线性插值\"></a>6. 球面线性插值</h5><p>四元数其实是一个四维超球面上的点，上述<code>LERP</code>只是在超球的弦上进行插值，而不是在超球面上进行插值，在弦上插值就会引入误差，当 $\\beta$ 以恒定速率改变时，旋转动画并非以恒定角速率进行，但由于<code>LERP</code>开销比较小，效果也还行，所以也常被采用</p>\n<p>球面线性插值，<code>SLERP</code>（s表示spherical）</p>\n"},{"_content":"欧拉角\n\n欧拉角用来表示旋转，由三个标量值组成（偏航角，俯仰角，滚动角），用一个三维矢量来表示：$[\\theta_{\\gamma}\\quad\\theta_P \\quad \\theta _R]$\n\n优缺点：\n\n1. 围绕<u>单轴</u>的旋转很容易插值，每个分量都是标量，很容易做线性插值。对于<u>任意方向的旋转轴</u>不好插值【】\n2. 会有<u>万向节死锁</u>（gimbal lock）的问题，当旋转90°时，三主轴中的一个会与另一主轴完全对齐。例如绕x轴旋转90°，y轴与z轴会<u>完全对齐</u>，此时就不能单独绕原来的y轴旋转了，此时绕y轴和绕z轴的旋转实际上已经等效。\n3. 旋转次序对旋转结果是有影响的，但从欧拉角的定义中看不出来旋转次序，所以 $[\\theta_{\\gamma}\\quad\\theta_P \\quad \\theta _R]$ 并不能确定一个旋转\n\n","source":"_posts/图形学&游戏开发/动画/欧拉角.md","raw":"欧拉角\n\n欧拉角用来表示旋转，由三个标量值组成（偏航角，俯仰角，滚动角），用一个三维矢量来表示：$[\\theta_{\\gamma}\\quad\\theta_P \\quad \\theta _R]$\n\n优缺点：\n\n1. 围绕<u>单轴</u>的旋转很容易插值，每个分量都是标量，很容易做线性插值。对于<u>任意方向的旋转轴</u>不好插值【】\n2. 会有<u>万向节死锁</u>（gimbal lock）的问题，当旋转90°时，三主轴中的一个会与另一主轴完全对齐。例如绕x轴旋转90°，y轴与z轴会<u>完全对齐</u>，此时就不能单独绕原来的y轴旋转了，此时绕y轴和绕z轴的旋转实际上已经等效。\n3. 旋转次序对旋转结果是有影响的，但从欧拉角的定义中看不出来旋转次序，所以 $[\\theta_{\\gamma}\\quad\\theta_P \\quad \\theta _R]$ 并不能确定一个旋转\n\n","slug":"图形学&游戏开发/动画/欧拉角","published":1,"date":"2022-05-14T02:08:06.540Z","updated":"2022-05-14T02:17:07.514Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0ky8001wpcu38oxs61as","content":"<p>欧拉角</p>\n<p>欧拉角用来表示旋转，由三个标量值组成（偏航角，俯仰角，滚动角），用一个三维矢量来表示：$[\\theta_{\\gamma}\\quad\\theta_P \\quad \\theta _R]$</p>\n<p>优缺点：</p>\n<ol>\n<li>围绕<u>单轴</u>的旋转很容易插值，每个分量都是标量，很容易做线性插值。对于<u>任意方向的旋转轴</u>不好插值【】</li>\n<li>会有<u>万向节死锁</u>（gimbal lock）的问题，当旋转90°时，三主轴中的一个会与另一主轴完全对齐。例如绕x轴旋转90°，y轴与z轴会<u>完全对齐</u>，此时就不能单独绕原来的y轴旋转了，此时绕y轴和绕z轴的旋转实际上已经等效。</li>\n<li>旋转次序对旋转结果是有影响的，但从欧拉角的定义中看不出来旋转次序，所以 $[\\theta_{\\gamma}\\quad\\theta_P \\quad \\theta _R]$ 并不能确定一个旋转</li>\n</ol>\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<p>欧拉角</p>\n<p>欧拉角用来表示旋转，由三个标量值组成（偏航角，俯仰角，滚动角），用一个三维矢量来表示：$[\\theta_{\\gamma}\\quad\\theta_P \\quad \\theta _R]$</p>\n<p>优缺点：</p>\n<ol>\n<li>围绕<u>单轴</u>的旋转很容易插值，每个分量都是标量，很容易做线性插值。对于<u>任意方向的旋转轴</u>不好插值【】</li>\n<li>会有<u>万向节死锁</u>（gimbal lock）的问题，当旋转90°时，三主轴中的一个会与另一主轴完全对齐。例如绕x轴旋转90°，y轴与z轴会<u>完全对齐</u>，此时就不能单独绕原来的y轴旋转了，此时绕y轴和绕z轴的旋转实际上已经等效。</li>\n<li>旋转次序对旋转结果是有影响的，但从欧拉角的定义中看不出来旋转次序，所以 $[\\theta_{\\gamma}\\quad\\theta_P \\quad \\theta _R]$ 并不能确定一个旋转</li>\n</ol>\n"},{"_content":"参考资料：游戏引擎架构\n\n## 0x01 骨骼\n\n蒙皮上的三角网格顶点按权重绑定至多个关节，当关节移动时，蒙皮跟随骨骼进行拉伸\n\n骨骼层级树结构在内存中的表示\n\n一个数组，索引由0~N-1，存储所有的关节，每个关节节点都维护了一个父节点索引\n\n> 每个关节只有一个父节点，根节点的父节点索引为-1\n\n关节数组的存储次序一般是父关节在子关节之前，这意味着第一个数组元素是根节点\n\n> 用“关节索引”来作为关节的标识，而不是关节的名字，提高性能\n\n关节数据结构\n\n- 关节名字，字符串\n- 父节点索引\n- 绑定姿势的逆变换\n\n> 绑定姿势指的是\n\n典型的骨骼数据结构\n\n```cpp\n//关节\nstruct Joint{\n  Matrix4x3   m_invBindPose; //绑定姿势的逆变换【】\n  const char* m_name;        //关节名字\n  U8 \t\t  m_iParent;     //父索引，0xFF表示根节点\n};\n\n//骨骼，保存所有关节的信息\nstruct Skeleton\n{\n    U32\t\t  m_jointCount;  //关节数目\n    Joint*    m_aJoint; \t //关节数组\n}\n```\n\n## 0x02 姿势\n\n一个关节的姿势被定义为相对某参考系的位置、定向、缩放；通常以SQT数据格式表示。\n\n#### 绑定姿势（T-pose）\n\n绑定姿势是三维网格绑定至骨骼前的姿势，此姿势中四肢远离身体，较容易把顶点绑定至关节。所以一般是在骨骼呈绑定姿势时，将蒙皮绑定至骨骼\n\n>  只有绑定姿势不会导致蒙皮变形\n\n局部姿势\n\n局部姿势是相对父关节的姿势，每个关节是一个坐标空间。关节姿势是一个仿射变换，第$j$个关节姿的姿势可表示为一个$4\\times4$的仿射变换矩阵$P_j$，此矩阵包括\n\n- 一个平移矢量$T_j$\n- $3\\times3$对角缩放矩阵$S_j$\n- $3\\times3$旋转矩阵$R_j$\n\n$$\nP_j=\n\\begin{equation}\n\\left[\n\\begin{array}{cc}\n\tS_jR_j & 0\\\\\n\tT_j & 1\\\\\n\\end{array}\n\\right]\n\\end{equation}\n$$\n\n内存中的关节姿势：\n\n```cpp\n//关节姿势\nstruct JointPose\n{\n  Quaternion m_rot;     //Q（旋转四元数）\n  Vector3    m_trans;   //T（平移）\n  F32\t\t m_scale;   //S（统一缩放）\n};\n\n//骨骼姿势\nstruct SkeletonPose\n{\n  Skeleton*\t\tm_pSkeleton;   //骨骼+关节数量\n  JointPose* \tm_aLoclPose;   //多个局部关节姿势\n};\n```\n\n全局姿势\n\n将关节姿势表示到模型空间或世界空间，即为全局姿势。某关节的模型空间姿势`（j->M）`，在该关节到根节点的路径上，由各个关节的局部姿势累乘计算得出，每次乘法迭代可理解成`i`变成`p(i)`\n\n> 函数`p(i)`回传关节`i`的父索引\n\n![aa](https://raw.githubusercontent.com/Vio1ette/blog-img/main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220422092753.jpg)\n\n$p(0)=M$，关节$J_2$的模型空间姿势可写成：\n$$\nP_{2\\rightarrow M}=P_{2\\rightarrow 1}P_{1\\rightarrow 0}P_{0\\rightarrow M}\n$$\n类似的，关节$J_5$的模型空间姿势可写成：\n$$\nP_{5\\rightarrow M}=P_{5\\rightarrow 4}P_{4\\rightarrow 3}P_{3\\rightarrow 0}P_{0\\rightarrow M}\n$$\n\n## 0x03 动画片段\n\n#### 动画片段\n\n动画电影中，整个场景会以一串很长的、连续的帧来产生动画。但游戏中没法这么做，游戏中人物的各种动作被拆分为大量小粒度的动作，称为动画片段。例如跳跃、蹲下、跑步就是一个个动画片段。\n\n#### 局部时间线\n\n每个动画片段都有自己的时间线，称为局部时间线，比如跳跃的局部时间线，从跳起开始，到落地结束。\n\n#### 姿势插值、关键帧、连续时间\n\n动画师会制作一些关键时间点的姿势，称为关键帧，然后其他普通时间点的姿势由插值得到\n\n![微信图片_20220422101527](https://raw.githubusercontent.com/Vio1ette/blog-img/main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220422101527.jpg)\n\n动画片段的时间线是连续的，时间变量t是浮点数，而非整数。对浮点数时间进行插值时，得到的可能会是非整数帧，比如1.1、1.9等帧。\n\n## 0x04 蒙皮\n\n每顶点的蒙皮信息\n\n每个顶点按权重绑定一个或多个关节，如果只绑定到一个关节，则顶点完全跟随该关节移动；如果绑定至多个关节，则最终顶点的位置是一个加权平均的结果\n\n> 顶点的位置 = 把它逐一绑定至各个关节后的位置 的加权平均【说的不清楚】\n\n一个顶点一般绑定至4个关节，原因如下：\n\n- 4个8位关节索引组成一个32位字\n- 每顶点绑定至2，3，4个关节时产生的质量差别比较明显，而超过4个关节的绑定所提升的质量不那么明显（边际效应）\n\n典型的蒙皮顶点数据结构\n\n```cpp\nfloat\n```\n\n蒙皮涉及的数学知识\n\n蒙皮矩阵（skinning matrix）：把网格顶点从骨骼的<u>绑定姿势</u>变换至骨骼的<u>当前姿势</u>，变换前后顶点都在模型空间\n\n蒙皮顶点的位置是在模型空间中定义的，无论其骨骼是绑定姿势或任意姿势。蒙皮矩阵会把顶点从绑定姿势的模型空间变换至当前姿势的模型空间。蒙皮矩阵在模型空间中变换顶点的位置，并非“基变更”，顶点在变换前后都在模型空间\n\n单个关节骨骼的例子\n\n![image-20220422110035592](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220422110035592.png)\n\n要记住，顶点随骨骼关节移动，顶点在关节局部空间中的相对坐标是不变的。\n\n例如\n\n![image-20220422112458087](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220422112458087.png)\n\n**绑定姿势**下，顶点 $V_M^B$ 在模型空间中的坐标为（4, 6），将此坐标变换到关节局部空间下，要用到$B_{j\\rightarrow M}$矩阵，它把点从关节`j`局部空间变换到模型空间。现在的需求是将模型空间中的点变换到关节局部空间下，所以要用到它的逆矩阵，即$B_{M\\rightarrow j}={(B_{j\\rightarrow M})}^{-1}$\n$$\nv_j=v_M^B{(B_{j\\rightarrow M})}^{-1}\n$$\n\n> 注意目前做的所有操作都是在绑定姿势下\n\n假设得到$v_j$为（1, 3），下面进行关节姿势变换，即从绑定姿势移动到当前姿势\n\n**在当前姿势下**，顶点在关节局部空间中的坐标仍为（1, 3），下面要将点坐标变换为模型空间。设在当前姿势下，将点从关节局部空间变换到模型空间所用的矩阵为$C_{j\\rightarrow M}$\n$$\nv_M^C=v_j{C_{j\\rightarrow M}}\n$$\n整合一下\n$$\n\\begin{align}\nv_M^C&=v_j{C_{j\\rightarrow M}}\\\\\n&=v_M^B{(B_{j\\rightarrow M})}^{-1}C_{j\\rightarrow M}\\\\\n&=v_M^BK_j\n\\end{align}\n$$\n其中，$K_j={(B_{j\\rightarrow M})}^{-1}C_{j\\rightarrow M}$就称为蒙皮矩阵","source":"_posts/图形学&游戏开发/动画/蒙皮、骨骼动画.md","raw":"参考资料：游戏引擎架构\n\n## 0x01 骨骼\n\n蒙皮上的三角网格顶点按权重绑定至多个关节，当关节移动时，蒙皮跟随骨骼进行拉伸\n\n骨骼层级树结构在内存中的表示\n\n一个数组，索引由0~N-1，存储所有的关节，每个关节节点都维护了一个父节点索引\n\n> 每个关节只有一个父节点，根节点的父节点索引为-1\n\n关节数组的存储次序一般是父关节在子关节之前，这意味着第一个数组元素是根节点\n\n> 用“关节索引”来作为关节的标识，而不是关节的名字，提高性能\n\n关节数据结构\n\n- 关节名字，字符串\n- 父节点索引\n- 绑定姿势的逆变换\n\n> 绑定姿势指的是\n\n典型的骨骼数据结构\n\n```cpp\n//关节\nstruct Joint{\n  Matrix4x3   m_invBindPose; //绑定姿势的逆变换【】\n  const char* m_name;        //关节名字\n  U8 \t\t  m_iParent;     //父索引，0xFF表示根节点\n};\n\n//骨骼，保存所有关节的信息\nstruct Skeleton\n{\n    U32\t\t  m_jointCount;  //关节数目\n    Joint*    m_aJoint; \t //关节数组\n}\n```\n\n## 0x02 姿势\n\n一个关节的姿势被定义为相对某参考系的位置、定向、缩放；通常以SQT数据格式表示。\n\n#### 绑定姿势（T-pose）\n\n绑定姿势是三维网格绑定至骨骼前的姿势，此姿势中四肢远离身体，较容易把顶点绑定至关节。所以一般是在骨骼呈绑定姿势时，将蒙皮绑定至骨骼\n\n>  只有绑定姿势不会导致蒙皮变形\n\n局部姿势\n\n局部姿势是相对父关节的姿势，每个关节是一个坐标空间。关节姿势是一个仿射变换，第$j$个关节姿的姿势可表示为一个$4\\times4$的仿射变换矩阵$P_j$，此矩阵包括\n\n- 一个平移矢量$T_j$\n- $3\\times3$对角缩放矩阵$S_j$\n- $3\\times3$旋转矩阵$R_j$\n\n$$\nP_j=\n\\begin{equation}\n\\left[\n\\begin{array}{cc}\n\tS_jR_j & 0\\\\\n\tT_j & 1\\\\\n\\end{array}\n\\right]\n\\end{equation}\n$$\n\n内存中的关节姿势：\n\n```cpp\n//关节姿势\nstruct JointPose\n{\n  Quaternion m_rot;     //Q（旋转四元数）\n  Vector3    m_trans;   //T（平移）\n  F32\t\t m_scale;   //S（统一缩放）\n};\n\n//骨骼姿势\nstruct SkeletonPose\n{\n  Skeleton*\t\tm_pSkeleton;   //骨骼+关节数量\n  JointPose* \tm_aLoclPose;   //多个局部关节姿势\n};\n```\n\n全局姿势\n\n将关节姿势表示到模型空间或世界空间，即为全局姿势。某关节的模型空间姿势`（j->M）`，在该关节到根节点的路径上，由各个关节的局部姿势累乘计算得出，每次乘法迭代可理解成`i`变成`p(i)`\n\n> 函数`p(i)`回传关节`i`的父索引\n\n![aa](https://raw.githubusercontent.com/Vio1ette/blog-img/main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220422092753.jpg)\n\n$p(0)=M$，关节$J_2$的模型空间姿势可写成：\n$$\nP_{2\\rightarrow M}=P_{2\\rightarrow 1}P_{1\\rightarrow 0}P_{0\\rightarrow M}\n$$\n类似的，关节$J_5$的模型空间姿势可写成：\n$$\nP_{5\\rightarrow M}=P_{5\\rightarrow 4}P_{4\\rightarrow 3}P_{3\\rightarrow 0}P_{0\\rightarrow M}\n$$\n\n## 0x03 动画片段\n\n#### 动画片段\n\n动画电影中，整个场景会以一串很长的、连续的帧来产生动画。但游戏中没法这么做，游戏中人物的各种动作被拆分为大量小粒度的动作，称为动画片段。例如跳跃、蹲下、跑步就是一个个动画片段。\n\n#### 局部时间线\n\n每个动画片段都有自己的时间线，称为局部时间线，比如跳跃的局部时间线，从跳起开始，到落地结束。\n\n#### 姿势插值、关键帧、连续时间\n\n动画师会制作一些关键时间点的姿势，称为关键帧，然后其他普通时间点的姿势由插值得到\n\n![微信图片_20220422101527](https://raw.githubusercontent.com/Vio1ette/blog-img/main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220422101527.jpg)\n\n动画片段的时间线是连续的，时间变量t是浮点数，而非整数。对浮点数时间进行插值时，得到的可能会是非整数帧，比如1.1、1.9等帧。\n\n## 0x04 蒙皮\n\n每顶点的蒙皮信息\n\n每个顶点按权重绑定一个或多个关节，如果只绑定到一个关节，则顶点完全跟随该关节移动；如果绑定至多个关节，则最终顶点的位置是一个加权平均的结果\n\n> 顶点的位置 = 把它逐一绑定至各个关节后的位置 的加权平均【说的不清楚】\n\n一个顶点一般绑定至4个关节，原因如下：\n\n- 4个8位关节索引组成一个32位字\n- 每顶点绑定至2，3，4个关节时产生的质量差别比较明显，而超过4个关节的绑定所提升的质量不那么明显（边际效应）\n\n典型的蒙皮顶点数据结构\n\n```cpp\nfloat\n```\n\n蒙皮涉及的数学知识\n\n蒙皮矩阵（skinning matrix）：把网格顶点从骨骼的<u>绑定姿势</u>变换至骨骼的<u>当前姿势</u>，变换前后顶点都在模型空间\n\n蒙皮顶点的位置是在模型空间中定义的，无论其骨骼是绑定姿势或任意姿势。蒙皮矩阵会把顶点从绑定姿势的模型空间变换至当前姿势的模型空间。蒙皮矩阵在模型空间中变换顶点的位置，并非“基变更”，顶点在变换前后都在模型空间\n\n单个关节骨骼的例子\n\n![image-20220422110035592](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220422110035592.png)\n\n要记住，顶点随骨骼关节移动，顶点在关节局部空间中的相对坐标是不变的。\n\n例如\n\n![image-20220422112458087](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220422112458087.png)\n\n**绑定姿势**下，顶点 $V_M^B$ 在模型空间中的坐标为（4, 6），将此坐标变换到关节局部空间下，要用到$B_{j\\rightarrow M}$矩阵，它把点从关节`j`局部空间变换到模型空间。现在的需求是将模型空间中的点变换到关节局部空间下，所以要用到它的逆矩阵，即$B_{M\\rightarrow j}={(B_{j\\rightarrow M})}^{-1}$\n$$\nv_j=v_M^B{(B_{j\\rightarrow M})}^{-1}\n$$\n\n> 注意目前做的所有操作都是在绑定姿势下\n\n假设得到$v_j$为（1, 3），下面进行关节姿势变换，即从绑定姿势移动到当前姿势\n\n**在当前姿势下**，顶点在关节局部空间中的坐标仍为（1, 3），下面要将点坐标变换为模型空间。设在当前姿势下，将点从关节局部空间变换到模型空间所用的矩阵为$C_{j\\rightarrow M}$\n$$\nv_M^C=v_j{C_{j\\rightarrow M}}\n$$\n整合一下\n$$\n\\begin{align}\nv_M^C&=v_j{C_{j\\rightarrow M}}\\\\\n&=v_M^B{(B_{j\\rightarrow M})}^{-1}C_{j\\rightarrow M}\\\\\n&=v_M^BK_j\n\\end{align}\n$$\n其中，$K_j={(B_{j\\rightarrow M})}^{-1}C_{j\\rightarrow M}$就称为蒙皮矩阵","slug":"图形学&游戏开发/动画/蒙皮、骨骼动画","published":1,"date":"2022-04-21T03:37:21.138Z","updated":"2022-05-13T03:25:07.549Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0ky8001xpcu36hay8xs1","content":"<p>参考资料：游戏引擎架构</p>\n<h2 id=\"0x01-骨骼\"><a href=\"#0x01-骨骼\" class=\"headerlink\" title=\"0x01 骨骼\"></a>0x01 骨骼</h2><p>蒙皮上的三角网格顶点按权重绑定至多个关节，当关节移动时，蒙皮跟随骨骼进行拉伸</p>\n<p>骨骼层级树结构在内存中的表示</p>\n<p>一个数组，索引由0~N-1，存储所有的关节，每个关节节点都维护了一个父节点索引</p>\n<blockquote>\n<p>每个关节只有一个父节点，根节点的父节点索引为-1</p>\n</blockquote>\n<p>关节数组的存储次序一般是父关节在子关节之前，这意味着第一个数组元素是根节点</p>\n<blockquote>\n<p>用“关节索引”来作为关节的标识，而不是关节的名字，提高性能</p>\n</blockquote>\n<p>关节数据结构</p>\n<ul>\n<li>关节名字，字符串</li>\n<li>父节点索引</li>\n<li>绑定姿势的逆变换</li>\n</ul>\n<blockquote>\n<p>绑定姿势指的是</p>\n</blockquote>\n<p>典型的骨骼数据结构</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//关节</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Joint</span>&#123;</span></span><br><span class=\"line\">  Matrix4x3   m_invBindPose; <span class=\"comment\">//绑定姿势的逆变换【】</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* m_name;        <span class=\"comment\">//关节名字</span></span><br><span class=\"line\">  U8 \t\t  m_iParent;     <span class=\"comment\">//父索引，0xFF表示根节点</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//骨骼，保存所有关节的信息</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Skeleton</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    U32\t\t  m_jointCount;  <span class=\"comment\">//关节数目</span></span><br><span class=\"line\">    Joint*    m_aJoint; \t <span class=\"comment\">//关节数组</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"0x02-姿势\"><a href=\"#0x02-姿势\" class=\"headerlink\" title=\"0x02 姿势\"></a>0x02 姿势</h2><p>一个关节的姿势被定义为相对某参考系的位置、定向、缩放；通常以SQT数据格式表示。</p>\n<h4 id=\"绑定姿势（T-pose）\"><a href=\"#绑定姿势（T-pose）\" class=\"headerlink\" title=\"绑定姿势（T-pose）\"></a>绑定姿势（T-pose）</h4><p>绑定姿势是三维网格绑定至骨骼前的姿势，此姿势中四肢远离身体，较容易把顶点绑定至关节。所以一般是在骨骼呈绑定姿势时，将蒙皮绑定至骨骼</p>\n<blockquote>\n<p> 只有绑定姿势不会导致蒙皮变形</p>\n</blockquote>\n<p>局部姿势</p>\n<p>局部姿势是相对父关节的姿势，每个关节是一个坐标空间。关节姿势是一个仿射变换，第$j$个关节姿的姿势可表示为一个$4\\times4$的仿射变换矩阵$P_j$，此矩阵包括</p>\n<ul>\n<li>一个平移矢量$T_j$</li>\n<li>$3\\times3$对角缩放矩阵$S_j$</li>\n<li>$3\\times3$旋转矩阵$R_j$</li>\n</ul>\n<p>$$<br>P_j=<br>\\begin{equation}<br>\\left[<br>\\begin{array}{cc}<br>    S_jR_j &amp; 0\\<br>    T_j &amp; 1\\<br>\\end{array}<br>\\right]<br>\\end{equation}<br>$$</p>\n<p>内存中的关节姿势：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//关节姿势</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">JointPose</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  Quaternion m_rot;     <span class=\"comment\">//Q（旋转四元数）</span></span><br><span class=\"line\">  Vector3    m_trans;   <span class=\"comment\">//T（平移）</span></span><br><span class=\"line\">  F32\t\t m_scale;   <span class=\"comment\">//S（统一缩放）</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//骨骼姿势</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SkeletonPose</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  Skeleton*\t\tm_pSkeleton;   <span class=\"comment\">//骨骼+关节数量</span></span><br><span class=\"line\">  JointPose* \tm_aLoclPose;   <span class=\"comment\">//多个局部关节姿势</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>全局姿势</p>\n<p>将关节姿势表示到模型空间或世界空间，即为全局姿势。某关节的模型空间姿势<code>（j-&gt;M）</code>，在该关节到根节点的路径上，由各个关节的局部姿势累乘计算得出，每次乘法迭代可理解成<code>i</code>变成<code>p(i)</code></p>\n<blockquote>\n<p>函数<code>p(i)</code>回传关节<code>i</code>的父索引</p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220422092753.jpg\" alt=\"aa\"></p>\n<p>$p(0)=M$，关节$J_2$的模型空间姿势可写成：<br>$$<br>P_{2\\rightarrow M}=P_{2\\rightarrow 1}P_{1\\rightarrow 0}P_{0\\rightarrow M}<br>$$<br>类似的，关节$J_5$的模型空间姿势可写成：<br>$$<br>P_{5\\rightarrow M}=P_{5\\rightarrow 4}P_{4\\rightarrow 3}P_{3\\rightarrow 0}P_{0\\rightarrow M}<br>$$</p>\n<h2 id=\"0x03-动画片段\"><a href=\"#0x03-动画片段\" class=\"headerlink\" title=\"0x03 动画片段\"></a>0x03 动画片段</h2><h4 id=\"动画片段\"><a href=\"#动画片段\" class=\"headerlink\" title=\"动画片段\"></a>动画片段</h4><p>动画电影中，整个场景会以一串很长的、连续的帧来产生动画。但游戏中没法这么做，游戏中人物的各种动作被拆分为大量小粒度的动作，称为动画片段。例如跳跃、蹲下、跑步就是一个个动画片段。</p>\n<h4 id=\"局部时间线\"><a href=\"#局部时间线\" class=\"headerlink\" title=\"局部时间线\"></a>局部时间线</h4><p>每个动画片段都有自己的时间线，称为局部时间线，比如跳跃的局部时间线，从跳起开始，到落地结束。</p>\n<h4 id=\"姿势插值、关键帧、连续时间\"><a href=\"#姿势插值、关键帧、连续时间\" class=\"headerlink\" title=\"姿势插值、关键帧、连续时间\"></a>姿势插值、关键帧、连续时间</h4><p>动画师会制作一些关键时间点的姿势，称为关键帧，然后其他普通时间点的姿势由插值得到</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220422101527.jpg\" alt=\"微信图片_20220422101527\"></p>\n<p>动画片段的时间线是连续的，时间变量t是浮点数，而非整数。对浮点数时间进行插值时，得到的可能会是非整数帧，比如1.1、1.9等帧。</p>\n<h2 id=\"0x04-蒙皮\"><a href=\"#0x04-蒙皮\" class=\"headerlink\" title=\"0x04 蒙皮\"></a>0x04 蒙皮</h2><p>每顶点的蒙皮信息</p>\n<p>每个顶点按权重绑定一个或多个关节，如果只绑定到一个关节，则顶点完全跟随该关节移动；如果绑定至多个关节，则最终顶点的位置是一个加权平均的结果</p>\n<blockquote>\n<p>顶点的位置 = 把它逐一绑定至各个关节后的位置 的加权平均【说的不清楚】</p>\n</blockquote>\n<p>一个顶点一般绑定至4个关节，原因如下：</p>\n<ul>\n<li>4个8位关节索引组成一个32位字</li>\n<li>每顶点绑定至2，3，4个关节时产生的质量差别比较明显，而超过4个关节的绑定所提升的质量不那么明显（边际效应）</li>\n</ul>\n<p>典型的蒙皮顶点数据结构</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">float</span></span><br></pre></td></tr></table></figure>\n\n<p>蒙皮涉及的数学知识</p>\n<p>蒙皮矩阵（skinning matrix）：把网格顶点从骨骼的<u>绑定姿势</u>变换至骨骼的<u>当前姿势</u>，变换前后顶点都在模型空间</p>\n<p>蒙皮顶点的位置是在模型空间中定义的，无论其骨骼是绑定姿势或任意姿势。蒙皮矩阵会把顶点从绑定姿势的模型空间变换至当前姿势的模型空间。蒙皮矩阵在模型空间中变换顶点的位置，并非“基变更”，顶点在变换前后都在模型空间</p>\n<p>单个关节骨骼的例子</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220422110035592.png\" alt=\"image-20220422110035592\"></p>\n<p>要记住，顶点随骨骼关节移动，顶点在关节局部空间中的相对坐标是不变的。</p>\n<p>例如</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220422112458087.png\" alt=\"image-20220422112458087\"></p>\n<p><strong>绑定姿势</strong>下，顶点 $V_M^B$ 在模型空间中的坐标为（4, 6），将此坐标变换到关节局部空间下，要用到$B_{j\\rightarrow M}$矩阵，它把点从关节<code>j</code>局部空间变换到模型空间。现在的需求是将模型空间中的点变换到关节局部空间下，所以要用到它的逆矩阵，即$B_{M\\rightarrow j}={(B_{j\\rightarrow M})}^{-1}$<br>$$<br>v_j=v_M^B{(B_{j\\rightarrow M})}^{-1}<br>$$</p>\n<blockquote>\n<p>注意目前做的所有操作都是在绑定姿势下</p>\n</blockquote>\n<p>假设得到$v_j$为（1, 3），下面进行关节姿势变换，即从绑定姿势移动到当前姿势</p>\n<p><strong>在当前姿势下</strong>，顶点在关节局部空间中的坐标仍为（1, 3），下面要将点坐标变换为模型空间。设在当前姿势下，将点从关节局部空间变换到模型空间所用的矩阵为$C_{j\\rightarrow M}$<br>$$<br>v_M^C=v_j{C_{j\\rightarrow M}}<br>$$<br>整合一下<br>$$<br>\\begin{align}<br>v_M^C&amp;=v_j{C_{j\\rightarrow M}}\\<br>&amp;=v_M^B{(B_{j\\rightarrow M})}^{-1}C_{j\\rightarrow M}\\<br>&amp;=v_M^BK_j<br>\\end{align}<br>$$<br>其中，$K_j={(B_{j\\rightarrow M})}^{-1}C_{j\\rightarrow M}$就称为蒙皮矩阵</p>\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<p>参考资料：游戏引擎架构</p>\n<h2 id=\"0x01-骨骼\"><a href=\"#0x01-骨骼\" class=\"headerlink\" title=\"0x01 骨骼\"></a>0x01 骨骼</h2><p>蒙皮上的三角网格顶点按权重绑定至多个关节，当关节移动时，蒙皮跟随骨骼进行拉伸</p>\n<p>骨骼层级树结构在内存中的表示</p>\n<p>一个数组，索引由0~N-1，存储所有的关节，每个关节节点都维护了一个父节点索引</p>\n<blockquote>\n<p>每个关节只有一个父节点，根节点的父节点索引为-1</p>\n</blockquote>\n<p>关节数组的存储次序一般是父关节在子关节之前，这意味着第一个数组元素是根节点</p>\n<blockquote>\n<p>用“关节索引”来作为关节的标识，而不是关节的名字，提高性能</p>\n</blockquote>\n<p>关节数据结构</p>\n<ul>\n<li>关节名字，字符串</li>\n<li>父节点索引</li>\n<li>绑定姿势的逆变换</li>\n</ul>\n<blockquote>\n<p>绑定姿势指的是</p>\n</blockquote>\n<p>典型的骨骼数据结构</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//关节</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Joint</span>&#123;</span></span><br><span class=\"line\">  Matrix4x3   m_invBindPose; <span class=\"comment\">//绑定姿势的逆变换【】</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* m_name;        <span class=\"comment\">//关节名字</span></span><br><span class=\"line\">  U8 \t\t  m_iParent;     <span class=\"comment\">//父索引，0xFF表示根节点</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//骨骼，保存所有关节的信息</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Skeleton</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    U32\t\t  m_jointCount;  <span class=\"comment\">//关节数目</span></span><br><span class=\"line\">    Joint*    m_aJoint; \t <span class=\"comment\">//关节数组</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"0x02-姿势\"><a href=\"#0x02-姿势\" class=\"headerlink\" title=\"0x02 姿势\"></a>0x02 姿势</h2><p>一个关节的姿势被定义为相对某参考系的位置、定向、缩放；通常以SQT数据格式表示。</p>\n<h4 id=\"绑定姿势（T-pose）\"><a href=\"#绑定姿势（T-pose）\" class=\"headerlink\" title=\"绑定姿势（T-pose）\"></a>绑定姿势（T-pose）</h4><p>绑定姿势是三维网格绑定至骨骼前的姿势，此姿势中四肢远离身体，较容易把顶点绑定至关节。所以一般是在骨骼呈绑定姿势时，将蒙皮绑定至骨骼</p>\n<blockquote>\n<p> 只有绑定姿势不会导致蒙皮变形</p>\n</blockquote>\n<p>局部姿势</p>\n<p>局部姿势是相对父关节的姿势，每个关节是一个坐标空间。关节姿势是一个仿射变换，第$j$个关节姿的姿势可表示为一个$4\\times4$的仿射变换矩阵$P_j$，此矩阵包括</p>\n<ul>\n<li>一个平移矢量$T_j$</li>\n<li>$3\\times3$对角缩放矩阵$S_j$</li>\n<li>$3\\times3$旋转矩阵$R_j$</li>\n</ul>\n<p>$$<br>P_j=<br>\\begin{equation}<br>\\left[<br>\\begin{array}{cc}<br>    S_jR_j &amp; 0\\<br>    T_j &amp; 1\\<br>\\end{array}<br>\\right]<br>\\end{equation}<br>$$</p>\n<p>内存中的关节姿势：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//关节姿势</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">JointPose</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  Quaternion m_rot;     <span class=\"comment\">//Q（旋转四元数）</span></span><br><span class=\"line\">  Vector3    m_trans;   <span class=\"comment\">//T（平移）</span></span><br><span class=\"line\">  F32\t\t m_scale;   <span class=\"comment\">//S（统一缩放）</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//骨骼姿势</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SkeletonPose</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  Skeleton*\t\tm_pSkeleton;   <span class=\"comment\">//骨骼+关节数量</span></span><br><span class=\"line\">  JointPose* \tm_aLoclPose;   <span class=\"comment\">//多个局部关节姿势</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>全局姿势</p>\n<p>将关节姿势表示到模型空间或世界空间，即为全局姿势。某关节的模型空间姿势<code>（j-&gt;M）</code>，在该关节到根节点的路径上，由各个关节的局部姿势累乘计算得出，每次乘法迭代可理解成<code>i</code>变成<code>p(i)</code></p>\n<blockquote>\n<p>函数<code>p(i)</code>回传关节<code>i</code>的父索引</p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220422092753.jpg\" alt=\"aa\"></p>\n<p>$p(0)=M$，关节$J_2$的模型空间姿势可写成：<br>$$<br>P_{2\\rightarrow M}=P_{2\\rightarrow 1}P_{1\\rightarrow 0}P_{0\\rightarrow M}<br>$$<br>类似的，关节$J_5$的模型空间姿势可写成：<br>$$<br>P_{5\\rightarrow M}=P_{5\\rightarrow 4}P_{4\\rightarrow 3}P_{3\\rightarrow 0}P_{0\\rightarrow M}<br>$$</p>\n<h2 id=\"0x03-动画片段\"><a href=\"#0x03-动画片段\" class=\"headerlink\" title=\"0x03 动画片段\"></a>0x03 动画片段</h2><h4 id=\"动画片段\"><a href=\"#动画片段\" class=\"headerlink\" title=\"动画片段\"></a>动画片段</h4><p>动画电影中，整个场景会以一串很长的、连续的帧来产生动画。但游戏中没法这么做，游戏中人物的各种动作被拆分为大量小粒度的动作，称为动画片段。例如跳跃、蹲下、跑步就是一个个动画片段。</p>\n<h4 id=\"局部时间线\"><a href=\"#局部时间线\" class=\"headerlink\" title=\"局部时间线\"></a>局部时间线</h4><p>每个动画片段都有自己的时间线，称为局部时间线，比如跳跃的局部时间线，从跳起开始，到落地结束。</p>\n<h4 id=\"姿势插值、关键帧、连续时间\"><a href=\"#姿势插值、关键帧、连续时间\" class=\"headerlink\" title=\"姿势插值、关键帧、连续时间\"></a>姿势插值、关键帧、连续时间</h4><p>动画师会制作一些关键时间点的姿势，称为关键帧，然后其他普通时间点的姿势由插值得到</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220422101527.jpg\" alt=\"微信图片_20220422101527\"></p>\n<p>动画片段的时间线是连续的，时间变量t是浮点数，而非整数。对浮点数时间进行插值时，得到的可能会是非整数帧，比如1.1、1.9等帧。</p>\n<h2 id=\"0x04-蒙皮\"><a href=\"#0x04-蒙皮\" class=\"headerlink\" title=\"0x04 蒙皮\"></a>0x04 蒙皮</h2><p>每顶点的蒙皮信息</p>\n<p>每个顶点按权重绑定一个或多个关节，如果只绑定到一个关节，则顶点完全跟随该关节移动；如果绑定至多个关节，则最终顶点的位置是一个加权平均的结果</p>\n<blockquote>\n<p>顶点的位置 = 把它逐一绑定至各个关节后的位置 的加权平均【说的不清楚】</p>\n</blockquote>\n<p>一个顶点一般绑定至4个关节，原因如下：</p>\n<ul>\n<li>4个8位关节索引组成一个32位字</li>\n<li>每顶点绑定至2，3，4个关节时产生的质量差别比较明显，而超过4个关节的绑定所提升的质量不那么明显（边际效应）</li>\n</ul>\n<p>典型的蒙皮顶点数据结构</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">float</span></span><br></pre></td></tr></table></figure>\n\n<p>蒙皮涉及的数学知识</p>\n<p>蒙皮矩阵（skinning matrix）：把网格顶点从骨骼的<u>绑定姿势</u>变换至骨骼的<u>当前姿势</u>，变换前后顶点都在模型空间</p>\n<p>蒙皮顶点的位置是在模型空间中定义的，无论其骨骼是绑定姿势或任意姿势。蒙皮矩阵会把顶点从绑定姿势的模型空间变换至当前姿势的模型空间。蒙皮矩阵在模型空间中变换顶点的位置，并非“基变更”，顶点在变换前后都在模型空间</p>\n<p>单个关节骨骼的例子</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220422110035592.png\" alt=\"image-20220422110035592\"></p>\n<p>要记住，顶点随骨骼关节移动，顶点在关节局部空间中的相对坐标是不变的。</p>\n<p>例如</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220422112458087.png\" alt=\"image-20220422112458087\"></p>\n<p><strong>绑定姿势</strong>下，顶点 $V_M^B$ 在模型空间中的坐标为（4, 6），将此坐标变换到关节局部空间下，要用到$B_{j\\rightarrow M}$矩阵，它把点从关节<code>j</code>局部空间变换到模型空间。现在的需求是将模型空间中的点变换到关节局部空间下，所以要用到它的逆矩阵，即$B_{M\\rightarrow j}={(B_{j\\rightarrow M})}^{-1}$<br>$$<br>v_j=v_M^B{(B_{j\\rightarrow M})}^{-1}<br>$$</p>\n<blockquote>\n<p>注意目前做的所有操作都是在绑定姿势下</p>\n</blockquote>\n<p>假设得到$v_j$为（1, 3），下面进行关节姿势变换，即从绑定姿势移动到当前姿势</p>\n<p><strong>在当前姿势下</strong>，顶点在关节局部空间中的坐标仍为（1, 3），下面要将点坐标变换为模型空间。设在当前姿势下，将点从关节局部空间变换到模型空间所用的矩阵为$C_{j\\rightarrow M}$<br>$$<br>v_M^C=v_j{C_{j\\rightarrow M}}<br>$$<br>整合一下<br>$$<br>\\begin{align}<br>v_M^C&amp;=v_j{C_{j\\rightarrow M}}\\<br>&amp;=v_M^B{(B_{j\\rightarrow M})}^{-1}C_{j\\rightarrow M}\\<br>&amp;=v_M^BK_j<br>\\end{align}<br>$$<br>其中，$K_j={(B_{j\\rightarrow M})}^{-1}C_{j\\rightarrow M}$就称为蒙皮矩阵</p>\n"},{"_content":"> 软（件）光栅器，一般是指运行在CPU上的光栅化器程序。而硬件光栅化器专指依赖于GPU的光栅化器，例如OpenGL、Vulkan之类的图形库\n\n背面剔除，字面意思理解就是背朝着照相机的面看不到，不进行渲染，提高渲染速度\n\n首先要判断图元到底是正向还是背向\n\n#### 软光栅化的背面剔除\n\n软光栅化的背面剔除通常在<u>世界空间或相机空间</u>进行，依据面法向量和视线向量的夹角（快速算向量的夹角用点乘）大小来判断面是正向还是背向\n\n![image-20220420210746650](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220420210746650.png)\n\n> 即使背面剔除通过，也有可能因为不在视锥体中而不被渲染\n\n#### 现代GPU中的背景剔除\n\n<u>发生在顶点变换（MVP）之后，光栅化之前，即在屏幕空间中</u>。\n\n为什么不在顶点变换时做？\n\n因为顶点变换阶段GPU只有一个个顶点的信息，还没有图元的信息，所以做不了背面剔除（要有面，就得先有图元）。光栅化阶段的输入是屏幕空间中图元数据（x, y, depth）\n\n在屏幕空间中如何确定图元的朝向？\n\n根据<u>顶点绕序</u>，DirectX默认情况下顺时针绕序是正面，逆时针绕序是反面，可以通过改变渲染状态来颠倒这个规则。\n\n![image-20220420210725116](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220420210725116.png)\n\n","source":"_posts/图形学&游戏开发/游戏场景管理博客笔记/三、背面剔除.md","raw":"> 软（件）光栅器，一般是指运行在CPU上的光栅化器程序。而硬件光栅化器专指依赖于GPU的光栅化器，例如OpenGL、Vulkan之类的图形库\n\n背面剔除，字面意思理解就是背朝着照相机的面看不到，不进行渲染，提高渲染速度\n\n首先要判断图元到底是正向还是背向\n\n#### 软光栅化的背面剔除\n\n软光栅化的背面剔除通常在<u>世界空间或相机空间</u>进行，依据面法向量和视线向量的夹角（快速算向量的夹角用点乘）大小来判断面是正向还是背向\n\n![image-20220420210746650](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220420210746650.png)\n\n> 即使背面剔除通过，也有可能因为不在视锥体中而不被渲染\n\n#### 现代GPU中的背景剔除\n\n<u>发生在顶点变换（MVP）之后，光栅化之前，即在屏幕空间中</u>。\n\n为什么不在顶点变换时做？\n\n因为顶点变换阶段GPU只有一个个顶点的信息，还没有图元的信息，所以做不了背面剔除（要有面，就得先有图元）。光栅化阶段的输入是屏幕空间中图元数据（x, y, depth）\n\n在屏幕空间中如何确定图元的朝向？\n\n根据<u>顶点绕序</u>，DirectX默认情况下顺时针绕序是正面，逆时针绕序是反面，可以通过改变渲染状态来颠倒这个规则。\n\n![image-20220420210725116](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220420210725116.png)\n\n","slug":"图形学&游戏开发/游戏场景管理博客笔记/三、背面剔除","published":1,"date":"2022-04-20T10:32:51.531Z","updated":"2022-05-05T02:51:04.464Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0ky9001ypcu3gl0t7mah","content":"<blockquote>\n<p>软（件）光栅器，一般是指运行在CPU上的光栅化器程序。而硬件光栅化器专指依赖于GPU的光栅化器，例如OpenGL、Vulkan之类的图形库</p>\n</blockquote>\n<p>背面剔除，字面意思理解就是背朝着照相机的面看不到，不进行渲染，提高渲染速度</p>\n<p>首先要判断图元到底是正向还是背向</p>\n<h4 id=\"软光栅化的背面剔除\"><a href=\"#软光栅化的背面剔除\" class=\"headerlink\" title=\"软光栅化的背面剔除\"></a>软光栅化的背面剔除</h4><p>软光栅化的背面剔除通常在<u>世界空间或相机空间</u>进行，依据面法向量和视线向量的夹角（快速算向量的夹角用点乘）大小来判断面是正向还是背向</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220420210746650.png\" alt=\"image-20220420210746650\"></p>\n<blockquote>\n<p>即使背面剔除通过，也有可能因为不在视锥体中而不被渲染</p>\n</blockquote>\n<h4 id=\"现代GPU中的背景剔除\"><a href=\"#现代GPU中的背景剔除\" class=\"headerlink\" title=\"现代GPU中的背景剔除\"></a>现代GPU中的背景剔除</h4><p><u>发生在顶点变换（MVP）之后，光栅化之前，即在屏幕空间中</u>。</p>\n<p>为什么不在顶点变换时做？</p>\n<p>因为顶点变换阶段GPU只有一个个顶点的信息，还没有图元的信息，所以做不了背面剔除（要有面，就得先有图元）。光栅化阶段的输入是屏幕空间中图元数据（x, y, depth）</p>\n<p>在屏幕空间中如何确定图元的朝向？</p>\n<p>根据<u>顶点绕序</u>，DirectX默认情况下顺时针绕序是正面，逆时针绕序是反面，可以通过改变渲染状态来颠倒这个规则。</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220420210725116.png\" alt=\"image-20220420210725116\"></p>\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<blockquote>\n<p>软（件）光栅器，一般是指运行在CPU上的光栅化器程序。而硬件光栅化器专指依赖于GPU的光栅化器，例如OpenGL、Vulkan之类的图形库</p>\n</blockquote>\n<p>背面剔除，字面意思理解就是背朝着照相机的面看不到，不进行渲染，提高渲染速度</p>\n<p>首先要判断图元到底是正向还是背向</p>\n<h4 id=\"软光栅化的背面剔除\"><a href=\"#软光栅化的背面剔除\" class=\"headerlink\" title=\"软光栅化的背面剔除\"></a>软光栅化的背面剔除</h4><p>软光栅化的背面剔除通常在<u>世界空间或相机空间</u>进行，依据面法向量和视线向量的夹角（快速算向量的夹角用点乘）大小来判断面是正向还是背向</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220420210746650.png\" alt=\"image-20220420210746650\"></p>\n<blockquote>\n<p>即使背面剔除通过，也有可能因为不在视锥体中而不被渲染</p>\n</blockquote>\n<h4 id=\"现代GPU中的背景剔除\"><a href=\"#现代GPU中的背景剔除\" class=\"headerlink\" title=\"现代GPU中的背景剔除\"></a>现代GPU中的背景剔除</h4><p><u>发生在顶点变换（MVP）之后，光栅化之前，即在屏幕空间中</u>。</p>\n<p>为什么不在顶点变换时做？</p>\n<p>因为顶点变换阶段GPU只有一个个顶点的信息，还没有图元的信息，所以做不了背面剔除（要有面，就得先有图元）。光栅化阶段的输入是屏幕空间中图元数据（x, y, depth）</p>\n<p>在屏幕空间中如何确定图元的朝向？</p>\n<p>根据<u>顶点绕序</u>，DirectX默认情况下顺时针绕序是正面，逆时针绕序是反面，可以通过改变渲染状态来颠倒这个规则。</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220420210725116.png\" alt=\"image-20220420210725116\"></p>\n"},{"_content":"单例模式\n\n限制其类实例只能有一个，对外提供一个该对象的全局访问点\n\nwhy？\n\n对一些类来说，确保只有一个实例是很重要的，比如打印机、文件系统、日志记录。\n\nwhat？\n\n让类自身来管理它自己的唯一的实例，并提供一个访问该实例的静态方法。\n\nhow？\n\n","source":"_posts/图形学&游戏开发/游戏编程模式/单例模式.md","raw":"单例模式\n\n限制其类实例只能有一个，对外提供一个该对象的全局访问点\n\nwhy？\n\n对一些类来说，确保只有一个实例是很重要的，比如打印机、文件系统、日志记录。\n\nwhat？\n\n让类自身来管理它自己的唯一的实例，并提供一个访问该实例的静态方法。\n\nhow？\n\n","slug":"图形学&游戏开发/游戏编程模式/单例模式","published":1,"date":"2022-04-22T11:38:58.028Z","updated":"2022-04-22T13:29:18.395Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0kya001zpcu3819m4h9a","content":"<p>单例模式</p>\n<p>限制其类实例只能有一个，对外提供一个该对象的全局访问点</p>\n<p>why？</p>\n<p>对一些类来说，确保只有一个实例是很重要的，比如打印机、文件系统、日志记录。</p>\n<p>what？</p>\n<p>让类自身来管理它自己的唯一的实例，并提供一个访问该实例的静态方法。</p>\n<p>how？</p>\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<p>单例模式</p>\n<p>限制其类实例只能有一个，对外提供一个该对象的全局访问点</p>\n<p>why？</p>\n<p>对一些类来说，确保只有一个实例是很重要的，比如打印机、文件系统、日志记录。</p>\n<p>what？</p>\n<p>让类自身来管理它自己的唯一的实例，并提供一个访问该实例的静态方法。</p>\n<p>how？</p>\n"},{"_content":"观察者模式\n\n在对象间定义一种一对多的依赖关系，以便当某对象的状态改变时，与它存在依赖关系的所有对象都能受到通知并自动进行更新\n\nwhy？\n\n考虑观察者模式的典型应用场景：游戏中的成就系统\n\n游戏角色从桥上掉下去，可以解锁“从桥上掉下”成就，判断角色是否从桥上掉下去，是物理引擎要做的事情，而为了实现成就系统，是否意味着要在物理引擎的代码部分添加解锁成就相关的逻辑？这看起来十分不优美\n\n如何**解耦**成就系统与物理引擎代码部分？\n\n> 成就在游戏的不同层面被触发，怎么解耦成就系统和其他部分\n\n观察者模式可以很好地解决这个问题。成就系统注册它本身为观察者，这样当物理系统发出一个通知时，成就系统就会收到通知。然后它会检查这个掉落的物体是否是“主角”，并检查它是否是从桥上掉下去的。如果条件都满足，就会触发成就系统并放射礼花，吹响号角，且这些判断、表现的代码是与物理系统完全解耦。\n\nwhat？\n\n在对象间定义一种一对多的依赖关系，以便当某对象的状态改变时，与它存在依赖关系的所有对象都能受到通知并自动进行更新\n\nhow?\n\n举个例子，有物理代码处理重力，追踪哪些物体待在地表，哪些坠入深渊。 为了实现“桥上掉落”的徽章，我们可以直接把成就代码放在那里，但那就会一团糟。 相反，可以这样做：\n\n```cpp\nvoid Physics::updateEntity(Entity& entity)\n{\n  bool wasOnSurface = entity.isOnSurface();\n  entity.accelerate(GRAVITY);\n  entity.update();\n  if (wasOnSurface && !entity.isOnSurface()) //掉下桥\n  {\n    notify(entity, EVENT_START_FALL);  //通知\n  }\n}\n```\n\n这样看起来很简洁\n\n成就系统注册它自己为观察者，\n\n#### 观察者\n\n```cpp\nclass Observer\n{\npublic:\n  virtual ~Observer() {}\n  virtual void onNotify(const Entity& entity, Event event) = 0;\n};\n```\n\n这是个抽象基类，任何派生了Observer的类都成为了观察者，对于成就系统：\n\n```cpp\nclass Achievements : public Observer\n{\npublic:\n  virtual void onNotify(const Entity& entity, Event event) //实现onNotify\n  {\n    switch (event)\n    {\n    case EVENT_ENTITY_FELL:\n      if (entity.isHero() && heroIsOnBridge_)\n      {\n        unlock(ACHIEVEMENT_FELL_OFF_BRIDGE);\n      }\n      break;\n\n      // 处理其他事件，更新heroIsOnBridge_变量……\n    }\n  }\n\nprivate:\n  void unlock(Achievement achievement)\n  {\n    // 如果还没有解锁，那就解锁成就……\n  }\n\n  bool heroIsOnBridge_;\n};\n```\n\n#### 被观察者\n\n被观察者有发送通知的函数，还维护了一个<u>观察者列表</u>，而非只支持单一观察者，列表中的所有观察者都可以接收到通知\n\n```cpp\nclass Subject\n{\nprivate:\n  Observer* observers_[MAX_OBSERVERS];\n  int numObservers_;\n};\n```\n\n被观察者提供了公开的API来对列表进行修改，这就允许了外界代码控制了谁接收通知\n\n```cpp\nclass Subject\n{\npublic:\n  void addObserver(Observer* observer)\n  {\n    // 添加到数组中……\n  }\n\n  void removeObserver(Observer* observer)\n  {\n    // 从数组中移除……\n  }\n\n  // 其他代码……\n};\n```\n\n被观察者发送通知：\n\n```cpp\nclass Subject\n{\nprotected:\n  void notify(const Entity& entity, Event event) //注意notify是protected的，意味着派生了可以访问，而外部代码不能访问\n  {\n    for (int i = 0; i < numObservers_; i++)\n    {\n      observers_[i]->onNotify(entity, event);\n    }\n  }\n\n  // 其他代码…………\n};\n```\n\n#### 可被观察的物理引擎\n\n物理引擎派生被观察者类，可以在有趣的时间点发出通知\n\n```cpp\nclass Physics : public Subject\n{\npublic:\n  void updateEntity(Entity& entity);\n};\n```\n\n","source":"_posts/图形学&游戏开发/游戏编程模式/观察者模式.md","raw":"观察者模式\n\n在对象间定义一种一对多的依赖关系，以便当某对象的状态改变时，与它存在依赖关系的所有对象都能受到通知并自动进行更新\n\nwhy？\n\n考虑观察者模式的典型应用场景：游戏中的成就系统\n\n游戏角色从桥上掉下去，可以解锁“从桥上掉下”成就，判断角色是否从桥上掉下去，是物理引擎要做的事情，而为了实现成就系统，是否意味着要在物理引擎的代码部分添加解锁成就相关的逻辑？这看起来十分不优美\n\n如何**解耦**成就系统与物理引擎代码部分？\n\n> 成就在游戏的不同层面被触发，怎么解耦成就系统和其他部分\n\n观察者模式可以很好地解决这个问题。成就系统注册它本身为观察者，这样当物理系统发出一个通知时，成就系统就会收到通知。然后它会检查这个掉落的物体是否是“主角”，并检查它是否是从桥上掉下去的。如果条件都满足，就会触发成就系统并放射礼花，吹响号角，且这些判断、表现的代码是与物理系统完全解耦。\n\nwhat？\n\n在对象间定义一种一对多的依赖关系，以便当某对象的状态改变时，与它存在依赖关系的所有对象都能受到通知并自动进行更新\n\nhow?\n\n举个例子，有物理代码处理重力，追踪哪些物体待在地表，哪些坠入深渊。 为了实现“桥上掉落”的徽章，我们可以直接把成就代码放在那里，但那就会一团糟。 相反，可以这样做：\n\n```cpp\nvoid Physics::updateEntity(Entity& entity)\n{\n  bool wasOnSurface = entity.isOnSurface();\n  entity.accelerate(GRAVITY);\n  entity.update();\n  if (wasOnSurface && !entity.isOnSurface()) //掉下桥\n  {\n    notify(entity, EVENT_START_FALL);  //通知\n  }\n}\n```\n\n这样看起来很简洁\n\n成就系统注册它自己为观察者，\n\n#### 观察者\n\n```cpp\nclass Observer\n{\npublic:\n  virtual ~Observer() {}\n  virtual void onNotify(const Entity& entity, Event event) = 0;\n};\n```\n\n这是个抽象基类，任何派生了Observer的类都成为了观察者，对于成就系统：\n\n```cpp\nclass Achievements : public Observer\n{\npublic:\n  virtual void onNotify(const Entity& entity, Event event) //实现onNotify\n  {\n    switch (event)\n    {\n    case EVENT_ENTITY_FELL:\n      if (entity.isHero() && heroIsOnBridge_)\n      {\n        unlock(ACHIEVEMENT_FELL_OFF_BRIDGE);\n      }\n      break;\n\n      // 处理其他事件，更新heroIsOnBridge_变量……\n    }\n  }\n\nprivate:\n  void unlock(Achievement achievement)\n  {\n    // 如果还没有解锁，那就解锁成就……\n  }\n\n  bool heroIsOnBridge_;\n};\n```\n\n#### 被观察者\n\n被观察者有发送通知的函数，还维护了一个<u>观察者列表</u>，而非只支持单一观察者，列表中的所有观察者都可以接收到通知\n\n```cpp\nclass Subject\n{\nprivate:\n  Observer* observers_[MAX_OBSERVERS];\n  int numObservers_;\n};\n```\n\n被观察者提供了公开的API来对列表进行修改，这就允许了外界代码控制了谁接收通知\n\n```cpp\nclass Subject\n{\npublic:\n  void addObserver(Observer* observer)\n  {\n    // 添加到数组中……\n  }\n\n  void removeObserver(Observer* observer)\n  {\n    // 从数组中移除……\n  }\n\n  // 其他代码……\n};\n```\n\n被观察者发送通知：\n\n```cpp\nclass Subject\n{\nprotected:\n  void notify(const Entity& entity, Event event) //注意notify是protected的，意味着派生了可以访问，而外部代码不能访问\n  {\n    for (int i = 0; i < numObservers_; i++)\n    {\n      observers_[i]->onNotify(entity, event);\n    }\n  }\n\n  // 其他代码…………\n};\n```\n\n#### 可被观察的物理引擎\n\n物理引擎派生被观察者类，可以在有趣的时间点发出通知\n\n```cpp\nclass Physics : public Subject\n{\npublic:\n  void updateEntity(Entity& entity);\n};\n```\n\n","slug":"图形学&游戏开发/游戏编程模式/观察者模式","published":1,"date":"2022-04-22T11:38:58.033Z","updated":"2022-04-22T13:31:47.038Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0kyc0020pcu3877p3mob","content":"<p>观察者模式</p>\n<p>在对象间定义一种一对多的依赖关系，以便当某对象的状态改变时，与它存在依赖关系的所有对象都能受到通知并自动进行更新</p>\n<p>why？</p>\n<p>考虑观察者模式的典型应用场景：游戏中的成就系统</p>\n<p>游戏角色从桥上掉下去，可以解锁“从桥上掉下”成就，判断角色是否从桥上掉下去，是物理引擎要做的事情，而为了实现成就系统，是否意味着要在物理引擎的代码部分添加解锁成就相关的逻辑？这看起来十分不优美</p>\n<p>如何<strong>解耦</strong>成就系统与物理引擎代码部分？</p>\n<blockquote>\n<p>成就在游戏的不同层面被触发，怎么解耦成就系统和其他部分</p>\n</blockquote>\n<p>观察者模式可以很好地解决这个问题。成就系统注册它本身为观察者，这样当物理系统发出一个通知时，成就系统就会收到通知。然后它会检查这个掉落的物体是否是“主角”，并检查它是否是从桥上掉下去的。如果条件都满足，就会触发成就系统并放射礼花，吹响号角，且这些判断、表现的代码是与物理系统完全解耦。</p>\n<p>what？</p>\n<p>在对象间定义一种一对多的依赖关系，以便当某对象的状态改变时，与它存在依赖关系的所有对象都能受到通知并自动进行更新</p>\n<p>how?</p>\n<p>举个例子，有物理代码处理重力，追踪哪些物体待在地表，哪些坠入深渊。 为了实现“桥上掉落”的徽章，我们可以直接把成就代码放在那里，但那就会一团糟。 相反，可以这样做：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Physics::updateEntity</span><span class=\"params\">(Entity&amp; entity)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">bool</span> wasOnSurface = entity.<span class=\"built_in\">isOnSurface</span>();</span><br><span class=\"line\">  entity.<span class=\"built_in\">accelerate</span>(GRAVITY);</span><br><span class=\"line\">  entity.<span class=\"built_in\">update</span>();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (wasOnSurface &amp;&amp; !entity.<span class=\"built_in\">isOnSurface</span>()) <span class=\"comment\">//掉下桥</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"built_in\">notify</span>(entity, EVENT_START_FALL);  <span class=\"comment\">//通知</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样看起来很简洁</p>\n<p>成就系统注册它自己为观察者，</p>\n<h4 id=\"观察者\"><a href=\"#观察者\" class=\"headerlink\" title=\"观察者\"></a>观察者</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Observer</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"keyword\">virtual</span> ~<span class=\"built_in\">Observer</span>() &#123;&#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">onNotify</span><span class=\"params\">(<span class=\"keyword\">const</span> Entity&amp; entity, Event event)</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这是个抽象基类，任何派生了Observer的类都成为了观察者，对于成就系统：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Achievements</span> :</span> <span class=\"keyword\">public</span> Observer</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">onNotify</span><span class=\"params\">(<span class=\"keyword\">const</span> Entity&amp; entity, Event event)</span> <span class=\"comment\">//实现onNotify</span></span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\"><span class=\"keyword\">switch</span></span> (event)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> EVENT_ENTITY_FELL:</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (entity.<span class=\"built_in\">isHero</span>() &amp;&amp; heroIsOnBridge_)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"built_in\">unlock</span>(ACHIEVEMENT_FELL_OFF_BRIDGE);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 处理其他事件，更新heroIsOnBridge_变量……</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">unlock</span><span class=\"params\">(Achievement achievement)</span></span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果还没有解锁，那就解锁成就……</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">bool</span> heroIsOnBridge_;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"被观察者\"><a href=\"#被观察者\" class=\"headerlink\" title=\"被观察者\"></a>被观察者</h4><p>被观察者有发送通知的函数，还维护了一个<u>观察者列表</u>，而非只支持单一观察者，列表中的所有观察者都可以接收到通知</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Subject</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  Observer* observers_[MAX_OBSERVERS];</span><br><span class=\"line\">  <span class=\"keyword\">int</span> numObservers_;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>被观察者提供了公开的API来对列表进行修改，这就允许了外界代码控制了谁接收通知</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Subject</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addObserver</span><span class=\"params\">(Observer* observer)</span></span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 添加到数组中……</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">removeObserver</span><span class=\"params\">(Observer* observer)</span></span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 从数组中移除……</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 其他代码……</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>被观察者发送通知：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Subject</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">notify</span><span class=\"params\">(<span class=\"keyword\">const</span> Entity&amp; entity, Event event)</span> <span class=\"comment\">//注意notify是protected的，意味着派生了可以访问，而外部代码不能访问</span></span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numObservers_; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      observers_[i]-&gt;<span class=\"built_in\">onNotify</span>(entity, event);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 其他代码…………</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"可被观察的物理引擎\"><a href=\"#可被观察的物理引擎\" class=\"headerlink\" title=\"可被观察的物理引擎\"></a>可被观察的物理引擎</h4><p>物理引擎派生被观察者类，可以在有趣的时间点发出通知</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Physics</span> :</span> <span class=\"keyword\">public</span> Subject</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">updateEntity</span><span class=\"params\">(Entity&amp; entity)</span></span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<p>观察者模式</p>\n<p>在对象间定义一种一对多的依赖关系，以便当某对象的状态改变时，与它存在依赖关系的所有对象都能受到通知并自动进行更新</p>\n<p>why？</p>\n<p>考虑观察者模式的典型应用场景：游戏中的成就系统</p>\n<p>游戏角色从桥上掉下去，可以解锁“从桥上掉下”成就，判断角色是否从桥上掉下去，是物理引擎要做的事情，而为了实现成就系统，是否意味着要在物理引擎的代码部分添加解锁成就相关的逻辑？这看起来十分不优美</p>\n<p>如何<strong>解耦</strong>成就系统与物理引擎代码部分？</p>\n<blockquote>\n<p>成就在游戏的不同层面被触发，怎么解耦成就系统和其他部分</p>\n</blockquote>\n<p>观察者模式可以很好地解决这个问题。成就系统注册它本身为观察者，这样当物理系统发出一个通知时，成就系统就会收到通知。然后它会检查这个掉落的物体是否是“主角”，并检查它是否是从桥上掉下去的。如果条件都满足，就会触发成就系统并放射礼花，吹响号角，且这些判断、表现的代码是与物理系统完全解耦。</p>\n<p>what？</p>\n<p>在对象间定义一种一对多的依赖关系，以便当某对象的状态改变时，与它存在依赖关系的所有对象都能受到通知并自动进行更新</p>\n<p>how?</p>\n<p>举个例子，有物理代码处理重力，追踪哪些物体待在地表，哪些坠入深渊。 为了实现“桥上掉落”的徽章，我们可以直接把成就代码放在那里，但那就会一团糟。 相反，可以这样做：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Physics::updateEntity</span><span class=\"params\">(Entity&amp; entity)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">bool</span> wasOnSurface = entity.<span class=\"built_in\">isOnSurface</span>();</span><br><span class=\"line\">  entity.<span class=\"built_in\">accelerate</span>(GRAVITY);</span><br><span class=\"line\">  entity.<span class=\"built_in\">update</span>();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (wasOnSurface &amp;&amp; !entity.<span class=\"built_in\">isOnSurface</span>()) <span class=\"comment\">//掉下桥</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"built_in\">notify</span>(entity, EVENT_START_FALL);  <span class=\"comment\">//通知</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样看起来很简洁</p>\n<p>成就系统注册它自己为观察者，</p>\n<h4 id=\"观察者\"><a href=\"#观察者\" class=\"headerlink\" title=\"观察者\"></a>观察者</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Observer</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"keyword\">virtual</span> ~<span class=\"built_in\">Observer</span>() &#123;&#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">onNotify</span><span class=\"params\">(<span class=\"keyword\">const</span> Entity&amp; entity, Event event)</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这是个抽象基类，任何派生了Observer的类都成为了观察者，对于成就系统：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Achievements</span> :</span> <span class=\"keyword\">public</span> Observer</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">onNotify</span><span class=\"params\">(<span class=\"keyword\">const</span> Entity&amp; entity, Event event)</span> <span class=\"comment\">//实现onNotify</span></span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\"><span class=\"keyword\">switch</span></span> (event)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> EVENT_ENTITY_FELL:</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (entity.<span class=\"built_in\">isHero</span>() &amp;&amp; heroIsOnBridge_)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"built_in\">unlock</span>(ACHIEVEMENT_FELL_OFF_BRIDGE);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 处理其他事件，更新heroIsOnBridge_变量……</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">unlock</span><span class=\"params\">(Achievement achievement)</span></span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果还没有解锁，那就解锁成就……</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">bool</span> heroIsOnBridge_;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"被观察者\"><a href=\"#被观察者\" class=\"headerlink\" title=\"被观察者\"></a>被观察者</h4><p>被观察者有发送通知的函数，还维护了一个<u>观察者列表</u>，而非只支持单一观察者，列表中的所有观察者都可以接收到通知</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Subject</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  Observer* observers_[MAX_OBSERVERS];</span><br><span class=\"line\">  <span class=\"keyword\">int</span> numObservers_;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>被观察者提供了公开的API来对列表进行修改，这就允许了外界代码控制了谁接收通知</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Subject</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addObserver</span><span class=\"params\">(Observer* observer)</span></span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 添加到数组中……</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">removeObserver</span><span class=\"params\">(Observer* observer)</span></span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 从数组中移除……</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 其他代码……</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>被观察者发送通知：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Subject</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">notify</span><span class=\"params\">(<span class=\"keyword\">const</span> Entity&amp; entity, Event event)</span> <span class=\"comment\">//注意notify是protected的，意味着派生了可以访问，而外部代码不能访问</span></span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numObservers_; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      observers_[i]-&gt;<span class=\"built_in\">onNotify</span>(entity, event);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 其他代码…………</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"可被观察的物理引擎\"><a href=\"#可被观察的物理引擎\" class=\"headerlink\" title=\"可被观察的物理引擎\"></a>可被观察的物理引擎</h4><p>物理引擎派生被观察者类，可以在有趣的时间点发出通知</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Physics</span> :</span> <span class=\"keyword\">public</span> Subject</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">updateEntity</span><span class=\"params\">(Entity&amp; entity)</span></span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n"},{"_content":"对象池\n\nwhy？\n\n粒子系统短时间内要创建销毁大量对象，如果不用对象池，就会很麻烦，而且还会产生内存碎片。利用对象池可以重用对象，避免频繁创建销毁对象，提高性能\n\nhow：\n\n定义一个池对象，其中包含一组可重用对象，每个可重用对象都可以查询使用状态\n\n应用场景：\n\n- 需要频繁创建销毁对象\n- 对象大小差不多\n- 在堆上进行内存分配缓慢且会导致内存碎片\n- \n\n","source":"_posts/图形学&游戏开发/游戏编程模式/对象池.md","raw":"对象池\n\nwhy？\n\n粒子系统短时间内要创建销毁大量对象，如果不用对象池，就会很麻烦，而且还会产生内存碎片。利用对象池可以重用对象，避免频繁创建销毁对象，提高性能\n\nhow：\n\n定义一个池对象，其中包含一组可重用对象，每个可重用对象都可以查询使用状态\n\n应用场景：\n\n- 需要频繁创建销毁对象\n- 对象大小差不多\n- 在堆上进行内存分配缓慢且会导致内存碎片\n- \n\n","slug":"图形学&游戏开发/游戏编程模式/对象池","published":1,"date":"2022-04-21T03:36:35.502Z","updated":"2022-04-22T13:33:28.962Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0kyc0021pcu39g1p1nf8","content":"<p>对象池</p>\n<p>why？</p>\n<p>粒子系统短时间内要创建销毁大量对象，如果不用对象池，就会很麻烦，而且还会产生内存碎片。利用对象池可以重用对象，避免频繁创建销毁对象，提高性能</p>\n<p>how：</p>\n<p>定义一个池对象，其中包含一组可重用对象，每个可重用对象都可以查询使用状态</p>\n<p>应用场景：</p>\n<ul>\n<li>需要频繁创建销毁对象</li>\n<li>对象大小差不多</li>\n<li>在堆上进行内存分配缓慢且会导致内存碎片</li>\n<li></li>\n</ul>\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<p>对象池</p>\n<p>why？</p>\n<p>粒子系统短时间内要创建销毁大量对象，如果不用对象池，就会很麻烦，而且还会产生内存碎片。利用对象池可以重用对象，避免频繁创建销毁对象，提高性能</p>\n<p>how：</p>\n<p>定义一个池对象，其中包含一组可重用对象，每个可重用对象都可以查询使用状态</p>\n<p>应用场景：</p>\n<ul>\n<li>需要频繁创建销毁对象</li>\n<li>对象大小差不多</li>\n<li>在堆上进行内存分配缓慢且会导致内存碎片</li>\n<li></li>\n</ul>\n"},{"_content":"![preview](https://raw.githubusercontent.com/Vio1ette/blog-img/main/v2-1eaef9fbb1768e716b146b0a2a4e1a41_r.jpg)\n\n图片来源：https://zhuanlan.zhihu.com/p/105390563\n\n帧同步又叫“锁步模式”。这种模式用形象的比喻来说，就是把所有参与对战的客户端，看成是排成一列的囚犯。这些囚犯们的左脚都被链子所在一起，因此他们如果要往前走，就只能同时迈步，如果其中某个人走快了，或者走慢了，都会让整队人停下来。\n\n作者：合肥黑\n链接：https://www.jianshu.com/p/81050871cce7\n来源：简书\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n帧同步要求每一帧都是一样的，而状态同步允许每个客户端屏幕上显示的内容不一样，只需要最后在逻辑上统一\n\n帧同步的优缺点：\n\n| 优点                                                   | 缺点                                                     |\n| ------------------------------------------------------ | -------------------------------------------------------- |\n| 开发效率高<br />打击感强<br />流量低<br />回放实现简单 | 网络要求高<br />反外挂能力弱<br />断线重连的时间长<br /> |\n\n状态同步的优缺点：\n\n| 优点                                             | 缺点                                       |\n| ------------------------------------------------ | ------------------------------------------ |\n| 安全性高<br />网络要求宽松<br />断线重连快<br /> | 开发效率低<br />打击感差<br />网络流量复杂 |\n\n\n## 1. 帧同步\n\n![image-20220505085138953](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220505085138953.png)\n\n`Server`将逻辑时间切分为一个个等长的逻辑时间片，每一个时间片对应一个`Frame`，每个`Frame`有一个代表逻辑时间的序号。`Client`的输入模块在接收到玩家输入的命令（`Cmd`）后，并不直接将`Cmd`直接传给游戏逻辑，而是发送给`Server`。如果`Server`在同一个时间片（比如`Frame3`）的周期里，收到了`Client A`和`Client B`的输入，那么就会将这两个`Client`的输入以`Cmd`列表的形式包含在`Frame 3`里。等到`Frame 3`的周期结束时，就会将`Frame 3`分别发送给`Client A`和`Client B`。那么，两个`Client`在相同的逻辑时间里，就会收到完全相同的`Cmd`列表。\n\n如果`Client A`与`Client B`的逻辑也完全相同，那么对于完全相同的`Cmd`输入，理论上，将会计算得出完全相同的逻辑结果，从而实现了高一致性的网络同步\n\n一个客户端做出操作，发送操作指令给服务器，服务器将这个<u>操作指令再广播</u>到其他客户端，其他客户端本地的逻辑层计算出结果，表现层根据逻辑层计算的结果刷新状态\n\n帧同步的优点：\n\n- 容易实现回放系统，客户端向服务器申请重新执行一遍操作指令\n\n- 逻辑表现分离\n\n- 服务器转发的是操作指令，数据量小\n\n\n### 1.1 延迟和卡顿\n\n这俩是一个tradeoff，一个好了另一个差了，比如延迟很低的情况下，严格按照逻辑计算结果进行表现，每帧就会出现不连贯的情况。\n\n解决办法：缓冲，积累两、三帧的数据，然后一块播放\n\n#### 1.1.1. 帧锁定\n\n#### 1.1.2 预测、快照、回滚\n\n##### 1.1.2.1 预测\n\n一般情况下，客户端将自己的输入指令发送给服务器，服务器会收集所有的客户端上传的操作指令，然后再一起广播给所有客户端。\n\n在某一帧，客户端A将自己的输入指令发送给服务器后，A预测自己的指令是有效的，预先执行自己的输入指令（逻辑计算->渲染），客户端不需要服务端确认帧返回才执行指令，而其他玩家的输入也可以预测（例如按照其上一个输入做预测）\n\n> 真实逻辑的预测执行和view层面的预测执行\n\n##### 1.1.2.2 快照\n\n客户端会保存服务端最后一次成功确认的帧和预测帧的数据和状态，方便后面回滚\n\n##### 1.1.2.3 回滚\n\n收到服务器的确认操作之后，如果确认操作和之前预测的操作一样，则万事大吉，不做任何改变；否则，客户端就需要回滚到最后一次服务器确认的正确帧，然后在执行**追帧**操作（从正确帧开始，快速执行中间的帧，直至最新的帧）\n\n### 1.2 逻辑表现分离\n\nwhy？\n\n有效解决“卡顿”现象，对于由延迟引发的卡顿，逻辑不平滑，但可以在逻辑值之间进行插值，让表现平滑。逻辑空间严格按照帧同步的要求进行计算，表现空间获得逻辑计算的结果进行显示，并利用插值来平滑显示效果\n\nhow？\n\n将一个游戏对象类拆分为两个类，分别为逻辑类和表现类\n\n逻辑类严格按照帧同步的要求进行计算（比如碰撞啊技能释放啊都是在这里，<u>不能用浮点数</u>），表现类就是`gameObject`的位置啊、动画等信息。逻辑对象和表现对象都有自己的ID，然后各自持有对方的引用，表现层就可以通过引用来获取逻辑层的计算结果\n\n### 1.3 安全性（外挂）\n\n帧同步的逻辑计算是放在客户端的，所以客户端一旦被破解，就可以很容易地获得数据，开发外挂\n\n### 1.4 避免使用浮点数\n\n帧同步技术的难点之一就是需要客户端计算结果的一致性。其中浮点数的运算在一些情况下是会产生不同的结果，所以实现帧同步要避免使用浮点数\n\n### 1.5 使用UDP\n\n在UDP之上实现了可靠性，增加序号和确认机制\n\n1. 为每个数据包增加序列号，每发一次，增加本地序号\n2. 每次收到包，把收到的包上序列号变为确认字符，发送包的时候带上这些确认字符\n\n## 2. 状态同步\n\n一个客户端发出操作指令给服务器，<u>服务器计算出结果</u>，更新状态，再将游戏中的所有<u>状态广播</u>给其他客户端\n\n> 逻辑计算在服务端，逻辑计算包括普攻、属性、移动、AI、碰撞、技能逻辑\n\n- 安全性高\n- 断线重连容易，服务器再传一次数据就行了\n\n为什么不能用浮点数（float）？因为要保证计算结果一致\n\n\n\nhttps://zhuanlan.zhihu.com/p/105390563\n\nhttps://jonyzhao.gitbooks.io/gamedev/content/Network/FrameLockStepSync.html\n\nhttps://zhuanlan.zhihu.com/p/36884005\n\nhttps://www.zhihu.com/question/323505671\n\nhttps://www.youxituoluo.com/528021.html\n\nhttp://codebear.fun/index.php/2020/04/02/548.html\n\nhttps://www.jianshu.com/p/8cca5458c45b\n\nhttp://bindog.github.io/blog/2015/03/10/synchronization-in-multiplayer-networked-game-lockstep/\n\n","source":"_posts/图形学&游戏开发/网络多人游戏编程/帧同步与状态同步.md","raw":"![preview](https://raw.githubusercontent.com/Vio1ette/blog-img/main/v2-1eaef9fbb1768e716b146b0a2a4e1a41_r.jpg)\n\n图片来源：https://zhuanlan.zhihu.com/p/105390563\n\n帧同步又叫“锁步模式”。这种模式用形象的比喻来说，就是把所有参与对战的客户端，看成是排成一列的囚犯。这些囚犯们的左脚都被链子所在一起，因此他们如果要往前走，就只能同时迈步，如果其中某个人走快了，或者走慢了，都会让整队人停下来。\n\n作者：合肥黑\n链接：https://www.jianshu.com/p/81050871cce7\n来源：简书\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n帧同步要求每一帧都是一样的，而状态同步允许每个客户端屏幕上显示的内容不一样，只需要最后在逻辑上统一\n\n帧同步的优缺点：\n\n| 优点                                                   | 缺点                                                     |\n| ------------------------------------------------------ | -------------------------------------------------------- |\n| 开发效率高<br />打击感强<br />流量低<br />回放实现简单 | 网络要求高<br />反外挂能力弱<br />断线重连的时间长<br /> |\n\n状态同步的优缺点：\n\n| 优点                                             | 缺点                                       |\n| ------------------------------------------------ | ------------------------------------------ |\n| 安全性高<br />网络要求宽松<br />断线重连快<br /> | 开发效率低<br />打击感差<br />网络流量复杂 |\n\n\n## 1. 帧同步\n\n![image-20220505085138953](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220505085138953.png)\n\n`Server`将逻辑时间切分为一个个等长的逻辑时间片，每一个时间片对应一个`Frame`，每个`Frame`有一个代表逻辑时间的序号。`Client`的输入模块在接收到玩家输入的命令（`Cmd`）后，并不直接将`Cmd`直接传给游戏逻辑，而是发送给`Server`。如果`Server`在同一个时间片（比如`Frame3`）的周期里，收到了`Client A`和`Client B`的输入，那么就会将这两个`Client`的输入以`Cmd`列表的形式包含在`Frame 3`里。等到`Frame 3`的周期结束时，就会将`Frame 3`分别发送给`Client A`和`Client B`。那么，两个`Client`在相同的逻辑时间里，就会收到完全相同的`Cmd`列表。\n\n如果`Client A`与`Client B`的逻辑也完全相同，那么对于完全相同的`Cmd`输入，理论上，将会计算得出完全相同的逻辑结果，从而实现了高一致性的网络同步\n\n一个客户端做出操作，发送操作指令给服务器，服务器将这个<u>操作指令再广播</u>到其他客户端，其他客户端本地的逻辑层计算出结果，表现层根据逻辑层计算的结果刷新状态\n\n帧同步的优点：\n\n- 容易实现回放系统，客户端向服务器申请重新执行一遍操作指令\n\n- 逻辑表现分离\n\n- 服务器转发的是操作指令，数据量小\n\n\n### 1.1 延迟和卡顿\n\n这俩是一个tradeoff，一个好了另一个差了，比如延迟很低的情况下，严格按照逻辑计算结果进行表现，每帧就会出现不连贯的情况。\n\n解决办法：缓冲，积累两、三帧的数据，然后一块播放\n\n#### 1.1.1. 帧锁定\n\n#### 1.1.2 预测、快照、回滚\n\n##### 1.1.2.1 预测\n\n一般情况下，客户端将自己的输入指令发送给服务器，服务器会收集所有的客户端上传的操作指令，然后再一起广播给所有客户端。\n\n在某一帧，客户端A将自己的输入指令发送给服务器后，A预测自己的指令是有效的，预先执行自己的输入指令（逻辑计算->渲染），客户端不需要服务端确认帧返回才执行指令，而其他玩家的输入也可以预测（例如按照其上一个输入做预测）\n\n> 真实逻辑的预测执行和view层面的预测执行\n\n##### 1.1.2.2 快照\n\n客户端会保存服务端最后一次成功确认的帧和预测帧的数据和状态，方便后面回滚\n\n##### 1.1.2.3 回滚\n\n收到服务器的确认操作之后，如果确认操作和之前预测的操作一样，则万事大吉，不做任何改变；否则，客户端就需要回滚到最后一次服务器确认的正确帧，然后在执行**追帧**操作（从正确帧开始，快速执行中间的帧，直至最新的帧）\n\n### 1.2 逻辑表现分离\n\nwhy？\n\n有效解决“卡顿”现象，对于由延迟引发的卡顿，逻辑不平滑，但可以在逻辑值之间进行插值，让表现平滑。逻辑空间严格按照帧同步的要求进行计算，表现空间获得逻辑计算的结果进行显示，并利用插值来平滑显示效果\n\nhow？\n\n将一个游戏对象类拆分为两个类，分别为逻辑类和表现类\n\n逻辑类严格按照帧同步的要求进行计算（比如碰撞啊技能释放啊都是在这里，<u>不能用浮点数</u>），表现类就是`gameObject`的位置啊、动画等信息。逻辑对象和表现对象都有自己的ID，然后各自持有对方的引用，表现层就可以通过引用来获取逻辑层的计算结果\n\n### 1.3 安全性（外挂）\n\n帧同步的逻辑计算是放在客户端的，所以客户端一旦被破解，就可以很容易地获得数据，开发外挂\n\n### 1.4 避免使用浮点数\n\n帧同步技术的难点之一就是需要客户端计算结果的一致性。其中浮点数的运算在一些情况下是会产生不同的结果，所以实现帧同步要避免使用浮点数\n\n### 1.5 使用UDP\n\n在UDP之上实现了可靠性，增加序号和确认机制\n\n1. 为每个数据包增加序列号，每发一次，增加本地序号\n2. 每次收到包，把收到的包上序列号变为确认字符，发送包的时候带上这些确认字符\n\n## 2. 状态同步\n\n一个客户端发出操作指令给服务器，<u>服务器计算出结果</u>，更新状态，再将游戏中的所有<u>状态广播</u>给其他客户端\n\n> 逻辑计算在服务端，逻辑计算包括普攻、属性、移动、AI、碰撞、技能逻辑\n\n- 安全性高\n- 断线重连容易，服务器再传一次数据就行了\n\n为什么不能用浮点数（float）？因为要保证计算结果一致\n\n\n\nhttps://zhuanlan.zhihu.com/p/105390563\n\nhttps://jonyzhao.gitbooks.io/gamedev/content/Network/FrameLockStepSync.html\n\nhttps://zhuanlan.zhihu.com/p/36884005\n\nhttps://www.zhihu.com/question/323505671\n\nhttps://www.youxituoluo.com/528021.html\n\nhttp://codebear.fun/index.php/2020/04/02/548.html\n\nhttps://www.jianshu.com/p/8cca5458c45b\n\nhttp://bindog.github.io/blog/2015/03/10/synchronization-in-multiplayer-networked-game-lockstep/\n\n","slug":"图形学&游戏开发/网络多人游戏编程/帧同步与状态同步","published":1,"date":"2022-04-16T08:24:27.263Z","updated":"2022-05-13T03:56:36.721Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0kyd0022pcu30mcbgpcr","content":"<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/v2-1eaef9fbb1768e716b146b0a2a4e1a41_r.jpg\" alt=\"preview\"></p>\n<p>图片来源：<a href=\"https://zhuanlan.zhihu.com/p/105390563\">https://zhuanlan.zhihu.com/p/105390563</a></p>\n<p>帧同步又叫“锁步模式”。这种模式用形象的比喻来说，就是把所有参与对战的客户端，看成是排成一列的囚犯。这些囚犯们的左脚都被链子所在一起，因此他们如果要往前走，就只能同时迈步，如果其中某个人走快了，或者走慢了，都会让整队人停下来。</p>\n<p>作者：合肥黑<br>链接：<a href=\"https://www.jianshu.com/p/81050871cce7\">https://www.jianshu.com/p/81050871cce7</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n<p>帧同步要求每一帧都是一样的，而状态同步允许每个客户端屏幕上显示的内容不一样，只需要最后在逻辑上统一</p>\n<p>帧同步的优缺点：</p>\n<table>\n<thead>\n<tr>\n<th>优点</th>\n<th>缺点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>开发效率高<br />打击感强<br />流量低<br />回放实现简单</td>\n<td>网络要求高<br />反外挂能力弱<br />断线重连的时间长<br /></td>\n</tr>\n</tbody></table>\n<p>状态同步的优缺点：</p>\n<table>\n<thead>\n<tr>\n<th>优点</th>\n<th>缺点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>安全性高<br />网络要求宽松<br />断线重连快<br /></td>\n<td>开发效率低<br />打击感差<br />网络流量复杂</td>\n</tr>\n</tbody></table>\n<h2 id=\"1-帧同步\"><a href=\"#1-帧同步\" class=\"headerlink\" title=\"1. 帧同步\"></a>1. 帧同步</h2><p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220505085138953.png\" alt=\"image-20220505085138953\"></p>\n<p><code>Server</code>将逻辑时间切分为一个个等长的逻辑时间片，每一个时间片对应一个<code>Frame</code>，每个<code>Frame</code>有一个代表逻辑时间的序号。<code>Client</code>的输入模块在接收到玩家输入的命令（<code>Cmd</code>）后，并不直接将<code>Cmd</code>直接传给游戏逻辑，而是发送给<code>Server</code>。如果<code>Server</code>在同一个时间片（比如<code>Frame3</code>）的周期里，收到了<code>Client A</code>和<code>Client B</code>的输入，那么就会将这两个<code>Client</code>的输入以<code>Cmd</code>列表的形式包含在<code>Frame 3</code>里。等到<code>Frame 3</code>的周期结束时，就会将<code>Frame 3</code>分别发送给<code>Client A</code>和<code>Client B</code>。那么，两个<code>Client</code>在相同的逻辑时间里，就会收到完全相同的<code>Cmd</code>列表。</p>\n<p>如果<code>Client A</code>与<code>Client B</code>的逻辑也完全相同，那么对于完全相同的<code>Cmd</code>输入，理论上，将会计算得出完全相同的逻辑结果，从而实现了高一致性的网络同步</p>\n<p>一个客户端做出操作，发送操作指令给服务器，服务器将这个<u>操作指令再广播</u>到其他客户端，其他客户端本地的逻辑层计算出结果，表现层根据逻辑层计算的结果刷新状态</p>\n<p>帧同步的优点：</p>\n<ul>\n<li><p>容易实现回放系统，客户端向服务器申请重新执行一遍操作指令</p>\n</li>\n<li><p>逻辑表现分离</p>\n</li>\n<li><p>服务器转发的是操作指令，数据量小</p>\n</li>\n</ul>\n<h3 id=\"1-1-延迟和卡顿\"><a href=\"#1-1-延迟和卡顿\" class=\"headerlink\" title=\"1.1 延迟和卡顿\"></a>1.1 延迟和卡顿</h3><p>这俩是一个tradeoff，一个好了另一个差了，比如延迟很低的情况下，严格按照逻辑计算结果进行表现，每帧就会出现不连贯的情况。</p>\n<p>解决办法：缓冲，积累两、三帧的数据，然后一块播放</p>\n<h4 id=\"1-1-1-帧锁定\"><a href=\"#1-1-1-帧锁定\" class=\"headerlink\" title=\"1.1.1. 帧锁定\"></a>1.1.1. 帧锁定</h4><h4 id=\"1-1-2-预测、快照、回滚\"><a href=\"#1-1-2-预测、快照、回滚\" class=\"headerlink\" title=\"1.1.2 预测、快照、回滚\"></a>1.1.2 预测、快照、回滚</h4><h5 id=\"1-1-2-1-预测\"><a href=\"#1-1-2-1-预测\" class=\"headerlink\" title=\"1.1.2.1 预测\"></a>1.1.2.1 预测</h5><p>一般情况下，客户端将自己的输入指令发送给服务器，服务器会收集所有的客户端上传的操作指令，然后再一起广播给所有客户端。</p>\n<p>在某一帧，客户端A将自己的输入指令发送给服务器后，A预测自己的指令是有效的，预先执行自己的输入指令（逻辑计算-&gt;渲染），客户端不需要服务端确认帧返回才执行指令，而其他玩家的输入也可以预测（例如按照其上一个输入做预测）</p>\n<blockquote>\n<p>真实逻辑的预测执行和view层面的预测执行</p>\n</blockquote>\n<h5 id=\"1-1-2-2-快照\"><a href=\"#1-1-2-2-快照\" class=\"headerlink\" title=\"1.1.2.2 快照\"></a>1.1.2.2 快照</h5><p>客户端会保存服务端最后一次成功确认的帧和预测帧的数据和状态，方便后面回滚</p>\n<h5 id=\"1-1-2-3-回滚\"><a href=\"#1-1-2-3-回滚\" class=\"headerlink\" title=\"1.1.2.3 回滚\"></a>1.1.2.3 回滚</h5><p>收到服务器的确认操作之后，如果确认操作和之前预测的操作一样，则万事大吉，不做任何改变；否则，客户端就需要回滚到最后一次服务器确认的正确帧，然后在执行<strong>追帧</strong>操作（从正确帧开始，快速执行中间的帧，直至最新的帧）</p>\n<h3 id=\"1-2-逻辑表现分离\"><a href=\"#1-2-逻辑表现分离\" class=\"headerlink\" title=\"1.2 逻辑表现分离\"></a>1.2 逻辑表现分离</h3><p>why？</p>\n<p>有效解决“卡顿”现象，对于由延迟引发的卡顿，逻辑不平滑，但可以在逻辑值之间进行插值，让表现平滑。逻辑空间严格按照帧同步的要求进行计算，表现空间获得逻辑计算的结果进行显示，并利用插值来平滑显示效果</p>\n<p>how？</p>\n<p>将一个游戏对象类拆分为两个类，分别为逻辑类和表现类</p>\n<p>逻辑类严格按照帧同步的要求进行计算（比如碰撞啊技能释放啊都是在这里，<u>不能用浮点数</u>），表现类就是<code>gameObject</code>的位置啊、动画等信息。逻辑对象和表现对象都有自己的ID，然后各自持有对方的引用，表现层就可以通过引用来获取逻辑层的计算结果</p>\n<h3 id=\"1-3-安全性（外挂）\"><a href=\"#1-3-安全性（外挂）\" class=\"headerlink\" title=\"1.3 安全性（外挂）\"></a>1.3 安全性（外挂）</h3><p>帧同步的逻辑计算是放在客户端的，所以客户端一旦被破解，就可以很容易地获得数据，开发外挂</p>\n<h3 id=\"1-4-避免使用浮点数\"><a href=\"#1-4-避免使用浮点数\" class=\"headerlink\" title=\"1.4 避免使用浮点数\"></a>1.4 避免使用浮点数</h3><p>帧同步技术的难点之一就是需要客户端计算结果的一致性。其中浮点数的运算在一些情况下是会产生不同的结果，所以实现帧同步要避免使用浮点数</p>\n<h3 id=\"1-5-使用UDP\"><a href=\"#1-5-使用UDP\" class=\"headerlink\" title=\"1.5 使用UDP\"></a>1.5 使用UDP</h3><p>在UDP之上实现了可靠性，增加序号和确认机制</p>\n<ol>\n<li>为每个数据包增加序列号，每发一次，增加本地序号</li>\n<li>每次收到包，把收到的包上序列号变为确认字符，发送包的时候带上这些确认字符</li>\n</ol>\n<h2 id=\"2-状态同步\"><a href=\"#2-状态同步\" class=\"headerlink\" title=\"2. 状态同步\"></a>2. 状态同步</h2><p>一个客户端发出操作指令给服务器，<u>服务器计算出结果</u>，更新状态，再将游戏中的所有<u>状态广播</u>给其他客户端</p>\n<blockquote>\n<p>逻辑计算在服务端，逻辑计算包括普攻、属性、移动、AI、碰撞、技能逻辑</p>\n</blockquote>\n<ul>\n<li>安全性高</li>\n<li>断线重连容易，服务器再传一次数据就行了</li>\n</ul>\n<p>为什么不能用浮点数（float）？因为要保证计算结果一致</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/105390563\">https://zhuanlan.zhihu.com/p/105390563</a></p>\n<p><a href=\"https://jonyzhao.gitbooks.io/gamedev/content/Network/FrameLockStepSync.html\">https://jonyzhao.gitbooks.io/gamedev/content/Network/FrameLockStepSync.html</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/36884005\">https://zhuanlan.zhihu.com/p/36884005</a></p>\n<p><a href=\"https://www.zhihu.com/question/323505671\">https://www.zhihu.com/question/323505671</a></p>\n<p><a href=\"https://www.youxituoluo.com/528021.html\">https://www.youxituoluo.com/528021.html</a></p>\n<p><a href=\"http://codebear.fun/index.php/2020/04/02/548.html\">http://codebear.fun/index.php/2020/04/02/548.html</a></p>\n<p><a href=\"https://www.jianshu.com/p/8cca5458c45b\">https://www.jianshu.com/p/8cca5458c45b</a></p>\n<p><a href=\"http://bindog.github.io/blog/2015/03/10/synchronization-in-multiplayer-networked-game-lockstep/\">http://bindog.github.io/blog/2015/03/10/synchronization-in-multiplayer-networked-game-lockstep/</a></p>\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/v2-1eaef9fbb1768e716b146b0a2a4e1a41_r.jpg\" alt=\"preview\"></p>\n<p>图片来源：<a href=\"https://zhuanlan.zhihu.com/p/105390563\">https://zhuanlan.zhihu.com/p/105390563</a></p>\n<p>帧同步又叫“锁步模式”。这种模式用形象的比喻来说，就是把所有参与对战的客户端，看成是排成一列的囚犯。这些囚犯们的左脚都被链子所在一起，因此他们如果要往前走，就只能同时迈步，如果其中某个人走快了，或者走慢了，都会让整队人停下来。</p>\n<p>作者：合肥黑<br>链接：<a href=\"https://www.jianshu.com/p/81050871cce7\">https://www.jianshu.com/p/81050871cce7</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n<p>帧同步要求每一帧都是一样的，而状态同步允许每个客户端屏幕上显示的内容不一样，只需要最后在逻辑上统一</p>\n<p>帧同步的优缺点：</p>\n<table>\n<thead>\n<tr>\n<th>优点</th>\n<th>缺点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>开发效率高<br />打击感强<br />流量低<br />回放实现简单</td>\n<td>网络要求高<br />反外挂能力弱<br />断线重连的时间长<br /></td>\n</tr>\n</tbody></table>\n<p>状态同步的优缺点：</p>\n<table>\n<thead>\n<tr>\n<th>优点</th>\n<th>缺点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>安全性高<br />网络要求宽松<br />断线重连快<br /></td>\n<td>开发效率低<br />打击感差<br />网络流量复杂</td>\n</tr>\n</tbody></table>\n<h2 id=\"1-帧同步\"><a href=\"#1-帧同步\" class=\"headerlink\" title=\"1. 帧同步\"></a>1. 帧同步</h2><p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220505085138953.png\" alt=\"image-20220505085138953\"></p>\n<p><code>Server</code>将逻辑时间切分为一个个等长的逻辑时间片，每一个时间片对应一个<code>Frame</code>，每个<code>Frame</code>有一个代表逻辑时间的序号。<code>Client</code>的输入模块在接收到玩家输入的命令（<code>Cmd</code>）后，并不直接将<code>Cmd</code>直接传给游戏逻辑，而是发送给<code>Server</code>。如果<code>Server</code>在同一个时间片（比如<code>Frame3</code>）的周期里，收到了<code>Client A</code>和<code>Client B</code>的输入，那么就会将这两个<code>Client</code>的输入以<code>Cmd</code>列表的形式包含在<code>Frame 3</code>里。等到<code>Frame 3</code>的周期结束时，就会将<code>Frame 3</code>分别发送给<code>Client A</code>和<code>Client B</code>。那么，两个<code>Client</code>在相同的逻辑时间里，就会收到完全相同的<code>Cmd</code>列表。</p>\n<p>如果<code>Client A</code>与<code>Client B</code>的逻辑也完全相同，那么对于完全相同的<code>Cmd</code>输入，理论上，将会计算得出完全相同的逻辑结果，从而实现了高一致性的网络同步</p>\n<p>一个客户端做出操作，发送操作指令给服务器，服务器将这个<u>操作指令再广播</u>到其他客户端，其他客户端本地的逻辑层计算出结果，表现层根据逻辑层计算的结果刷新状态</p>\n<p>帧同步的优点：</p>\n<ul>\n<li><p>容易实现回放系统，客户端向服务器申请重新执行一遍操作指令</p>\n</li>\n<li><p>逻辑表现分离</p>\n</li>\n<li><p>服务器转发的是操作指令，数据量小</p>\n</li>\n</ul>\n<h3 id=\"1-1-延迟和卡顿\"><a href=\"#1-1-延迟和卡顿\" class=\"headerlink\" title=\"1.1 延迟和卡顿\"></a>1.1 延迟和卡顿</h3><p>这俩是一个tradeoff，一个好了另一个差了，比如延迟很低的情况下，严格按照逻辑计算结果进行表现，每帧就会出现不连贯的情况。</p>\n<p>解决办法：缓冲，积累两、三帧的数据，然后一块播放</p>\n<h4 id=\"1-1-1-帧锁定\"><a href=\"#1-1-1-帧锁定\" class=\"headerlink\" title=\"1.1.1. 帧锁定\"></a>1.1.1. 帧锁定</h4><h4 id=\"1-1-2-预测、快照、回滚\"><a href=\"#1-1-2-预测、快照、回滚\" class=\"headerlink\" title=\"1.1.2 预测、快照、回滚\"></a>1.1.2 预测、快照、回滚</h4><h5 id=\"1-1-2-1-预测\"><a href=\"#1-1-2-1-预测\" class=\"headerlink\" title=\"1.1.2.1 预测\"></a>1.1.2.1 预测</h5><p>一般情况下，客户端将自己的输入指令发送给服务器，服务器会收集所有的客户端上传的操作指令，然后再一起广播给所有客户端。</p>\n<p>在某一帧，客户端A将自己的输入指令发送给服务器后，A预测自己的指令是有效的，预先执行自己的输入指令（逻辑计算-&gt;渲染），客户端不需要服务端确认帧返回才执行指令，而其他玩家的输入也可以预测（例如按照其上一个输入做预测）</p>\n<blockquote>\n<p>真实逻辑的预测执行和view层面的预测执行</p>\n</blockquote>\n<h5 id=\"1-1-2-2-快照\"><a href=\"#1-1-2-2-快照\" class=\"headerlink\" title=\"1.1.2.2 快照\"></a>1.1.2.2 快照</h5><p>客户端会保存服务端最后一次成功确认的帧和预测帧的数据和状态，方便后面回滚</p>\n<h5 id=\"1-1-2-3-回滚\"><a href=\"#1-1-2-3-回滚\" class=\"headerlink\" title=\"1.1.2.3 回滚\"></a>1.1.2.3 回滚</h5><p>收到服务器的确认操作之后，如果确认操作和之前预测的操作一样，则万事大吉，不做任何改变；否则，客户端就需要回滚到最后一次服务器确认的正确帧，然后在执行<strong>追帧</strong>操作（从正确帧开始，快速执行中间的帧，直至最新的帧）</p>\n<h3 id=\"1-2-逻辑表现分离\"><a href=\"#1-2-逻辑表现分离\" class=\"headerlink\" title=\"1.2 逻辑表现分离\"></a>1.2 逻辑表现分离</h3><p>why？</p>\n<p>有效解决“卡顿”现象，对于由延迟引发的卡顿，逻辑不平滑，但可以在逻辑值之间进行插值，让表现平滑。逻辑空间严格按照帧同步的要求进行计算，表现空间获得逻辑计算的结果进行显示，并利用插值来平滑显示效果</p>\n<p>how？</p>\n<p>将一个游戏对象类拆分为两个类，分别为逻辑类和表现类</p>\n<p>逻辑类严格按照帧同步的要求进行计算（比如碰撞啊技能释放啊都是在这里，<u>不能用浮点数</u>），表现类就是<code>gameObject</code>的位置啊、动画等信息。逻辑对象和表现对象都有自己的ID，然后各自持有对方的引用，表现层就可以通过引用来获取逻辑层的计算结果</p>\n<h3 id=\"1-3-安全性（外挂）\"><a href=\"#1-3-安全性（外挂）\" class=\"headerlink\" title=\"1.3 安全性（外挂）\"></a>1.3 安全性（外挂）</h3><p>帧同步的逻辑计算是放在客户端的，所以客户端一旦被破解，就可以很容易地获得数据，开发外挂</p>\n<h3 id=\"1-4-避免使用浮点数\"><a href=\"#1-4-避免使用浮点数\" class=\"headerlink\" title=\"1.4 避免使用浮点数\"></a>1.4 避免使用浮点数</h3><p>帧同步技术的难点之一就是需要客户端计算结果的一致性。其中浮点数的运算在一些情况下是会产生不同的结果，所以实现帧同步要避免使用浮点数</p>\n<h3 id=\"1-5-使用UDP\"><a href=\"#1-5-使用UDP\" class=\"headerlink\" title=\"1.5 使用UDP\"></a>1.5 使用UDP</h3><p>在UDP之上实现了可靠性，增加序号和确认机制</p>\n<ol>\n<li>为每个数据包增加序列号，每发一次，增加本地序号</li>\n<li>每次收到包，把收到的包上序列号变为确认字符，发送包的时候带上这些确认字符</li>\n</ol>\n<h2 id=\"2-状态同步\"><a href=\"#2-状态同步\" class=\"headerlink\" title=\"2. 状态同步\"></a>2. 状态同步</h2><p>一个客户端发出操作指令给服务器，<u>服务器计算出结果</u>，更新状态，再将游戏中的所有<u>状态广播</u>给其他客户端</p>\n<blockquote>\n<p>逻辑计算在服务端，逻辑计算包括普攻、属性、移动、AI、碰撞、技能逻辑</p>\n</blockquote>\n<ul>\n<li>安全性高</li>\n<li>断线重连容易，服务器再传一次数据就行了</li>\n</ul>\n<p>为什么不能用浮点数（float）？因为要保证计算结果一致</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/105390563\">https://zhuanlan.zhihu.com/p/105390563</a></p>\n<p><a href=\"https://jonyzhao.gitbooks.io/gamedev/content/Network/FrameLockStepSync.html\">https://jonyzhao.gitbooks.io/gamedev/content/Network/FrameLockStepSync.html</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/36884005\">https://zhuanlan.zhihu.com/p/36884005</a></p>\n<p><a href=\"https://www.zhihu.com/question/323505671\">https://www.zhihu.com/question/323505671</a></p>\n<p><a href=\"https://www.youxituoluo.com/528021.html\">https://www.youxituoluo.com/528021.html</a></p>\n<p><a href=\"http://codebear.fun/index.php/2020/04/02/548.html\">http://codebear.fun/index.php/2020/04/02/548.html</a></p>\n<p><a href=\"https://www.jianshu.com/p/8cca5458c45b\">https://www.jianshu.com/p/8cca5458c45b</a></p>\n<p><a href=\"http://bindog.github.io/blog/2015/03/10/synchronization-in-multiplayer-networked-game-lockstep/\">http://bindog.github.io/blog/2015/03/10/synchronization-in-multiplayer-networked-game-lockstep/</a></p>\n"},{"_content":"堆排序\n\n#### 1.1 堆\n\n堆可以看成一个近似的完全二叉树，除了最底层外，该树是完全充满的。给定一个结点的下标 $i$，容易计算出它的父节点的下标为$\\lfloor i/2\\rfloor$，左右孩子结点的下标分别为：$2i$，$2i+1$\n\n![image-20220506152914663](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220506152914663.png)\n\n可以看出，下标为 $\\lfloor n/2\\rfloor+1$，$\\lfloor n/2\\rfloor+2$，$\\dots$，$n$ 的结点都是叶子结点\n\n#### 1.2 MAX-HEAPIFY\n\n`max-heapify`用来维护最大堆性质，对于堆中的`i`结点，它有可能违反了堆的性质，比如下图中`i=2`的结点，它的值小于其左右孩子结点的值，违反了大顶堆的性质。调整方法为，在`2`结点和它的左右孩子结点，即`4`、`5`结点，比较三者的值，得出一个最大值，并将最大值交换到三者的顶部（最大值不是`i`的话才需要交换），这个过程的复杂度视为常数级别`O(1)`。问题是，这样做完了一次交换之后，这三个元素已经满足大顶堆的性质了没错，但整体的堆性质还有可能不满足，比如交换后的结点的值仍小于其左结点或右结点，这就需要再调用一次`max-heapify`，如此递归下去，所以维护堆性质算法的时间复杂度为`O(log n)`，即与堆的高度有关。\n\n![image-20220506153855037](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220506153855037.png)\n\n#### 1.3 BUILD-MAX-HEAP\n\n建堆，时间复杂度为`O(n)`，利用`max-heapify`，从最后一个非叶子结点开始，进行自底向上调整建堆。\n\n> 为什么要从最后一个非叶子结点开始？因为叶子结点已经可以视为满足性质的堆了\n\n伪代码：\n\n```cpp\nBUILD-MAX-HEAP(A)\nFOR i = lower_bound(n/2) DOWNTO 1\n    MAX-HEAPIFY(i)\n```\n\n因为下标为 $\\lfloor n/2\\rfloor+1$，$\\lfloor n/2\\rfloor+2$，$\\dots$，$n$ 的结点都是叶子结点，所以从最后一个非叶子结点开始，对每个下标范围为 $\\lfloor n/2\\rfloor\\rightarrow1$ 的结点都调用一次`MAX-HEAPIFY`，每次调用MAX-HEAPIFY的时间复杂度是`O(lg n)`，BUILD-MAX-HEAP需要O(n)次这样的调用，因此总的时间复杂度为`O(n lg n)`，但这个上界不是渐进紧确的，考虑到不同结点运行MAX-HEAPIFY的时间与该结点的树高相关，而且大部分结点的高度都很小，因此更加紧确的时间复杂度是`O(n)`\n\n> 得出`O(n)`的过程参考算法导论P88，初看时，其中的一些性质我是没有看懂的","source":"_posts/数据结构与算法、/排序/堆排序.md","raw":"堆排序\n\n#### 1.1 堆\n\n堆可以看成一个近似的完全二叉树，除了最底层外，该树是完全充满的。给定一个结点的下标 $i$，容易计算出它的父节点的下标为$\\lfloor i/2\\rfloor$，左右孩子结点的下标分别为：$2i$，$2i+1$\n\n![image-20220506152914663](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220506152914663.png)\n\n可以看出，下标为 $\\lfloor n/2\\rfloor+1$，$\\lfloor n/2\\rfloor+2$，$\\dots$，$n$ 的结点都是叶子结点\n\n#### 1.2 MAX-HEAPIFY\n\n`max-heapify`用来维护最大堆性质，对于堆中的`i`结点，它有可能违反了堆的性质，比如下图中`i=2`的结点，它的值小于其左右孩子结点的值，违反了大顶堆的性质。调整方法为，在`2`结点和它的左右孩子结点，即`4`、`5`结点，比较三者的值，得出一个最大值，并将最大值交换到三者的顶部（最大值不是`i`的话才需要交换），这个过程的复杂度视为常数级别`O(1)`。问题是，这样做完了一次交换之后，这三个元素已经满足大顶堆的性质了没错，但整体的堆性质还有可能不满足，比如交换后的结点的值仍小于其左结点或右结点，这就需要再调用一次`max-heapify`，如此递归下去，所以维护堆性质算法的时间复杂度为`O(log n)`，即与堆的高度有关。\n\n![image-20220506153855037](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220506153855037.png)\n\n#### 1.3 BUILD-MAX-HEAP\n\n建堆，时间复杂度为`O(n)`，利用`max-heapify`，从最后一个非叶子结点开始，进行自底向上调整建堆。\n\n> 为什么要从最后一个非叶子结点开始？因为叶子结点已经可以视为满足性质的堆了\n\n伪代码：\n\n```cpp\nBUILD-MAX-HEAP(A)\nFOR i = lower_bound(n/2) DOWNTO 1\n    MAX-HEAPIFY(i)\n```\n\n因为下标为 $\\lfloor n/2\\rfloor+1$，$\\lfloor n/2\\rfloor+2$，$\\dots$，$n$ 的结点都是叶子结点，所以从最后一个非叶子结点开始，对每个下标范围为 $\\lfloor n/2\\rfloor\\rightarrow1$ 的结点都调用一次`MAX-HEAPIFY`，每次调用MAX-HEAPIFY的时间复杂度是`O(lg n)`，BUILD-MAX-HEAP需要O(n)次这样的调用，因此总的时间复杂度为`O(n lg n)`，但这个上界不是渐进紧确的，考虑到不同结点运行MAX-HEAPIFY的时间与该结点的树高相关，而且大部分结点的高度都很小，因此更加紧确的时间复杂度是`O(n)`\n\n> 得出`O(n)`的过程参考算法导论P88，初看时，其中的一些性质我是没有看懂的","slug":"数据结构与算法、/排序/堆排序","published":1,"date":"2022-05-06T07:39:44.477Z","updated":"2022-05-06T10:54:42.828Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0kyd0023pcu31soeeg4n","content":"<p>堆排序</p>\n<h4 id=\"1-1-堆\"><a href=\"#1-1-堆\" class=\"headerlink\" title=\"1.1 堆\"></a>1.1 堆</h4><p>堆可以看成一个近似的完全二叉树，除了最底层外，该树是完全充满的。给定一个结点的下标 $i$，容易计算出它的父节点的下标为$\\lfloor i/2\\rfloor$，左右孩子结点的下标分别为：$2i$，$2i+1$</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220506152914663.png\" alt=\"image-20220506152914663\"></p>\n<p>可以看出，下标为 $\\lfloor n/2\\rfloor+1$，$\\lfloor n/2\\rfloor+2$，$\\dots$，$n$ 的结点都是叶子结点</p>\n<h4 id=\"1-2-MAX-HEAPIFY\"><a href=\"#1-2-MAX-HEAPIFY\" class=\"headerlink\" title=\"1.2 MAX-HEAPIFY\"></a>1.2 MAX-HEAPIFY</h4><p><code>max-heapify</code>用来维护最大堆性质，对于堆中的<code>i</code>结点，它有可能违反了堆的性质，比如下图中<code>i=2</code>的结点，它的值小于其左右孩子结点的值，违反了大顶堆的性质。调整方法为，在<code>2</code>结点和它的左右孩子结点，即<code>4</code>、<code>5</code>结点，比较三者的值，得出一个最大值，并将最大值交换到三者的顶部（最大值不是<code>i</code>的话才需要交换），这个过程的复杂度视为常数级别<code>O(1)</code>。问题是，这样做完了一次交换之后，这三个元素已经满足大顶堆的性质了没错，但整体的堆性质还有可能不满足，比如交换后的结点的值仍小于其左结点或右结点，这就需要再调用一次<code>max-heapify</code>，如此递归下去，所以维护堆性质算法的时间复杂度为<code>O(log n)</code>，即与堆的高度有关。</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220506153855037.png\" alt=\"image-20220506153855037\"></p>\n<h4 id=\"1-3-BUILD-MAX-HEAP\"><a href=\"#1-3-BUILD-MAX-HEAP\" class=\"headerlink\" title=\"1.3 BUILD-MAX-HEAP\"></a>1.3 BUILD-MAX-HEAP</h4><p>建堆，时间复杂度为<code>O(n)</code>，利用<code>max-heapify</code>，从最后一个非叶子结点开始，进行自底向上调整建堆。</p>\n<blockquote>\n<p>为什么要从最后一个非叶子结点开始？因为叶子结点已经可以视为满足性质的堆了</p>\n</blockquote>\n<p>伪代码：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BUILD-MAX-<span class=\"built_in\">HEAP</span>(A)</span><br><span class=\"line\">FOR i = <span class=\"built_in\">lower_bound</span>(n/<span class=\"number\">2</span>) DOWNTO <span class=\"number\">1</span></span><br><span class=\"line\">    MAX-<span class=\"built_in\">HEAPIFY</span>(i)</span><br></pre></td></tr></table></figure>\n\n<p>因为下标为 $\\lfloor n/2\\rfloor+1$，$\\lfloor n/2\\rfloor+2$，$\\dots$，$n$ 的结点都是叶子结点，所以从最后一个非叶子结点开始，对每个下标范围为 $\\lfloor n/2\\rfloor\\rightarrow1$ 的结点都调用一次<code>MAX-HEAPIFY</code>，每次调用MAX-HEAPIFY的时间复杂度是<code>O(lg n)</code>，BUILD-MAX-HEAP需要O(n)次这样的调用，因此总的时间复杂度为<code>O(n lg n)</code>，但这个上界不是渐进紧确的，考虑到不同结点运行MAX-HEAPIFY的时间与该结点的树高相关，而且大部分结点的高度都很小，因此更加紧确的时间复杂度是<code>O(n)</code></p>\n<blockquote>\n<p>得出<code>O(n)</code>的过程参考算法导论P88，初看时，其中的一些性质我是没有看懂的</p>\n</blockquote>\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<p>堆排序</p>\n<h4 id=\"1-1-堆\"><a href=\"#1-1-堆\" class=\"headerlink\" title=\"1.1 堆\"></a>1.1 堆</h4><p>堆可以看成一个近似的完全二叉树，除了最底层外，该树是完全充满的。给定一个结点的下标 $i$，容易计算出它的父节点的下标为$\\lfloor i/2\\rfloor$，左右孩子结点的下标分别为：$2i$，$2i+1$</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220506152914663.png\" alt=\"image-20220506152914663\"></p>\n<p>可以看出，下标为 $\\lfloor n/2\\rfloor+1$，$\\lfloor n/2\\rfloor+2$，$\\dots$，$n$ 的结点都是叶子结点</p>\n<h4 id=\"1-2-MAX-HEAPIFY\"><a href=\"#1-2-MAX-HEAPIFY\" class=\"headerlink\" title=\"1.2 MAX-HEAPIFY\"></a>1.2 MAX-HEAPIFY</h4><p><code>max-heapify</code>用来维护最大堆性质，对于堆中的<code>i</code>结点，它有可能违反了堆的性质，比如下图中<code>i=2</code>的结点，它的值小于其左右孩子结点的值，违反了大顶堆的性质。调整方法为，在<code>2</code>结点和它的左右孩子结点，即<code>4</code>、<code>5</code>结点，比较三者的值，得出一个最大值，并将最大值交换到三者的顶部（最大值不是<code>i</code>的话才需要交换），这个过程的复杂度视为常数级别<code>O(1)</code>。问题是，这样做完了一次交换之后，这三个元素已经满足大顶堆的性质了没错，但整体的堆性质还有可能不满足，比如交换后的结点的值仍小于其左结点或右结点，这就需要再调用一次<code>max-heapify</code>，如此递归下去，所以维护堆性质算法的时间复杂度为<code>O(log n)</code>，即与堆的高度有关。</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220506153855037.png\" alt=\"image-20220506153855037\"></p>\n<h4 id=\"1-3-BUILD-MAX-HEAP\"><a href=\"#1-3-BUILD-MAX-HEAP\" class=\"headerlink\" title=\"1.3 BUILD-MAX-HEAP\"></a>1.3 BUILD-MAX-HEAP</h4><p>建堆，时间复杂度为<code>O(n)</code>，利用<code>max-heapify</code>，从最后一个非叶子结点开始，进行自底向上调整建堆。</p>\n<blockquote>\n<p>为什么要从最后一个非叶子结点开始？因为叶子结点已经可以视为满足性质的堆了</p>\n</blockquote>\n<p>伪代码：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BUILD-MAX-<span class=\"built_in\">HEAP</span>(A)</span><br><span class=\"line\">FOR i = <span class=\"built_in\">lower_bound</span>(n/<span class=\"number\">2</span>) DOWNTO <span class=\"number\">1</span></span><br><span class=\"line\">    MAX-<span class=\"built_in\">HEAPIFY</span>(i)</span><br></pre></td></tr></table></figure>\n\n<p>因为下标为 $\\lfloor n/2\\rfloor+1$，$\\lfloor n/2\\rfloor+2$，$\\dots$，$n$ 的结点都是叶子结点，所以从最后一个非叶子结点开始，对每个下标范围为 $\\lfloor n/2\\rfloor\\rightarrow1$ 的结点都调用一次<code>MAX-HEAPIFY</code>，每次调用MAX-HEAPIFY的时间复杂度是<code>O(lg n)</code>，BUILD-MAX-HEAP需要O(n)次这样的调用，因此总的时间复杂度为<code>O(n lg n)</code>，但这个上界不是渐进紧确的，考虑到不同结点运行MAX-HEAPIFY的时间与该结点的树高相关，而且大部分结点的高度都很小，因此更加紧确的时间复杂度是<code>O(n)</code></p>\n<blockquote>\n<p>得出<code>O(n)</code>的过程参考算法导论P88，初看时，其中的一些性质我是没有看懂的</p>\n</blockquote>\n"},{"title":"快速排序","date":"2022-01-11T13:36:53.000Z","_content":"\n#### 1、代码示例\n\n选取第一个元素为枢纽：\n\n```cpp\nvoid swap(vector<int>& arr, int i, int j) {\n    int temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n}\n\nint Partition(vector<int>& arr, int low, int high) {\n    int pivot_key = arr[low];\n    while (low < high) {  // 当low==high时，arr[high]肯定等于arr[low]，即pivot_key，high一定--，然后low就大于high了，此时一定得退出循环，所以low==high和low>high都得退出循环，所以while的表达式中没有等号\n        while (low < high && arr[high] >= pivot_key //>= ，多个相同数字在一起符合有序情况，应该跳过所有相同数字\n            high--;\n        swap(arr, low, high);\n        while (low < high && arr[low] <= pivot_key)\n            low++;\n        swap(arr, low, high);\n    }\n    return low;  // 返回枢纽位置\n}\n\nvoid QSort(vector<int>& arr, int low, int high) {\n    int pivot;\n    if (low < high) {\n        pivot = Partition(arr, low, high); //一次排序结果\n\n        //递归\n        QSort(arr, low, pivot - 1);\n        QSort(arr, pivot + 1, high);\n\n    }\n}\n```\n\n#### 2、快排时间复杂度分析：\n\n##### 2.1 **最优**情况下：\n\n每次 Partition 都是一分为二，如果排序 n 个关键字，其递归树深度（应该是完全二叉树）就为：$\\lfloor \\log_2n\\rfloor+n$，仅需递归 $\\log_2n$ 次\n\n而每次扫描一遍，把枢纽值放在正确的位置上，将数组一分为二，需要的时间为 $T(n)$\n$$\nT(1)=0\\\\\n\\\\\nT(n)&=&2T(n/2)+n\\\\\n&=&2(2T(n/4)+n/2)+n=4T(n/4)+2n\\\\\n&=&4(2T(n/8)+n/4)+2n=8T(n/8)+3n\\\\\n&=&...\\\\\n&=&nT(1)+(\\log_2n)*n=O(nlogn)\n$$\n\n##### 2.2 最坏情况下：\n\n待排序的序列为正序或逆序，每次划分只得到一个比上一次划分少一个记录的子序列，另一半为空\n\n递归树为一颗斜树，需要 n-1 次递归调用\n\n且第 i 次划分需要经过 n-i 次关键字的比较，总比较次数为\n$$\n\\sum\\limits_{i=1}^{n-1}(n-i)=\\frac{n(n-1)}{2}\n$$\n所以最坏情况下的时间复杂度为：$O(n^2)$\n\n> 不用再纠结<u>递归次数</u>，因为算<u>比较次数</u>的时候，已经把<u>递归次数</u>考虑进去了，算了 n-1 次<u>比较次数</u>（求和函数是从 1 到 n-1），也就是每次递归计算<u>比较次数</u>\n\n##### 2.3平均情况下\n\n也是$O(n\\log n)$，原因先挖坑以后再解释【坑】（https://blog.csdn.net/weshjiness/article/details/8660583）\n\n#### 3、快排空间复杂度分析：\n\n主要是递归造成的栈空间的使用\n\n最好、平均情况下，栈空间的使用为 $\\log_2n$，其空间复杂度为 $O(logn)$\n\n最坏情况下：需要进行 n-1 次递归，空间复杂度为 $O(n)$\n\n#### 4、快排稳定性\n\n由于关键字的比较和交换是跳跃进行的，所以快排是**不稳定**的\n\n#### 5. 题目\n\nhttps://www.nowcoder.com/questionTerminal/69fc9122a0a74b5f8e011c4f53419dd3\n","source":"_posts/数据结构与算法、/排序/快速排序.md","raw":"---\ntitle: 快速排序\ndate: 2022-01-11 21:36:53\ncategories: [\"数据结构与算法\"]\n---\n\n#### 1、代码示例\n\n选取第一个元素为枢纽：\n\n```cpp\nvoid swap(vector<int>& arr, int i, int j) {\n    int temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n}\n\nint Partition(vector<int>& arr, int low, int high) {\n    int pivot_key = arr[low];\n    while (low < high) {  // 当low==high时，arr[high]肯定等于arr[low]，即pivot_key，high一定--，然后low就大于high了，此时一定得退出循环，所以low==high和low>high都得退出循环，所以while的表达式中没有等号\n        while (low < high && arr[high] >= pivot_key //>= ，多个相同数字在一起符合有序情况，应该跳过所有相同数字\n            high--;\n        swap(arr, low, high);\n        while (low < high && arr[low] <= pivot_key)\n            low++;\n        swap(arr, low, high);\n    }\n    return low;  // 返回枢纽位置\n}\n\nvoid QSort(vector<int>& arr, int low, int high) {\n    int pivot;\n    if (low < high) {\n        pivot = Partition(arr, low, high); //一次排序结果\n\n        //递归\n        QSort(arr, low, pivot - 1);\n        QSort(arr, pivot + 1, high);\n\n    }\n}\n```\n\n#### 2、快排时间复杂度分析：\n\n##### 2.1 **最优**情况下：\n\n每次 Partition 都是一分为二，如果排序 n 个关键字，其递归树深度（应该是完全二叉树）就为：$\\lfloor \\log_2n\\rfloor+n$，仅需递归 $\\log_2n$ 次\n\n而每次扫描一遍，把枢纽值放在正确的位置上，将数组一分为二，需要的时间为 $T(n)$\n$$\nT(1)=0\\\\\n\\\\\nT(n)&=&2T(n/2)+n\\\\\n&=&2(2T(n/4)+n/2)+n=4T(n/4)+2n\\\\\n&=&4(2T(n/8)+n/4)+2n=8T(n/8)+3n\\\\\n&=&...\\\\\n&=&nT(1)+(\\log_2n)*n=O(nlogn)\n$$\n\n##### 2.2 最坏情况下：\n\n待排序的序列为正序或逆序，每次划分只得到一个比上一次划分少一个记录的子序列，另一半为空\n\n递归树为一颗斜树，需要 n-1 次递归调用\n\n且第 i 次划分需要经过 n-i 次关键字的比较，总比较次数为\n$$\n\\sum\\limits_{i=1}^{n-1}(n-i)=\\frac{n(n-1)}{2}\n$$\n所以最坏情况下的时间复杂度为：$O(n^2)$\n\n> 不用再纠结<u>递归次数</u>，因为算<u>比较次数</u>的时候，已经把<u>递归次数</u>考虑进去了，算了 n-1 次<u>比较次数</u>（求和函数是从 1 到 n-1），也就是每次递归计算<u>比较次数</u>\n\n##### 2.3平均情况下\n\n也是$O(n\\log n)$，原因先挖坑以后再解释【坑】（https://blog.csdn.net/weshjiness/article/details/8660583）\n\n#### 3、快排空间复杂度分析：\n\n主要是递归造成的栈空间的使用\n\n最好、平均情况下，栈空间的使用为 $\\log_2n$，其空间复杂度为 $O(logn)$\n\n最坏情况下：需要进行 n-1 次递归，空间复杂度为 $O(n)$\n\n#### 4、快排稳定性\n\n由于关键字的比较和交换是跳跃进行的，所以快排是**不稳定**的\n\n#### 5. 题目\n\nhttps://www.nowcoder.com/questionTerminal/69fc9122a0a74b5f8e011c4f53419dd3\n","slug":"数据结构与算法、/排序/快速排序","published":1,"updated":"2022-05-05T06:44:00.273Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0kye0024pcu39c9ealj7","content":"<h4 id=\"1、代码示例\"><a href=\"#1、代码示例\" class=\"headerlink\" title=\"1、代码示例\"></a>1、代码示例</h4><p>选取第一个元素为枢纽：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; arr, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> temp = arr[i];</span><br><span class=\"line\">    arr[i] = arr[j];</span><br><span class=\"line\">    arr[j] = temp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Partition</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; arr, <span class=\"keyword\">int</span> low, <span class=\"keyword\">int</span> high)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> pivot_key = arr[low];</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (low &lt; high) &#123;  <span class=\"comment\">// 当low==high时，arr[high]肯定等于arr[low]，即pivot_key，high一定--，然后low就大于high了，此时一定得退出循环，所以low==high和low&gt;high都得退出循环，所以while的表达式中没有等号</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (low &lt; high &amp;&amp; arr[high] &gt;= pivot_key <span class=\"comment\">//&gt;= ，多个相同数字在一起符合有序情况，应该跳过所有相同数字</span></span><br><span class=\"line\">            high--;</span><br><span class=\"line\">        <span class=\"built_in\">swap</span>(arr, low, high);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (low &lt; high &amp;&amp; arr[low] &lt;= pivot_key)</span><br><span class=\"line\">            low++;</span><br><span class=\"line\">        <span class=\"built_in\">swap</span>(arr, low, high);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> low;  <span class=\"comment\">// 返回枢纽位置</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"built_in\">QSort</span>(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; arr, <span class=\"keyword\">int</span> low, <span class=\"keyword\">int</span> high) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> pivot;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (low &lt; high) &#123;</span><br><span class=\"line\">        pivot = <span class=\"built_in\">Partition</span>(arr, low, high); <span class=\"comment\">//一次排序结果</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//递归</span></span><br><span class=\"line\">        <span class=\"built_in\">QSort</span>(arr, low, pivot - <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"built_in\">QSort</span>(arr, pivot + <span class=\"number\">1</span>, high);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2、快排时间复杂度分析：\"><a href=\"#2、快排时间复杂度分析：\" class=\"headerlink\" title=\"2、快排时间复杂度分析：\"></a>2、快排时间复杂度分析：</h4><h5 id=\"2-1-最优情况下：\"><a href=\"#2-1-最优情况下：\" class=\"headerlink\" title=\"2.1 最优情况下：\"></a>2.1 <strong>最优</strong>情况下：</h5><p>每次 Partition 都是一分为二，如果排序 n 个关键字，其递归树深度（应该是完全二叉树）就为：$\\lfloor \\log_2n\\rfloor+n$，仅需递归 $\\log_2n$ 次</p>\n<p>而每次扫描一遍，把枢纽值放在正确的位置上，将数组一分为二，需要的时间为 $T(n)$<br>$$<br>T(1)=0\\<br>\\<br>T(n)&amp;=&amp;2T(n/2)+n\\<br>&amp;=&amp;2(2T(n/4)+n/2)+n=4T(n/4)+2n\\<br>&amp;=&amp;4(2T(n/8)+n/4)+2n=8T(n/8)+3n\\<br>&amp;=&amp;…\\<br>&amp;=&amp;nT(1)+(\\log_2n)*n=O(nlogn)<br>$$</p>\n<h5 id=\"2-2-最坏情况下：\"><a href=\"#2-2-最坏情况下：\" class=\"headerlink\" title=\"2.2 最坏情况下：\"></a>2.2 最坏情况下：</h5><p>待排序的序列为正序或逆序，每次划分只得到一个比上一次划分少一个记录的子序列，另一半为空</p>\n<p>递归树为一颗斜树，需要 n-1 次递归调用</p>\n<p>且第 i 次划分需要经过 n-i 次关键字的比较，总比较次数为<br>$$<br>\\sum\\limits_{i=1}^{n-1}(n-i)=\\frac{n(n-1)}{2}<br>$$<br>所以最坏情况下的时间复杂度为：$O(n^2)$</p>\n<blockquote>\n<p>不用再纠结<u>递归次数</u>，因为算<u>比较次数</u>的时候，已经把<u>递归次数</u>考虑进去了，算了 n-1 次<u>比较次数</u>（求和函数是从 1 到 n-1），也就是每次递归计算<u>比较次数</u></p>\n</blockquote>\n<h5 id=\"2-3平均情况下\"><a href=\"#2-3平均情况下\" class=\"headerlink\" title=\"2.3平均情况下\"></a>2.3平均情况下</h5><p>也是$O(n\\log n)$，原因先挖坑以后再解释【坑】（<a href=\"https://blog.csdn.net/weshjiness/article/details/8660583%EF%BC%89\">https://blog.csdn.net/weshjiness/article/details/8660583）</a></p>\n<h4 id=\"3、快排空间复杂度分析：\"><a href=\"#3、快排空间复杂度分析：\" class=\"headerlink\" title=\"3、快排空间复杂度分析：\"></a>3、快排空间复杂度分析：</h4><p>主要是递归造成的栈空间的使用</p>\n<p>最好、平均情况下，栈空间的使用为 $\\log_2n$，其空间复杂度为 $O(logn)$</p>\n<p>最坏情况下：需要进行 n-1 次递归，空间复杂度为 $O(n)$</p>\n<h4 id=\"4、快排稳定性\"><a href=\"#4、快排稳定性\" class=\"headerlink\" title=\"4、快排稳定性\"></a>4、快排稳定性</h4><p>由于关键字的比较和交换是跳跃进行的，所以快排是<strong>不稳定</strong>的</p>\n<h4 id=\"5-题目\"><a href=\"#5-题目\" class=\"headerlink\" title=\"5. 题目\"></a>5. 题目</h4><p><a href=\"https://www.nowcoder.com/questionTerminal/69fc9122a0a74b5f8e011c4f53419dd3\">https://www.nowcoder.com/questionTerminal/69fc9122a0a74b5f8e011c4f53419dd3</a></p>\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<h4 id=\"1、代码示例\"><a href=\"#1、代码示例\" class=\"headerlink\" title=\"1、代码示例\"></a>1、代码示例</h4><p>选取第一个元素为枢纽：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; arr, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> temp = arr[i];</span><br><span class=\"line\">    arr[i] = arr[j];</span><br><span class=\"line\">    arr[j] = temp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Partition</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; arr, <span class=\"keyword\">int</span> low, <span class=\"keyword\">int</span> high)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> pivot_key = arr[low];</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (low &lt; high) &#123;  <span class=\"comment\">// 当low==high时，arr[high]肯定等于arr[low]，即pivot_key，high一定--，然后low就大于high了，此时一定得退出循环，所以low==high和low&gt;high都得退出循环，所以while的表达式中没有等号</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (low &lt; high &amp;&amp; arr[high] &gt;= pivot_key <span class=\"comment\">//&gt;= ，多个相同数字在一起符合有序情况，应该跳过所有相同数字</span></span><br><span class=\"line\">            high--;</span><br><span class=\"line\">        <span class=\"built_in\">swap</span>(arr, low, high);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (low &lt; high &amp;&amp; arr[low] &lt;= pivot_key)</span><br><span class=\"line\">            low++;</span><br><span class=\"line\">        <span class=\"built_in\">swap</span>(arr, low, high);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> low;  <span class=\"comment\">// 返回枢纽位置</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"built_in\">QSort</span>(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; arr, <span class=\"keyword\">int</span> low, <span class=\"keyword\">int</span> high) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> pivot;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (low &lt; high) &#123;</span><br><span class=\"line\">        pivot = <span class=\"built_in\">Partition</span>(arr, low, high); <span class=\"comment\">//一次排序结果</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//递归</span></span><br><span class=\"line\">        <span class=\"built_in\">QSort</span>(arr, low, pivot - <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"built_in\">QSort</span>(arr, pivot + <span class=\"number\">1</span>, high);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2、快排时间复杂度分析：\"><a href=\"#2、快排时间复杂度分析：\" class=\"headerlink\" title=\"2、快排时间复杂度分析：\"></a>2、快排时间复杂度分析：</h4><h5 id=\"2-1-最优情况下：\"><a href=\"#2-1-最优情况下：\" class=\"headerlink\" title=\"2.1 最优情况下：\"></a>2.1 <strong>最优</strong>情况下：</h5><p>每次 Partition 都是一分为二，如果排序 n 个关键字，其递归树深度（应该是完全二叉树）就为：$\\lfloor \\log_2n\\rfloor+n$，仅需递归 $\\log_2n$ 次</p>\n<p>而每次扫描一遍，把枢纽值放在正确的位置上，将数组一分为二，需要的时间为 $T(n)$<br>$$<br>T(1)=0\\<br>\\<br>T(n)&amp;=&amp;2T(n/2)+n\\<br>&amp;=&amp;2(2T(n/4)+n/2)+n=4T(n/4)+2n\\<br>&amp;=&amp;4(2T(n/8)+n/4)+2n=8T(n/8)+3n\\<br>&amp;=&amp;…\\<br>&amp;=&amp;nT(1)+(\\log_2n)*n=O(nlogn)<br>$$</p>\n<h5 id=\"2-2-最坏情况下：\"><a href=\"#2-2-最坏情况下：\" class=\"headerlink\" title=\"2.2 最坏情况下：\"></a>2.2 最坏情况下：</h5><p>待排序的序列为正序或逆序，每次划分只得到一个比上一次划分少一个记录的子序列，另一半为空</p>\n<p>递归树为一颗斜树，需要 n-1 次递归调用</p>\n<p>且第 i 次划分需要经过 n-i 次关键字的比较，总比较次数为<br>$$<br>\\sum\\limits_{i=1}^{n-1}(n-i)=\\frac{n(n-1)}{2}<br>$$<br>所以最坏情况下的时间复杂度为：$O(n^2)$</p>\n<blockquote>\n<p>不用再纠结<u>递归次数</u>，因为算<u>比较次数</u>的时候，已经把<u>递归次数</u>考虑进去了，算了 n-1 次<u>比较次数</u>（求和函数是从 1 到 n-1），也就是每次递归计算<u>比较次数</u></p>\n</blockquote>\n<h5 id=\"2-3平均情况下\"><a href=\"#2-3平均情况下\" class=\"headerlink\" title=\"2.3平均情况下\"></a>2.3平均情况下</h5><p>也是$O(n\\log n)$，原因先挖坑以后再解释【坑】（<a href=\"https://blog.csdn.net/weshjiness/article/details/8660583%EF%BC%89\">https://blog.csdn.net/weshjiness/article/details/8660583）</a></p>\n<h4 id=\"3、快排空间复杂度分析：\"><a href=\"#3、快排空间复杂度分析：\" class=\"headerlink\" title=\"3、快排空间复杂度分析：\"></a>3、快排空间复杂度分析：</h4><p>主要是递归造成的栈空间的使用</p>\n<p>最好、平均情况下，栈空间的使用为 $\\log_2n$，其空间复杂度为 $O(logn)$</p>\n<p>最坏情况下：需要进行 n-1 次递归，空间复杂度为 $O(n)$</p>\n<h4 id=\"4、快排稳定性\"><a href=\"#4、快排稳定性\" class=\"headerlink\" title=\"4、快排稳定性\"></a>4、快排稳定性</h4><p>由于关键字的比较和交换是跳跃进行的，所以快排是<strong>不稳定</strong>的</p>\n<h4 id=\"5-题目\"><a href=\"#5-题目\" class=\"headerlink\" title=\"5. 题目\"></a>5. 题目</h4><p><a href=\"https://www.nowcoder.com/questionTerminal/69fc9122a0a74b5f8e011c4f53419dd3\">https://www.nowcoder.com/questionTerminal/69fc9122a0a74b5f8e011c4f53419dd3</a></p>\n"},{"title":"主语从句","date":"2022-01-04T09:02:03.000Z","_content":"\n## 1. 三种类型的主语从句\n\n###### (1) 由 `that` 引导的主语从句\n\n​\t<u>That</u> he hasn't arrived is odd.\n\n​\tIt's certain <u>that</u> prices will go up.\n\n###### (2) 由<u>连接代（副）词</u>引导的主语从句\n\n<u>\tWhy</u> he left wasn't Important.\n\n<u>\tIt</u> was uncertain <u>whether</u> he would come or not.\n\n###### (3) 由关系代词型和 <u>what</u> 和 <u>whatever</u> 引导的从句：\n\n<u>\tWhat I want</u> is a canvas travelling bag.\n\n<u>\tWhatever she did</u> was right.\n\n## 2. 由 that 引导的主语从句\n\n一般都用 `it` 作形式主语\n\n###### a. it + be + 形容词 + that 从句\n\n<u>It</u> is natural <u>that</u> they should have different views.\n\n<u>It</u> was quite plain <u>that</u> she didn't want to come.\n\n###### b. it + be + 名词 + that 从句\n\n<u>It's</u> a pity (<u>that</u>) he can't swim.\n\n###### c. it + 动词 + （宾、状） + that\n\n<u>It happened that</u> she wasn't in that day. ( happen 这里不及物，碰巧那天她不在家 )\n\n<u>It</u> never occurred to me <u>that</u> perhaps she was lying.\n\n<u>It</u> seems <u>that</u> you are right.\n\n<u>It</u> struck me <u>that</u> we ought to make a new plan.\n\n###### d. it + 动词的被动语态 + that 从句\n\n<u>It</u> was rumoured <u>that</u> he was suffering from a stone in the kidney.\n\n<u>It</u> is estimated <u>that</u> 25 million school lunches are sold each day.  \n\n###### 在口语中 `that` 有时可以省略\n\nIt was clear his words pleased her.\n\nIt strikes me Kent is a nice lad.\n\n## 3. 由连接代（副）词引导的主语从句\n\n可放句首，不用 it：\n\n<u>When he'll be back</u> depends much on the weather.\n\n<u>How it was done</u> was a mystery.\n\n<u>Who is to be sent there</u> hasn't been decided. \n\n<u>Whether we'll succeed</u> remains to be seen.\n\n一般用 it 作形式主语\n\n###### a. it + be + 形容词 + 从句\n\n<u>It</u> was not clear to me <u>why</u> he behaved like that.\n\n<u>It's</u> uncertain <u>whether</u> the game will be held.\n\n<u>It</u> is amazing <u>that</u> he should have said nothing about the murder.\n\n###### b. it + be + 名词 + 从句\n\n<u>It's</u> a puzzle <u>how</u> life began.\n\n<u>It</u> was a question <u>whether</u> he should get married.\n\n###### c. it + 动词 （宾语、状语）+ 从句\n\n<u>It</u> doesn't matter much <u>where</u> we live.\n\n<u>It</u> struck her <u>how</u> considerate he was.\n\n###### d. it + 动词被动语态 + 从句\n\n<u>It</u> is not decided <u>who</u> will edit it.\n\n## 4. 由关系代词型 what 引导的主语从句\n\n<u>What is over</u> is over.\n\n<u>What you should do</u> is to choose a company to invest in.\n\n<u>Whoever wants to go</u> may sign up here.\n\n<u>Whichever you want</u> is yours.\n\n","source":"_posts/英语/名词性从句/主语从句.md","raw":"---\ntitle: 主语从句\ndate: 2022-01-04 17:02:03\ntags: [\"Grammar\"]\ncategories: [\"English\"]\n---\n\n## 1. 三种类型的主语从句\n\n###### (1) 由 `that` 引导的主语从句\n\n​\t<u>That</u> he hasn't arrived is odd.\n\n​\tIt's certain <u>that</u> prices will go up.\n\n###### (2) 由<u>连接代（副）词</u>引导的主语从句\n\n<u>\tWhy</u> he left wasn't Important.\n\n<u>\tIt</u> was uncertain <u>whether</u> he would come or not.\n\n###### (3) 由关系代词型和 <u>what</u> 和 <u>whatever</u> 引导的从句：\n\n<u>\tWhat I want</u> is a canvas travelling bag.\n\n<u>\tWhatever she did</u> was right.\n\n## 2. 由 that 引导的主语从句\n\n一般都用 `it` 作形式主语\n\n###### a. it + be + 形容词 + that 从句\n\n<u>It</u> is natural <u>that</u> they should have different views.\n\n<u>It</u> was quite plain <u>that</u> she didn't want to come.\n\n###### b. it + be + 名词 + that 从句\n\n<u>It's</u> a pity (<u>that</u>) he can't swim.\n\n###### c. it + 动词 + （宾、状） + that\n\n<u>It happened that</u> she wasn't in that day. ( happen 这里不及物，碰巧那天她不在家 )\n\n<u>It</u> never occurred to me <u>that</u> perhaps she was lying.\n\n<u>It</u> seems <u>that</u> you are right.\n\n<u>It</u> struck me <u>that</u> we ought to make a new plan.\n\n###### d. it + 动词的被动语态 + that 从句\n\n<u>It</u> was rumoured <u>that</u> he was suffering from a stone in the kidney.\n\n<u>It</u> is estimated <u>that</u> 25 million school lunches are sold each day.  \n\n###### 在口语中 `that` 有时可以省略\n\nIt was clear his words pleased her.\n\nIt strikes me Kent is a nice lad.\n\n## 3. 由连接代（副）词引导的主语从句\n\n可放句首，不用 it：\n\n<u>When he'll be back</u> depends much on the weather.\n\n<u>How it was done</u> was a mystery.\n\n<u>Who is to be sent there</u> hasn't been decided. \n\n<u>Whether we'll succeed</u> remains to be seen.\n\n一般用 it 作形式主语\n\n###### a. it + be + 形容词 + 从句\n\n<u>It</u> was not clear to me <u>why</u> he behaved like that.\n\n<u>It's</u> uncertain <u>whether</u> the game will be held.\n\n<u>It</u> is amazing <u>that</u> he should have said nothing about the murder.\n\n###### b. it + be + 名词 + 从句\n\n<u>It's</u> a puzzle <u>how</u> life began.\n\n<u>It</u> was a question <u>whether</u> he should get married.\n\n###### c. it + 动词 （宾语、状语）+ 从句\n\n<u>It</u> doesn't matter much <u>where</u> we live.\n\n<u>It</u> struck her <u>how</u> considerate he was.\n\n###### d. it + 动词被动语态 + 从句\n\n<u>It</u> is not decided <u>who</u> will edit it.\n\n## 4. 由关系代词型 what 引导的主语从句\n\n<u>What is over</u> is over.\n\n<u>What you should do</u> is to choose a company to invest in.\n\n<u>Whoever wants to go</u> may sign up here.\n\n<u>Whichever you want</u> is yours.\n\n","slug":"英语/名词性从句/主语从句","published":1,"updated":"2022-01-04T10:39:17.166Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0kye0025pcu3geaybyud","content":"<h2 id=\"1-三种类型的主语从句\"><a href=\"#1-三种类型的主语从句\" class=\"headerlink\" title=\"1. 三种类型的主语从句\"></a>1. 三种类型的主语从句</h2><h6 id=\"1-由-that-引导的主语从句\"><a href=\"#1-由-that-引导的主语从句\" class=\"headerlink\" title=\"(1) 由 that 引导的主语从句\"></a>(1) 由 <code>that</code> 引导的主语从句</h6><p>​    <u>That</u> he hasn’t arrived is odd.</p>\n<p>​    It’s certain <u>that</u> prices will go up.</p>\n<h6 id=\"2-由连接代（副）词引导的主语从句\"><a href=\"#2-由连接代（副）词引导的主语从句\" class=\"headerlink\" title=\"(2) 由连接代（副）词引导的主语从句\"></a>(2) 由<u>连接代（副）词</u>引导的主语从句</h6><p><u>    Why</u> he left wasn’t Important.</p>\n<p><u>    It</u> was uncertain <u>whether</u> he would come or not.</p>\n<h6 id=\"3-由关系代词型和-what-和-whatever-引导的从句：\"><a href=\"#3-由关系代词型和-what-和-whatever-引导的从句：\" class=\"headerlink\" title=\"(3) 由关系代词型和 what 和 whatever 引导的从句：\"></a>(3) 由关系代词型和 <u>what</u> 和 <u>whatever</u> 引导的从句：</h6><p><u>    What I want</u> is a canvas travelling bag.</p>\n<p><u>    Whatever she did</u> was right.</p>\n<h2 id=\"2-由-that-引导的主语从句\"><a href=\"#2-由-that-引导的主语从句\" class=\"headerlink\" title=\"2. 由 that 引导的主语从句\"></a>2. 由 that 引导的主语从句</h2><p>一般都用 <code>it</code> 作形式主语</p>\n<h6 id=\"a-it-be-形容词-that-从句\"><a href=\"#a-it-be-形容词-that-从句\" class=\"headerlink\" title=\"a. it + be + 形容词 + that 从句\"></a>a. it + be + 形容词 + that 从句</h6><p><u>It</u> is natural <u>that</u> they should have different views.</p>\n<p><u>It</u> was quite plain <u>that</u> she didn’t want to come.</p>\n<h6 id=\"b-it-be-名词-that-从句\"><a href=\"#b-it-be-名词-that-从句\" class=\"headerlink\" title=\"b. it + be + 名词 + that 从句\"></a>b. it + be + 名词 + that 从句</h6><p><u>It’s</u> a pity (<u>that</u>) he can’t swim.</p>\n<h6 id=\"c-it-动词-（宾、状）-that\"><a href=\"#c-it-动词-（宾、状）-that\" class=\"headerlink\" title=\"c. it + 动词 + （宾、状） + that\"></a>c. it + 动词 + （宾、状） + that</h6><p><u>It happened that</u> she wasn’t in that day. ( happen 这里不及物，碰巧那天她不在家 )</p>\n<p><u>It</u> never occurred to me <u>that</u> perhaps she was lying.</p>\n<p><u>It</u> seems <u>that</u> you are right.</p>\n<p><u>It</u> struck me <u>that</u> we ought to make a new plan.</p>\n<h6 id=\"d-it-动词的被动语态-that-从句\"><a href=\"#d-it-动词的被动语态-that-从句\" class=\"headerlink\" title=\"d. it + 动词的被动语态 + that 从句\"></a>d. it + 动词的被动语态 + that 从句</h6><p><u>It</u> was rumoured <u>that</u> he was suffering from a stone in the kidney.</p>\n<p><u>It</u> is estimated <u>that</u> 25 million school lunches are sold each day.  </p>\n<h6 id=\"在口语中-that-有时可以省略\"><a href=\"#在口语中-that-有时可以省略\" class=\"headerlink\" title=\"在口语中 that 有时可以省略\"></a>在口语中 <code>that</code> 有时可以省略</h6><p>It was clear his words pleased her.</p>\n<p>It strikes me Kent is a nice lad.</p>\n<h2 id=\"3-由连接代（副）词引导的主语从句\"><a href=\"#3-由连接代（副）词引导的主语从句\" class=\"headerlink\" title=\"3. 由连接代（副）词引导的主语从句\"></a>3. 由连接代（副）词引导的主语从句</h2><p>可放句首，不用 it：</p>\n<p><u>When he’ll be back</u> depends much on the weather.</p>\n<p><u>How it was done</u> was a mystery.</p>\n<p><u>Who is to be sent there</u> hasn’t been decided. </p>\n<p><u>Whether we’ll succeed</u> remains to be seen.</p>\n<p>一般用 it 作形式主语</p>\n<h6 id=\"a-it-be-形容词-从句\"><a href=\"#a-it-be-形容词-从句\" class=\"headerlink\" title=\"a. it + be + 形容词 + 从句\"></a>a. it + be + 形容词 + 从句</h6><p><u>It</u> was not clear to me <u>why</u> he behaved like that.</p>\n<p><u>It’s</u> uncertain <u>whether</u> the game will be held.</p>\n<p><u>It</u> is amazing <u>that</u> he should have said nothing about the murder.</p>\n<h6 id=\"b-it-be-名词-从句\"><a href=\"#b-it-be-名词-从句\" class=\"headerlink\" title=\"b. it + be + 名词 + 从句\"></a>b. it + be + 名词 + 从句</h6><p><u>It’s</u> a puzzle <u>how</u> life began.</p>\n<p><u>It</u> was a question <u>whether</u> he should get married.</p>\n<h6 id=\"c-it-动词-（宾语、状语）-从句\"><a href=\"#c-it-动词-（宾语、状语）-从句\" class=\"headerlink\" title=\"c. it + 动词 （宾语、状语）+ 从句\"></a>c. it + 动词 （宾语、状语）+ 从句</h6><p><u>It</u> doesn’t matter much <u>where</u> we live.</p>\n<p><u>It</u> struck her <u>how</u> considerate he was.</p>\n<h6 id=\"d-it-动词被动语态-从句\"><a href=\"#d-it-动词被动语态-从句\" class=\"headerlink\" title=\"d. it + 动词被动语态 + 从句\"></a>d. it + 动词被动语态 + 从句</h6><p><u>It</u> is not decided <u>who</u> will edit it.</p>\n<h2 id=\"4-由关系代词型-what-引导的主语从句\"><a href=\"#4-由关系代词型-what-引导的主语从句\" class=\"headerlink\" title=\"4. 由关系代词型 what 引导的主语从句\"></a>4. 由关系代词型 what 引导的主语从句</h2><p><u>What is over</u> is over.</p>\n<p><u>What you should do</u> is to choose a company to invest in.</p>\n<p><u>Whoever wants to go</u> may sign up here.</p>\n<p><u>Whichever you want</u> is yours.</p>\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<h2 id=\"1-三种类型的主语从句\"><a href=\"#1-三种类型的主语从句\" class=\"headerlink\" title=\"1. 三种类型的主语从句\"></a>1. 三种类型的主语从句</h2><h6 id=\"1-由-that-引导的主语从句\"><a href=\"#1-由-that-引导的主语从句\" class=\"headerlink\" title=\"(1) 由 that 引导的主语从句\"></a>(1) 由 <code>that</code> 引导的主语从句</h6><p>​    <u>That</u> he hasn’t arrived is odd.</p>\n<p>​    It’s certain <u>that</u> prices will go up.</p>\n<h6 id=\"2-由连接代（副）词引导的主语从句\"><a href=\"#2-由连接代（副）词引导的主语从句\" class=\"headerlink\" title=\"(2) 由连接代（副）词引导的主语从句\"></a>(2) 由<u>连接代（副）词</u>引导的主语从句</h6><p><u>    Why</u> he left wasn’t Important.</p>\n<p><u>    It</u> was uncertain <u>whether</u> he would come or not.</p>\n<h6 id=\"3-由关系代词型和-what-和-whatever-引导的从句：\"><a href=\"#3-由关系代词型和-what-和-whatever-引导的从句：\" class=\"headerlink\" title=\"(3) 由关系代词型和 what 和 whatever 引导的从句：\"></a>(3) 由关系代词型和 <u>what</u> 和 <u>whatever</u> 引导的从句：</h6><p><u>    What I want</u> is a canvas travelling bag.</p>\n<p><u>    Whatever she did</u> was right.</p>\n<h2 id=\"2-由-that-引导的主语从句\"><a href=\"#2-由-that-引导的主语从句\" class=\"headerlink\" title=\"2. 由 that 引导的主语从句\"></a>2. 由 that 引导的主语从句</h2><p>一般都用 <code>it</code> 作形式主语</p>\n<h6 id=\"a-it-be-形容词-that-从句\"><a href=\"#a-it-be-形容词-that-从句\" class=\"headerlink\" title=\"a. it + be + 形容词 + that 从句\"></a>a. it + be + 形容词 + that 从句</h6><p><u>It</u> is natural <u>that</u> they should have different views.</p>\n<p><u>It</u> was quite plain <u>that</u> she didn’t want to come.</p>\n<h6 id=\"b-it-be-名词-that-从句\"><a href=\"#b-it-be-名词-that-从句\" class=\"headerlink\" title=\"b. it + be + 名词 + that 从句\"></a>b. it + be + 名词 + that 从句</h6><p><u>It’s</u> a pity (<u>that</u>) he can’t swim.</p>\n<h6 id=\"c-it-动词-（宾、状）-that\"><a href=\"#c-it-动词-（宾、状）-that\" class=\"headerlink\" title=\"c. it + 动词 + （宾、状） + that\"></a>c. it + 动词 + （宾、状） + that</h6><p><u>It happened that</u> she wasn’t in that day. ( happen 这里不及物，碰巧那天她不在家 )</p>\n<p><u>It</u> never occurred to me <u>that</u> perhaps she was lying.</p>\n<p><u>It</u> seems <u>that</u> you are right.</p>\n<p><u>It</u> struck me <u>that</u> we ought to make a new plan.</p>\n<h6 id=\"d-it-动词的被动语态-that-从句\"><a href=\"#d-it-动词的被动语态-that-从句\" class=\"headerlink\" title=\"d. it + 动词的被动语态 + that 从句\"></a>d. it + 动词的被动语态 + that 从句</h6><p><u>It</u> was rumoured <u>that</u> he was suffering from a stone in the kidney.</p>\n<p><u>It</u> is estimated <u>that</u> 25 million school lunches are sold each day.  </p>\n<h6 id=\"在口语中-that-有时可以省略\"><a href=\"#在口语中-that-有时可以省略\" class=\"headerlink\" title=\"在口语中 that 有时可以省略\"></a>在口语中 <code>that</code> 有时可以省略</h6><p>It was clear his words pleased her.</p>\n<p>It strikes me Kent is a nice lad.</p>\n<h2 id=\"3-由连接代（副）词引导的主语从句\"><a href=\"#3-由连接代（副）词引导的主语从句\" class=\"headerlink\" title=\"3. 由连接代（副）词引导的主语从句\"></a>3. 由连接代（副）词引导的主语从句</h2><p>可放句首，不用 it：</p>\n<p><u>When he’ll be back</u> depends much on the weather.</p>\n<p><u>How it was done</u> was a mystery.</p>\n<p><u>Who is to be sent there</u> hasn’t been decided. </p>\n<p><u>Whether we’ll succeed</u> remains to be seen.</p>\n<p>一般用 it 作形式主语</p>\n<h6 id=\"a-it-be-形容词-从句\"><a href=\"#a-it-be-形容词-从句\" class=\"headerlink\" title=\"a. it + be + 形容词 + 从句\"></a>a. it + be + 形容词 + 从句</h6><p><u>It</u> was not clear to me <u>why</u> he behaved like that.</p>\n<p><u>It’s</u> uncertain <u>whether</u> the game will be held.</p>\n<p><u>It</u> is amazing <u>that</u> he should have said nothing about the murder.</p>\n<h6 id=\"b-it-be-名词-从句\"><a href=\"#b-it-be-名词-从句\" class=\"headerlink\" title=\"b. it + be + 名词 + 从句\"></a>b. it + be + 名词 + 从句</h6><p><u>It’s</u> a puzzle <u>how</u> life began.</p>\n<p><u>It</u> was a question <u>whether</u> he should get married.</p>\n<h6 id=\"c-it-动词-（宾语、状语）-从句\"><a href=\"#c-it-动词-（宾语、状语）-从句\" class=\"headerlink\" title=\"c. it + 动词 （宾语、状语）+ 从句\"></a>c. it + 动词 （宾语、状语）+ 从句</h6><p><u>It</u> doesn’t matter much <u>where</u> we live.</p>\n<p><u>It</u> struck her <u>how</u> considerate he was.</p>\n<h6 id=\"d-it-动词被动语态-从句\"><a href=\"#d-it-动词被动语态-从句\" class=\"headerlink\" title=\"d. it + 动词被动语态 + 从句\"></a>d. it + 动词被动语态 + 从句</h6><p><u>It</u> is not decided <u>who</u> will edit it.</p>\n<h2 id=\"4-由关系代词型-what-引导的主语从句\"><a href=\"#4-由关系代词型-what-引导的主语从句\" class=\"headerlink\" title=\"4. 由关系代词型 what 引导的主语从句\"></a>4. 由关系代词型 what 引导的主语从句</h2><p><u>What is over</u> is over.</p>\n<p><u>What you should do</u> is to choose a company to invest in.</p>\n<p><u>Whoever wants to go</u> may sign up here.</p>\n<p><u>Whichever you want</u> is yours.</p>\n"},{"_content":"---\n\n---\n\n\n\n## 关联容器(map, set, pair)\n\n### 1. 定义\n\n- **空容器**（调用默认构造函数）\n\n```c++\nmap<string, size_t> mp; \nset<string> st; \n```\n\n- **列表初始化**\n\n```c++\nset<string> st = {\"aaa\",\"bbb\"};\nmap<string, string> mp = {{\"Joey\",\"Phoebe\"},{\"Ross\",\"Rachel\"}};\n```\n\n- **迭代器**\n\n```c++\nset<int> iset(ivec.begin(), ivec.end());\n```\n\n也可以将关联容器初始化为另一个同类型容器的**拷贝**【?】\n\n从一个**值范围**来初始化关联容器，只要这些值能转化为容器所需类型【?】\n\n**值初始化**【?】\n\n### 2. **pair**相关\n\n- 基础操作\n\n![pair上的操作](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211113101831838.png)\n\n- 返回值类型为 pair（对返回值列表初始化）\n\n```c++\npair<string, int> my_fun(){\n    ...\n    return {s1, i1};\n    return pair<string, int>(); //构造一个空的 pair\n    \n}\n```\n\n### 3. 关键字、值类型\n\n```cpp\nkey_type\t\t\t//键类型\nmapped_type\t\t\t//值类型（只适用于map）\nvalue_type\t\t\t//对set，与key_type相同\n\t\t\t\t\t//对map，pair键值对：pair<const key_type, mapped_type>, //注意第一个为const\n```\n\n如何使用？：**域运算符**\n\n```c++\nmap<string, int>::mapped_type v1;  //其余类似\n```\n\n### 4. 迭代器\n\n解引用一个关联容器迭代器，会得到一个 `value_type` 的**引用**\n\n```c++\nauto map_it = mp.begin();\n//(*map_it) 是 value_type，一个pair类型的引用\n// -> 可以用来解引用\nmap_it->first   // 关键字，是const的\nmap_it->second  // 值，非const，可以改变\n++map_it->second; // 值自增 1\n\n// set 的迭代器是 const 的，set的关键字是只读的\nauto set_it = st.begin();\n```\n\n### 5. 遍历\n\n1. 用**迭代器**遍历\n\n```c++\nauto map_it = mp.cbegin();\nwhile(map_it != mp.cend()){\n    // do something with map_it->first, map_it->second\n    ++map_it;\n}\n```\n\n2. **for each** 语法\n\n```c++\nfor(auto x:mp){\n    //每一个 x 都是 pair 类型\n    //x.first\n    //x.second\n}\n```\n\n### 6. 添加元素\n\n![image-20220402155957813](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220402155957813.png)\n\n1. set\n\n```cpp\nvecrot<int> v = {2,4,6,8,2,5,1};\n\nset<int> st;\nst.insert(v.begin(), v.end()); //一对迭代器\nst.insert({1,3,4,5,6,7});\n```\n\n2. map\n\n`insert` 一个 `pair`\n\n``` cpp\nmap<string, int> mp;\nstring word;\n\nmp.insert({word, 1});  // 初始化列表构造 pair\nmp.insert(pair<string, int>(word, 1);  // pair 没有不带等号的列表初始化\nmp.insert(make_pair<string, int>(word, 1)); // make_pair 是一个函数\nmp.insert(map<string, int>::value_type(word, 1)); //也用小括号来初始化一个 pair\n```\n\n3. `insert` 的返回值\n\n- 不重（有添加失败的风险，已存在）\n\n添加单一元素的 `insert` 和 `emplace` 返回一个 pair<迭代器，bool>\n\n`迭代器`：指向刚添加的元素\n\n`bool`：如果插入成功（从无到有），返回 `true`，否则返回 `false`\n\n- 可重（没有添加失败的风险）\n\nmulti，`insert`只返回一个迭代器，指向刚添加的新元素\n\n### 7. 删除元素\n\nerase\n\n![从关联容器删除元素](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211113111113342.png)\n\n### 8. 特殊的map下标\n\n```c++\nmp[key]==value  //访问 键key 对应的 value值\n```\n\n- 若 `key` 不存在，则**插入**，并且将其值进行初始化 `value`\n\n- 只能对 **非const** 的 `map` 使用下标，因为可能会插入值\n- map 的下标操作返回一个 **mapped_type** 对象，**左值**\n\n![map的下标操作](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211113111754675.png)\n\n### 9. 访问、查找元素\n\n![在一个关联容器中查找操作](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211113112310777.png)\n\n![查找](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211113112230892.png)\n\n```c++\nif(mp.find(\"one key\") == mp.end()){\n    ...\n}\n```\n\n### 10. 无序容器(unordered_map、unordered_set)\n\n底层都由<u>哈希表</u>实现，其find和count的时间复杂度为O(1)\n\n> 在一般情况下，哈希表查找的时间复杂度均摊为O(1) ，但是极端情况下会因为哈希碰撞退化到O(n)\n\n无序容器自定义哈希函数，自定义比较操作符【坑】\n","source":"_posts/C++/STL/关联容器/关联容器基础.md","raw":"---\n\n---\n\n\n\n## 关联容器(map, set, pair)\n\n### 1. 定义\n\n- **空容器**（调用默认构造函数）\n\n```c++\nmap<string, size_t> mp; \nset<string> st; \n```\n\n- **列表初始化**\n\n```c++\nset<string> st = {\"aaa\",\"bbb\"};\nmap<string, string> mp = {{\"Joey\",\"Phoebe\"},{\"Ross\",\"Rachel\"}};\n```\n\n- **迭代器**\n\n```c++\nset<int> iset(ivec.begin(), ivec.end());\n```\n\n也可以将关联容器初始化为另一个同类型容器的**拷贝**【?】\n\n从一个**值范围**来初始化关联容器，只要这些值能转化为容器所需类型【?】\n\n**值初始化**【?】\n\n### 2. **pair**相关\n\n- 基础操作\n\n![pair上的操作](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211113101831838.png)\n\n- 返回值类型为 pair（对返回值列表初始化）\n\n```c++\npair<string, int> my_fun(){\n    ...\n    return {s1, i1};\n    return pair<string, int>(); //构造一个空的 pair\n    \n}\n```\n\n### 3. 关键字、值类型\n\n```cpp\nkey_type\t\t\t//键类型\nmapped_type\t\t\t//值类型（只适用于map）\nvalue_type\t\t\t//对set，与key_type相同\n\t\t\t\t\t//对map，pair键值对：pair<const key_type, mapped_type>, //注意第一个为const\n```\n\n如何使用？：**域运算符**\n\n```c++\nmap<string, int>::mapped_type v1;  //其余类似\n```\n\n### 4. 迭代器\n\n解引用一个关联容器迭代器，会得到一个 `value_type` 的**引用**\n\n```c++\nauto map_it = mp.begin();\n//(*map_it) 是 value_type，一个pair类型的引用\n// -> 可以用来解引用\nmap_it->first   // 关键字，是const的\nmap_it->second  // 值，非const，可以改变\n++map_it->second; // 值自增 1\n\n// set 的迭代器是 const 的，set的关键字是只读的\nauto set_it = st.begin();\n```\n\n### 5. 遍历\n\n1. 用**迭代器**遍历\n\n```c++\nauto map_it = mp.cbegin();\nwhile(map_it != mp.cend()){\n    // do something with map_it->first, map_it->second\n    ++map_it;\n}\n```\n\n2. **for each** 语法\n\n```c++\nfor(auto x:mp){\n    //每一个 x 都是 pair 类型\n    //x.first\n    //x.second\n}\n```\n\n### 6. 添加元素\n\n![image-20220402155957813](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220402155957813.png)\n\n1. set\n\n```cpp\nvecrot<int> v = {2,4,6,8,2,5,1};\n\nset<int> st;\nst.insert(v.begin(), v.end()); //一对迭代器\nst.insert({1,3,4,5,6,7});\n```\n\n2. map\n\n`insert` 一个 `pair`\n\n``` cpp\nmap<string, int> mp;\nstring word;\n\nmp.insert({word, 1});  // 初始化列表构造 pair\nmp.insert(pair<string, int>(word, 1);  // pair 没有不带等号的列表初始化\nmp.insert(make_pair<string, int>(word, 1)); // make_pair 是一个函数\nmp.insert(map<string, int>::value_type(word, 1)); //也用小括号来初始化一个 pair\n```\n\n3. `insert` 的返回值\n\n- 不重（有添加失败的风险，已存在）\n\n添加单一元素的 `insert` 和 `emplace` 返回一个 pair<迭代器，bool>\n\n`迭代器`：指向刚添加的元素\n\n`bool`：如果插入成功（从无到有），返回 `true`，否则返回 `false`\n\n- 可重（没有添加失败的风险）\n\nmulti，`insert`只返回一个迭代器，指向刚添加的新元素\n\n### 7. 删除元素\n\nerase\n\n![从关联容器删除元素](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211113111113342.png)\n\n### 8. 特殊的map下标\n\n```c++\nmp[key]==value  //访问 键key 对应的 value值\n```\n\n- 若 `key` 不存在，则**插入**，并且将其值进行初始化 `value`\n\n- 只能对 **非const** 的 `map` 使用下标，因为可能会插入值\n- map 的下标操作返回一个 **mapped_type** 对象，**左值**\n\n![map的下标操作](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211113111754675.png)\n\n### 9. 访问、查找元素\n\n![在一个关联容器中查找操作](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211113112310777.png)\n\n![查找](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211113112230892.png)\n\n```c++\nif(mp.find(\"one key\") == mp.end()){\n    ...\n}\n```\n\n### 10. 无序容器(unordered_map、unordered_set)\n\n底层都由<u>哈希表</u>实现，其find和count的时间复杂度为O(1)\n\n> 在一般情况下，哈希表查找的时间复杂度均摊为O(1) ，但是极端情况下会因为哈希碰撞退化到O(n)\n\n无序容器自定义哈希函数，自定义比较操作符【坑】\n","slug":"C++/STL/关联容器/关联容器基础","published":1,"date":"2021-12-31T02:09:01.563Z","updated":"2022-04-26T12:54:52.413Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0kyf0027pcu3av1f97ju","content":"<hr>\n<hr>\n<h2 id=\"关联容器-map-set-pair\"><a href=\"#关联容器-map-set-pair\" class=\"headerlink\" title=\"关联容器(map, set, pair)\"></a>关联容器(map, set, pair)</h2><h3 id=\"1-定义\"><a href=\"#1-定义\" class=\"headerlink\" title=\"1. 定义\"></a>1. 定义</h3><ul>\n<li><strong>空容器</strong>（调用默认构造函数）</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">map&lt;string, <span class=\"keyword\">size_t</span>&gt; mp; </span><br><span class=\"line\">set&lt;string&gt; st; </span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>列表初始化</strong></li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set&lt;string&gt; st = &#123;<span class=\"string\">&quot;aaa&quot;</span>,<span class=\"string\">&quot;bbb&quot;</span>&#125;;</span><br><span class=\"line\">map&lt;string, string&gt; mp = &#123;&#123;<span class=\"string\">&quot;Joey&quot;</span>,<span class=\"string\">&quot;Phoebe&quot;</span>&#125;,&#123;<span class=\"string\">&quot;Ross&quot;</span>,<span class=\"string\">&quot;Rachel&quot;</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>迭代器</strong></li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">set&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">iset</span><span class=\"params\">(ivec.begin(), ivec.end())</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>也可以将关联容器初始化为另一个同类型容器的<strong>拷贝</strong>【?】</p>\n<p>从一个<strong>值范围</strong>来初始化关联容器，只要这些值能转化为容器所需类型【?】</p>\n<p><strong>值初始化</strong>【?】</p>\n<h3 id=\"2-pair相关\"><a href=\"#2-pair相关\" class=\"headerlink\" title=\"2. pair相关\"></a>2. <strong>pair</strong>相关</h3><ul>\n<li>基础操作</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211113101831838.png\" alt=\"pair上的操作\"></p>\n<ul>\n<li>返回值类型为 pair（对返回值列表初始化）</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">pair&lt;string, <span class=\"keyword\">int</span>&gt; <span class=\"title\">my_fun</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;s1, i1&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pair&lt;string, <span class=\"keyword\">int</span>&gt;(); <span class=\"comment\">//构造一个空的 pair</span></span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-关键字、值类型\"><a href=\"#3-关键字、值类型\" class=\"headerlink\" title=\"3. 关键字、值类型\"></a>3. 关键字、值类型</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">key_type\t\t\t<span class=\"comment\">//键类型</span></span><br><span class=\"line\">mapped_type\t\t\t<span class=\"comment\">//值类型（只适用于map）</span></span><br><span class=\"line\">value_type\t\t\t<span class=\"comment\">//对set，与key_type相同</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">//对map，pair键值对：pair&lt;const key_type, mapped_type&gt;, //注意第一个为const</span></span><br></pre></td></tr></table></figure>\n\n<p>如何使用？：<strong>域运算符</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">map&lt;string, <span class=\"keyword\">int</span>&gt;::mapped_type v1;  <span class=\"comment\">//其余类似</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-迭代器\"><a href=\"#4-迭代器\" class=\"headerlink\" title=\"4. 迭代器\"></a>4. 迭代器</h3><p>解引用一个关联容器迭代器，会得到一个 <code>value_type</code> 的<strong>引用</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> map_it = mp.<span class=\"built_in\">begin</span>();</span><br><span class=\"line\"><span class=\"comment\">//(*map_it) 是 value_type，一个pair类型的引用</span></span><br><span class=\"line\"><span class=\"comment\">// -&gt; 可以用来解引用</span></span><br><span class=\"line\">map_it-&gt;first   <span class=\"comment\">// 关键字，是const的</span></span><br><span class=\"line\">map_it-&gt;second  <span class=\"comment\">// 值，非const，可以改变</span></span><br><span class=\"line\">++map_it-&gt;second; <span class=\"comment\">// 值自增 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// set 的迭代器是 const 的，set的关键字是只读的</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> set_it = st.<span class=\"built_in\">begin</span>();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-遍历\"><a href=\"#5-遍历\" class=\"headerlink\" title=\"5. 遍历\"></a>5. 遍历</h3><ol>\n<li>用<strong>迭代器</strong>遍历</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> map_it = mp.<span class=\"built_in\">cbegin</span>();</span><br><span class=\"line\"><span class=\"keyword\">while</span>(map_it != mp.<span class=\"built_in\">cend</span>())&#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something with map_it-&gt;first, map_it-&gt;second</span></span><br><span class=\"line\">    ++map_it;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>for each</strong> 语法</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> x:mp)&#123;</span><br><span class=\"line\">    <span class=\"comment\">//每一个 x 都是 pair 类型</span></span><br><span class=\"line\">    <span class=\"comment\">//x.first</span></span><br><span class=\"line\">    <span class=\"comment\">//x.second</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-添加元素\"><a href=\"#6-添加元素\" class=\"headerlink\" title=\"6. 添加元素\"></a>6. 添加元素</h3><p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220402155957813.png\" alt=\"image-20220402155957813\"></p>\n<ol>\n<li>set</li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vecrot&lt;<span class=\"keyword\">int</span>&gt; v = &#123;<span class=\"number\">2</span>,<span class=\"number\">4</span>,<span class=\"number\">6</span>,<span class=\"number\">8</span>,<span class=\"number\">2</span>,<span class=\"number\">5</span>,<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">set&lt;<span class=\"keyword\">int</span>&gt; st;</span><br><span class=\"line\">st.<span class=\"built_in\">insert</span>(v.<span class=\"built_in\">begin</span>(), v.<span class=\"built_in\">end</span>()); <span class=\"comment\">//一对迭代器</span></span><br><span class=\"line\">st.<span class=\"built_in\">insert</span>(&#123;<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>&#125;);</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>map</li>\n</ol>\n<p><code>insert</code> 一个 <code>pair</code></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">map&lt;string, <span class=\"keyword\">int</span>&gt; mp;</span><br><span class=\"line\">string word;</span><br><span class=\"line\"></span><br><span class=\"line\">mp.<span class=\"built_in\">insert</span>(&#123;word, <span class=\"number\">1</span>&#125;);  <span class=\"comment\">// 初始化列表构造 pair</span></span><br><span class=\"line\">mp.<span class=\"built_in\">insert</span>(pair&lt;string, <span class=\"keyword\">int</span>&gt;(word, <span class=\"number\">1</span>);  <span class=\"comment\">// pair 没有不带等号的列表初始化</span></span><br><span class=\"line\">mp.<span class=\"built_in\">insert</span>(make_pair&lt;string, <span class=\"keyword\">int</span>&gt;(word, <span class=\"number\">1</span>)); <span class=\"comment\">// make_pair 是一个函数</span></span><br><span class=\"line\">mp.<span class=\"built_in\">insert</span>(map&lt;string, <span class=\"keyword\">int</span>&gt;::<span class=\"built_in\">value_type</span>(word, <span class=\"number\">1</span>)); <span class=\"comment\">//也用小括号来初始化一个 pair</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><code>insert</code> 的返回值</li>\n</ol>\n<ul>\n<li>不重（有添加失败的风险，已存在）</li>\n</ul>\n<p>添加单一元素的 <code>insert</code> 和 <code>emplace</code> 返回一个 pair&lt;迭代器，bool&gt;</p>\n<p><code>迭代器</code>：指向刚添加的元素</p>\n<p><code>bool</code>：如果插入成功（从无到有），返回 <code>true</code>，否则返回 <code>false</code></p>\n<ul>\n<li>可重（没有添加失败的风险）</li>\n</ul>\n<p>multi，<code>insert</code>只返回一个迭代器，指向刚添加的新元素</p>\n<h3 id=\"7-删除元素\"><a href=\"#7-删除元素\" class=\"headerlink\" title=\"7. 删除元素\"></a>7. 删除元素</h3><p>erase</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211113111113342.png\" alt=\"从关联容器删除元素\"></p>\n<h3 id=\"8-特殊的map下标\"><a href=\"#8-特殊的map下标\" class=\"headerlink\" title=\"8. 特殊的map下标\"></a>8. 特殊的map下标</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mp[key]==value  <span class=\"comment\">//访问 键key 对应的 value值</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>若 <code>key</code> 不存在，则<strong>插入</strong>，并且将其值进行初始化 <code>value</code></p>\n</li>\n<li><p>只能对 <strong>非const</strong> 的 <code>map</code> 使用下标，因为可能会插入值</p>\n</li>\n<li><p>map 的下标操作返回一个 <strong>mapped_type</strong> 对象，<strong>左值</strong></p>\n</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211113111754675.png\" alt=\"map的下标操作\"></p>\n<h3 id=\"9-访问、查找元素\"><a href=\"#9-访问、查找元素\" class=\"headerlink\" title=\"9. 访问、查找元素\"></a>9. 访问、查找元素</h3><p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211113112310777.png\" alt=\"在一个关联容器中查找操作\"></p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211113112230892.png\" alt=\"查找\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(mp.<span class=\"built_in\">find</span>(<span class=\"string\">&quot;one key&quot;</span>) == mp.<span class=\"built_in\">end</span>())&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"10-无序容器-unordered-map、unordered-set\"><a href=\"#10-无序容器-unordered-map、unordered-set\" class=\"headerlink\" title=\"10. 无序容器(unordered_map、unordered_set)\"></a>10. 无序容器(unordered_map、unordered_set)</h3><p>底层都由<u>哈希表</u>实现，其find和count的时间复杂度为O(1)</p>\n<blockquote>\n<p>在一般情况下，哈希表查找的时间复杂度均摊为O(1) ，但是极端情况下会因为哈希碰撞退化到O(n)</p>\n</blockquote>\n<p>无序容器自定义哈希函数，自定义比较操作符【坑】</p>\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<hr>\n<hr>\n<h2 id=\"关联容器-map-set-pair\"><a href=\"#关联容器-map-set-pair\" class=\"headerlink\" title=\"关联容器(map, set, pair)\"></a>关联容器(map, set, pair)</h2><h3 id=\"1-定义\"><a href=\"#1-定义\" class=\"headerlink\" title=\"1. 定义\"></a>1. 定义</h3><ul>\n<li><strong>空容器</strong>（调用默认构造函数）</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">map&lt;string, <span class=\"keyword\">size_t</span>&gt; mp; </span><br><span class=\"line\">set&lt;string&gt; st; </span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>列表初始化</strong></li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set&lt;string&gt; st = &#123;<span class=\"string\">&quot;aaa&quot;</span>,<span class=\"string\">&quot;bbb&quot;</span>&#125;;</span><br><span class=\"line\">map&lt;string, string&gt; mp = &#123;&#123;<span class=\"string\">&quot;Joey&quot;</span>,<span class=\"string\">&quot;Phoebe&quot;</span>&#125;,&#123;<span class=\"string\">&quot;Ross&quot;</span>,<span class=\"string\">&quot;Rachel&quot;</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>迭代器</strong></li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">set&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">iset</span><span class=\"params\">(ivec.begin(), ivec.end())</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>也可以将关联容器初始化为另一个同类型容器的<strong>拷贝</strong>【?】</p>\n<p>从一个<strong>值范围</strong>来初始化关联容器，只要这些值能转化为容器所需类型【?】</p>\n<p><strong>值初始化</strong>【?】</p>\n<h3 id=\"2-pair相关\"><a href=\"#2-pair相关\" class=\"headerlink\" title=\"2. pair相关\"></a>2. <strong>pair</strong>相关</h3><ul>\n<li>基础操作</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211113101831838.png\" alt=\"pair上的操作\"></p>\n<ul>\n<li>返回值类型为 pair（对返回值列表初始化）</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">pair&lt;string, <span class=\"keyword\">int</span>&gt; <span class=\"title\">my_fun</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;s1, i1&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pair&lt;string, <span class=\"keyword\">int</span>&gt;(); <span class=\"comment\">//构造一个空的 pair</span></span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-关键字、值类型\"><a href=\"#3-关键字、值类型\" class=\"headerlink\" title=\"3. 关键字、值类型\"></a>3. 关键字、值类型</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">key_type\t\t\t<span class=\"comment\">//键类型</span></span><br><span class=\"line\">mapped_type\t\t\t<span class=\"comment\">//值类型（只适用于map）</span></span><br><span class=\"line\">value_type\t\t\t<span class=\"comment\">//对set，与key_type相同</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">//对map，pair键值对：pair&lt;const key_type, mapped_type&gt;, //注意第一个为const</span></span><br></pre></td></tr></table></figure>\n\n<p>如何使用？：<strong>域运算符</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">map&lt;string, <span class=\"keyword\">int</span>&gt;::mapped_type v1;  <span class=\"comment\">//其余类似</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-迭代器\"><a href=\"#4-迭代器\" class=\"headerlink\" title=\"4. 迭代器\"></a>4. 迭代器</h3><p>解引用一个关联容器迭代器，会得到一个 <code>value_type</code> 的<strong>引用</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> map_it = mp.<span class=\"built_in\">begin</span>();</span><br><span class=\"line\"><span class=\"comment\">//(*map_it) 是 value_type，一个pair类型的引用</span></span><br><span class=\"line\"><span class=\"comment\">// -&gt; 可以用来解引用</span></span><br><span class=\"line\">map_it-&gt;first   <span class=\"comment\">// 关键字，是const的</span></span><br><span class=\"line\">map_it-&gt;second  <span class=\"comment\">// 值，非const，可以改变</span></span><br><span class=\"line\">++map_it-&gt;second; <span class=\"comment\">// 值自增 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// set 的迭代器是 const 的，set的关键字是只读的</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> set_it = st.<span class=\"built_in\">begin</span>();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-遍历\"><a href=\"#5-遍历\" class=\"headerlink\" title=\"5. 遍历\"></a>5. 遍历</h3><ol>\n<li>用<strong>迭代器</strong>遍历</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> map_it = mp.<span class=\"built_in\">cbegin</span>();</span><br><span class=\"line\"><span class=\"keyword\">while</span>(map_it != mp.<span class=\"built_in\">cend</span>())&#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something with map_it-&gt;first, map_it-&gt;second</span></span><br><span class=\"line\">    ++map_it;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>for each</strong> 语法</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> x:mp)&#123;</span><br><span class=\"line\">    <span class=\"comment\">//每一个 x 都是 pair 类型</span></span><br><span class=\"line\">    <span class=\"comment\">//x.first</span></span><br><span class=\"line\">    <span class=\"comment\">//x.second</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-添加元素\"><a href=\"#6-添加元素\" class=\"headerlink\" title=\"6. 添加元素\"></a>6. 添加元素</h3><p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220402155957813.png\" alt=\"image-20220402155957813\"></p>\n<ol>\n<li>set</li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vecrot&lt;<span class=\"keyword\">int</span>&gt; v = &#123;<span class=\"number\">2</span>,<span class=\"number\">4</span>,<span class=\"number\">6</span>,<span class=\"number\">8</span>,<span class=\"number\">2</span>,<span class=\"number\">5</span>,<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">set&lt;<span class=\"keyword\">int</span>&gt; st;</span><br><span class=\"line\">st.<span class=\"built_in\">insert</span>(v.<span class=\"built_in\">begin</span>(), v.<span class=\"built_in\">end</span>()); <span class=\"comment\">//一对迭代器</span></span><br><span class=\"line\">st.<span class=\"built_in\">insert</span>(&#123;<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>&#125;);</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>map</li>\n</ol>\n<p><code>insert</code> 一个 <code>pair</code></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">map&lt;string, <span class=\"keyword\">int</span>&gt; mp;</span><br><span class=\"line\">string word;</span><br><span class=\"line\"></span><br><span class=\"line\">mp.<span class=\"built_in\">insert</span>(&#123;word, <span class=\"number\">1</span>&#125;);  <span class=\"comment\">// 初始化列表构造 pair</span></span><br><span class=\"line\">mp.<span class=\"built_in\">insert</span>(pair&lt;string, <span class=\"keyword\">int</span>&gt;(word, <span class=\"number\">1</span>);  <span class=\"comment\">// pair 没有不带等号的列表初始化</span></span><br><span class=\"line\">mp.<span class=\"built_in\">insert</span>(make_pair&lt;string, <span class=\"keyword\">int</span>&gt;(word, <span class=\"number\">1</span>)); <span class=\"comment\">// make_pair 是一个函数</span></span><br><span class=\"line\">mp.<span class=\"built_in\">insert</span>(map&lt;string, <span class=\"keyword\">int</span>&gt;::<span class=\"built_in\">value_type</span>(word, <span class=\"number\">1</span>)); <span class=\"comment\">//也用小括号来初始化一个 pair</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><code>insert</code> 的返回值</li>\n</ol>\n<ul>\n<li>不重（有添加失败的风险，已存在）</li>\n</ul>\n<p>添加单一元素的 <code>insert</code> 和 <code>emplace</code> 返回一个 pair&lt;迭代器，bool&gt;</p>\n<p><code>迭代器</code>：指向刚添加的元素</p>\n<p><code>bool</code>：如果插入成功（从无到有），返回 <code>true</code>，否则返回 <code>false</code></p>\n<ul>\n<li>可重（没有添加失败的风险）</li>\n</ul>\n<p>multi，<code>insert</code>只返回一个迭代器，指向刚添加的新元素</p>\n<h3 id=\"7-删除元素\"><a href=\"#7-删除元素\" class=\"headerlink\" title=\"7. 删除元素\"></a>7. 删除元素</h3><p>erase</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211113111113342.png\" alt=\"从关联容器删除元素\"></p>\n<h3 id=\"8-特殊的map下标\"><a href=\"#8-特殊的map下标\" class=\"headerlink\" title=\"8. 特殊的map下标\"></a>8. 特殊的map下标</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mp[key]==value  <span class=\"comment\">//访问 键key 对应的 value值</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>若 <code>key</code> 不存在，则<strong>插入</strong>，并且将其值进行初始化 <code>value</code></p>\n</li>\n<li><p>只能对 <strong>非const</strong> 的 <code>map</code> 使用下标，因为可能会插入值</p>\n</li>\n<li><p>map 的下标操作返回一个 <strong>mapped_type</strong> 对象，<strong>左值</strong></p>\n</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211113111754675.png\" alt=\"map的下标操作\"></p>\n<h3 id=\"9-访问、查找元素\"><a href=\"#9-访问、查找元素\" class=\"headerlink\" title=\"9. 访问、查找元素\"></a>9. 访问、查找元素</h3><p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211113112310777.png\" alt=\"在一个关联容器中查找操作\"></p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211113112230892.png\" alt=\"查找\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(mp.<span class=\"built_in\">find</span>(<span class=\"string\">&quot;one key&quot;</span>) == mp.<span class=\"built_in\">end</span>())&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"10-无序容器-unordered-map、unordered-set\"><a href=\"#10-无序容器-unordered-map、unordered-set\" class=\"headerlink\" title=\"10. 无序容器(unordered_map、unordered_set)\"></a>10. 无序容器(unordered_map、unordered_set)</h3><p>底层都由<u>哈希表</u>实现，其find和count的时间复杂度为O(1)</p>\n<blockquote>\n<p>在一般情况下，哈希表查找的时间复杂度均摊为O(1) ，但是极端情况下会因为哈希碰撞退化到O(n)</p>\n</blockquote>\n<p>无序容器自定义哈希函数，自定义比较操作符【坑】</p>\n"},{"title":"字符串输入这些麻烦事儿","date":"2021-11-09T16:00:00.000Z","draft":false,"_content":"\n## 1. cin\n\n`cin`使用**空白**（空格、制表符和换行符）来确定字符串的**结束位置**，`cin`只能读取一个单词，读取到空格就结束了，然后将读到的字符串放到数组中，并在结尾添加空字符`'\\0'`。       \n\n> `cin`将换行符**保留**在输入队列中。\n\n#### 1.1 while(cin)用法\n\n> `istream` 类提供了一个可以将 `istream` 对象（如 `cin`）转换为 `bool` 值的函数。\n>\n> 当 `cin` 出现在需要 `bool` 值的地方（例如 `while` 条件中）`cin`将被转换为`bool`值。读取成功返回 `true`，否则就返回 `false`。\n\n常见用法如下：\n\n1. 每次读取一个字符，直到遇到EOF\n\n   ```c++\n   cin.get(ch);\n   while(cin){  // 单飘一个cin，用来测试是否到文件尾了，当遇到文件结束符EOF时，终止\n       ...\n       cin.get(ch);  //如果读取没成功，会将失败标记置位\n   }   \n   ```\n\n   或者\n\n   ```c++\n   while(cin.get(ch)){\n       ...\n   }\n   ```\n\n   \n\n2. 循环输入一组数字到`vector`，遇到换行符终止\n\n   ```c++\n   vector<int> arr;\n   int num;\n   while(cin>>num){\n       arr.push_back(num);\n       if(cin.get()=='\\n'){\n           break;\n       }\n   }\n   ```\n\n   \n\n## 2. cin.getline()、cin.get()\n\n#### 2.1 cin.getline()\n\n```c++\nistream& getline (char* s, streamsize n );\n```\n\n遇到换行符停止读入，<u>**不保存**换行符</u>，用空字符替代换行符，加到数组后面\n\n接受两个参数\n\n1. 第一个是要接受读进来的字符串的字符数组的地址\n\n2. 第二个是要读取的字符数 `n`\n\n注意：`n` 不能超过字符数组的大小，且 `n` 已经计入了 `'\\0'`，也就是说有效允许读入字符数应该是 `n-1`\n\n#### 2.2 cin.get()\n\n`cin.get()`有几种变体：\n\n1. 接受的参数与`cin.getline()`一样，但是**保留换行符在输入队列中**（和`cin`一样）\n\n2. 不带任何参数\n\n   `cin.get();` 它可用来读取**下一个字符**（可以是换行符）\n\n3. 带一个char参数，读取下一个字符到`_Ch`\n\n   ```c++\n   cin.get(char &_Ch)\n   ```\n\n## 3. string类成员函数getline()\n\n读取一整行，直到遇到**换行符**（换行符也被读入，但是抛弃它，**不存**）\n\n```c++\nstring str;\ngetline(cin,str);\n```\n\n","source":"_posts/C++/STL/顺序容器/字符串输入.md","raw":"---\ntitle: \"字符串输入这些麻烦事儿\"\ndate: 2021-11-10\ndraft: false\ntags: [\"C/C++\"]\ncategories: [\"我为什么这么菜~~\"]\n---\n\n## 1. cin\n\n`cin`使用**空白**（空格、制表符和换行符）来确定字符串的**结束位置**，`cin`只能读取一个单词，读取到空格就结束了，然后将读到的字符串放到数组中，并在结尾添加空字符`'\\0'`。       \n\n> `cin`将换行符**保留**在输入队列中。\n\n#### 1.1 while(cin)用法\n\n> `istream` 类提供了一个可以将 `istream` 对象（如 `cin`）转换为 `bool` 值的函数。\n>\n> 当 `cin` 出现在需要 `bool` 值的地方（例如 `while` 条件中）`cin`将被转换为`bool`值。读取成功返回 `true`，否则就返回 `false`。\n\n常见用法如下：\n\n1. 每次读取一个字符，直到遇到EOF\n\n   ```c++\n   cin.get(ch);\n   while(cin){  // 单飘一个cin，用来测试是否到文件尾了，当遇到文件结束符EOF时，终止\n       ...\n       cin.get(ch);  //如果读取没成功，会将失败标记置位\n   }   \n   ```\n\n   或者\n\n   ```c++\n   while(cin.get(ch)){\n       ...\n   }\n   ```\n\n   \n\n2. 循环输入一组数字到`vector`，遇到换行符终止\n\n   ```c++\n   vector<int> arr;\n   int num;\n   while(cin>>num){\n       arr.push_back(num);\n       if(cin.get()=='\\n'){\n           break;\n       }\n   }\n   ```\n\n   \n\n## 2. cin.getline()、cin.get()\n\n#### 2.1 cin.getline()\n\n```c++\nistream& getline (char* s, streamsize n );\n```\n\n遇到换行符停止读入，<u>**不保存**换行符</u>，用空字符替代换行符，加到数组后面\n\n接受两个参数\n\n1. 第一个是要接受读进来的字符串的字符数组的地址\n\n2. 第二个是要读取的字符数 `n`\n\n注意：`n` 不能超过字符数组的大小，且 `n` 已经计入了 `'\\0'`，也就是说有效允许读入字符数应该是 `n-1`\n\n#### 2.2 cin.get()\n\n`cin.get()`有几种变体：\n\n1. 接受的参数与`cin.getline()`一样，但是**保留换行符在输入队列中**（和`cin`一样）\n\n2. 不带任何参数\n\n   `cin.get();` 它可用来读取**下一个字符**（可以是换行符）\n\n3. 带一个char参数，读取下一个字符到`_Ch`\n\n   ```c++\n   cin.get(char &_Ch)\n   ```\n\n## 3. string类成员函数getline()\n\n读取一整行，直到遇到**换行符**（换行符也被读入，但是抛弃它，**不存**）\n\n```c++\nstring str;\ngetline(cin,str);\n```\n\n","slug":"C++/STL/顺序容器/字符串输入","published":1,"updated":"2022-03-04T12:04:06.649Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0kyg0029pcu3fppr2s0h","content":"<h2 id=\"1-cin\"><a href=\"#1-cin\" class=\"headerlink\" title=\"1. cin\"></a>1. cin</h2><p><code>cin</code>使用<strong>空白</strong>（空格、制表符和换行符）来确定字符串的<strong>结束位置</strong>，<code>cin</code>只能读取一个单词，读取到空格就结束了，然后将读到的字符串放到数组中，并在结尾添加空字符<code>&#39;\\0&#39;</code>。       </p>\n<blockquote>\n<p><code>cin</code>将换行符<strong>保留</strong>在输入队列中。</p>\n</blockquote>\n<h4 id=\"1-1-while-cin-用法\"><a href=\"#1-1-while-cin-用法\" class=\"headerlink\" title=\"1.1 while(cin)用法\"></a>1.1 while(cin)用法</h4><blockquote>\n<p><code>istream</code> 类提供了一个可以将 <code>istream</code> 对象（如 <code>cin</code>）转换为 <code>bool</code> 值的函数。</p>\n<p>当 <code>cin</code> 出现在需要 <code>bool</code> 值的地方（例如 <code>while</code> 条件中）<code>cin</code>将被转换为<code>bool</code>值。读取成功返回 <code>true</code>，否则就返回 <code>false</code>。</p>\n</blockquote>\n<p>常见用法如下：</p>\n<ol>\n<li><p>每次读取一个字符，直到遇到EOF</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cin.<span class=\"built_in\">get</span>(ch);</span><br><span class=\"line\"><span class=\"keyword\">while</span>(cin)&#123;  <span class=\"comment\">// 单飘一个cin，用来测试是否到文件尾了，当遇到文件结束符EOF时，终止</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    cin.<span class=\"built_in\">get</span>(ch);  <span class=\"comment\">//如果读取没成功，会将失败标记置位</span></span><br><span class=\"line\">&#125;   </span><br></pre></td></tr></table></figure>\n\n<p>或者</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(cin.<span class=\"built_in\">get</span>(ch))&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>循环输入一组数字到<code>vector</code>，遇到换行符终止</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;<span class=\"keyword\">int</span>&gt; arr;</span><br><span class=\"line\"><span class=\"keyword\">int</span> num;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(cin&gt;&gt;num)&#123;</span><br><span class=\"line\">    arr.<span class=\"built_in\">push_back</span>(num);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(cin.<span class=\"built_in\">get</span>()==<span class=\"string\">&#x27;\\n&#x27;</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"2-cin-getline-、cin-get\"><a href=\"#2-cin-getline-、cin-get\" class=\"headerlink\" title=\"2. cin.getline()、cin.get()\"></a>2. cin.getline()、cin.get()</h2><h4 id=\"2-1-cin-getline\"><a href=\"#2-1-cin-getline\" class=\"headerlink\" title=\"2.1 cin.getline()\"></a>2.1 cin.getline()</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">istream&amp; <span class=\"title\">getline</span> <span class=\"params\">(<span class=\"keyword\">char</span>* s, streamsize n )</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>遇到换行符停止读入，<u><strong>不保存</strong>换行符</u>，用空字符替代换行符，加到数组后面</p>\n<p>接受两个参数</p>\n<ol>\n<li><p>第一个是要接受读进来的字符串的字符数组的地址</p>\n</li>\n<li><p>第二个是要读取的字符数 <code>n</code></p>\n</li>\n</ol>\n<p>注意：<code>n</code> 不能超过字符数组的大小，且 <code>n</code> 已经计入了 <code>&#39;\\0&#39;</code>，也就是说有效允许读入字符数应该是 <code>n-1</code></p>\n<h4 id=\"2-2-cin-get\"><a href=\"#2-2-cin-get\" class=\"headerlink\" title=\"2.2 cin.get()\"></a>2.2 cin.get()</h4><p><code>cin.get()</code>有几种变体：</p>\n<ol>\n<li><p>接受的参数与<code>cin.getline()</code>一样，但是<strong>保留换行符在输入队列中</strong>（和<code>cin</code>一样）</p>\n</li>\n<li><p>不带任何参数</p>\n<p><code>cin.get();</code> 它可用来读取<strong>下一个字符</strong>（可以是换行符）</p>\n</li>\n<li><p>带一个char参数，读取下一个字符到<code>_Ch</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cin.<span class=\"built_in\">get</span>(<span class=\"keyword\">char</span> &amp;_Ch)</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"3-string类成员函数getline\"><a href=\"#3-string类成员函数getline\" class=\"headerlink\" title=\"3. string类成员函数getline()\"></a>3. string类成员函数getline()</h2><p>读取一整行，直到遇到<strong>换行符</strong>（换行符也被读入，但是抛弃它，<strong>不存</strong>）</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string str;</span><br><span class=\"line\"><span class=\"built_in\">getline</span>(cin,str);</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<h2 id=\"1-cin\"><a href=\"#1-cin\" class=\"headerlink\" title=\"1. cin\"></a>1. cin</h2><p><code>cin</code>使用<strong>空白</strong>（空格、制表符和换行符）来确定字符串的<strong>结束位置</strong>，<code>cin</code>只能读取一个单词，读取到空格就结束了，然后将读到的字符串放到数组中，并在结尾添加空字符<code>&#39;\\0&#39;</code>。       </p>\n<blockquote>\n<p><code>cin</code>将换行符<strong>保留</strong>在输入队列中。</p>\n</blockquote>\n<h4 id=\"1-1-while-cin-用法\"><a href=\"#1-1-while-cin-用法\" class=\"headerlink\" title=\"1.1 while(cin)用法\"></a>1.1 while(cin)用法</h4><blockquote>\n<p><code>istream</code> 类提供了一个可以将 <code>istream</code> 对象（如 <code>cin</code>）转换为 <code>bool</code> 值的函数。</p>\n<p>当 <code>cin</code> 出现在需要 <code>bool</code> 值的地方（例如 <code>while</code> 条件中）<code>cin</code>将被转换为<code>bool</code>值。读取成功返回 <code>true</code>，否则就返回 <code>false</code>。</p>\n</blockquote>\n<p>常见用法如下：</p>\n<ol>\n<li><p>每次读取一个字符，直到遇到EOF</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cin.<span class=\"built_in\">get</span>(ch);</span><br><span class=\"line\"><span class=\"keyword\">while</span>(cin)&#123;  <span class=\"comment\">// 单飘一个cin，用来测试是否到文件尾了，当遇到文件结束符EOF时，终止</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    cin.<span class=\"built_in\">get</span>(ch);  <span class=\"comment\">//如果读取没成功，会将失败标记置位</span></span><br><span class=\"line\">&#125;   </span><br></pre></td></tr></table></figure>\n\n<p>或者</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(cin.<span class=\"built_in\">get</span>(ch))&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>循环输入一组数字到<code>vector</code>，遇到换行符终止</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;<span class=\"keyword\">int</span>&gt; arr;</span><br><span class=\"line\"><span class=\"keyword\">int</span> num;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(cin&gt;&gt;num)&#123;</span><br><span class=\"line\">    arr.<span class=\"built_in\">push_back</span>(num);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(cin.<span class=\"built_in\">get</span>()==<span class=\"string\">&#x27;\\n&#x27;</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"2-cin-getline-、cin-get\"><a href=\"#2-cin-getline-、cin-get\" class=\"headerlink\" title=\"2. cin.getline()、cin.get()\"></a>2. cin.getline()、cin.get()</h2><h4 id=\"2-1-cin-getline\"><a href=\"#2-1-cin-getline\" class=\"headerlink\" title=\"2.1 cin.getline()\"></a>2.1 cin.getline()</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">istream&amp; <span class=\"title\">getline</span> <span class=\"params\">(<span class=\"keyword\">char</span>* s, streamsize n )</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>遇到换行符停止读入，<u><strong>不保存</strong>换行符</u>，用空字符替代换行符，加到数组后面</p>\n<p>接受两个参数</p>\n<ol>\n<li><p>第一个是要接受读进来的字符串的字符数组的地址</p>\n</li>\n<li><p>第二个是要读取的字符数 <code>n</code></p>\n</li>\n</ol>\n<p>注意：<code>n</code> 不能超过字符数组的大小，且 <code>n</code> 已经计入了 <code>&#39;\\0&#39;</code>，也就是说有效允许读入字符数应该是 <code>n-1</code></p>\n<h4 id=\"2-2-cin-get\"><a href=\"#2-2-cin-get\" class=\"headerlink\" title=\"2.2 cin.get()\"></a>2.2 cin.get()</h4><p><code>cin.get()</code>有几种变体：</p>\n<ol>\n<li><p>接受的参数与<code>cin.getline()</code>一样，但是<strong>保留换行符在输入队列中</strong>（和<code>cin</code>一样）</p>\n</li>\n<li><p>不带任何参数</p>\n<p><code>cin.get();</code> 它可用来读取<strong>下一个字符</strong>（可以是换行符）</p>\n</li>\n<li><p>带一个char参数，读取下一个字符到<code>_Ch</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cin.<span class=\"built_in\">get</span>(<span class=\"keyword\">char</span> &amp;_Ch)</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"3-string类成员函数getline\"><a href=\"#3-string类成员函数getline\" class=\"headerlink\" title=\"3. string类成员函数getline()\"></a>3. string类成员函数getline()</h2><p>读取一整行，直到遇到<strong>换行符</strong>（换行符也被读入，但是抛弃它，<strong>不存</strong>）</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string str;</span><br><span class=\"line\"><span class=\"built_in\">getline</span>(cin,str);</span><br></pre></td></tr></table></figure>\n\n"},{"_content":"尽量用编译器，而不用预处理器\n\n#### 1. #define 、const 定义符号常量\n\n```cpp\n#define ASPECT_RATIO 1.653\n```\n\n`#define`在<u>预处理阶段</u>进行文本展开，编译器看不到`ASPECT_RATIO`符号名，如果涉及到`1.653`的代码在编译时报错，就会很难Debug，所以用`const`会比较好\n\n```cpp\nconst double ASPECT_RATIO = 1.653;\n```\n\n- `#define`在预处理阶段进行的，而`const`是一个运行时概念\n- `#define`定义的常量没有类型，没有类型安全检查 ，`const`的常量带类型，要在编译时进行类型检查\n- `#define`是直接替换，没有分配内存，存储于程序代码段中。而`const`需要进行内存分配，存储于程序数据段中\n- `const`可以将常量限制在作用域内，例如class专属常量，而`#define`不重视作用域，不能提供封装性\n\n#### 2. #define、inline 定义函数\n\n- #define宏函数容易导致歧义，会发生不可预计的行为，要用inline内联函数代替宏函数，就可以实现可预计的行为和类型安全（template inline），还可以设定作用域和访问规则\n- inline只是对内联的建议，编译器不一定真的实现内联\n","source":"_posts/C++/《effective C++ 第三版》读书笔记/1. 让自己习惯C++/条款02：尽量以const，enum，inline替换#define.md","raw":"尽量用编译器，而不用预处理器\n\n#### 1. #define 、const 定义符号常量\n\n```cpp\n#define ASPECT_RATIO 1.653\n```\n\n`#define`在<u>预处理阶段</u>进行文本展开，编译器看不到`ASPECT_RATIO`符号名，如果涉及到`1.653`的代码在编译时报错，就会很难Debug，所以用`const`会比较好\n\n```cpp\nconst double ASPECT_RATIO = 1.653;\n```\n\n- `#define`在预处理阶段进行的，而`const`是一个运行时概念\n- `#define`定义的常量没有类型，没有类型安全检查 ，`const`的常量带类型，要在编译时进行类型检查\n- `#define`是直接替换，没有分配内存，存储于程序代码段中。而`const`需要进行内存分配，存储于程序数据段中\n- `const`可以将常量限制在作用域内，例如class专属常量，而`#define`不重视作用域，不能提供封装性\n\n#### 2. #define、inline 定义函数\n\n- #define宏函数容易导致歧义，会发生不可预计的行为，要用inline内联函数代替宏函数，就可以实现可预计的行为和类型安全（template inline），还可以设定作用域和访问规则\n- inline只是对内联的建议，编译器不一定真的实现内联\n","slug":"C++/《effective C++ 第三版》读书笔记/1. 让自己习惯C++/条款02：尽量以const，enum，inline替换#define","published":1,"date":"2022-05-09T02:27:17.672Z","updated":"2022-05-26T08:59:17.278Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0kyg002apcu3b86v9a0h","content":"<p>尽量用编译器，而不用预处理器</p>\n<h4 id=\"1-define-、const-定义符号常量\"><a href=\"#1-define-、const-定义符号常量\" class=\"headerlink\" title=\"1. #define 、const 定义符号常量\"></a>1. #define 、const 定义符号常量</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ASPECT_RATIO 1.653</span></span><br></pre></td></tr></table></figure>\n\n<p><code>#define</code>在<u>预处理阶段</u>进行文本展开，编译器看不到<code>ASPECT_RATIO</code>符号名，如果涉及到<code>1.653</code>的代码在编译时报错，就会很难Debug，所以用<code>const</code>会比较好</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">double</span> ASPECT_RATIO = <span class=\"number\">1.653</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>#define</code>在预处理阶段进行的，而<code>const</code>是一个运行时概念</li>\n<li><code>#define</code>定义的常量没有类型，没有类型安全检查 ，<code>const</code>的常量带类型，要在编译时进行类型检查</li>\n<li><code>#define</code>是直接替换，没有分配内存，存储于程序代码段中。而<code>const</code>需要进行内存分配，存储于程序数据段中</li>\n<li><code>const</code>可以将常量限制在作用域内，例如class专属常量，而<code>#define</code>不重视作用域，不能提供封装性</li>\n</ul>\n<h4 id=\"2-define、inline-定义函数\"><a href=\"#2-define、inline-定义函数\" class=\"headerlink\" title=\"2. #define、inline 定义函数\"></a>2. #define、inline 定义函数</h4><ul>\n<li>#define宏函数容易导致歧义，会发生不可预计的行为，要用inline内联函数代替宏函数，就可以实现可预计的行为和类型安全（template inline），还可以设定作用域和访问规则</li>\n<li>inline只是对内联的建议，编译器不一定真的实现内联</li>\n</ul>\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<p>尽量用编译器，而不用预处理器</p>\n<h4 id=\"1-define-、const-定义符号常量\"><a href=\"#1-define-、const-定义符号常量\" class=\"headerlink\" title=\"1. #define 、const 定义符号常量\"></a>1. #define 、const 定义符号常量</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ASPECT_RATIO 1.653</span></span><br></pre></td></tr></table></figure>\n\n<p><code>#define</code>在<u>预处理阶段</u>进行文本展开，编译器看不到<code>ASPECT_RATIO</code>符号名，如果涉及到<code>1.653</code>的代码在编译时报错，就会很难Debug，所以用<code>const</code>会比较好</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">double</span> ASPECT_RATIO = <span class=\"number\">1.653</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>#define</code>在预处理阶段进行的，而<code>const</code>是一个运行时概念</li>\n<li><code>#define</code>定义的常量没有类型，没有类型安全检查 ，<code>const</code>的常量带类型，要在编译时进行类型检查</li>\n<li><code>#define</code>是直接替换，没有分配内存，存储于程序代码段中。而<code>const</code>需要进行内存分配，存储于程序数据段中</li>\n<li><code>const</code>可以将常量限制在作用域内，例如class专属常量，而<code>#define</code>不重视作用域，不能提供封装性</li>\n</ul>\n<h4 id=\"2-define、inline-定义函数\"><a href=\"#2-define、inline-定义函数\" class=\"headerlink\" title=\"2. #define、inline 定义函数\"></a>2. #define、inline 定义函数</h4><ul>\n<li>#define宏函数容易导致歧义，会发生不可预计的行为，要用inline内联函数代替宏函数，就可以实现可预计的行为和类型安全（template inline），还可以设定作用域和访问规则</li>\n<li>inline只是对内联的建议，编译器不一定真的实现内联</li>\n</ul>\n"},{"_content":"const是一个语义约束，由编译器强制实现\n\n#### 1. 指针与const\n\n涉及到指针时，注意区分const是修饰指针本身还是指针所指之物\n\n```cpp\nchar* p = greeting;\nconst char* p =greeting;    // 不可修改 *p\nchar* const p = greeting;   // 不可修改 p\n```\n\n#### 2. STL迭代器与const\n\n声明一个迭代器为`const`就像声明一个指针为`const（T* const）`，表示迭代器不能指向不同的东西，但它所指之物本身可以修改，而`const_iterator`约束了所指之物本身不能被修改。\n\n```cpp\nconst std::vector<int>::iterator iter = vec.begin();\nstd::vector<int>::const_iterator cIter = vec.begin();\n```\n\n#### 3. const成员函数\n\n在成员函数声明语句末端添加`const`关键字，意味着该函数不能修改对象内任何`non-static`成员变量（可以修改static）。const对象不能被修改， 所以const对象只能调用const成员函数。\n\n```cpp\nclass T{\n  void fun1() const;   //const成员函数\n};\n```\n\n> 两个成员函数如果只是常量性不同，可以被重载\n\n##### 3.1 bitwise constness 和 logical constness\n\n`bitwise`常量性是编译器规定的，表示对象内部的任何一个字节都不被修改，但这种常量性无法保证成员指针指向的data不被修改。\n\n`logical`常量性比较宽松，主张一个const成员函数可以修改它所处理的对象内的某些bits，但只有在客户端侦测不出的情况下才行。具体实现要用`mutable`关键字，指出那些无关紧要的变量，这些变量即使在const成员函数内也可以被修改。\n\n```cpp\nclass CTextBlock {\npublic:\n    ...\n\tstd::size_t length() const;\nprivate:\n    char* pText;\n    mutable std::size_t textLength; // 可被const函数修改\n    mutable bool lengthIsValid;\t\t// 可被const函数修改\n};\n\nstd::size_t CTextBlock::length() const\n{\n    // 可以对 textLength 和 lengthIsValid 进行修改\n}\n```\n\n##### 3.2 用const成员函数实现non-const成员函数\n\n为了避免代码重复，有时需要这么做，方法是使用转型（casting）\n\n```cpp\nclass TextBlock {\npublic:\n    ...\n\tconst char& operator[](std::size_t position) const \n    {\n        return text[position];\n    }\n    \n    char& operator[](std::size_t position)\n    {\n    \treturn \n            const_cast<char&>(\n            static_cast<const TextBlock&>(*this)[position]\n                                );\n    }\n    \nprivate:\n    char* pText;\n};\n```\n\n这里有两次转型，第一次用来为 *this 添加 const，所以调用 operator[] 时可以调用其 const 版本，然后第二次转型从 const operator[] 的返回值中移除 const\n\n","source":"_posts/C++/《effective C++ 第三版》读书笔记/1. 让自己习惯C++/条款03：尽可能使用const.md","raw":"const是一个语义约束，由编译器强制实现\n\n#### 1. 指针与const\n\n涉及到指针时，注意区分const是修饰指针本身还是指针所指之物\n\n```cpp\nchar* p = greeting;\nconst char* p =greeting;    // 不可修改 *p\nchar* const p = greeting;   // 不可修改 p\n```\n\n#### 2. STL迭代器与const\n\n声明一个迭代器为`const`就像声明一个指针为`const（T* const）`，表示迭代器不能指向不同的东西，但它所指之物本身可以修改，而`const_iterator`约束了所指之物本身不能被修改。\n\n```cpp\nconst std::vector<int>::iterator iter = vec.begin();\nstd::vector<int>::const_iterator cIter = vec.begin();\n```\n\n#### 3. const成员函数\n\n在成员函数声明语句末端添加`const`关键字，意味着该函数不能修改对象内任何`non-static`成员变量（可以修改static）。const对象不能被修改， 所以const对象只能调用const成员函数。\n\n```cpp\nclass T{\n  void fun1() const;   //const成员函数\n};\n```\n\n> 两个成员函数如果只是常量性不同，可以被重载\n\n##### 3.1 bitwise constness 和 logical constness\n\n`bitwise`常量性是编译器规定的，表示对象内部的任何一个字节都不被修改，但这种常量性无法保证成员指针指向的data不被修改。\n\n`logical`常量性比较宽松，主张一个const成员函数可以修改它所处理的对象内的某些bits，但只有在客户端侦测不出的情况下才行。具体实现要用`mutable`关键字，指出那些无关紧要的变量，这些变量即使在const成员函数内也可以被修改。\n\n```cpp\nclass CTextBlock {\npublic:\n    ...\n\tstd::size_t length() const;\nprivate:\n    char* pText;\n    mutable std::size_t textLength; // 可被const函数修改\n    mutable bool lengthIsValid;\t\t// 可被const函数修改\n};\n\nstd::size_t CTextBlock::length() const\n{\n    // 可以对 textLength 和 lengthIsValid 进行修改\n}\n```\n\n##### 3.2 用const成员函数实现non-const成员函数\n\n为了避免代码重复，有时需要这么做，方法是使用转型（casting）\n\n```cpp\nclass TextBlock {\npublic:\n    ...\n\tconst char& operator[](std::size_t position) const \n    {\n        return text[position];\n    }\n    \n    char& operator[](std::size_t position)\n    {\n    \treturn \n            const_cast<char&>(\n            static_cast<const TextBlock&>(*this)[position]\n                                );\n    }\n    \nprivate:\n    char* pText;\n};\n```\n\n这里有两次转型，第一次用来为 *this 添加 const，所以调用 operator[] 时可以调用其 const 版本，然后第二次转型从 const operator[] 的返回值中移除 const\n\n","slug":"C++/《effective C++ 第三版》读书笔记/1. 让自己习惯C++/条款03：尽可能使用const","published":1,"date":"2022-05-19T03:37:07.542Z","updated":"2022-05-28T02:06:13.738Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0kyh002dpcu3bymp3o5o","content":"<p>const是一个语义约束，由编译器强制实现</p>\n<h4 id=\"1-指针与const\"><a href=\"#1-指针与const\" class=\"headerlink\" title=\"1. 指针与const\"></a>1. 指针与const</h4><p>涉及到指针时，注意区分const是修饰指针本身还是指针所指之物</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span>* p = greeting;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* p =greeting;    <span class=\"comment\">// 不可修改 *p</span></span><br><span class=\"line\"><span class=\"keyword\">char</span>* <span class=\"keyword\">const</span> p = greeting;   <span class=\"comment\">// 不可修改 p</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-STL迭代器与const\"><a href=\"#2-STL迭代器与const\" class=\"headerlink\" title=\"2. STL迭代器与const\"></a>2. STL迭代器与const</h4><p>声明一个迭代器为<code>const</code>就像声明一个指针为<code>const（T* const）</code>，表示迭代器不能指向不同的东西，但它所指之物本身可以修改，而<code>const_iterator</code>约束了所指之物本身不能被修改。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> std::vector&lt;<span class=\"keyword\">int</span>&gt;::iterator iter = vec.<span class=\"built_in\">begin</span>();</span><br><span class=\"line\">std::vector&lt;<span class=\"keyword\">int</span>&gt;::const_iterator cIter = vec.<span class=\"built_in\">begin</span>();</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-const成员函数\"><a href=\"#3-const成员函数\" class=\"headerlink\" title=\"3. const成员函数\"></a>3. const成员函数</h4><p>在成员函数声明语句末端添加<code>const</code>关键字，意味着该函数不能修改对象内任何<code>non-static</code>成员变量（可以修改static）。const对象不能被修改， 所以const对象只能调用const成员函数。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&#123;</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fun1</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;   <span class=\"comment\">//const成员函数</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>两个成员函数如果只是常量性不同，可以被重载</p>\n</blockquote>\n<h5 id=\"3-1-bitwise-constness-和-logical-constness\"><a href=\"#3-1-bitwise-constness-和-logical-constness\" class=\"headerlink\" title=\"3.1 bitwise constness 和 logical constness\"></a>3.1 bitwise constness 和 logical constness</h5><p><code>bitwise</code>常量性是编译器规定的，表示对象内部的任何一个字节都不被修改，但这种常量性无法保证成员指针指向的data不被修改。</p>\n<p><code>logical</code>常量性比较宽松，主张一个const成员函数可以修改它所处理的对象内的某些bits，但只有在客户端侦测不出的情况下才行。具体实现要用<code>mutable</code>关键字，指出那些无关紧要的变量，这些变量即使在const成员函数内也可以被修改。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CTextBlock</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    ...</span><br><span class=\"line\">\t<span class=\"function\">std::<span class=\"keyword\">size_t</span> <span class=\"title\">length</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">char</span>* pText;</span><br><span class=\"line\">    <span class=\"keyword\">mutable</span> std::<span class=\"keyword\">size_t</span> textLength; <span class=\"comment\">// 可被const函数修改</span></span><br><span class=\"line\">    <span class=\"keyword\">mutable</span> <span class=\"keyword\">bool</span> lengthIsValid;\t\t<span class=\"comment\">// 可被const函数修改</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">std::<span class=\"keyword\">size_t</span> <span class=\"title\">CTextBlock::length</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 可以对 textLength 和 lengthIsValid 进行修改</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"3-2-用const成员函数实现non-const成员函数\"><a href=\"#3-2-用const成员函数实现non-const成员函数\" class=\"headerlink\" title=\"3.2 用const成员函数实现non-const成员函数\"></a>3.2 用const成员函数实现non-const成员函数</h5><p>为了避免代码重复，有时需要这么做，方法是使用转型（casting）</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TextBlock</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    ...</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>&amp; <span class=\"keyword\">operator</span>[](std::<span class=\"keyword\">size_t</span> position) <span class=\"keyword\">const</span> </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> text[position];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">char</span>&amp; <span class=\"keyword\">operator</span>[](std::<span class=\"keyword\">size_t</span> position)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> </span><br><span class=\"line\">            <span class=\"keyword\">const_cast</span>&lt;<span class=\"keyword\">char</span>&amp;&gt;(</span><br><span class=\"line\">            <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">const</span> TextBlock&amp;&gt;(*<span class=\"keyword\">this</span>)[position]</span><br><span class=\"line\">                                );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">char</span>* pText;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这里有两次转型，第一次用来为 *this 添加 const，所以调用 operator[] 时可以调用其 const 版本，然后第二次转型从 const operator[] 的返回值中移除 const</p>\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<p>const是一个语义约束，由编译器强制实现</p>\n<h4 id=\"1-指针与const\"><a href=\"#1-指针与const\" class=\"headerlink\" title=\"1. 指针与const\"></a>1. 指针与const</h4><p>涉及到指针时，注意区分const是修饰指针本身还是指针所指之物</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span>* p = greeting;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* p =greeting;    <span class=\"comment\">// 不可修改 *p</span></span><br><span class=\"line\"><span class=\"keyword\">char</span>* <span class=\"keyword\">const</span> p = greeting;   <span class=\"comment\">// 不可修改 p</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-STL迭代器与const\"><a href=\"#2-STL迭代器与const\" class=\"headerlink\" title=\"2. STL迭代器与const\"></a>2. STL迭代器与const</h4><p>声明一个迭代器为<code>const</code>就像声明一个指针为<code>const（T* const）</code>，表示迭代器不能指向不同的东西，但它所指之物本身可以修改，而<code>const_iterator</code>约束了所指之物本身不能被修改。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> std::vector&lt;<span class=\"keyword\">int</span>&gt;::iterator iter = vec.<span class=\"built_in\">begin</span>();</span><br><span class=\"line\">std::vector&lt;<span class=\"keyword\">int</span>&gt;::const_iterator cIter = vec.<span class=\"built_in\">begin</span>();</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-const成员函数\"><a href=\"#3-const成员函数\" class=\"headerlink\" title=\"3. const成员函数\"></a>3. const成员函数</h4><p>在成员函数声明语句末端添加<code>const</code>关键字，意味着该函数不能修改对象内任何<code>non-static</code>成员变量（可以修改static）。const对象不能被修改， 所以const对象只能调用const成员函数。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&#123;</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fun1</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;   <span class=\"comment\">//const成员函数</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>两个成员函数如果只是常量性不同，可以被重载</p>\n</blockquote>\n<h5 id=\"3-1-bitwise-constness-和-logical-constness\"><a href=\"#3-1-bitwise-constness-和-logical-constness\" class=\"headerlink\" title=\"3.1 bitwise constness 和 logical constness\"></a>3.1 bitwise constness 和 logical constness</h5><p><code>bitwise</code>常量性是编译器规定的，表示对象内部的任何一个字节都不被修改，但这种常量性无法保证成员指针指向的data不被修改。</p>\n<p><code>logical</code>常量性比较宽松，主张一个const成员函数可以修改它所处理的对象内的某些bits，但只有在客户端侦测不出的情况下才行。具体实现要用<code>mutable</code>关键字，指出那些无关紧要的变量，这些变量即使在const成员函数内也可以被修改。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CTextBlock</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    ...</span><br><span class=\"line\">\t<span class=\"function\">std::<span class=\"keyword\">size_t</span> <span class=\"title\">length</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">char</span>* pText;</span><br><span class=\"line\">    <span class=\"keyword\">mutable</span> std::<span class=\"keyword\">size_t</span> textLength; <span class=\"comment\">// 可被const函数修改</span></span><br><span class=\"line\">    <span class=\"keyword\">mutable</span> <span class=\"keyword\">bool</span> lengthIsValid;\t\t<span class=\"comment\">// 可被const函数修改</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">std::<span class=\"keyword\">size_t</span> <span class=\"title\">CTextBlock::length</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 可以对 textLength 和 lengthIsValid 进行修改</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"3-2-用const成员函数实现non-const成员函数\"><a href=\"#3-2-用const成员函数实现non-const成员函数\" class=\"headerlink\" title=\"3.2 用const成员函数实现non-const成员函数\"></a>3.2 用const成员函数实现non-const成员函数</h5><p>为了避免代码重复，有时需要这么做，方法是使用转型（casting）</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TextBlock</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    ...</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>&amp; <span class=\"keyword\">operator</span>[](std::<span class=\"keyword\">size_t</span> position) <span class=\"keyword\">const</span> </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> text[position];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">char</span>&amp; <span class=\"keyword\">operator</span>[](std::<span class=\"keyword\">size_t</span> position)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> </span><br><span class=\"line\">            <span class=\"keyword\">const_cast</span>&lt;<span class=\"keyword\">char</span>&amp;&gt;(</span><br><span class=\"line\">            <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">const</span> TextBlock&amp;&gt;(*<span class=\"keyword\">this</span>)[position]</span><br><span class=\"line\">                                );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">char</span>* pText;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这里有两次转型，第一次用来为 *this 添加 const，所以调用 operator[] 时可以调用其 const 版本，然后第二次转型从 const operator[] 的返回值中移除 const</p>\n"},{"_content":"#### 1. 区分初始化（initialization）与赋值（assignment）\n\n```cpp\nclass PhoneNumber {...};\nclass ABEntry {\npublic:\n    ABEntry(const std::string& name, const std::string& address, const std::list<PhoneNumber>& phones);\nprivate:\n    std::string theName;\n    std::string theAddress;\n    std::list<PhoneNumber> thePhones;\n    int numTimesConsulted;\n};\nABEntry::ABEntry(const std::string& name, const std::string& address, const std::list<PhoneNumber>& phones){\n\ttheName = name;  \t \t//构造函数体内的对对成员对象的操作都是赋值，而非初始化\n    theAddress = address; \n    thePhones = phones;\n    numTimesConsulted = 0;  //对于内置类型，不保证会有一个提前初始化动作\n}\n```\n\nC++规定，对象的成员变量的初始化动作发生在进入构造函数本体之前。上述构造函数体中的形如`theName = name;`的语句都是赋值，初始化动作发生在进入构造函数本体之前。\n\n在进入构造函数体之前，类成员对象的<u>默认构造函数</u>会被调用，以进行初始化动作。这里之所以是<u>默认构造函数</u>被调用，是因为这些对象在初始化时没有参数传入，自然就会调用默认构造函数了。而用初始化列表（member initialization list）可以在其初始化时引入参数，代替默认行为。\n\n```cpp\nABEntry::ABEntry(const std::string& name, const std::string& address, const std::list<PhoneNumber>& phones)\n:theName(name),\n theAddress(address),\n thePhones(phones),\n numTimesConsulted(0)\n{}\n```\n\n用初始化列表，只会有<u>一次</u>类成员对象的<u>拷贝构造函数</u>被调用，传入copy构造函数的参数，以进行初始化。而之前在构造函数体内进行赋值的操作会有初始化、赋值两个动作：\n\n1. 默认构造函数初始化\n2. 赋值运算符重载函数\n\n所以，用初始化列表往往更高效\n\n在某些情况下， 必须使用初始化，不能用赋值。例如类成员是`const`或`引用`，这些类型不能被赋值，只能被初始化，所以它们不能放在构造函数体内，只能用初始化列表。\n\n> 注意，成员变量的初始化顺序只跟它们的声明顺序有关，跟它们在初始化列表中的顺序无关\n\n#### 2. ”不同编译单元内定义之non-local static 对象“的初始化次序\n\nstatic对象的寿命从被构造出来直到程序结束为止\n\n##### 2.1 non-local static\n\n所谓`non-local static`对象，就是<u>在函数内</u>的`static`对象，其他对象都被称为`non-local static`对象\n\n##### 2.2 编译单元\n\n所谓编译单元（translation unit）是指产出单一目标文件（single object file）的那些源码。基本上，它是单一源码文件加上其所含入的头文件（#iinclude files）\n\n##### 2.3 初始化次序问题\n\n当两个及以上的编译单元内都存在non-local static对象，这些static对象可以互相看见\n\n关键问题是：如果某个编译单元内的non-local static对象的初始化动作使用了另一编译单元内的某个non-local static对象，它所用到的这个对象可能还没有被初始化。<u>因为C++对定义于不同编译单元内的non-local static对象的初始化次序并无明确定义</u>\n\n##### 2.4 解决方案 \n\n将每个non-local static对象搬到自己的专属函数内，这些函数返回一个引用reference指向它所含的对象，然后用户调用这些函数，而不直接使用这些对象。本质上就是用local static对象替换non-local static对象。\n\n**<u>*C++保证，函数内的local static对象会在”该函数被调用期间“”首次遇到该对象定义式“时被初始化*</u>**\n\n所以，用户想使用那个对象，而调用函数时， 可以保证函数返回的reference是一个已经被初始化过了的对象。而且，仅当该函数被调用时，其中的local static对象才会进行构造初始化，所以如果从未调用该函数，就不会有构造、析构成本。\n\n> 内含static对象的函数在多线程环境下带有不确定性\n\n##### 2.5 应用场景：单例模式\n\n先来看看C++单例模式的经典实现（Meyers' Singleton）：\n\n```cpp\nclass Singleton {\npublic:\n    static Singleton& getInstance(){\n        static Singleton inst;\n        return inst;\n    }\n    Singleton(const Singleton&) = delete; //不准使用拷贝构造函数【使用delete也防止它被编译器自动生成？】\n    Singleton& operator=(const Singleton&) = delete;\n    //其他数据函数\n    //...\nprivate:\n    Singleton() {...}\n    //其他数据函数\n    //...\n}\n```\n\n> 注意：C++11已经规定static变量是线程安全的了，所以无需我们自己写加锁保护的代码，编译器可以帮我们做到。所以C++单例模式不需要考虑`double check`或`volatile`了\n\n将静态单例的定义放在函数内，形成局部静态变量，保证在用户第一次调用`getInstance()`时，`inst`才会被构造出来，所以用户不用担想获得单例时，单例还没有被初始化的困境，解决了“不同文件里的static变量的初始化顺序问题”。同时，如果没有调用`getInstance()`，就不会产生构造`inst`的开销。\n\n","source":"_posts/C++/《effective C++ 第三版》读书笔记/1. 让自己习惯C++/条款04：确定对象被使用前已先被初始化.md","raw":"#### 1. 区分初始化（initialization）与赋值（assignment）\n\n```cpp\nclass PhoneNumber {...};\nclass ABEntry {\npublic:\n    ABEntry(const std::string& name, const std::string& address, const std::list<PhoneNumber>& phones);\nprivate:\n    std::string theName;\n    std::string theAddress;\n    std::list<PhoneNumber> thePhones;\n    int numTimesConsulted;\n};\nABEntry::ABEntry(const std::string& name, const std::string& address, const std::list<PhoneNumber>& phones){\n\ttheName = name;  \t \t//构造函数体内的对对成员对象的操作都是赋值，而非初始化\n    theAddress = address; \n    thePhones = phones;\n    numTimesConsulted = 0;  //对于内置类型，不保证会有一个提前初始化动作\n}\n```\n\nC++规定，对象的成员变量的初始化动作发生在进入构造函数本体之前。上述构造函数体中的形如`theName = name;`的语句都是赋值，初始化动作发生在进入构造函数本体之前。\n\n在进入构造函数体之前，类成员对象的<u>默认构造函数</u>会被调用，以进行初始化动作。这里之所以是<u>默认构造函数</u>被调用，是因为这些对象在初始化时没有参数传入，自然就会调用默认构造函数了。而用初始化列表（member initialization list）可以在其初始化时引入参数，代替默认行为。\n\n```cpp\nABEntry::ABEntry(const std::string& name, const std::string& address, const std::list<PhoneNumber>& phones)\n:theName(name),\n theAddress(address),\n thePhones(phones),\n numTimesConsulted(0)\n{}\n```\n\n用初始化列表，只会有<u>一次</u>类成员对象的<u>拷贝构造函数</u>被调用，传入copy构造函数的参数，以进行初始化。而之前在构造函数体内进行赋值的操作会有初始化、赋值两个动作：\n\n1. 默认构造函数初始化\n2. 赋值运算符重载函数\n\n所以，用初始化列表往往更高效\n\n在某些情况下， 必须使用初始化，不能用赋值。例如类成员是`const`或`引用`，这些类型不能被赋值，只能被初始化，所以它们不能放在构造函数体内，只能用初始化列表。\n\n> 注意，成员变量的初始化顺序只跟它们的声明顺序有关，跟它们在初始化列表中的顺序无关\n\n#### 2. ”不同编译单元内定义之non-local static 对象“的初始化次序\n\nstatic对象的寿命从被构造出来直到程序结束为止\n\n##### 2.1 non-local static\n\n所谓`non-local static`对象，就是<u>在函数内</u>的`static`对象，其他对象都被称为`non-local static`对象\n\n##### 2.2 编译单元\n\n所谓编译单元（translation unit）是指产出单一目标文件（single object file）的那些源码。基本上，它是单一源码文件加上其所含入的头文件（#iinclude files）\n\n##### 2.3 初始化次序问题\n\n当两个及以上的编译单元内都存在non-local static对象，这些static对象可以互相看见\n\n关键问题是：如果某个编译单元内的non-local static对象的初始化动作使用了另一编译单元内的某个non-local static对象，它所用到的这个对象可能还没有被初始化。<u>因为C++对定义于不同编译单元内的non-local static对象的初始化次序并无明确定义</u>\n\n##### 2.4 解决方案 \n\n将每个non-local static对象搬到自己的专属函数内，这些函数返回一个引用reference指向它所含的对象，然后用户调用这些函数，而不直接使用这些对象。本质上就是用local static对象替换non-local static对象。\n\n**<u>*C++保证，函数内的local static对象会在”该函数被调用期间“”首次遇到该对象定义式“时被初始化*</u>**\n\n所以，用户想使用那个对象，而调用函数时， 可以保证函数返回的reference是一个已经被初始化过了的对象。而且，仅当该函数被调用时，其中的local static对象才会进行构造初始化，所以如果从未调用该函数，就不会有构造、析构成本。\n\n> 内含static对象的函数在多线程环境下带有不确定性\n\n##### 2.5 应用场景：单例模式\n\n先来看看C++单例模式的经典实现（Meyers' Singleton）：\n\n```cpp\nclass Singleton {\npublic:\n    static Singleton& getInstance(){\n        static Singleton inst;\n        return inst;\n    }\n    Singleton(const Singleton&) = delete; //不准使用拷贝构造函数【使用delete也防止它被编译器自动生成？】\n    Singleton& operator=(const Singleton&) = delete;\n    //其他数据函数\n    //...\nprivate:\n    Singleton() {...}\n    //其他数据函数\n    //...\n}\n```\n\n> 注意：C++11已经规定static变量是线程安全的了，所以无需我们自己写加锁保护的代码，编译器可以帮我们做到。所以C++单例模式不需要考虑`double check`或`volatile`了\n\n将静态单例的定义放在函数内，形成局部静态变量，保证在用户第一次调用`getInstance()`时，`inst`才会被构造出来，所以用户不用担想获得单例时，单例还没有被初始化的困境，解决了“不同文件里的static变量的初始化顺序问题”。同时，如果没有调用`getInstance()`，就不会产生构造`inst`的开销。\n\n","slug":"C++/《effective C++ 第三版》读书笔记/1. 让自己习惯C++/条款04：确定对象被使用前已先被初始化","published":1,"date":"2022-05-28T02:07:22.634Z","updated":"2022-06-08T00:01:37.945Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0kyi002epcu3ag0wfgwd","content":"<h4 id=\"1-区分初始化（initialization）与赋值（assignment）\"><a href=\"#1-区分初始化（initialization）与赋值（assignment）\" class=\"headerlink\" title=\"1. 区分初始化（initialization）与赋值（assignment）\"></a>1. 区分初始化（initialization）与赋值（assignment）</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PhoneNumber</span> &#123;</span>...&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ABEntry</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">ABEntry</span>(<span class=\"keyword\">const</span> std::string&amp; name, <span class=\"keyword\">const</span> std::string&amp; address, <span class=\"keyword\">const</span> std::list&lt;PhoneNumber&gt;&amp; phones);</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    std::string theName;</span><br><span class=\"line\">    std::string theAddress;</span><br><span class=\"line\">    std::list&lt;PhoneNumber&gt; thePhones;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> numTimesConsulted;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">ABEntry::<span class=\"built_in\">ABEntry</span>(<span class=\"keyword\">const</span> std::string&amp; name, <span class=\"keyword\">const</span> std::string&amp; address, <span class=\"keyword\">const</span> std::list&lt;PhoneNumber&gt;&amp; phones)&#123;</span><br><span class=\"line\">\ttheName = name;  \t \t<span class=\"comment\">//构造函数体内的对对成员对象的操作都是赋值，而非初始化</span></span><br><span class=\"line\">    theAddress = address; </span><br><span class=\"line\">    thePhones = phones;</span><br><span class=\"line\">    numTimesConsulted = <span class=\"number\">0</span>;  <span class=\"comment\">//对于内置类型，不保证会有一个提前初始化动作</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>C++规定，对象的成员变量的初始化动作发生在进入构造函数本体之前。上述构造函数体中的形如<code>theName = name;</code>的语句都是赋值，初始化动作发生在进入构造函数本体之前。</p>\n<p>在进入构造函数体之前，类成员对象的<u>默认构造函数</u>会被调用，以进行初始化动作。这里之所以是<u>默认构造函数</u>被调用，是因为这些对象在初始化时没有参数传入，自然就会调用默认构造函数了。而用初始化列表（member initialization list）可以在其初始化时引入参数，代替默认行为。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ABEntry::<span class=\"built_in\">ABEntry</span>(<span class=\"keyword\">const</span> std::string&amp; name, <span class=\"keyword\">const</span> std::string&amp; address, <span class=\"keyword\">const</span> std::list&lt;PhoneNumber&gt;&amp; phones)</span><br><span class=\"line\">:<span class=\"built_in\">theName</span>(name),</span><br><span class=\"line\"> <span class=\"built_in\">theAddress</span>(address),</span><br><span class=\"line\"> <span class=\"built_in\">thePhones</span>(phones),</span><br><span class=\"line\"> <span class=\"built_in\">numTimesConsulted</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>用初始化列表，只会有<u>一次</u>类成员对象的<u>拷贝构造函数</u>被调用，传入copy构造函数的参数，以进行初始化。而之前在构造函数体内进行赋值的操作会有初始化、赋值两个动作：</p>\n<ol>\n<li>默认构造函数初始化</li>\n<li>赋值运算符重载函数</li>\n</ol>\n<p>所以，用初始化列表往往更高效</p>\n<p>在某些情况下， 必须使用初始化，不能用赋值。例如类成员是<code>const</code>或<code>引用</code>，这些类型不能被赋值，只能被初始化，所以它们不能放在构造函数体内，只能用初始化列表。</p>\n<blockquote>\n<p>注意，成员变量的初始化顺序只跟它们的声明顺序有关，跟它们在初始化列表中的顺序无关</p>\n</blockquote>\n<h4 id=\"2-”不同编译单元内定义之non-local-static-对象“的初始化次序\"><a href=\"#2-”不同编译单元内定义之non-local-static-对象“的初始化次序\" class=\"headerlink\" title=\"2. ”不同编译单元内定义之non-local static 对象“的初始化次序\"></a>2. ”不同编译单元内定义之non-local static 对象“的初始化次序</h4><p>static对象的寿命从被构造出来直到程序结束为止</p>\n<h5 id=\"2-1-non-local-static\"><a href=\"#2-1-non-local-static\" class=\"headerlink\" title=\"2.1 non-local static\"></a>2.1 non-local static</h5><p>所谓<code>non-local static</code>对象，就是<u>在函数内</u>的<code>static</code>对象，其他对象都被称为<code>non-local static</code>对象</p>\n<h5 id=\"2-2-编译单元\"><a href=\"#2-2-编译单元\" class=\"headerlink\" title=\"2.2 编译单元\"></a>2.2 编译单元</h5><p>所谓编译单元（translation unit）是指产出单一目标文件（single object file）的那些源码。基本上，它是单一源码文件加上其所含入的头文件（#iinclude files）</p>\n<h5 id=\"2-3-初始化次序问题\"><a href=\"#2-3-初始化次序问题\" class=\"headerlink\" title=\"2.3 初始化次序问题\"></a>2.3 初始化次序问题</h5><p>当两个及以上的编译单元内都存在non-local static对象，这些static对象可以互相看见</p>\n<p>关键问题是：如果某个编译单元内的non-local static对象的初始化动作使用了另一编译单元内的某个non-local static对象，它所用到的这个对象可能还没有被初始化。<u>因为C++对定义于不同编译单元内的non-local static对象的初始化次序并无明确定义</u></p>\n<h5 id=\"2-4-解决方案\"><a href=\"#2-4-解决方案\" class=\"headerlink\" title=\"2.4 解决方案\"></a>2.4 解决方案</h5><p>将每个non-local static对象搬到自己的专属函数内，这些函数返回一个引用reference指向它所含的对象，然后用户调用这些函数，而不直接使用这些对象。本质上就是用local static对象替换non-local static对象。</p>\n<p><strong><u><em>C++保证，函数内的local static对象会在”该函数被调用期间“”首次遇到该对象定义式“时被初始化</em></u></strong></p>\n<p>所以，用户想使用那个对象，而调用函数时， 可以保证函数返回的reference是一个已经被初始化过了的对象。而且，仅当该函数被调用时，其中的local static对象才会进行构造初始化，所以如果从未调用该函数，就不会有构造、析构成本。</p>\n<blockquote>\n<p>内含static对象的函数在多线程环境下带有不确定性</p>\n</blockquote>\n<h5 id=\"2-5-应用场景：单例模式\"><a href=\"#2-5-应用场景：单例模式\" class=\"headerlink\" title=\"2.5 应用场景：单例模式\"></a>2.5 应用场景：单例模式</h5><p>先来看看C++单例模式的经典实现（Meyers’ Singleton）：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> Singleton&amp; <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">static</span> Singleton inst;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> inst;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">Singleton</span>(<span class=\"keyword\">const</span> Singleton&amp;) = <span class=\"keyword\">delete</span>; <span class=\"comment\">//不准使用拷贝构造函数【使用delete也防止它被编译器自动生成？】</span></span><br><span class=\"line\">    Singleton&amp; <span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> Singleton&amp;) = <span class=\"keyword\">delete</span>;</span><br><span class=\"line\">    <span class=\"comment\">//其他数据函数</span></span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Singleton</span>() &#123;...&#125;</span><br><span class=\"line\">    <span class=\"comment\">//其他数据函数</span></span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：C++11已经规定static变量是线程安全的了，所以无需我们自己写加锁保护的代码，编译器可以帮我们做到。所以C++单例模式不需要考虑<code>double check</code>或<code>volatile</code>了</p>\n</blockquote>\n<p>将静态单例的定义放在函数内，形成局部静态变量，保证在用户第一次调用<code>getInstance()</code>时，<code>inst</code>才会被构造出来，所以用户不用担想获得单例时，单例还没有被初始化的困境，解决了“不同文件里的static变量的初始化顺序问题”。同时，如果没有调用<code>getInstance()</code>，就不会产生构造<code>inst</code>的开销。</p>\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<h4 id=\"1-区分初始化（initialization）与赋值（assignment）\"><a href=\"#1-区分初始化（initialization）与赋值（assignment）\" class=\"headerlink\" title=\"1. 区分初始化（initialization）与赋值（assignment）\"></a>1. 区分初始化（initialization）与赋值（assignment）</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PhoneNumber</span> &#123;</span>...&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ABEntry</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">ABEntry</span>(<span class=\"keyword\">const</span> std::string&amp; name, <span class=\"keyword\">const</span> std::string&amp; address, <span class=\"keyword\">const</span> std::list&lt;PhoneNumber&gt;&amp; phones);</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    std::string theName;</span><br><span class=\"line\">    std::string theAddress;</span><br><span class=\"line\">    std::list&lt;PhoneNumber&gt; thePhones;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> numTimesConsulted;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">ABEntry::<span class=\"built_in\">ABEntry</span>(<span class=\"keyword\">const</span> std::string&amp; name, <span class=\"keyword\">const</span> std::string&amp; address, <span class=\"keyword\">const</span> std::list&lt;PhoneNumber&gt;&amp; phones)&#123;</span><br><span class=\"line\">\ttheName = name;  \t \t<span class=\"comment\">//构造函数体内的对对成员对象的操作都是赋值，而非初始化</span></span><br><span class=\"line\">    theAddress = address; </span><br><span class=\"line\">    thePhones = phones;</span><br><span class=\"line\">    numTimesConsulted = <span class=\"number\">0</span>;  <span class=\"comment\">//对于内置类型，不保证会有一个提前初始化动作</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>C++规定，对象的成员变量的初始化动作发生在进入构造函数本体之前。上述构造函数体中的形如<code>theName = name;</code>的语句都是赋值，初始化动作发生在进入构造函数本体之前。</p>\n<p>在进入构造函数体之前，类成员对象的<u>默认构造函数</u>会被调用，以进行初始化动作。这里之所以是<u>默认构造函数</u>被调用，是因为这些对象在初始化时没有参数传入，自然就会调用默认构造函数了。而用初始化列表（member initialization list）可以在其初始化时引入参数，代替默认行为。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ABEntry::<span class=\"built_in\">ABEntry</span>(<span class=\"keyword\">const</span> std::string&amp; name, <span class=\"keyword\">const</span> std::string&amp; address, <span class=\"keyword\">const</span> std::list&lt;PhoneNumber&gt;&amp; phones)</span><br><span class=\"line\">:<span class=\"built_in\">theName</span>(name),</span><br><span class=\"line\"> <span class=\"built_in\">theAddress</span>(address),</span><br><span class=\"line\"> <span class=\"built_in\">thePhones</span>(phones),</span><br><span class=\"line\"> <span class=\"built_in\">numTimesConsulted</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>用初始化列表，只会有<u>一次</u>类成员对象的<u>拷贝构造函数</u>被调用，传入copy构造函数的参数，以进行初始化。而之前在构造函数体内进行赋值的操作会有初始化、赋值两个动作：</p>\n<ol>\n<li>默认构造函数初始化</li>\n<li>赋值运算符重载函数</li>\n</ol>\n<p>所以，用初始化列表往往更高效</p>\n<p>在某些情况下， 必须使用初始化，不能用赋值。例如类成员是<code>const</code>或<code>引用</code>，这些类型不能被赋值，只能被初始化，所以它们不能放在构造函数体内，只能用初始化列表。</p>\n<blockquote>\n<p>注意，成员变量的初始化顺序只跟它们的声明顺序有关，跟它们在初始化列表中的顺序无关</p>\n</blockquote>\n<h4 id=\"2-”不同编译单元内定义之non-local-static-对象“的初始化次序\"><a href=\"#2-”不同编译单元内定义之non-local-static-对象“的初始化次序\" class=\"headerlink\" title=\"2. ”不同编译单元内定义之non-local static 对象“的初始化次序\"></a>2. ”不同编译单元内定义之non-local static 对象“的初始化次序</h4><p>static对象的寿命从被构造出来直到程序结束为止</p>\n<h5 id=\"2-1-non-local-static\"><a href=\"#2-1-non-local-static\" class=\"headerlink\" title=\"2.1 non-local static\"></a>2.1 non-local static</h5><p>所谓<code>non-local static</code>对象，就是<u>在函数内</u>的<code>static</code>对象，其他对象都被称为<code>non-local static</code>对象</p>\n<h5 id=\"2-2-编译单元\"><a href=\"#2-2-编译单元\" class=\"headerlink\" title=\"2.2 编译单元\"></a>2.2 编译单元</h5><p>所谓编译单元（translation unit）是指产出单一目标文件（single object file）的那些源码。基本上，它是单一源码文件加上其所含入的头文件（#iinclude files）</p>\n<h5 id=\"2-3-初始化次序问题\"><a href=\"#2-3-初始化次序问题\" class=\"headerlink\" title=\"2.3 初始化次序问题\"></a>2.3 初始化次序问题</h5><p>当两个及以上的编译单元内都存在non-local static对象，这些static对象可以互相看见</p>\n<p>关键问题是：如果某个编译单元内的non-local static对象的初始化动作使用了另一编译单元内的某个non-local static对象，它所用到的这个对象可能还没有被初始化。<u>因为C++对定义于不同编译单元内的non-local static对象的初始化次序并无明确定义</u></p>\n<h5 id=\"2-4-解决方案\"><a href=\"#2-4-解决方案\" class=\"headerlink\" title=\"2.4 解决方案\"></a>2.4 解决方案</h5><p>将每个non-local static对象搬到自己的专属函数内，这些函数返回一个引用reference指向它所含的对象，然后用户调用这些函数，而不直接使用这些对象。本质上就是用local static对象替换non-local static对象。</p>\n<p><strong><u><em>C++保证，函数内的local static对象会在”该函数被调用期间“”首次遇到该对象定义式“时被初始化</em></u></strong></p>\n<p>所以，用户想使用那个对象，而调用函数时， 可以保证函数返回的reference是一个已经被初始化过了的对象。而且，仅当该函数被调用时，其中的local static对象才会进行构造初始化，所以如果从未调用该函数，就不会有构造、析构成本。</p>\n<blockquote>\n<p>内含static对象的函数在多线程环境下带有不确定性</p>\n</blockquote>\n<h5 id=\"2-5-应用场景：单例模式\"><a href=\"#2-5-应用场景：单例模式\" class=\"headerlink\" title=\"2.5 应用场景：单例模式\"></a>2.5 应用场景：单例模式</h5><p>先来看看C++单例模式的经典实现（Meyers’ Singleton）：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> Singleton&amp; <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">static</span> Singleton inst;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> inst;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">Singleton</span>(<span class=\"keyword\">const</span> Singleton&amp;) = <span class=\"keyword\">delete</span>; <span class=\"comment\">//不准使用拷贝构造函数【使用delete也防止它被编译器自动生成？】</span></span><br><span class=\"line\">    Singleton&amp; <span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> Singleton&amp;) = <span class=\"keyword\">delete</span>;</span><br><span class=\"line\">    <span class=\"comment\">//其他数据函数</span></span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Singleton</span>() &#123;...&#125;</span><br><span class=\"line\">    <span class=\"comment\">//其他数据函数</span></span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：C++11已经规定static变量是线程安全的了，所以无需我们自己写加锁保护的代码，编译器可以帮我们做到。所以C++单例模式不需要考虑<code>double check</code>或<code>volatile</code>了</p>\n</blockquote>\n<p>将静态单例的定义放在函数内，形成局部静态变量，保证在用户第一次调用<code>getInstance()</code>时，<code>inst</code>才会被构造出来，所以用户不用担想获得单例时，单例还没有被初始化的困境，解决了“不同文件里的static变量的初始化顺序问题”。同时，如果没有调用<code>getInstance()</code>，就不会产生构造<code>inst</code>的开销。</p>\n"},{"_content":"对于一个空类\n\n```cpp\nclass Empty{};\n```\n\n C++编译器会自动为它添加一些代码，其等价于：\n\n```cpp\nclass Empty{\npublic:\n    Empty() {...}  \t\t\t\t\t\t\t\t//default构造函数\n    Empty(const Empty& rhs) {...}\t\t\t\t //copy构造函数\n    ~Empty() {...}\t\t\t\t\t\t\t    //析构函数\n  \n    Empty& operator=(const Empty& rhs) {...}\t  //copy assignment 操作符\n};\n```\n\n> 注意：\n>\n> - 这些函数都是 public inline 的\n>- 当且仅当这些函数被调用，编译器才会把它们创建出来\n> - 编译器产出的析构函数是 non-virtual 的，除非这个 class 的 base class 自身有 virtual 析构函数\n\n这些函数做了什么？\n\n- 编译器会在default构造函数里放一些通用代码，比如：调用`base classes`和`non-staic`成员变量的构造函数和析构函数\n\n- 对于 copy 构造函数和 copy assignment 操作符重载函数，编译器创建的版本只是简单地将来源对象的每一个 non-static 成员变量拷贝到目标对象（浅拷贝）\n\n编译器拒绝产生 copy assignment 操作符的情况\n\n1. 如果一个类内存在引用类型的成员变量（reference 成员）、const 成员，它们无法被赋值，编译器就不会为这个类生成 copy assignment 操作符重载函数，需要用户自己定义 copy assignment 操作符\n\n2. 如果 base class 将 copy assignment 操作符声明为 private，编译器也不会为其 derived class 生成 copy assignment 操作符，因为编译器生成的版本默认是可以处理其 base class 的成分的，但因为 derived class 无法访问其 base class 的 copy assignment 操作符（private），所以编译器不知道该怎么办了\n\n","source":"_posts/C++/《effective C++ 第三版》读书笔记/2. 构造、析构、赋值运算/条款 05：了解C++默认编写并调用了哪些函数.md","raw":"对于一个空类\n\n```cpp\nclass Empty{};\n```\n\n C++编译器会自动为它添加一些代码，其等价于：\n\n```cpp\nclass Empty{\npublic:\n    Empty() {...}  \t\t\t\t\t\t\t\t//default构造函数\n    Empty(const Empty& rhs) {...}\t\t\t\t //copy构造函数\n    ~Empty() {...}\t\t\t\t\t\t\t    //析构函数\n  \n    Empty& operator=(const Empty& rhs) {...}\t  //copy assignment 操作符\n};\n```\n\n> 注意：\n>\n> - 这些函数都是 public inline 的\n>- 当且仅当这些函数被调用，编译器才会把它们创建出来\n> - 编译器产出的析构函数是 non-virtual 的，除非这个 class 的 base class 自身有 virtual 析构函数\n\n这些函数做了什么？\n\n- 编译器会在default构造函数里放一些通用代码，比如：调用`base classes`和`non-staic`成员变量的构造函数和析构函数\n\n- 对于 copy 构造函数和 copy assignment 操作符重载函数，编译器创建的版本只是简单地将来源对象的每一个 non-static 成员变量拷贝到目标对象（浅拷贝）\n\n编译器拒绝产生 copy assignment 操作符的情况\n\n1. 如果一个类内存在引用类型的成员变量（reference 成员）、const 成员，它们无法被赋值，编译器就不会为这个类生成 copy assignment 操作符重载函数，需要用户自己定义 copy assignment 操作符\n\n2. 如果 base class 将 copy assignment 操作符声明为 private，编译器也不会为其 derived class 生成 copy assignment 操作符，因为编译器生成的版本默认是可以处理其 base class 的成分的，但因为 derived class 无法访问其 base class 的 copy assignment 操作符（private），所以编译器不知道该怎么办了\n\n","slug":"C++/《effective C++ 第三版》读书笔记/2. 构造、析构、赋值运算/条款 05：了解C++默认编写并调用了哪些函数","published":1,"date":"2022-06-08T00:53:19.545Z","updated":"2022-06-08T01:25:57.504Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0kyj002gpcu37kxv8hjv","content":"<p>对于一个空类</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Empty</span>&#123;</span>&#125;;</span><br></pre></td></tr></table></figure>\n\n<p> C++编译器会自动为它添加一些代码，其等价于：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Empty</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Empty</span>() &#123;...&#125;  \t\t\t\t\t\t\t\t<span class=\"comment\">//default构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">Empty</span>(<span class=\"keyword\">const</span> Empty&amp; rhs) &#123;...&#125;\t\t\t\t <span class=\"comment\">//copy构造函数</span></span><br><span class=\"line\">    ~<span class=\"built_in\">Empty</span>() &#123;...&#125;\t\t\t\t\t\t\t    <span class=\"comment\">//析构函数</span></span><br><span class=\"line\">  </span><br><span class=\"line\">    Empty&amp; <span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> Empty&amp; rhs) &#123;...&#125;\t  <span class=\"comment\">//copy assignment 操作符</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：</p>\n<ul>\n<li>这些函数都是 public inline 的</li>\n<li>当且仅当这些函数被调用，编译器才会把它们创建出来</li>\n<li>编译器产出的析构函数是 non-virtual 的，除非这个 class 的 base class 自身有 virtual 析构函数</li>\n</ul>\n</blockquote>\n<p>这些函数做了什么？</p>\n<ul>\n<li><p>编译器会在default构造函数里放一些通用代码，比如：调用<code>base classes</code>和<code>non-staic</code>成员变量的构造函数和析构函数</p>\n</li>\n<li><p>对于 copy 构造函数和 copy assignment 操作符重载函数，编译器创建的版本只是简单地将来源对象的每一个 non-static 成员变量拷贝到目标对象（浅拷贝）</p>\n</li>\n</ul>\n<p>编译器拒绝产生 copy assignment 操作符的情况</p>\n<ol>\n<li><p>如果一个类内存在引用类型的成员变量（reference 成员）、const 成员，它们无法被赋值，编译器就不会为这个类生成 copy assignment 操作符重载函数，需要用户自己定义 copy assignment 操作符</p>\n</li>\n<li><p>如果 base class 将 copy assignment 操作符声明为 private，编译器也不会为其 derived class 生成 copy assignment 操作符，因为编译器生成的版本默认是可以处理其 base class 的成分的，但因为 derived class 无法访问其 base class 的 copy assignment 操作符（private），所以编译器不知道该怎么办了</p>\n</li>\n</ol>\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<p>对于一个空类</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Empty</span>&#123;</span>&#125;;</span><br></pre></td></tr></table></figure>\n\n<p> C++编译器会自动为它添加一些代码，其等价于：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Empty</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Empty</span>() &#123;...&#125;  \t\t\t\t\t\t\t\t<span class=\"comment\">//default构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">Empty</span>(<span class=\"keyword\">const</span> Empty&amp; rhs) &#123;...&#125;\t\t\t\t <span class=\"comment\">//copy构造函数</span></span><br><span class=\"line\">    ~<span class=\"built_in\">Empty</span>() &#123;...&#125;\t\t\t\t\t\t\t    <span class=\"comment\">//析构函数</span></span><br><span class=\"line\">  </span><br><span class=\"line\">    Empty&amp; <span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> Empty&amp; rhs) &#123;...&#125;\t  <span class=\"comment\">//copy assignment 操作符</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：</p>\n<ul>\n<li>这些函数都是 public inline 的</li>\n<li>当且仅当这些函数被调用，编译器才会把它们创建出来</li>\n<li>编译器产出的析构函数是 non-virtual 的，除非这个 class 的 base class 自身有 virtual 析构函数</li>\n</ul>\n</blockquote>\n<p>这些函数做了什么？</p>\n<ul>\n<li><p>编译器会在default构造函数里放一些通用代码，比如：调用<code>base classes</code>和<code>non-staic</code>成员变量的构造函数和析构函数</p>\n</li>\n<li><p>对于 copy 构造函数和 copy assignment 操作符重载函数，编译器创建的版本只是简单地将来源对象的每一个 non-static 成员变量拷贝到目标对象（浅拷贝）</p>\n</li>\n</ul>\n<p>编译器拒绝产生 copy assignment 操作符的情况</p>\n<ol>\n<li><p>如果一个类内存在引用类型的成员变量（reference 成员）、const 成员，它们无法被赋值，编译器就不会为这个类生成 copy assignment 操作符重载函数，需要用户自己定义 copy assignment 操作符</p>\n</li>\n<li><p>如果 base class 将 copy assignment 操作符声明为 private，编译器也不会为其 derived class 生成 copy assignment 操作符，因为编译器生成的版本默认是可以处理其 base class 的成分的，但因为 derived class 无法访问其 base class 的 copy assignment 操作符（private），所以编译器不知道该怎么办了</p>\n</li>\n</ol>\n"},{"_content":"```cpp\nclass Base{};\nclass Derived : Base {};\nBase* b1 = new Derived();\ndelete b1;\n```\n\n当一个`Base`类指针指向一个`derived`类对象，那么要求`Base`类中的析构函数一定要被声明为`virtual`。否则会发生未定义行为，通常是对象的 derived 部分没有被销毁（只调用了基类的析构函数，而基类的`non-virtual`析构函数只负责销毁基类的成员）\n\n析构函数的运作方式是：最深层派生（most derived）类的析构函数会最先被调用，然后其每一个 base class 的析构函数会被调用。<u>编译器会在 derived class 的析构函数中创建一个对其直接基类的析构函数的调用动作。</u>\n\n\n\n","source":"_posts/C++/《effective C++ 第三版》读书笔记/2. 构造、析构、赋值运算/条款 07：为多态基类声明 virtual 析构函数.md","raw":"```cpp\nclass Base{};\nclass Derived : Base {};\nBase* b1 = new Derived();\ndelete b1;\n```\n\n当一个`Base`类指针指向一个`derived`类对象，那么要求`Base`类中的析构函数一定要被声明为`virtual`。否则会发生未定义行为，通常是对象的 derived 部分没有被销毁（只调用了基类的析构函数，而基类的`non-virtual`析构函数只负责销毁基类的成员）\n\n析构函数的运作方式是：最深层派生（most derived）类的析构函数会最先被调用，然后其每一个 base class 的析构函数会被调用。<u>编译器会在 derived class 的析构函数中创建一个对其直接基类的析构函数的调用动作。</u>\n\n\n\n","slug":"C++/《effective C++ 第三版》读书笔记/2. 构造、析构、赋值运算/条款 07：为多态基类声明 virtual 析构函数","published":1,"date":"2022-06-08T03:14:49.754Z","updated":"2022-06-08T03:32:57.158Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0kyj002ipcu333fgc0yx","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span>&#123;</span>&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Derived</span> :</span> Base &#123;&#125;;</span><br><span class=\"line\">Base* b1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Derived</span>();</span><br><span class=\"line\"><span class=\"keyword\">delete</span> b1;</span><br></pre></td></tr></table></figure>\n\n<p>当一个<code>Base</code>类指针指向一个<code>derived</code>类对象，那么要求<code>Base</code>类中的析构函数一定要被声明为<code>virtual</code>。否则会发生未定义行为，通常是对象的 derived 部分没有被销毁（只调用了基类的析构函数，而基类的<code>non-virtual</code>析构函数只负责销毁基类的成员）</p>\n<p>析构函数的运作方式是：最深层派生（most derived）类的析构函数会最先被调用，然后其每一个 base class 的析构函数会被调用。<u>编译器会在 derived class 的析构函数中创建一个对其直接基类的析构函数的调用动作。</u></p>\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span>&#123;</span>&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Derived</span> :</span> Base &#123;&#125;;</span><br><span class=\"line\">Base* b1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Derived</span>();</span><br><span class=\"line\"><span class=\"keyword\">delete</span> b1;</span><br></pre></td></tr></table></figure>\n\n<p>当一个<code>Base</code>类指针指向一个<code>derived</code>类对象，那么要求<code>Base</code>类中的析构函数一定要被声明为<code>virtual</code>。否则会发生未定义行为，通常是对象的 derived 部分没有被销毁（只调用了基类的析构函数，而基类的<code>non-virtual</code>析构函数只负责销毁基类的成员）</p>\n<p>析构函数的运作方式是：最深层派生（most derived）类的析构函数会最先被调用，然后其每一个 base class 的析构函数会被调用。<u>编译器会在 derived class 的析构函数中创建一个对其直接基类的析构函数的调用动作。</u></p>\n"},{"_content":"如何阻止 copy 行为？\n\n不声明 copy 构造函数、copy assignment 操作符并不能阻止 copy 行为，因为编译器还是会自己创建一个默认的版本。\n\n<u>自行将 copy 构造函数、copy assignment 操作符声明为 private，且不给出它们的定义，</u>这即阻止了编译器产生这些函数的默认版本，又阻止了外部对这些函数的调用。同时当使用 member 函数和 friend 函数调用它们的时候，会得到一个 link 错误，因为它们根本就没有定义！\n\nUncopyable函数【挖坑，代填】\n\n现代C++11可以用`delete`来阻止一个函数被使用：\n\n```cpp\nclass Magic {\npublic:\n    Magic() = default;  \t\t\t\t\t//显示声明使用编译器生成的构造函数\n    Magic& opeartor=(const Magic&) = delete;  //显示声明拒绝编译器生成 copy assignment 操作符\n    ...\n}\n```\n","source":"_posts/C++/《effective C++ 第三版》读书笔记/2. 构造、析构、赋值运算/条款 06：若不想使用编译器自动生成的函数，就该明确拒绝.md","raw":"如何阻止 copy 行为？\n\n不声明 copy 构造函数、copy assignment 操作符并不能阻止 copy 行为，因为编译器还是会自己创建一个默认的版本。\n\n<u>自行将 copy 构造函数、copy assignment 操作符声明为 private，且不给出它们的定义，</u>这即阻止了编译器产生这些函数的默认版本，又阻止了外部对这些函数的调用。同时当使用 member 函数和 friend 函数调用它们的时候，会得到一个 link 错误，因为它们根本就没有定义！\n\nUncopyable函数【挖坑，代填】\n\n现代C++11可以用`delete`来阻止一个函数被使用：\n\n```cpp\nclass Magic {\npublic:\n    Magic() = default;  \t\t\t\t\t//显示声明使用编译器生成的构造函数\n    Magic& opeartor=(const Magic&) = delete;  //显示声明拒绝编译器生成 copy assignment 操作符\n    ...\n}\n```\n","slug":"C++/《effective C++ 第三版》读书笔记/2. 构造、析构、赋值运算/条款 06：若不想使用编译器自动生成的函数，就该明确拒绝","published":1,"date":"2022-06-08T01:22:17.299Z","updated":"2022-06-08T03:14:44.576Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0kyk002jpcu39f3a6v4t","content":"<p>如何阻止 copy 行为？</p>\n<p>不声明 copy 构造函数、copy assignment 操作符并不能阻止 copy 行为，因为编译器还是会自己创建一个默认的版本。</p>\n<p><u>自行将 copy 构造函数、copy assignment 操作符声明为 private，且不给出它们的定义，</u>这即阻止了编译器产生这些函数的默认版本，又阻止了外部对这些函数的调用。同时当使用 member 函数和 friend 函数调用它们的时候，会得到一个 link 错误，因为它们根本就没有定义！</p>\n<p>Uncopyable函数【挖坑，代填】</p>\n<p>现代C++11可以用<code>delete</code>来阻止一个函数被使用：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Magic</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Magic</span>() = <span class=\"keyword\">default</span>;  \t\t\t\t\t<span class=\"comment\">//显示声明使用编译器生成的构造函数</span></span><br><span class=\"line\">    Magic&amp; opeartor=(<span class=\"keyword\">const</span> Magic&amp;) = <span class=\"keyword\">delete</span>;  <span class=\"comment\">//显示声明拒绝编译器生成 copy assignment 操作符</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<p>如何阻止 copy 行为？</p>\n<p>不声明 copy 构造函数、copy assignment 操作符并不能阻止 copy 行为，因为编译器还是会自己创建一个默认的版本。</p>\n<p><u>自行将 copy 构造函数、copy assignment 操作符声明为 private，且不给出它们的定义，</u>这即阻止了编译器产生这些函数的默认版本，又阻止了外部对这些函数的调用。同时当使用 member 函数和 friend 函数调用它们的时候，会得到一个 link 错误，因为它们根本就没有定义！</p>\n<p>Uncopyable函数【挖坑，代填】</p>\n<p>现代C++11可以用<code>delete</code>来阻止一个函数被使用：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Magic</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Magic</span>() = <span class=\"keyword\">default</span>;  \t\t\t\t\t<span class=\"comment\">//显示声明使用编译器生成的构造函数</span></span><br><span class=\"line\">    Magic&amp; opeartor=(<span class=\"keyword\">const</span> Magic&amp;) = <span class=\"keyword\">delete</span>;  <span class=\"comment\">//显示声明拒绝编译器生成 copy assignment 操作符</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"_content":"为了实现“连锁赋值”，赋值操作符（或所有赋值相关运算）必须返回一个 reference 指向操作符的左侧实参\n\n```cpp\nclass Widget {\npublic:\n    ...\n\tWidget& operator=(cosnt Widget& rhs)\n    {\n        ...\n\t   return *this;\n    }\n    ...\n}\n```\n\n​\t","source":"_posts/C++/《effective C++ 第三版》读书笔记/2. 构造、析构、赋值运算/条款10：令 operator= 返回一个 reference to [星号]this.md","raw":"为了实现“连锁赋值”，赋值操作符（或所有赋值相关运算）必须返回一个 reference 指向操作符的左侧实参\n\n```cpp\nclass Widget {\npublic:\n    ...\n\tWidget& operator=(cosnt Widget& rhs)\n    {\n        ...\n\t   return *this;\n    }\n    ...\n}\n```\n\n​\t","slug":"C++/《effective C++ 第三版》读书笔记/2. 构造、析构、赋值运算/条款10：令 operator= 返回一个 reference to [星号]this","published":1,"date":"2022-06-08T04:35:18.637Z","updated":"2022-06-08T04:49:28.424Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0kyk002kpcu399jv0ajg","content":"<p>为了实现“连锁赋值”，赋值操作符（或所有赋值相关运算）必须返回一个 reference 指向操作符的左侧实参</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Widget</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    ...</span><br><span class=\"line\">\tWidget&amp; <span class=\"keyword\">operator</span>=(cosnt Widget&amp; rhs)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">\t   <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​    </p>\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<p>为了实现“连锁赋值”，赋值操作符（或所有赋值相关运算）必须返回一个 reference 指向操作符的左侧实参</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Widget</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    ...</span><br><span class=\"line\">\tWidget&amp; <span class=\"keyword\">operator</span>=(cosnt Widget&amp; rhs)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">\t   <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​    </p>\n"},{"_content":"\n\n为什么不要在构造函数中调用 virtual 函数？\n\n在 base class 构造期间，virtual 函数退化为 non-virtual 函数，因为在 base 类构造的时候，derived 类还没有被构造出来，此时是不可能调用到 derived 类的函数的\n\n在 derived class 对象的 base class 构造期间，对象的类型被编译器视为 base class，而不是 derived class。而且此时 dynamic_cast 和 typeid 都会将该对象的类型识别为 base class\n\n对于析构函数，有类似的解释：\n\n由于是先调用 derived class 的析构函数，再调用其 base class 的析构函数，此时对象的 derived 部分已经被销毁了，所以再调用虚函数也没有意义了\n\n","source":"_posts/C++/《effective C++ 第三版》读书笔记/2. 构造、析构、赋值运算/条款09：绝不在构造和析构过程中调用 virtual 函数.md","raw":"\n\n为什么不要在构造函数中调用 virtual 函数？\n\n在 base class 构造期间，virtual 函数退化为 non-virtual 函数，因为在 base 类构造的时候，derived 类还没有被构造出来，此时是不可能调用到 derived 类的函数的\n\n在 derived class 对象的 base class 构造期间，对象的类型被编译器视为 base class，而不是 derived class。而且此时 dynamic_cast 和 typeid 都会将该对象的类型识别为 base class\n\n对于析构函数，有类似的解释：\n\n由于是先调用 derived class 的析构函数，再调用其 base class 的析构函数，此时对象的 derived 部分已经被销毁了，所以再调用虚函数也没有意义了\n\n","slug":"C++/《effective C++ 第三版》读书笔记/2. 构造、析构、赋值运算/条款09：绝不在构造和析构过程中调用 virtual 函数","published":1,"date":"2022-06-08T03:36:23.584Z","updated":"2022-06-08T04:06:02.880Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0kyl002lpcu36zrkfubm","content":"<p>为什么不要在构造函数中调用 virtual 函数？</p>\n<p>在 base class 构造期间，virtual 函数退化为 non-virtual 函数，因为在 base 类构造的时候，derived 类还没有被构造出来，此时是不可能调用到 derived 类的函数的</p>\n<p>在 derived class 对象的 base class 构造期间，对象的类型被编译器视为 base class，而不是 derived class。而且此时 dynamic_cast 和 typeid 都会将该对象的类型识别为 base class</p>\n<p>对于析构函数，有类似的解释：</p>\n<p>由于是先调用 derived class 的析构函数，再调用其 base class 的析构函数，此时对象的 derived 部分已经被销毁了，所以再调用虚函数也没有意义了</p>\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<p>为什么不要在构造函数中调用 virtual 函数？</p>\n<p>在 base class 构造期间，virtual 函数退化为 non-virtual 函数，因为在 base 类构造的时候，derived 类还没有被构造出来，此时是不可能调用到 derived 类的函数的</p>\n<p>在 derived class 对象的 base class 构造期间，对象的类型被编译器视为 base class，而不是 derived class。而且此时 dynamic_cast 和 typeid 都会将该对象的类型识别为 base class</p>\n<p>对于析构函数，有类似的解释：</p>\n<p>由于是先调用 derived class 的析构函数，再调用其 base class 的析构函数，此时对象的 derived 部分已经被销毁了，所以再调用虚函数也没有意义了</p>\n"},{"_content":"自我赋值：\n\n```cpp\nclass Bitmap {...};\nclass Widget {\n    ...\nprivate:\n    Bitmap* pb;\n};\nWidget w;\n...\nw = w;\n```\n\n下面是一个在自我赋值时不安全的 operator= 实现代码\n\n```cpp\nWidget& Widget::operator=(const Widget& rhs)\n{\n    delete pb; \t\t\t\t\t//停止使用当前的 bitmap\n    pb = new Bitmap(*rhs.pb);\t //使用 rhs's bitmap 的副本\n    return *this;\n}\n```\n\noperator= 函数的参数 rhs 和 *this 有可能是同一个对象，如果真是这样，那么 delete pb; 就会将这个对象销毁！后面的拷贝将是无意义的\n\n传统优化手段是加一个 if 判断：\n\n```cpp\nif (this == &rhs) return *this;  //证同测试\n```\n\n但是这段代码还不具备异常安全性，假如`new Bitmap`导致了异常，Widget 最终会持有一个指针指向被删除的 Bitmap\n\n让 operator 具备异常安全性往往自动获得自我赋值安全性：\n\n```cpp\nWidget& Widget::operator=(const Widget& rhs)\n{\n    Bitmap* pOrig = pb;\n    pb = new Bitmap(*rhs.pb);\t //使用 rhs's bitmap 的副本\n    delete pOrig;\n    return *this;\n}\n```\n\n现在这段代码在`new Bitmap`爬出异常时仍能正常工作，同时也可兼容处理自我赋值（虽然效率不高）\n\ncopy and swap 技术\n\n```cpp\nclass Widget{\n  \t...\n\tvoid swap(Widget& rhs);\t\t// 交换*this和rhs的数据 \n    ...\n};\nWidget& Widget::operator=(const Widget& rhs)\n{\n    Widget temp(rhs); //不用 new 了，而是用一个栈上的局部对象\n    swap(temp);\t\t // 自我赋值时仍能工作\n    return *this;    // 局部变量 temp 自动销毁，\n}  \n```\n\n\n\n","source":"_posts/C++/《effective C++ 第三版》读书笔记/2. 构造、析构、赋值运算/条款11：在operator=中处理自我赋值.md","raw":"自我赋值：\n\n```cpp\nclass Bitmap {...};\nclass Widget {\n    ...\nprivate:\n    Bitmap* pb;\n};\nWidget w;\n...\nw = w;\n```\n\n下面是一个在自我赋值时不安全的 operator= 实现代码\n\n```cpp\nWidget& Widget::operator=(const Widget& rhs)\n{\n    delete pb; \t\t\t\t\t//停止使用当前的 bitmap\n    pb = new Bitmap(*rhs.pb);\t //使用 rhs's bitmap 的副本\n    return *this;\n}\n```\n\noperator= 函数的参数 rhs 和 *this 有可能是同一个对象，如果真是这样，那么 delete pb; 就会将这个对象销毁！后面的拷贝将是无意义的\n\n传统优化手段是加一个 if 判断：\n\n```cpp\nif (this == &rhs) return *this;  //证同测试\n```\n\n但是这段代码还不具备异常安全性，假如`new Bitmap`导致了异常，Widget 最终会持有一个指针指向被删除的 Bitmap\n\n让 operator 具备异常安全性往往自动获得自我赋值安全性：\n\n```cpp\nWidget& Widget::operator=(const Widget& rhs)\n{\n    Bitmap* pOrig = pb;\n    pb = new Bitmap(*rhs.pb);\t //使用 rhs's bitmap 的副本\n    delete pOrig;\n    return *this;\n}\n```\n\n现在这段代码在`new Bitmap`爬出异常时仍能正常工作，同时也可兼容处理自我赋值（虽然效率不高）\n\ncopy and swap 技术\n\n```cpp\nclass Widget{\n  \t...\n\tvoid swap(Widget& rhs);\t\t// 交换*this和rhs的数据 \n    ...\n};\nWidget& Widget::operator=(const Widget& rhs)\n{\n    Widget temp(rhs); //不用 new 了，而是用一个栈上的局部对象\n    swap(temp);\t\t // 自我赋值时仍能工作\n    return *this;    // 局部变量 temp 自动销毁，\n}  \n```\n\n\n\n","slug":"C++/《effective C++ 第三版》读书笔记/2. 构造、析构、赋值运算/条款11：在operator=中处理自我赋值","published":1,"date":"2022-06-08T04:49:37.055Z","updated":"2022-06-08T05:13:29.266Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0kyl002mpcu39h246dhc","content":"<p>自我赋值：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bitmap</span> &#123;</span>...&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Widget</span> &#123;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    Bitmap* pb;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Widget w;</span><br><span class=\"line\">...</span><br><span class=\"line\">w = w;</span><br></pre></td></tr></table></figure>\n\n<p>下面是一个在自我赋值时不安全的 operator= 实现代码</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Widget&amp; Widget::<span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> Widget&amp; rhs)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> pb; \t\t\t\t\t<span class=\"comment\">//停止使用当前的 bitmap</span></span><br><span class=\"line\">    pb = <span class=\"keyword\">new</span> <span class=\"built_in\">Bitmap</span>(*rhs.pb);\t <span class=\"comment\">//使用 rhs&#x27;s bitmap 的副本</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>operator= 函数的参数 rhs 和 *this 有可能是同一个对象，如果真是这样，那么 delete pb; 就会将这个对象销毁！后面的拷贝将是无意义的</p>\n<p>传统优化手段是加一个 if 判断：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> == &amp;rhs) <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;  <span class=\"comment\">//证同测试</span></span><br></pre></td></tr></table></figure>\n\n<p>但是这段代码还不具备异常安全性，假如<code>new Bitmap</code>导致了异常，Widget 最终会持有一个指针指向被删除的 Bitmap</p>\n<p>让 operator 具备异常安全性往往自动获得自我赋值安全性：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Widget&amp; Widget::<span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> Widget&amp; rhs)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Bitmap* pOrig = pb;</span><br><span class=\"line\">    pb = <span class=\"keyword\">new</span> <span class=\"built_in\">Bitmap</span>(*rhs.pb);\t <span class=\"comment\">//使用 rhs&#x27;s bitmap 的副本</span></span><br><span class=\"line\">    <span class=\"keyword\">delete</span> pOrig;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在这段代码在<code>new Bitmap</code>爬出异常时仍能正常工作，同时也可兼容处理自我赋值（虽然效率不高）</p>\n<p>copy and swap 技术</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Widget</span>&#123;</span></span><br><span class=\"line\">  \t...</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(Widget&amp; rhs)</span></span>;\t\t<span class=\"comment\">// 交换*this和rhs的数据 </span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Widget&amp; Widget::<span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> Widget&amp; rhs)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Widget <span class=\"built_in\">temp</span>(rhs); <span class=\"comment\">//不用 new 了，而是用一个栈上的局部对象</span></span><br><span class=\"line\">    <span class=\"built_in\">swap</span>(temp);\t\t <span class=\"comment\">// 自我赋值时仍能工作</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;    <span class=\"comment\">// 局部变量 temp 自动销毁，</span></span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n\n\n\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<p>自我赋值：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bitmap</span> &#123;</span>...&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Widget</span> &#123;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    Bitmap* pb;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Widget w;</span><br><span class=\"line\">...</span><br><span class=\"line\">w = w;</span><br></pre></td></tr></table></figure>\n\n<p>下面是一个在自我赋值时不安全的 operator= 实现代码</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Widget&amp; Widget::<span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> Widget&amp; rhs)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> pb; \t\t\t\t\t<span class=\"comment\">//停止使用当前的 bitmap</span></span><br><span class=\"line\">    pb = <span class=\"keyword\">new</span> <span class=\"built_in\">Bitmap</span>(*rhs.pb);\t <span class=\"comment\">//使用 rhs&#x27;s bitmap 的副本</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>operator= 函数的参数 rhs 和 *this 有可能是同一个对象，如果真是这样，那么 delete pb; 就会将这个对象销毁！后面的拷贝将是无意义的</p>\n<p>传统优化手段是加一个 if 判断：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> == &amp;rhs) <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;  <span class=\"comment\">//证同测试</span></span><br></pre></td></tr></table></figure>\n\n<p>但是这段代码还不具备异常安全性，假如<code>new Bitmap</code>导致了异常，Widget 最终会持有一个指针指向被删除的 Bitmap</p>\n<p>让 operator 具备异常安全性往往自动获得自我赋值安全性：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Widget&amp; Widget::<span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> Widget&amp; rhs)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Bitmap* pOrig = pb;</span><br><span class=\"line\">    pb = <span class=\"keyword\">new</span> <span class=\"built_in\">Bitmap</span>(*rhs.pb);\t <span class=\"comment\">//使用 rhs&#x27;s bitmap 的副本</span></span><br><span class=\"line\">    <span class=\"keyword\">delete</span> pOrig;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在这段代码在<code>new Bitmap</code>爬出异常时仍能正常工作，同时也可兼容处理自我赋值（虽然效率不高）</p>\n<p>copy and swap 技术</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Widget</span>&#123;</span></span><br><span class=\"line\">  \t...</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(Widget&amp; rhs)</span></span>;\t\t<span class=\"comment\">// 交换*this和rhs的数据 </span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Widget&amp; Widget::<span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> Widget&amp; rhs)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Widget <span class=\"built_in\">temp</span>(rhs); <span class=\"comment\">//不用 new 了，而是用一个栈上的局部对象</span></span><br><span class=\"line\">    <span class=\"built_in\">swap</span>(temp);\t\t <span class=\"comment\">// 自我赋值时仍能工作</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;    <span class=\"comment\">// 局部变量 temp 自动销毁，</span></span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n\n\n\n"},{"_content":"条款十三：RALL（Resource Acquisition Is Initialization，资源获取时初始化）\n\n条款十七：在“资源被创建（new）”和“资源被转换为资源管理对象”两个时间点之间有可能发生异常干扰，所以要以独立语句将 newed 对象存储于智能指针内，否则有可能发生资源泄漏\n\n","source":"_posts/C++/《effective C++ 第三版》读书笔记/3. 资源管理/条款13：以对象管理资源-.md","raw":"条款十三：RALL（Resource Acquisition Is Initialization，资源获取时初始化）\n\n条款十七：在“资源被创建（new）”和“资源被转换为资源管理对象”两个时间点之间有可能发生异常干扰，所以要以独立语句将 newed 对象存储于智能指针内，否则有可能发生资源泄漏\n\n","slug":"C++/《effective C++ 第三版》读书笔记/3. 资源管理/条款13：以对象管理资源-","published":1,"date":"2022-06-11T09:21:55.026Z","updated":"2022-06-22T09:44:13.843Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0kym002npcu3axe8d560","content":"<p>条款十三：RALL（Resource Acquisition Is Initialization，资源获取时初始化）</p>\n<p>条款十七：在“资源被创建（new）”和“资源被转换为资源管理对象”两个时间点之间有可能发生异常干扰，所以要以独立语句将 newed 对象存储于智能指针内，否则有可能发生资源泄漏</p>\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<p>条款十三：RALL（Resource Acquisition Is Initialization，资源获取时初始化）</p>\n<p>条款十七：在“资源被创建（new）”和“资源被转换为资源管理对象”两个时间点之间有可能发生异常干扰，所以要以独立语句将 newed 对象存储于智能指针内，否则有可能发生资源泄漏</p>\n"},{"_content":"给出参考资料如下：https://www.cnblogs.com/jerry19880126/p/3551836.html，做笔记太花时间，目前自身基础薄弱，要高效利用时间\n\n\n\nC++基础编译知识，现有3个类，对应6个文件，分别是\n\n1. ComplexClass.h、ComplexClass.cpp\n2. SimpleClass1.h、SimpleClass1.cpp\n3. SimpleClass2.h、SimpleClass2.cpp\n\n合情合理，ComplexClass.h的内容如下：\n\n```cpp\n#ifndef COMPLESS_CLASS_H\n#define COMPLESS_CLASS_H\n\n#include “SimpleClass1.h”\n#include “SimpleClass2.h”\n\nclass ComplexClass\n{\n    SimpleClass1 xx;\n    SimpleClass2 xxx;\n};\n…\n\n#endif /* COMPLESS _CLASS_H */\n```\n\n考虑以下几种情况：\n\n1. SimpleClass1.h发生改变\n\n比如SimpleClass的类定义中新添加了一个变量。因为SimpleClass1.cpp一定有#include \"SimpleClass.h\"，所以SimpleClass1.cpp一定会被重新编译。SimpleClass2和SimpleClass1是独立的，所以SimpleClass2不需要被重新编译。\n\n\n\n因为ComplexClass.h存在#include \"SimpleClass.h\"，所以ComplexClass.h和ComplexClass.cpp都要重新编译，<u>而且所有使用了ComplexClass类对象的文件都需要重新编译</u>\n\n\n如果用“前置声明”代替“include头文件”，就可以避免对那些头文件产生编译依赖关系，但是却<u>无法通过编译</u>，因为编译器需要在编译时确定类对象的大小，而确定对象的大小需要寻找到对象class的定义式，例如：\n\n```cpp\nint main(){\n    int x;\n    ComplexClass my_class;\n}\n```\n\n编译器在编译时无法确定my_class对象的大小，因为无法确定ComplexClass类成员变量SimpleClass1的大小，仅靠其前置声明class SimpleClass1;无法知道其大小，如果将成员变量换为指针呢\n\n\n\n参考资料：https://www.cnblogs.com/jerry19880126/p/3551836.html\n\n在实现文件中包含 `#include .h`，而在头文件中仅使用声明和指针，来使得头文件尽可能不发生变化，进而所有用到这个头文件的“用户”也不需要变化，降低了依存关系、\n\n`Class`的定义式即包含了接口声明，还包含了`private`成员变量（实现细节），如果修改了某个成员变量（增删改），则所有用到这个Class定义式的用户都要重新编译，现在的想法是让`Class`定义式仅包含接口，这样的话只要其接口不变，用户就不必重新编译\n\n```cpp\nclass Person{\npublic:\n    //接口\n    Person(const std::string& name, const Date& birthday, const Address& addr);\n    std::string name() const;\n    std::string birthDate() const;\n    std::string address() const;\n    ...\nprivate:\n    //实现细节\n    std::string theName;\n    Date theBirthDate;\n    Address theAddress;\n};\n```\n\n由于存在类对象，所以此文件必须包含对实现细节的定义，例如`Date`类的定义，所以在此文件开头有：\n\n```cpp\n#include <string>\n#include \"date.h\"\n#include \"address.h\"\n```\n\n这就形成了一种依存关系，上述头文件中的任何一处的改变，将会导致包含或使用`Person`类的文件重新编译。\n\n有没有办法不包含那些头文件呢？如果用前置声明来替换要`#include`的头文件\n\n```cpp\n#include <string> //标准库string没法用前置声明\nclass Date;   //前置声明 \nclass Person; //前置声明 \n```\n\n会<u>无法通过编译</u>，因为仅靠前置声明无法知道对象的大小，而编译器必须在编译期知道对象的大小，方法就是询问class定义式，所以仅有前置声明无法通过编译\n\n如果将实现细节放在另一个类里（`PersonImpl`），然后用指针指向实现类，就可以了。因为编译器可以知道指针的大小\n\n```cpp\n#include <string>\n#include <memory>\n\nclass PersonImpl; // 实现类前置声明\nclass Date;      // Person 接口用到的 classed 的前置声明，与pImpl无关\nclass Address;   \n\nclass Person{\npublic:\n    //接口\n    Person(const std::string& name, const Date& birthday, const Address& addr);\n    std::string name() const;\n    std::string birthDate() const;\n    std::string address() const;\n    ...\nprivate:\n    std::tr1::shared_ptr<PersonImpl> pImpl; //指针，指向实现\n};\n```\n\n","source":"_posts/C++/《effective C++ 第三版》读书笔记/5. 实现/条款三十一：将文件间的编译依存关系降至最低（第一部分） - 副本.md","raw":"给出参考资料如下：https://www.cnblogs.com/jerry19880126/p/3551836.html，做笔记太花时间，目前自身基础薄弱，要高效利用时间\n\n\n\nC++基础编译知识，现有3个类，对应6个文件，分别是\n\n1. ComplexClass.h、ComplexClass.cpp\n2. SimpleClass1.h、SimpleClass1.cpp\n3. SimpleClass2.h、SimpleClass2.cpp\n\n合情合理，ComplexClass.h的内容如下：\n\n```cpp\n#ifndef COMPLESS_CLASS_H\n#define COMPLESS_CLASS_H\n\n#include “SimpleClass1.h”\n#include “SimpleClass2.h”\n\nclass ComplexClass\n{\n    SimpleClass1 xx;\n    SimpleClass2 xxx;\n};\n…\n\n#endif /* COMPLESS _CLASS_H */\n```\n\n考虑以下几种情况：\n\n1. SimpleClass1.h发生改变\n\n比如SimpleClass的类定义中新添加了一个变量。因为SimpleClass1.cpp一定有#include \"SimpleClass.h\"，所以SimpleClass1.cpp一定会被重新编译。SimpleClass2和SimpleClass1是独立的，所以SimpleClass2不需要被重新编译。\n\n\n\n因为ComplexClass.h存在#include \"SimpleClass.h\"，所以ComplexClass.h和ComplexClass.cpp都要重新编译，<u>而且所有使用了ComplexClass类对象的文件都需要重新编译</u>\n\n\n如果用“前置声明”代替“include头文件”，就可以避免对那些头文件产生编译依赖关系，但是却<u>无法通过编译</u>，因为编译器需要在编译时确定类对象的大小，而确定对象的大小需要寻找到对象class的定义式，例如：\n\n```cpp\nint main(){\n    int x;\n    ComplexClass my_class;\n}\n```\n\n编译器在编译时无法确定my_class对象的大小，因为无法确定ComplexClass类成员变量SimpleClass1的大小，仅靠其前置声明class SimpleClass1;无法知道其大小，如果将成员变量换为指针呢\n\n\n\n参考资料：https://www.cnblogs.com/jerry19880126/p/3551836.html\n\n在实现文件中包含 `#include .h`，而在头文件中仅使用声明和指针，来使得头文件尽可能不发生变化，进而所有用到这个头文件的“用户”也不需要变化，降低了依存关系、\n\n`Class`的定义式即包含了接口声明，还包含了`private`成员变量（实现细节），如果修改了某个成员变量（增删改），则所有用到这个Class定义式的用户都要重新编译，现在的想法是让`Class`定义式仅包含接口，这样的话只要其接口不变，用户就不必重新编译\n\n```cpp\nclass Person{\npublic:\n    //接口\n    Person(const std::string& name, const Date& birthday, const Address& addr);\n    std::string name() const;\n    std::string birthDate() const;\n    std::string address() const;\n    ...\nprivate:\n    //实现细节\n    std::string theName;\n    Date theBirthDate;\n    Address theAddress;\n};\n```\n\n由于存在类对象，所以此文件必须包含对实现细节的定义，例如`Date`类的定义，所以在此文件开头有：\n\n```cpp\n#include <string>\n#include \"date.h\"\n#include \"address.h\"\n```\n\n这就形成了一种依存关系，上述头文件中的任何一处的改变，将会导致包含或使用`Person`类的文件重新编译。\n\n有没有办法不包含那些头文件呢？如果用前置声明来替换要`#include`的头文件\n\n```cpp\n#include <string> //标准库string没法用前置声明\nclass Date;   //前置声明 \nclass Person; //前置声明 \n```\n\n会<u>无法通过编译</u>，因为仅靠前置声明无法知道对象的大小，而编译器必须在编译期知道对象的大小，方法就是询问class定义式，所以仅有前置声明无法通过编译\n\n如果将实现细节放在另一个类里（`PersonImpl`），然后用指针指向实现类，就可以了。因为编译器可以知道指针的大小\n\n```cpp\n#include <string>\n#include <memory>\n\nclass PersonImpl; // 实现类前置声明\nclass Date;      // Person 接口用到的 classed 的前置声明，与pImpl无关\nclass Address;   \n\nclass Person{\npublic:\n    //接口\n    Person(const std::string& name, const Date& birthday, const Address& addr);\n    std::string name() const;\n    std::string birthDate() const;\n    std::string address() const;\n    ...\nprivate:\n    std::tr1::shared_ptr<PersonImpl> pImpl; //指针，指向实现\n};\n```\n\n","slug":"C++/《effective C++ 第三版》读书笔记/5. 实现/条款三十一：将文件间的编译依存关系降至最低（第一部分） - 副本","published":1,"date":"2022-05-23T12:56:09.431Z","updated":"2022-05-23T13:26:45.852Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0kym002opcu3eo4x42nn","content":"<p>给出参考资料如下：<a href=\"https://www.cnblogs.com/jerry19880126/p/3551836.html%EF%BC%8C%E5%81%9A%E7%AC%94%E8%AE%B0%E5%A4%AA%E8%8A%B1%E6%97%B6%E9%97%B4%EF%BC%8C%E7%9B%AE%E5%89%8D%E8%87%AA%E8%BA%AB%E5%9F%BA%E7%A1%80%E8%96%84%E5%BC%B1%EF%BC%8C%E8%A6%81%E9%AB%98%E6%95%88%E5%88%A9%E7%94%A8%E6%97%B6%E9%97%B4\">https://www.cnblogs.com/jerry19880126/p/3551836.html，做笔记太花时间，目前自身基础薄弱，要高效利用时间</a></p>\n<p>C++基础编译知识，现有3个类，对应6个文件，分别是</p>\n<ol>\n<li>ComplexClass.h、ComplexClass.cpp</li>\n<li>SimpleClass1.h、SimpleClass1.cpp</li>\n<li>SimpleClass2.h、SimpleClass2.cpp</li>\n</ol>\n<p>合情合理，ComplexClass.h的内容如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> COMPLESS_CLASS_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> COMPLESS_CLASS_H</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> “SimpleClass1.h”</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> “SimpleClass2.h”</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ComplexClass</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    SimpleClass1 xx;</span><br><span class=\"line\">    SimpleClass2 xxx;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">…</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">/* COMPLESS _CLASS_H */</span></span></span><br></pre></td></tr></table></figure>\n\n<p>考虑以下几种情况：</p>\n<ol>\n<li>SimpleClass1.h发生改变</li>\n</ol>\n<p>比如SimpleClass的类定义中新添加了一个变量。因为SimpleClass1.cpp一定有#include “SimpleClass.h”，所以SimpleClass1.cpp一定会被重新编译。SimpleClass2和SimpleClass1是独立的，所以SimpleClass2不需要被重新编译。</p>\n<p>因为ComplexClass.h存在#include “SimpleClass.h”，所以ComplexClass.h和ComplexClass.cpp都要重新编译，<u>而且所有使用了ComplexClass类对象的文件都需要重新编译</u></p>\n<p>如果用“前置声明”代替“include头文件”，就可以避免对那些头文件产生编译依赖关系，但是却<u>无法通过编译</u>，因为编译器需要在编译时确定类对象的大小，而确定对象的大小需要寻找到对象class的定义式，例如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x;</span><br><span class=\"line\">    ComplexClass my_class;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>编译器在编译时无法确定my_class对象的大小，因为无法确定ComplexClass类成员变量SimpleClass1的大小，仅靠其前置声明class SimpleClass1;无法知道其大小，如果将成员变量换为指针呢</p>\n<p>参考资料：<a href=\"https://www.cnblogs.com/jerry19880126/p/3551836.html\">https://www.cnblogs.com/jerry19880126/p/3551836.html</a></p>\n<p>在实现文件中包含 <code>#include .h</code>，而在头文件中仅使用声明和指针，来使得头文件尽可能不发生变化，进而所有用到这个头文件的“用户”也不需要变化，降低了依存关系、</p>\n<p><code>Class</code>的定义式即包含了接口声明，还包含了<code>private</code>成员变量（实现细节），如果修改了某个成员变量（增删改），则所有用到这个Class定义式的用户都要重新编译，现在的想法是让<code>Class</code>定义式仅包含接口，这样的话只要其接口不变，用户就不必重新编译</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">//接口</span></span><br><span class=\"line\">    <span class=\"built_in\">Person</span>(<span class=\"keyword\">const</span> std::string&amp; name, <span class=\"keyword\">const</span> Date&amp; birthday, <span class=\"keyword\">const</span> Address&amp; addr);</span><br><span class=\"line\">    <span class=\"function\">std::string <span class=\"title\">name</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\">    <span class=\"function\">std::string <span class=\"title\">birthDate</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\">    <span class=\"function\">std::string <span class=\"title\">address</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"comment\">//实现细节</span></span><br><span class=\"line\">    std::string theName;</span><br><span class=\"line\">    Date theBirthDate;</span><br><span class=\"line\">    Address theAddress;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>由于存在类对象，所以此文件必须包含对实现细节的定义，例如<code>Date</code>类的定义，所以在此文件开头有：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;date.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;address.h&quot;</span></span></span><br></pre></td></tr></table></figure>\n\n<p>这就形成了一种依存关系，上述头文件中的任何一处的改变，将会导致包含或使用<code>Person</code>类的文件重新编译。</p>\n<p>有没有办法不包含那些头文件呢？如果用前置声明来替换要<code>#include</code>的头文件</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span> <span class=\"comment\">//标准库string没法用前置声明</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Date</span>;</span>   <span class=\"comment\">//前置声明 </span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span>;</span> <span class=\"comment\">//前置声明 </span></span><br></pre></td></tr></table></figure>\n\n<p>会<u>无法通过编译</u>，因为仅靠前置声明无法知道对象的大小，而编译器必须在编译期知道对象的大小，方法就是询问class定义式，所以仅有前置声明无法通过编译</p>\n<p>如果将实现细节放在另一个类里（<code>PersonImpl</code>），然后用指针指向实现类，就可以了。因为编译器可以知道指针的大小</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;memory&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PersonImpl</span>;</span> <span class=\"comment\">// 实现类前置声明</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Date</span>;</span>      <span class=\"comment\">// Person 接口用到的 classed 的前置声明，与pImpl无关</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Address</span>;</span>   </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">//接口</span></span><br><span class=\"line\">    <span class=\"built_in\">Person</span>(<span class=\"keyword\">const</span> std::string&amp; name, <span class=\"keyword\">const</span> Date&amp; birthday, <span class=\"keyword\">const</span> Address&amp; addr);</span><br><span class=\"line\">    <span class=\"function\">std::string <span class=\"title\">name</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\">    <span class=\"function\">std::string <span class=\"title\">birthDate</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\">    <span class=\"function\">std::string <span class=\"title\">address</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    std::tr1::shared_ptr&lt;PersonImpl&gt; pImpl; <span class=\"comment\">//指针，指向实现</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<p>给出参考资料如下：<a href=\"https://www.cnblogs.com/jerry19880126/p/3551836.html%EF%BC%8C%E5%81%9A%E7%AC%94%E8%AE%B0%E5%A4%AA%E8%8A%B1%E6%97%B6%E9%97%B4%EF%BC%8C%E7%9B%AE%E5%89%8D%E8%87%AA%E8%BA%AB%E5%9F%BA%E7%A1%80%E8%96%84%E5%BC%B1%EF%BC%8C%E8%A6%81%E9%AB%98%E6%95%88%E5%88%A9%E7%94%A8%E6%97%B6%E9%97%B4\">https://www.cnblogs.com/jerry19880126/p/3551836.html，做笔记太花时间，目前自身基础薄弱，要高效利用时间</a></p>\n<p>C++基础编译知识，现有3个类，对应6个文件，分别是</p>\n<ol>\n<li>ComplexClass.h、ComplexClass.cpp</li>\n<li>SimpleClass1.h、SimpleClass1.cpp</li>\n<li>SimpleClass2.h、SimpleClass2.cpp</li>\n</ol>\n<p>合情合理，ComplexClass.h的内容如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> COMPLESS_CLASS_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> COMPLESS_CLASS_H</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> “SimpleClass1.h”</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> “SimpleClass2.h”</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ComplexClass</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    SimpleClass1 xx;</span><br><span class=\"line\">    SimpleClass2 xxx;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">…</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">/* COMPLESS _CLASS_H */</span></span></span><br></pre></td></tr></table></figure>\n\n<p>考虑以下几种情况：</p>\n<ol>\n<li>SimpleClass1.h发生改变</li>\n</ol>\n<p>比如SimpleClass的类定义中新添加了一个变量。因为SimpleClass1.cpp一定有#include “SimpleClass.h”，所以SimpleClass1.cpp一定会被重新编译。SimpleClass2和SimpleClass1是独立的，所以SimpleClass2不需要被重新编译。</p>\n<p>因为ComplexClass.h存在#include “SimpleClass.h”，所以ComplexClass.h和ComplexClass.cpp都要重新编译，<u>而且所有使用了ComplexClass类对象的文件都需要重新编译</u></p>\n<p>如果用“前置声明”代替“include头文件”，就可以避免对那些头文件产生编译依赖关系，但是却<u>无法通过编译</u>，因为编译器需要在编译时确定类对象的大小，而确定对象的大小需要寻找到对象class的定义式，例如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x;</span><br><span class=\"line\">    ComplexClass my_class;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>编译器在编译时无法确定my_class对象的大小，因为无法确定ComplexClass类成员变量SimpleClass1的大小，仅靠其前置声明class SimpleClass1;无法知道其大小，如果将成员变量换为指针呢</p>\n<p>参考资料：<a href=\"https://www.cnblogs.com/jerry19880126/p/3551836.html\">https://www.cnblogs.com/jerry19880126/p/3551836.html</a></p>\n<p>在实现文件中包含 <code>#include .h</code>，而在头文件中仅使用声明和指针，来使得头文件尽可能不发生变化，进而所有用到这个头文件的“用户”也不需要变化，降低了依存关系、</p>\n<p><code>Class</code>的定义式即包含了接口声明，还包含了<code>private</code>成员变量（实现细节），如果修改了某个成员变量（增删改），则所有用到这个Class定义式的用户都要重新编译，现在的想法是让<code>Class</code>定义式仅包含接口，这样的话只要其接口不变，用户就不必重新编译</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">//接口</span></span><br><span class=\"line\">    <span class=\"built_in\">Person</span>(<span class=\"keyword\">const</span> std::string&amp; name, <span class=\"keyword\">const</span> Date&amp; birthday, <span class=\"keyword\">const</span> Address&amp; addr);</span><br><span class=\"line\">    <span class=\"function\">std::string <span class=\"title\">name</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\">    <span class=\"function\">std::string <span class=\"title\">birthDate</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\">    <span class=\"function\">std::string <span class=\"title\">address</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"comment\">//实现细节</span></span><br><span class=\"line\">    std::string theName;</span><br><span class=\"line\">    Date theBirthDate;</span><br><span class=\"line\">    Address theAddress;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>由于存在类对象，所以此文件必须包含对实现细节的定义，例如<code>Date</code>类的定义，所以在此文件开头有：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;date.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;address.h&quot;</span></span></span><br></pre></td></tr></table></figure>\n\n<p>这就形成了一种依存关系，上述头文件中的任何一处的改变，将会导致包含或使用<code>Person</code>类的文件重新编译。</p>\n<p>有没有办法不包含那些头文件呢？如果用前置声明来替换要<code>#include</code>的头文件</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span> <span class=\"comment\">//标准库string没法用前置声明</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Date</span>;</span>   <span class=\"comment\">//前置声明 </span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span>;</span> <span class=\"comment\">//前置声明 </span></span><br></pre></td></tr></table></figure>\n\n<p>会<u>无法通过编译</u>，因为仅靠前置声明无法知道对象的大小，而编译器必须在编译期知道对象的大小，方法就是询问class定义式，所以仅有前置声明无法通过编译</p>\n<p>如果将实现细节放在另一个类里（<code>PersonImpl</code>），然后用指针指向实现类，就可以了。因为编译器可以知道指针的大小</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;memory&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PersonImpl</span>;</span> <span class=\"comment\">// 实现类前置声明</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Date</span>;</span>      <span class=\"comment\">// Person 接口用到的 classed 的前置声明，与pImpl无关</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Address</span>;</span>   </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">//接口</span></span><br><span class=\"line\">    <span class=\"built_in\">Person</span>(<span class=\"keyword\">const</span> std::string&amp; name, <span class=\"keyword\">const</span> Date&amp; birthday, <span class=\"keyword\">const</span> Address&amp; addr);</span><br><span class=\"line\">    <span class=\"function\">std::string <span class=\"title\">name</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\">    <span class=\"function\">std::string <span class=\"title\">birthDate</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\">    <span class=\"function\">std::string <span class=\"title\">address</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    std::tr1::shared_ptr&lt;PersonImpl&gt; pImpl; <span class=\"comment\">//指针，指向实现</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n"},{"_content":"以 by value 方式传参会有额外的构造函数和析构函数的调用开销，以 by reference 传参可以回避这些开销，const 可以防止函数内部修改 reference 参数\n\nby value 传参还会造成 slicing（对象切割）问题，例如形参类型为 base class，当传入一个 derived class 对象时，此对象会被切割至仅剩 base class 部分。而当以 reference 类型传参时，将一个 derived class 对象赋给 base 引用/指针是合法的，不会被切割。","source":"_posts/C++/《effective C++ 第三版》读书笔记/4. 设计与声明/条款20：宁以 pass-by-reference-to-const 替换 pass-by-value.md","raw":"以 by value 方式传参会有额外的构造函数和析构函数的调用开销，以 by reference 传参可以回避这些开销，const 可以防止函数内部修改 reference 参数\n\nby value 传参还会造成 slicing（对象切割）问题，例如形参类型为 base class，当传入一个 derived class 对象时，此对象会被切割至仅剩 base class 部分。而当以 reference 类型传参时，将一个 derived class 对象赋给 base 引用/指针是合法的，不会被切割。","slug":"C++/《effective C++ 第三版》读书笔记/4. 设计与声明/条款20：宁以 pass-by-reference-to-const 替换 pass-by-value","published":1,"date":"2022-06-14T13:36:13.330Z","updated":"2022-06-22T09:42:50.495Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0kyn002ppcu3g38obbxx","content":"<p>以 by value 方式传参会有额外的构造函数和析构函数的调用开销，以 by reference 传参可以回避这些开销，const 可以防止函数内部修改 reference 参数</p>\n<p>by value 传参还会造成 slicing（对象切割）问题，例如形参类型为 base class，当传入一个 derived class 对象时，此对象会被切割至仅剩 base class 部分。而当以 reference 类型传参时，将一个 derived class 对象赋给 base 引用/指针是合法的，不会被切割。</p>\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<p>以 by value 方式传参会有额外的构造函数和析构函数的调用开销，以 by reference 传参可以回避这些开销，const 可以防止函数内部修改 reference 参数</p>\n<p>by value 传参还会造成 slicing（对象切割）问题，例如形参类型为 base class，当传入一个 derived class 对象时，此对象会被切割至仅剩 base class 部分。而当以 reference 类型传参时，将一个 derived class 对象赋给 base 引用/指针是合法的，不会被切割。</p>\n"},{"_content":"```cpp\nclass Rational {\npublic:\n    Rational(int numerator = 0, int denominator = 1); //构造函数不为 explicit，可以进行 int-to-Rational隐式转换\n    int numerator() const;  \t\t//分子\n    int denominator() const;\t\t//分母\n};\n```\n\n若将有理数乘法 operator* 写成 Rational 成员函数：\n\n```cpp\nclass Rational {\npublic:\n    ...\n\tconst Rational operator* (const Rational& rhs) const;\n};\n```\n\n这种设计可以很好地满足两个有理数想乘的情况：\n\n```cpp\nRational oneEighth(1, 8);\nRational oneHalf(1, 2);\nRational result = oneHalf * oneEighth;\nresult = result * oneEighth;\n```\n\n但混合式运算时，会发生错误：\n\n```cpp\nresult = oneHalf * 2;    //OK\nresult = 2 * oneHalf; \t //错误！\n\n//等价于\nresult = oneHalf.operator*(2);  //OK\nresult = 2.operator*(oneHalf);  //错误！\n```\n\n因为 class 中有一个没有 explicit 的“转换构造函数”，所以可以发生隐式类型转换，将 2 直接隐式转换为了一个 Rational 对象。但 2 没法调用 operator*，所以第二条语句无法通过编译。\n\n> 转换构造函数只有一个参数（或其他参数均有默认值），而且该参数又不是 class 的 const reference 。\n\n为了支持混合式算术运算，需要把 operator* 定义成 non-member 函数：\n\n```cpp\nclass Rational {\n    ...\n};\n\nconst Rational operator*(const Rational& lhs, const Rational& rhs)\n{\n    return Rational(lhs.numerator() * rhs.numerator(), lhs.denominator() * rhs.denominator());\n}\nRational oneFourth(1, 4);\nRational result;\nresult = oneFourth * 2;\nresult = 2 * oneFourth; \t//OK\n```\n\n要不要把 operator* 实现为一个 Rational class 的 friend 函数？答案是不需要，因为 operator* 函数不需要访问 private 成员\n\n","source":"_posts/C++/《effective C++ 第三版》读书笔记/4. 设计与声明/条款24：若所有参数皆需类型转换，请为此采用non-member函数.md","raw":"```cpp\nclass Rational {\npublic:\n    Rational(int numerator = 0, int denominator = 1); //构造函数不为 explicit，可以进行 int-to-Rational隐式转换\n    int numerator() const;  \t\t//分子\n    int denominator() const;\t\t//分母\n};\n```\n\n若将有理数乘法 operator* 写成 Rational 成员函数：\n\n```cpp\nclass Rational {\npublic:\n    ...\n\tconst Rational operator* (const Rational& rhs) const;\n};\n```\n\n这种设计可以很好地满足两个有理数想乘的情况：\n\n```cpp\nRational oneEighth(1, 8);\nRational oneHalf(1, 2);\nRational result = oneHalf * oneEighth;\nresult = result * oneEighth;\n```\n\n但混合式运算时，会发生错误：\n\n```cpp\nresult = oneHalf * 2;    //OK\nresult = 2 * oneHalf; \t //错误！\n\n//等价于\nresult = oneHalf.operator*(2);  //OK\nresult = 2.operator*(oneHalf);  //错误！\n```\n\n因为 class 中有一个没有 explicit 的“转换构造函数”，所以可以发生隐式类型转换，将 2 直接隐式转换为了一个 Rational 对象。但 2 没法调用 operator*，所以第二条语句无法通过编译。\n\n> 转换构造函数只有一个参数（或其他参数均有默认值），而且该参数又不是 class 的 const reference 。\n\n为了支持混合式算术运算，需要把 operator* 定义成 non-member 函数：\n\n```cpp\nclass Rational {\n    ...\n};\n\nconst Rational operator*(const Rational& lhs, const Rational& rhs)\n{\n    return Rational(lhs.numerator() * rhs.numerator(), lhs.denominator() * rhs.denominator());\n}\nRational oneFourth(1, 4);\nRational result;\nresult = oneFourth * 2;\nresult = 2 * oneFourth; \t//OK\n```\n\n要不要把 operator* 实现为一个 Rational class 的 friend 函数？答案是不需要，因为 operator* 函数不需要访问 private 成员\n\n","slug":"C++/《effective C++ 第三版》读书笔记/4. 设计与声明/条款24：若所有参数皆需类型转换，请为此采用non-member函数","published":1,"date":"2022-06-22T10:29:49.808Z","updated":"2022-06-22T11:06:00.934Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0kyn002qpcu36h8vck6z","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Rational</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Rational</span>(<span class=\"keyword\">int</span> numerator = <span class=\"number\">0</span>, <span class=\"keyword\">int</span> denominator = <span class=\"number\">1</span>); <span class=\"comment\">//构造函数不为 explicit，可以进行 int-to-Rational隐式转换</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">numerator</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;  \t\t<span class=\"comment\">//分子</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">denominator</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;\t\t<span class=\"comment\">//分母</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>若将有理数乘法 operator* 写成 Rational 成员函数：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Rational</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    ...</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> Rational <span class=\"keyword\">operator</span>* (<span class=\"keyword\">const</span> Rational&amp; rhs) <span class=\"keyword\">const</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这种设计可以很好地满足两个有理数想乘的情况：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Rational <span class=\"title\">oneEighth</span><span class=\"params\">(<span class=\"number\">1</span>, <span class=\"number\">8</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\">Rational <span class=\"title\">oneHalf</span><span class=\"params\">(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span></span>;</span><br><span class=\"line\">Rational result = oneHalf * oneEighth;</span><br><span class=\"line\">result = result * oneEighth;</span><br></pre></td></tr></table></figure>\n\n<p>但混合式运算时，会发生错误：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">result = oneHalf * <span class=\"number\">2</span>;    <span class=\"comment\">//OK</span></span><br><span class=\"line\">result = <span class=\"number\">2</span> * oneHalf; \t <span class=\"comment\">//错误！</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//等价于</span></span><br><span class=\"line\">result = oneHalf.<span class=\"keyword\">operator</span>*(<span class=\"number\">2</span>);  <span class=\"comment\">//OK</span></span><br><span class=\"line\">result = <span class=\"number\">2.</span><span class=\"keyword\">operator</span>*(oneHalf);  <span class=\"comment\">//错误！</span></span><br></pre></td></tr></table></figure>\n\n<p>因为 class 中有一个没有 explicit 的“转换构造函数”，所以可以发生隐式类型转换，将 2 直接隐式转换为了一个 Rational 对象。但 2 没法调用 operator*，所以第二条语句无法通过编译。</p>\n<blockquote>\n<p>转换构造函数只有一个参数（或其他参数均有默认值），而且该参数又不是 class 的 const reference 。</p>\n</blockquote>\n<p>为了支持混合式算术运算，需要把 operator* 定义成 non-member 函数：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Rational</span> &#123;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> Rational <span class=\"keyword\">operator</span>*(<span class=\"keyword\">const</span> Rational&amp; lhs, <span class=\"keyword\">const</span> Rational&amp; rhs)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Rational</span>(lhs.<span class=\"built_in\">numerator</span>() * rhs.<span class=\"built_in\">numerator</span>(), lhs.<span class=\"built_in\">denominator</span>() * rhs.<span class=\"built_in\">denominator</span>());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">Rational <span class=\"title\">oneFourth</span><span class=\"params\">(<span class=\"number\">1</span>, <span class=\"number\">4</span>)</span></span>;</span><br><span class=\"line\">Rational result;</span><br><span class=\"line\">result = oneFourth * <span class=\"number\">2</span>;</span><br><span class=\"line\">result = <span class=\"number\">2</span> * oneFourth; \t<span class=\"comment\">//OK</span></span><br></pre></td></tr></table></figure>\n\n<p>要不要把 operator* 实现为一个 Rational class 的 friend 函数？答案是不需要，因为 operator* 函数不需要访问 private 成员</p>\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Rational</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Rational</span>(<span class=\"keyword\">int</span> numerator = <span class=\"number\">0</span>, <span class=\"keyword\">int</span> denominator = <span class=\"number\">1</span>); <span class=\"comment\">//构造函数不为 explicit，可以进行 int-to-Rational隐式转换</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">numerator</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;  \t\t<span class=\"comment\">//分子</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">denominator</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;\t\t<span class=\"comment\">//分母</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>若将有理数乘法 operator* 写成 Rational 成员函数：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Rational</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    ...</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> Rational <span class=\"keyword\">operator</span>* (<span class=\"keyword\">const</span> Rational&amp; rhs) <span class=\"keyword\">const</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这种设计可以很好地满足两个有理数想乘的情况：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Rational <span class=\"title\">oneEighth</span><span class=\"params\">(<span class=\"number\">1</span>, <span class=\"number\">8</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\">Rational <span class=\"title\">oneHalf</span><span class=\"params\">(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span></span>;</span><br><span class=\"line\">Rational result = oneHalf * oneEighth;</span><br><span class=\"line\">result = result * oneEighth;</span><br></pre></td></tr></table></figure>\n\n<p>但混合式运算时，会发生错误：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">result = oneHalf * <span class=\"number\">2</span>;    <span class=\"comment\">//OK</span></span><br><span class=\"line\">result = <span class=\"number\">2</span> * oneHalf; \t <span class=\"comment\">//错误！</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//等价于</span></span><br><span class=\"line\">result = oneHalf.<span class=\"keyword\">operator</span>*(<span class=\"number\">2</span>);  <span class=\"comment\">//OK</span></span><br><span class=\"line\">result = <span class=\"number\">2.</span><span class=\"keyword\">operator</span>*(oneHalf);  <span class=\"comment\">//错误！</span></span><br></pre></td></tr></table></figure>\n\n<p>因为 class 中有一个没有 explicit 的“转换构造函数”，所以可以发生隐式类型转换，将 2 直接隐式转换为了一个 Rational 对象。但 2 没法调用 operator*，所以第二条语句无法通过编译。</p>\n<blockquote>\n<p>转换构造函数只有一个参数（或其他参数均有默认值），而且该参数又不是 class 的 const reference 。</p>\n</blockquote>\n<p>为了支持混合式算术运算，需要把 operator* 定义成 non-member 函数：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Rational</span> &#123;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> Rational <span class=\"keyword\">operator</span>*(<span class=\"keyword\">const</span> Rational&amp; lhs, <span class=\"keyword\">const</span> Rational&amp; rhs)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Rational</span>(lhs.<span class=\"built_in\">numerator</span>() * rhs.<span class=\"built_in\">numerator</span>(), lhs.<span class=\"built_in\">denominator</span>() * rhs.<span class=\"built_in\">denominator</span>());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">Rational <span class=\"title\">oneFourth</span><span class=\"params\">(<span class=\"number\">1</span>, <span class=\"number\">4</span>)</span></span>;</span><br><span class=\"line\">Rational result;</span><br><span class=\"line\">result = oneFourth * <span class=\"number\">2</span>;</span><br><span class=\"line\">result = <span class=\"number\">2</span> * oneFourth; \t<span class=\"comment\">//OK</span></span><br></pre></td></tr></table></figure>\n\n<p>要不要把 operator* 实现为一个 Rational class 的 friend 函数？答案是不需要，因为 operator* 函数不需要访问 private 成员</p>\n"},{"_content":"考虑一个有理数 class\n\n```cpp\nclass Rational {\npublic:\n    Rational(int numerator = 0, int denominator = 1);\n    ...\nprivate:\n    int n,d;  // 分子、分母\n    friend const Rational operator* (const Rational& lhs, const Rational& rhs);\n};\n```\n\n注意 operator* 函数的返回值类型是 const value 类型，这里是否需要返回 reference 以避免临时对象的构造、析构成本呢？\n\nby reference 传递出来的语义是一个已存在的东西的名称，所以如果要返回 reference 对象，那么这个对象必须在 operator* 函数内部创建出来，因为两个形参都不能作为乘积的结果来返回。\n\n1. 在 local stack 上创建对象：\n\n```cpp\nconst Rational& operator* (const Rational& lhs, const Rational& rhs)\n{\n    Rational result(lhs.n * rhs.n, lhs.d * rhs.d);\n    return result;\n}\n```\n\n上面这种做法是极其错误的，因为 local 对象在函数结束时已经被销毁了，对这个已死亡对象的 reference 是无意义的\n\n2. 在 heap 上创建对象：\n\n```cpp\nconst Rational& operator* (const Rational& lhs, const Rational& rhs)\n{\n    Rational* result = new Rational(lhs.n * rhs.n, lhs.d * rhs.d);\n    return result;\n}\n```\n\n这又会造成不好 delete 的糟糕状况\n\n3. 定义在函数内部的 static Rational 对象\n\n```cpp\nconst Rational& operator* (const Rational& lhs, const Rational& rhs)\n{\n    static Rational result;\n    result = ...\n    return result;\n}\n```\n\n这种代码在实际中是不可用的，例如：\n\n```cpp\nbool operator==(const Rational& lhs, const Rational& rhs);\nRational a,b,c,d;\n...\nif((a*b) == (c*d)){\n}\n```\n\n注意，表达式 ((a*b) == (c\\*d)) 永远为真，因为 static 对象只有一份\n\n**综上，绝对不要让函数返回 pointer 或 reference 指向一个 local stack 对象，或 heap-allocated 对象。当返回 local static 对象时，要记住这个对象只有一份**\n\n\n\n","source":"_posts/C++/《effective C++ 第三版》读书笔记/4. 设计与声明/条款21：必须返回对象时，别妄想返回其reference.md","raw":"考虑一个有理数 class\n\n```cpp\nclass Rational {\npublic:\n    Rational(int numerator = 0, int denominator = 1);\n    ...\nprivate:\n    int n,d;  // 分子、分母\n    friend const Rational operator* (const Rational& lhs, const Rational& rhs);\n};\n```\n\n注意 operator* 函数的返回值类型是 const value 类型，这里是否需要返回 reference 以避免临时对象的构造、析构成本呢？\n\nby reference 传递出来的语义是一个已存在的东西的名称，所以如果要返回 reference 对象，那么这个对象必须在 operator* 函数内部创建出来，因为两个形参都不能作为乘积的结果来返回。\n\n1. 在 local stack 上创建对象：\n\n```cpp\nconst Rational& operator* (const Rational& lhs, const Rational& rhs)\n{\n    Rational result(lhs.n * rhs.n, lhs.d * rhs.d);\n    return result;\n}\n```\n\n上面这种做法是极其错误的，因为 local 对象在函数结束时已经被销毁了，对这个已死亡对象的 reference 是无意义的\n\n2. 在 heap 上创建对象：\n\n```cpp\nconst Rational& operator* (const Rational& lhs, const Rational& rhs)\n{\n    Rational* result = new Rational(lhs.n * rhs.n, lhs.d * rhs.d);\n    return result;\n}\n```\n\n这又会造成不好 delete 的糟糕状况\n\n3. 定义在函数内部的 static Rational 对象\n\n```cpp\nconst Rational& operator* (const Rational& lhs, const Rational& rhs)\n{\n    static Rational result;\n    result = ...\n    return result;\n}\n```\n\n这种代码在实际中是不可用的，例如：\n\n```cpp\nbool operator==(const Rational& lhs, const Rational& rhs);\nRational a,b,c,d;\n...\nif((a*b) == (c*d)){\n}\n```\n\n注意，表达式 ((a*b) == (c\\*d)) 永远为真，因为 static 对象只有一份\n\n**综上，绝对不要让函数返回 pointer 或 reference 指向一个 local stack 对象，或 heap-allocated 对象。当返回 local static 对象时，要记住这个对象只有一份**\n\n\n\n","slug":"C++/《effective C++ 第三版》读书笔记/4. 设计与声明/条款21：必须返回对象时，别妄想返回其reference","published":1,"date":"2022-06-22T09:55:06.946Z","updated":"2022-06-22T10:21:20.180Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0kyo002rpcu31u8e3nfh","content":"<p>考虑一个有理数 class</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Rational</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Rational</span>(<span class=\"keyword\">int</span> numerator = <span class=\"number\">0</span>, <span class=\"keyword\">int</span> denominator = <span class=\"number\">1</span>);</span><br><span class=\"line\">    ...</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n,d;  <span class=\"comment\">// 分子、分母</span></span><br><span class=\"line\">    <span class=\"keyword\">friend</span> <span class=\"keyword\">const</span> Rational <span class=\"keyword\">operator</span>* (<span class=\"keyword\">const</span> Rational&amp; lhs, <span class=\"keyword\">const</span> Rational&amp; rhs);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>注意 operator* 函数的返回值类型是 const value 类型，这里是否需要返回 reference 以避免临时对象的构造、析构成本呢？</p>\n<p>by reference 传递出来的语义是一个已存在的东西的名称，所以如果要返回 reference 对象，那么这个对象必须在 operator* 函数内部创建出来，因为两个形参都不能作为乘积的结果来返回。</p>\n<ol>\n<li>在 local stack 上创建对象：</li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Rational&amp; <span class=\"keyword\">operator</span>* (<span class=\"keyword\">const</span> Rational&amp; lhs, <span class=\"keyword\">const</span> Rational&amp; rhs)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\">Rational <span class=\"title\">result</span><span class=\"params\">(lhs.n * rhs.n, lhs.d * rhs.d)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面这种做法是极其错误的，因为 local 对象在函数结束时已经被销毁了，对这个已死亡对象的 reference 是无意义的</p>\n<ol start=\"2\">\n<li>在 heap 上创建对象：</li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Rational&amp; <span class=\"keyword\">operator</span>* (<span class=\"keyword\">const</span> Rational&amp; lhs, <span class=\"keyword\">const</span> Rational&amp; rhs)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Rational* result = <span class=\"keyword\">new</span> <span class=\"built_in\">Rational</span>(lhs.n * rhs.n, lhs.d * rhs.d);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这又会造成不好 delete 的糟糕状况</p>\n<ol start=\"3\">\n<li>定义在函数内部的 static Rational 对象</li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Rational&amp; <span class=\"keyword\">operator</span>* (<span class=\"keyword\">const</span> Rational&amp; lhs, <span class=\"keyword\">const</span> Rational&amp; rhs)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> Rational result;</span><br><span class=\"line\">    result = ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这种代码在实际中是不可用的，例如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>==(<span class=\"keyword\">const</span> Rational&amp; lhs, <span class=\"keyword\">const</span> Rational&amp; rhs);</span><br><span class=\"line\">Rational a,b,c,d;</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">if</span>((a*b) == (c*d))&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意，表达式 ((a*b) == (c*d)) 永远为真，因为 static 对象只有一份</p>\n<p><strong>综上，绝对不要让函数返回 pointer 或 reference 指向一个 local stack 对象，或 heap-allocated 对象。当返回 local static 对象时，要记住这个对象只有一份</strong></p>\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<p>考虑一个有理数 class</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Rational</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Rational</span>(<span class=\"keyword\">int</span> numerator = <span class=\"number\">0</span>, <span class=\"keyword\">int</span> denominator = <span class=\"number\">1</span>);</span><br><span class=\"line\">    ...</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n,d;  <span class=\"comment\">// 分子、分母</span></span><br><span class=\"line\">    <span class=\"keyword\">friend</span> <span class=\"keyword\">const</span> Rational <span class=\"keyword\">operator</span>* (<span class=\"keyword\">const</span> Rational&amp; lhs, <span class=\"keyword\">const</span> Rational&amp; rhs);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>注意 operator* 函数的返回值类型是 const value 类型，这里是否需要返回 reference 以避免临时对象的构造、析构成本呢？</p>\n<p>by reference 传递出来的语义是一个已存在的东西的名称，所以如果要返回 reference 对象，那么这个对象必须在 operator* 函数内部创建出来，因为两个形参都不能作为乘积的结果来返回。</p>\n<ol>\n<li>在 local stack 上创建对象：</li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Rational&amp; <span class=\"keyword\">operator</span>* (<span class=\"keyword\">const</span> Rational&amp; lhs, <span class=\"keyword\">const</span> Rational&amp; rhs)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\">Rational <span class=\"title\">result</span><span class=\"params\">(lhs.n * rhs.n, lhs.d * rhs.d)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面这种做法是极其错误的，因为 local 对象在函数结束时已经被销毁了，对这个已死亡对象的 reference 是无意义的</p>\n<ol start=\"2\">\n<li>在 heap 上创建对象：</li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Rational&amp; <span class=\"keyword\">operator</span>* (<span class=\"keyword\">const</span> Rational&amp; lhs, <span class=\"keyword\">const</span> Rational&amp; rhs)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Rational* result = <span class=\"keyword\">new</span> <span class=\"built_in\">Rational</span>(lhs.n * rhs.n, lhs.d * rhs.d);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这又会造成不好 delete 的糟糕状况</p>\n<ol start=\"3\">\n<li>定义在函数内部的 static Rational 对象</li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Rational&amp; <span class=\"keyword\">operator</span>* (<span class=\"keyword\">const</span> Rational&amp; lhs, <span class=\"keyword\">const</span> Rational&amp; rhs)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> Rational result;</span><br><span class=\"line\">    result = ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这种代码在实际中是不可用的，例如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>==(<span class=\"keyword\">const</span> Rational&amp; lhs, <span class=\"keyword\">const</span> Rational&amp; rhs);</span><br><span class=\"line\">Rational a,b,c,d;</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">if</span>((a*b) == (c*d))&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意，表达式 ((a*b) == (c*d)) 永远为真，因为 static 对象只有一份</p>\n<p><strong>综上，绝对不要让函数返回 pointer 或 reference 指向一个 local stack 对象，或 heap-allocated 对象。当返回 local static 对象时，要记住这个对象只有一份</strong></p>\n"},{"_content":"信号量是进程/线程间同步手段的原语\n\n#### 1. 二值信号量（值为0，1）\n\n考虑不同进程间的同步\n\n![image-20220429152324117](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220429152324117.png)\n\n进程可以在信号量上执行三种操作：创建、等待、挂起\n\n1. 创建一个信号量\n\n2. 等待一个信号量\n\n   进程测试一个信号量的值，如果它小于等于0，则进程阻塞，直到信号量的值变为1，然后进程将信号量的值减1\n\n   ```cpp\n   while(semaphore_value <= 0)\n       ;\n   semaphore_value--;\n   /* we have the semaphore */\n   ```\n\n3. 挂出（post）一个信号量，将一个信号量的值加1，有可能会唤醒一个阻塞的进程\n\n   ```cpp\n   semaphore_value++;\n   ```\n\n","source":"_posts/C++/多线程/进程间通信IPC/信号量.md","raw":"信号量是进程/线程间同步手段的原语\n\n#### 1. 二值信号量（值为0，1）\n\n考虑不同进程间的同步\n\n![image-20220429152324117](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220429152324117.png)\n\n进程可以在信号量上执行三种操作：创建、等待、挂起\n\n1. 创建一个信号量\n\n2. 等待一个信号量\n\n   进程测试一个信号量的值，如果它小于等于0，则进程阻塞，直到信号量的值变为1，然后进程将信号量的值减1\n\n   ```cpp\n   while(semaphore_value <= 0)\n       ;\n   semaphore_value--;\n   /* we have the semaphore */\n   ```\n\n3. 挂出（post）一个信号量，将一个信号量的值加1，有可能会唤醒一个阻塞的进程\n\n   ```cpp\n   semaphore_value++;\n   ```\n\n","slug":"C++/多线程/进程间通信IPC/信号量","published":1,"date":"2022-04-29T07:18:13.035Z","updated":"2022-05-12T14:08:04.386Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0kyp002spcu30ah01pqk","content":"<p>信号量是进程/线程间同步手段的原语</p>\n<h4 id=\"1-二值信号量（值为0，1）\"><a href=\"#1-二值信号量（值为0，1）\" class=\"headerlink\" title=\"1. 二值信号量（值为0，1）\"></a>1. 二值信号量（值为0，1）</h4><p>考虑不同进程间的同步</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220429152324117.png\" alt=\"image-20220429152324117\"></p>\n<p>进程可以在信号量上执行三种操作：创建、等待、挂起</p>\n<ol>\n<li><p>创建一个信号量</p>\n</li>\n<li><p>等待一个信号量</p>\n<p>进程测试一个信号量的值，如果它小于等于0，则进程阻塞，直到信号量的值变为1，然后进程将信号量的值减1</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(semaphore_value &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">    ;</span><br><span class=\"line\">semaphore_value--;</span><br><span class=\"line\"><span class=\"comment\">/* we have the semaphore */</span></span><br></pre></td></tr></table></figure></li>\n<li><p>挂出（post）一个信号量，将一个信号量的值加1，有可能会唤醒一个阻塞的进程</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">semaphore_value++;</span><br></pre></td></tr></table></figure></li>\n</ol>\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<p>信号量是进程/线程间同步手段的原语</p>\n<h4 id=\"1-二值信号量（值为0，1）\"><a href=\"#1-二值信号量（值为0，1）\" class=\"headerlink\" title=\"1. 二值信号量（值为0，1）\"></a>1. 二值信号量（值为0，1）</h4><p>考虑不同进程间的同步</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220429152324117.png\" alt=\"image-20220429152324117\"></p>\n<p>进程可以在信号量上执行三种操作：创建、等待、挂起</p>\n<ol>\n<li><p>创建一个信号量</p>\n</li>\n<li><p>等待一个信号量</p>\n<p>进程测试一个信号量的值，如果它小于等于0，则进程阻塞，直到信号量的值变为1，然后进程将信号量的值减1</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(semaphore_value &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">    ;</span><br><span class=\"line\">semaphore_value--;</span><br><span class=\"line\"><span class=\"comment\">/* we have the semaphore */</span></span><br></pre></td></tr></table></figure></li>\n<li><p>挂出（post）一个信号量，将一个信号量的值加1，有可能会唤醒一个阻塞的进程</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">semaphore_value++;</span><br></pre></td></tr></table></figure></li>\n</ol>\n"},{"_content":"这里只将System V消息队列，因为其使用更广\n\n在内核中维护一个链表，每个节点都是一个消息，每个消息的属性有：\n\n1. 优先级（long 类型System V）\n\n2. 消息数据部分长度（可用来识别消息边界）\n3. 实际数据\n\n![image-20220429112312157](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220429112312157.png)\n\n具有足够写权限的线程可向链表中放置消息并设置其优先级，有足够读权限的线程可从链表中取出消息。一个进程向链表中添加节点（消息）时，并不要求另一个进程在等待此消息，但管道要求读、写者同时存在。\n\n链表头节点中有整个队列的属性：队列中允许的最大消息数，每个消息的最大大小等\n\nSystem V消息队列存放在内核中（下图中），且具有内核持续性，即使进程被关闭了，消息队列仍然存在于内核中\n\n> 内核持续性，IPC对象一直存在直到内核重新自举或显示删除该对象为止\n\n![image-20220428211142434](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220428211142434.png)\n","source":"_posts/C++/多线程/进程间通信IPC/消息队列.md","raw":"这里只将System V消息队列，因为其使用更广\n\n在内核中维护一个链表，每个节点都是一个消息，每个消息的属性有：\n\n1. 优先级（long 类型System V）\n\n2. 消息数据部分长度（可用来识别消息边界）\n3. 实际数据\n\n![image-20220429112312157](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220429112312157.png)\n\n具有足够写权限的线程可向链表中放置消息并设置其优先级，有足够读权限的线程可从链表中取出消息。一个进程向链表中添加节点（消息）时，并不要求另一个进程在等待此消息，但管道要求读、写者同时存在。\n\n链表头节点中有整个队列的属性：队列中允许的最大消息数，每个消息的最大大小等\n\nSystem V消息队列存放在内核中（下图中），且具有内核持续性，即使进程被关闭了，消息队列仍然存在于内核中\n\n> 内核持续性，IPC对象一直存在直到内核重新自举或显示删除该对象为止\n\n![image-20220428211142434](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220428211142434.png)\n","slug":"C++/多线程/进程间通信IPC/消息队列","published":1,"date":"2022-04-28T13:28:26.203Z","updated":"2022-05-12T14:05:35.999Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0kyq002tpcu30maddlvi","content":"<p>这里只将System V消息队列，因为其使用更广</p>\n<p>在内核中维护一个链表，每个节点都是一个消息，每个消息的属性有：</p>\n<ol>\n<li><p>优先级（long 类型System V）</p>\n</li>\n<li><p>消息数据部分长度（可用来识别消息边界）</p>\n</li>\n<li><p>实际数据</p>\n</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220429112312157.png\" alt=\"image-20220429112312157\"></p>\n<p>具有足够写权限的线程可向链表中放置消息并设置其优先级，有足够读权限的线程可从链表中取出消息。一个进程向链表中添加节点（消息）时，并不要求另一个进程在等待此消息，但管道要求读、写者同时存在。</p>\n<p>链表头节点中有整个队列的属性：队列中允许的最大消息数，每个消息的最大大小等</p>\n<p>System V消息队列存放在内核中（下图中），且具有内核持续性，即使进程被关闭了，消息队列仍然存在于内核中</p>\n<blockquote>\n<p>内核持续性，IPC对象一直存在直到内核重新自举或显示删除该对象为止</p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220428211142434.png\" alt=\"image-20220428211142434\"></p>\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<p>这里只将System V消息队列，因为其使用更广</p>\n<p>在内核中维护一个链表，每个节点都是一个消息，每个消息的属性有：</p>\n<ol>\n<li><p>优先级（long 类型System V）</p>\n</li>\n<li><p>消息数据部分长度（可用来识别消息边界）</p>\n</li>\n<li><p>实际数据</p>\n</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220429112312157.png\" alt=\"image-20220429112312157\"></p>\n<p>具有足够写权限的线程可向链表中放置消息并设置其优先级，有足够读权限的线程可从链表中取出消息。一个进程向链表中添加节点（消息）时，并不要求另一个进程在等待此消息，但管道要求读、写者同时存在。</p>\n<p>链表头节点中有整个队列的属性：队列中允许的最大消息数，每个消息的最大大小等</p>\n<p>System V消息队列存放在内核中（下图中），且具有内核持续性，即使进程被关闭了，消息队列仍然存在于内核中</p>\n<blockquote>\n<p>内核持续性，IPC对象一直存在直到内核重新自举或显示删除该对象为止</p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220428211142434.png\" alt=\"image-20220428211142434\"></p>\n"},{"_content":"\n\n其他 IPC形式（管道、FIFO、消息队列）的通用问题是：进程之间交换信息是，数据流必须经过内核，就要进行用户态和内核态的切换、内核和用户进程之间的数据复制，会造成额外的开销。而共享内存可以绕过内核，直接对<u>共享内存区</u>进行读写，但是进程在访问共享内存的时候必须要考虑<u>同步</u>问题\n\n![4ED4A595F06036CBEE114CBC6EE61FA4](https://raw.githubusercontent.com/Vio1ette/blog-img/main/4ED4A595F06036CBEE114CBC6EE61FA4.png)\n\n### 2. 共享内存的实现方式\n\n#### 2.1 mmap（内存映射文件）\n\n磁盘中的一个文件可以映射到进程的虚拟内存上，然后进程访问自己的虚拟内存上的这块映射区，对其进行读写，其实是对磁盘文件进行了读写，但是这里对磁盘文件进行读写竟然不用系统调用，不用转换状态（用户态->内核态），因为在进程看来，自己只不过是在访问自己的内存地址空间而已\n\n![img](https://raw.githubusercontent.com/Vio1ette/blog-img/main/20200917180729.png)\n\n> 磁盘文件映射虚拟内存，虚拟内存映射物理内存，实际上就是磁盘文件映射物理内存！\n\n#### 2.2 System V共享内存\n\n在<u>物理内存</u>上创建一块共享内存区，不同进程将自己的一块虚拟内存通过页表映射到同一块物理内存\n\n![img](https://raw.githubusercontent.com/Vio1ette/blog-img/main/20200917180539.png)\n\n\n\n参考资料：\n\n（1）https://cana.space/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E4%B8%8E%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84/\n\n（2）《unix网络编程-卷2，进程间通信》\n","source":"_posts/C++/多线程/进程间通信IPC/共享内存.md","raw":"\n\n其他 IPC形式（管道、FIFO、消息队列）的通用问题是：进程之间交换信息是，数据流必须经过内核，就要进行用户态和内核态的切换、内核和用户进程之间的数据复制，会造成额外的开销。而共享内存可以绕过内核，直接对<u>共享内存区</u>进行读写，但是进程在访问共享内存的时候必须要考虑<u>同步</u>问题\n\n![4ED4A595F06036CBEE114CBC6EE61FA4](https://raw.githubusercontent.com/Vio1ette/blog-img/main/4ED4A595F06036CBEE114CBC6EE61FA4.png)\n\n### 2. 共享内存的实现方式\n\n#### 2.1 mmap（内存映射文件）\n\n磁盘中的一个文件可以映射到进程的虚拟内存上，然后进程访问自己的虚拟内存上的这块映射区，对其进行读写，其实是对磁盘文件进行了读写，但是这里对磁盘文件进行读写竟然不用系统调用，不用转换状态（用户态->内核态），因为在进程看来，自己只不过是在访问自己的内存地址空间而已\n\n![img](https://raw.githubusercontent.com/Vio1ette/blog-img/main/20200917180729.png)\n\n> 磁盘文件映射虚拟内存，虚拟内存映射物理内存，实际上就是磁盘文件映射物理内存！\n\n#### 2.2 System V共享内存\n\n在<u>物理内存</u>上创建一块共享内存区，不同进程将自己的一块虚拟内存通过页表映射到同一块物理内存\n\n![img](https://raw.githubusercontent.com/Vio1ette/blog-img/main/20200917180539.png)\n\n\n\n参考资料：\n\n（1）https://cana.space/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E4%B8%8E%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84/\n\n（2）《unix网络编程-卷2，进程间通信》\n","slug":"C++/多线程/进程间通信IPC/共享内存","published":1,"date":"2022-04-29T03:32:57.864Z","updated":"2022-05-05T06:25:29.190Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0kys002upcu33n2s81rg","content":"<p>其他 IPC形式（管道、FIFO、消息队列）的通用问题是：进程之间交换信息是，数据流必须经过内核，就要进行用户态和内核态的切换、内核和用户进程之间的数据复制，会造成额外的开销。而共享内存可以绕过内核，直接对<u>共享内存区</u>进行读写，但是进程在访问共享内存的时候必须要考虑<u>同步</u>问题</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/4ED4A595F06036CBEE114CBC6EE61FA4.png\" alt=\"4ED4A595F06036CBEE114CBC6EE61FA4\"></p>\n<h3 id=\"2-共享内存的实现方式\"><a href=\"#2-共享内存的实现方式\" class=\"headerlink\" title=\"2. 共享内存的实现方式\"></a>2. 共享内存的实现方式</h3><h4 id=\"2-1-mmap（内存映射文件）\"><a href=\"#2-1-mmap（内存映射文件）\" class=\"headerlink\" title=\"2.1 mmap（内存映射文件）\"></a>2.1 mmap（内存映射文件）</h4><p>磁盘中的一个文件可以映射到进程的虚拟内存上，然后进程访问自己的虚拟内存上的这块映射区，对其进行读写，其实是对磁盘文件进行了读写，但是这里对磁盘文件进行读写竟然不用系统调用，不用转换状态（用户态-&gt;内核态），因为在进程看来，自己只不过是在访问自己的内存地址空间而已</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/20200917180729.png\" alt=\"img\"></p>\n<blockquote>\n<p>磁盘文件映射虚拟内存，虚拟内存映射物理内存，实际上就是磁盘文件映射物理内存！</p>\n</blockquote>\n<h4 id=\"2-2-System-V共享内存\"><a href=\"#2-2-System-V共享内存\" class=\"headerlink\" title=\"2.2 System V共享内存\"></a>2.2 System V共享内存</h4><p>在<u>物理内存</u>上创建一块共享内存区，不同进程将自己的一块虚拟内存通过页表映射到同一块物理内存</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/20200917180539.png\" alt=\"img\"></p>\n<p>参考资料：</p>\n<p>（1）<a href=\"https://cana.space/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E4%B8%8E%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84/\">https://cana.space/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E4%B8%8E%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84/</a></p>\n<p>（2）《unix网络编程-卷2，进程间通信》</p>\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<p>其他 IPC形式（管道、FIFO、消息队列）的通用问题是：进程之间交换信息是，数据流必须经过内核，就要进行用户态和内核态的切换、内核和用户进程之间的数据复制，会造成额外的开销。而共享内存可以绕过内核，直接对<u>共享内存区</u>进行读写，但是进程在访问共享内存的时候必须要考虑<u>同步</u>问题</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/4ED4A595F06036CBEE114CBC6EE61FA4.png\" alt=\"4ED4A595F06036CBEE114CBC6EE61FA4\"></p>\n<h3 id=\"2-共享内存的实现方式\"><a href=\"#2-共享内存的实现方式\" class=\"headerlink\" title=\"2. 共享内存的实现方式\"></a>2. 共享内存的实现方式</h3><h4 id=\"2-1-mmap（内存映射文件）\"><a href=\"#2-1-mmap（内存映射文件）\" class=\"headerlink\" title=\"2.1 mmap（内存映射文件）\"></a>2.1 mmap（内存映射文件）</h4><p>磁盘中的一个文件可以映射到进程的虚拟内存上，然后进程访问自己的虚拟内存上的这块映射区，对其进行读写，其实是对磁盘文件进行了读写，但是这里对磁盘文件进行读写竟然不用系统调用，不用转换状态（用户态-&gt;内核态），因为在进程看来，自己只不过是在访问自己的内存地址空间而已</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/20200917180729.png\" alt=\"img\"></p>\n<blockquote>\n<p>磁盘文件映射虚拟内存，虚拟内存映射物理内存，实际上就是磁盘文件映射物理内存！</p>\n</blockquote>\n<h4 id=\"2-2-System-V共享内存\"><a href=\"#2-2-System-V共享内存\" class=\"headerlink\" title=\"2.2 System V共享内存\"></a>2.2 System V共享内存</h4><p>在<u>物理内存</u>上创建一块共享内存区，不同进程将自己的一块虚拟内存通过页表映射到同一块物理内存</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/20200917180539.png\" alt=\"img\"></p>\n<p>参考资料：</p>\n<p>（1）<a href=\"https://cana.space/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E4%B8%8E%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84/\">https://cana.space/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E4%B8%8E%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84/</a></p>\n<p>（2）《unix网络编程-卷2，进程间通信》</p>\n"},{"_content":"## 1. 匿名管道\n\n匿名管道只能用于具有<u>亲缘关系</u>的进程\n\n> 当两个或多个无亲缘关系的进程使用某种类型的IPC对象来通信时，该IPC对象必须是有名字或标识符的，否则它无法被不同进程（没有亲缘关系）指定\n\n管道内的<u>数据是在内核中维护</u>的（如下图，管道属于kernel中的shared info），但管道的数据依赖于进程而存在（<u>进程持续性</u>），如果打开管道的进程关闭它时，内核将丢弃所有数据并删除管道。\n\n![image-20220428211142434](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220428211142434.png)\n\n匿名管道由pipe函数创建，是一个<u>单工</u>（向）<u>先进先出</u>数据流，不支持异步读写（要求读、写者同时存在），当写端未写完或管道为空时，read发生阻塞；当读端未读完或管道已经满了时，write发生阻塞。\n\n```cpp\n#include <unistd.h>\nint pipe(int fd[2]);   //若成功建立管道，pipe函数返回0，出错则返回1\n```\n\npipe维护两个文件描述符，fd[0]，fd[1]。第一个文件`fd[0]`专门用作“读”，第二个文件`fd[1]`专门用作“写”\n\n### 1.1 父子进程间通信\n\n如果一个进程创建一个管道后，fork一个子进程，则它们之间的管道连接如下：\n\n![image-20220428210245867](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220428210245867.png)\n\n如果父进程关闭管道的读出端`fd[0]`，子进程关闭管道的写入端`fd[1]`，就在父子进程间形成了一个单向数据流：\n\n![image-20220428211812466](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220428211812466.png)\n\n### 1.2 shell中的管道：who | sort | lp\n\nwho | sort | lp 包含三个命令，将创建三个进程，每个进程的输入输出通过管道建立连接：\n\n![image-20220428212039614](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220428212039614.png)\n\n\n\n## 2. FIFO\n\n匿名管道的最大缺陷是只能用于有亲缘关系的进程之间，无亲缘关系进程之间的通信可用FIFO，FIFO（first in, first out）类似于管道，每个FIFO都有一个<u>路径名</u>与之关联，所以FIFO又被称为有名管道。FIFO是半双工的，就有进程持续性\n\n","source":"_posts/C++/多线程/进程间通信IPC/管道.md","raw":"## 1. 匿名管道\n\n匿名管道只能用于具有<u>亲缘关系</u>的进程\n\n> 当两个或多个无亲缘关系的进程使用某种类型的IPC对象来通信时，该IPC对象必须是有名字或标识符的，否则它无法被不同进程（没有亲缘关系）指定\n\n管道内的<u>数据是在内核中维护</u>的（如下图，管道属于kernel中的shared info），但管道的数据依赖于进程而存在（<u>进程持续性</u>），如果打开管道的进程关闭它时，内核将丢弃所有数据并删除管道。\n\n![image-20220428211142434](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220428211142434.png)\n\n匿名管道由pipe函数创建，是一个<u>单工</u>（向）<u>先进先出</u>数据流，不支持异步读写（要求读、写者同时存在），当写端未写完或管道为空时，read发生阻塞；当读端未读完或管道已经满了时，write发生阻塞。\n\n```cpp\n#include <unistd.h>\nint pipe(int fd[2]);   //若成功建立管道，pipe函数返回0，出错则返回1\n```\n\npipe维护两个文件描述符，fd[0]，fd[1]。第一个文件`fd[0]`专门用作“读”，第二个文件`fd[1]`专门用作“写”\n\n### 1.1 父子进程间通信\n\n如果一个进程创建一个管道后，fork一个子进程，则它们之间的管道连接如下：\n\n![image-20220428210245867](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220428210245867.png)\n\n如果父进程关闭管道的读出端`fd[0]`，子进程关闭管道的写入端`fd[1]`，就在父子进程间形成了一个单向数据流：\n\n![image-20220428211812466](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220428211812466.png)\n\n### 1.2 shell中的管道：who | sort | lp\n\nwho | sort | lp 包含三个命令，将创建三个进程，每个进程的输入输出通过管道建立连接：\n\n![image-20220428212039614](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220428212039614.png)\n\n\n\n## 2. FIFO\n\n匿名管道的最大缺陷是只能用于有亲缘关系的进程之间，无亲缘关系进程之间的通信可用FIFO，FIFO（first in, first out）类似于管道，每个FIFO都有一个<u>路径名</u>与之关联，所以FIFO又被称为有名管道。FIFO是半双工的，就有进程持续性\n\n","slug":"C++/多线程/进程间通信IPC/管道","published":1,"date":"2022-04-28T12:48:31.950Z","updated":"2022-05-12T14:06:22.914Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7yt0kyt002vpcu36yqk71qb","content":"<h2 id=\"1-匿名管道\"><a href=\"#1-匿名管道\" class=\"headerlink\" title=\"1. 匿名管道\"></a>1. 匿名管道</h2><p>匿名管道只能用于具有<u>亲缘关系</u>的进程</p>\n<blockquote>\n<p>当两个或多个无亲缘关系的进程使用某种类型的IPC对象来通信时，该IPC对象必须是有名字或标识符的，否则它无法被不同进程（没有亲缘关系）指定</p>\n</blockquote>\n<p>管道内的<u>数据是在内核中维护</u>的（如下图，管道属于kernel中的shared info），但管道的数据依赖于进程而存在（<u>进程持续性</u>），如果打开管道的进程关闭它时，内核将丢弃所有数据并删除管道。</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220428211142434.png\" alt=\"image-20220428211142434\"></p>\n<p>匿名管道由pipe函数创建，是一个<u>单工</u>（向）<u>先进先出</u>数据流，不支持异步读写（要求读、写者同时存在），当写端未写完或管道为空时，read发生阻塞；当读端未读完或管道已经满了时，write发生阻塞。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pipe</span><span class=\"params\">(<span class=\"keyword\">int</span> fd[<span class=\"number\">2</span>])</span></span>;   <span class=\"comment\">//若成功建立管道，pipe函数返回0，出错则返回1</span></span><br></pre></td></tr></table></figure>\n\n<p>pipe维护两个文件描述符，fd[0]，fd[1]。第一个文件<code>fd[0]</code>专门用作“读”，第二个文件<code>fd[1]</code>专门用作“写”</p>\n<h3 id=\"1-1-父子进程间通信\"><a href=\"#1-1-父子进程间通信\" class=\"headerlink\" title=\"1.1 父子进程间通信\"></a>1.1 父子进程间通信</h3><p>如果一个进程创建一个管道后，fork一个子进程，则它们之间的管道连接如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220428210245867.png\" alt=\"image-20220428210245867\"></p>\n<p>如果父进程关闭管道的读出端<code>fd[0]</code>，子进程关闭管道的写入端<code>fd[1]</code>，就在父子进程间形成了一个单向数据流：</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220428211812466.png\" alt=\"image-20220428211812466\"></p>\n<h3 id=\"1-2-shell中的管道：who-sort-lp\"><a href=\"#1-2-shell中的管道：who-sort-lp\" class=\"headerlink\" title=\"1.2 shell中的管道：who | sort | lp\"></a>1.2 shell中的管道：who | sort | lp</h3><p>who | sort | lp 包含三个命令，将创建三个进程，每个进程的输入输出通过管道建立连接：</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220428212039614.png\" alt=\"image-20220428212039614\"></p>\n<h2 id=\"2-FIFO\"><a href=\"#2-FIFO\" class=\"headerlink\" title=\"2. FIFO\"></a>2. FIFO</h2><p>匿名管道的最大缺陷是只能用于有亲缘关系的进程之间，无亲缘关系进程之间的通信可用FIFO，FIFO（first in, first out）类似于管道，每个FIFO都有一个<u>路径名</u>与之关联，所以FIFO又被称为有名管道。FIFO是半双工的，就有进程持续性</p>\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<h2 id=\"1-匿名管道\"><a href=\"#1-匿名管道\" class=\"headerlink\" title=\"1. 匿名管道\"></a>1. 匿名管道</h2><p>匿名管道只能用于具有<u>亲缘关系</u>的进程</p>\n<blockquote>\n<p>当两个或多个无亲缘关系的进程使用某种类型的IPC对象来通信时，该IPC对象必须是有名字或标识符的，否则它无法被不同进程（没有亲缘关系）指定</p>\n</blockquote>\n<p>管道内的<u>数据是在内核中维护</u>的（如下图，管道属于kernel中的shared info），但管道的数据依赖于进程而存在（<u>进程持续性</u>），如果打开管道的进程关闭它时，内核将丢弃所有数据并删除管道。</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220428211142434.png\" alt=\"image-20220428211142434\"></p>\n<p>匿名管道由pipe函数创建，是一个<u>单工</u>（向）<u>先进先出</u>数据流，不支持异步读写（要求读、写者同时存在），当写端未写完或管道为空时，read发生阻塞；当读端未读完或管道已经满了时，write发生阻塞。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pipe</span><span class=\"params\">(<span class=\"keyword\">int</span> fd[<span class=\"number\">2</span>])</span></span>;   <span class=\"comment\">//若成功建立管道，pipe函数返回0，出错则返回1</span></span><br></pre></td></tr></table></figure>\n\n<p>pipe维护两个文件描述符，fd[0]，fd[1]。第一个文件<code>fd[0]</code>专门用作“读”，第二个文件<code>fd[1]</code>专门用作“写”</p>\n<h3 id=\"1-1-父子进程间通信\"><a href=\"#1-1-父子进程间通信\" class=\"headerlink\" title=\"1.1 父子进程间通信\"></a>1.1 父子进程间通信</h3><p>如果一个进程创建一个管道后，fork一个子进程，则它们之间的管道连接如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220428210245867.png\" alt=\"image-20220428210245867\"></p>\n<p>如果父进程关闭管道的读出端<code>fd[0]</code>，子进程关闭管道的写入端<code>fd[1]</code>，就在父子进程间形成了一个单向数据流：</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220428211812466.png\" alt=\"image-20220428211812466\"></p>\n<h3 id=\"1-2-shell中的管道：who-sort-lp\"><a href=\"#1-2-shell中的管道：who-sort-lp\" class=\"headerlink\" title=\"1.2 shell中的管道：who | sort | lp\"></a>1.2 shell中的管道：who | sort | lp</h3><p>who | sort | lp 包含三个命令，将创建三个进程，每个进程的输入输出通过管道建立连接：</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220428212039614.png\" alt=\"image-20220428212039614\"></p>\n<h2 id=\"2-FIFO\"><a href=\"#2-FIFO\" class=\"headerlink\" title=\"2. FIFO\"></a>2. FIFO</h2><p>匿名管道的最大缺陷是只能用于有亲缘关系的进程之间，无亲缘关系进程之间的通信可用FIFO，FIFO（first in, first out）类似于管道，每个FIFO都有一个<u>路径名</u>与之关联，所以FIFO又被称为有名管道。FIFO是半双工的，就有进程持续性</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cl7yt0kx9000ppcu39gt2hosc","category_id":"cl7yt0kxc000rpcu34r1s2utl","_id":"cl7yt0kxo0011pcu365g33du3"},{"post_id":"cl7yt0kxa000qpcu3g2ya4oqv","category_id":"cl7yt0kxc000rpcu34r1s2utl","_id":"cl7yt0kxp0015pcu3h4zkdwxg"},{"post_id":"cl7yt0kxy001fpcu36eaq54cb","category_id":"cl7yt0kxz001hpcu3b94f8dpi","_id":"cl7yt0ky2001ppcu34gic6u3w"},{"post_id":"cl7yt0kye0025pcu3geaybyud","category_id":"cl7yt0kxc000rpcu34r1s2utl","_id":"cl7yt0kyh002bpcu31386d8o1"},{"post_id":"cl7yt0kyg0029pcu3fppr2s0h","category_id":"cl7yt0kxz001hpcu3b94f8dpi","_id":"cl7yt0kyi002fpcu3a3fb0uek"},{"post_id":"cl7yt0kye0024pcu39c9ealj7","category_id":"cl7yt0kyf0026pcu3f2c55v9y","_id":"cl7yt0kyj002hpcu31ohqb5z1"}],"PostTag":[{"post_id":"cl7yt0kx9000ppcu39gt2hosc","tag_id":"cl7yt0kxi000spcu3htzs5mys","_id":"cl7yt0kxm000ypcu36uwv42h4"},{"post_id":"cl7yt0kxa000qpcu3g2ya4oqv","tag_id":"cl7yt0kxi000spcu3htzs5mys","_id":"cl7yt0kxo0012pcu3c6ev2n2v"},{"post_id":"cl7yt0kxy001fpcu36eaq54cb","tag_id":"cl7yt0kxz001ipcu33um6am1k","_id":"cl7yt0ky1001mpcu3h7ii5ud7"},{"post_id":"cl7yt0kye0025pcu3geaybyud","tag_id":"cl7yt0kxi000spcu3htzs5mys","_id":"cl7yt0kyg0028pcu3552k0mij"},{"post_id":"cl7yt0kyg0029pcu3fppr2s0h","tag_id":"cl7yt0kxz001ipcu33um6am1k","_id":"cl7yt0kyh002cpcu36sp664zo"}],"Tag":[{"name":"Grammar","_id":"cl7yt0kxi000spcu3htzs5mys"},{"name":"C/C++","_id":"cl7yt0kxz001ipcu33um6am1k"}]}}