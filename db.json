{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/longmao-01.jpg","path":"images/longmao-01.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/images/longmao-02.jpg","path":"images/longmao-02.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/images/spirited_away.jpg","path":"images/spirited_away.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/images/spongeBob-01.jpg","path":"images/spongeBob-01.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/anime.min.js","path":"lib/anime.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","path":"lib/font-awesome/css/all.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","path":"lib/font-awesome/webfonts/fa-brands-400.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","path":"lib/font-awesome/webfonts/fa-regular-400.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","path":"lib/font-awesome/webfonts/fa-solid-900.woff2","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/hello-world.md","hash":"acad91ace80b80295b11a9b7ad4c29a2dcfdd8fb","modified":1640862505774},{"_id":"source/about/index.md","hash":"33c26773af3c6a605dfeee5fada5d75ff3e72a7a","modified":1640918013028},{"_id":"source/tags/index.md","hash":"b8ba45e92b0213389e9a7c0d197542ab5fbb80a1","modified":1640917381101},{"_id":"source/categories/index.md","hash":"319ec2dfa4b99b866df8fa841cbc17f61bd918a5","modified":1640917739398},{"_id":"source/_posts/C++基础/初始化.md","hash":"1f4580f17fe24cab6cf93083c3effddf1250ba92","modified":1640919808815},{"_id":"source/_posts/C++基础/extern-大型项目工程中使用全局变量.md","hash":"fd9b8643a4b0771ebde1cbae726a00069368b3e4","modified":1639571420728},{"_id":"source/_data/styles.styl","hash":"4a42cb1509f7713617f9ab60417c282d5ac28097","modified":1640921967843},{"_id":"source/_posts/C++基础/static-const关键字总结.md","hash":"7de43eb28722d3176e595a1ffa0964b70e70b792","modified":1639572904114},{"_id":"source/_posts/英语/定语从句专题.md","hash":"b3e86b5f45530c3f69ccbb576b6ed3216e8752de","modified":1641285899772},{"_id":"source/_posts/C++基础/智能指针.md","hash":"cbefe312df983b7f97793bb827b7640d549fb7f4","modified":1640858974895},{"_id":"source/_posts/C++基础/回调函数.md","hash":"9742d8b49e9a552de3700526bdfb1ebb74c0a5b2","modified":1638534544046},{"_id":"source/_posts/C++基础/字符串输入.md","hash":"05b92a63e3dd6e0bf2aa19cec7c6f01dad3ff7c7","modified":1638772986365},{"_id":"source/_posts/英语/虚拟语气专题.md","hash":"0307b962ff9c3d6f19c9d0e192b5fe0d46b98f3c","modified":1640916635486},{"_id":"source/_posts/C++基础/类/名字查找与继承.md","hash":"21a788f3edaa31c66c4d0ac2a693c25a657a098e","modified":1638530590431},{"_id":"source/_posts/C++基础/拷贝控制/拷贝初始化.md","hash":"4dfad97ec80d1292decb06b3100f926e1389300d","modified":1638777817616},{"_id":"source/_posts/C++基础/STL/自定义比较器.md","hash":"a136b2550bc1a49dff79640693c1350680e70819","modified":1636803791375},{"_id":"source/_posts/C++基础/类/隐式类型转换.md","hash":"1db4055e9381f8eed6cb8decd87dc7a0d68a3ebb","modified":1637678622160},{"_id":"source/_posts/C++基础/类/访问控制与继承.md","hash":"df671ef7013e93fa293bba05d006d30dfb9a15a2","modified":1640073442107},{"_id":"source/_posts/C++基础/类/虚函数专题.md","hash":"02a9866850d3c7c63eab7774d4328837ee0b28b1","modified":1639444147594},{"_id":"source/_posts/C++基础/STL/顺序容器/顺序容器基础.md","hash":"e4a47b84c262223dfa74c7b153c5dbff32db71ee","modified":1640919244993},{"_id":"source/_posts/C++基础/STL/关联容器/关联容器基础.md","hash":"787d6f4c54370a6a370ced55ffee831533b4238a","modified":1638777728999},{"_id":"themes/next/.editorconfig","hash":"731c650ddad6eb0fc7c3d4a91cad1698fe7ad311","modified":1640864776538},{"_id":"themes/next/.gitattributes","hash":"3e00e1fb043438cd820d94ee3dc9ffb6718996f3","modified":1640864776539},{"_id":"themes/next/.eslintrc.json","hash":"d3c11de434171d55d70daadd3914bc33544b74b8","modified":1640864776539},{"_id":"themes/next/.gitignore","hash":"83418530da80e6a78501e1d62a89c3bf5cbaec3d","modified":1640864776544},{"_id":"themes/next/.travis.yml","hash":"379f31a140ce41e441442add6f673bf397d863ea","modified":1640864776545},{"_id":"themes/next/crowdin.yml","hash":"4a53f5985e545c635cb56b2a57ed290cb8cf8942","modified":1640864776546},{"_id":"themes/next/.stylintrc","hash":"6259e2a0b65d46865ab89564b88fc67638668295","modified":1640864776545},{"_id":"themes/next/LICENSE.md","hash":"0a9c7399f102b4eb0a6950dd31264be421557c7d","modified":1640864776545},{"_id":"themes/next/package.json","hash":"b099e7cea4406e209130410d13de87988ba37b2a","modified":1640864776587},{"_id":"themes/next/gulpfile.js","hash":"0c76a1ac610ee8cbe8e2cc9cca1c925ffd0edf98","modified":1640864776558},{"_id":"themes/next/_config.yml","hash":"ff19d24809dec3ff9d371d724fbae94ce5c61f27","modified":1640917622958},{"_id":"themes/next/README.md","hash":"7d56751b580d042559b2acf904fca4b42bcb30a7","modified":1640864776546},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"d2f8e6b65783e31787feb05d2ccea86151f53f35","modified":1640864776542},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5ddde54fb50d11dc08cec899a3588addb56aa386","modified":1640864776540},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"778b7e052993ed59f21ed266ba7119ee2e5253fb","modified":1640864776539},{"_id":"themes/next/.github/lock.yml","hash":"3ce3d0a26030a1cd52b273cc6a6d444d7c8d85c2","modified":1640864776543},{"_id":"themes/next/.github/issue-close-app.yml","hash":"b14756e65546eb9ecc9d4393f0c9a84a3dac1824","modified":1640864776542},{"_id":"themes/next/.github/config.yml","hash":"df3d970700e6b409edc3d23be8d553db78d5ba3f","modified":1640864776542},{"_id":"themes/next/.github/issue_label_bot.yaml","hash":"533fbe6b2f87d7e7ec6949063bb7ea7eb4fbe52d","modified":1640864776543},{"_id":"themes/next/.github/stale.yml","hash":"590b65aca710e0fba75d3cf5361a64d13b6b0f63","modified":1640864776544},{"_id":"themes/next/.github/release-drafter.yml","hash":"09c3352b2d643acdc6839601ceb38abc38ab97c5","modified":1640864776543},{"_id":"themes/next/.github/mergeable.yml","hash":"1c1cb77a62df1e3654b151c2da34b4a10d351170","modified":1640864776543},{"_id":"themes/next/.github/support.yml","hash":"7ce2722d6904c31a086444c422dc49b6aa310651","modified":1640864776544},{"_id":"themes/next/docs/AGPL3.md","hash":"f463f95b169d64983f59fa6f3e4b6760290a0e6b","modified":1640864776547},{"_id":"themes/next/docs/DATA-FILES.md","hash":"980fb8d37701f7fd96b30bb911519de3bbb473d1","modified":1640864776548},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"60c7e9ef0c578deebad43e9395c958fa61096baf","modified":1640864776547},{"_id":"themes/next/docs/AUTHORS.md","hash":"cde7cc095ac31b421a573042cf61060f90d9ad0d","modified":1640864776548},{"_id":"themes/next/docs/INSTALLATION.md","hash":"07ea00bee149a1bdc9073e903ee6b411e9f2f818","modified":1640864776548},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"6cc663db5e99fd86bb993c10d446ad26ada88e58","modified":1640864776548},{"_id":"themes/next/docs/LICENSE.txt","hash":"ae5ad07e4f4106bad55535dba042221539e6c7f9","modified":1640864776549},{"_id":"themes/next/docs/MATH.md","hash":"f56946053ade0915ff7efa74d43c38b8dd9e63bb","modified":1640864776549},{"_id":"themes/next/languages/de.yml","hash":"15078b7ede1b084e8a6a15d271f0db9c325bd698","modified":1640864776559},{"_id":"themes/next/languages/ar.yml","hash":"abcf220bd615cec0dd50e4d98da56580169d77e1","modified":1640864776559},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"1e86d32063b490d204baa9d45d8d3cb22c24a37d","modified":1640864776550},{"_id":"themes/next/languages/es.yml","hash":"f064c793d56a5e0f20cda93b6f0e355044efc7d8","modified":1640864776560},{"_id":"themes/next/languages/en.yml","hash":"dbb64776f9c001c54d0058256c415a9a0724ed5d","modified":1640864776560},{"_id":"themes/next/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1640864776559},{"_id":"themes/next/languages/fa.yml","hash":"6c0a7d5bcc26eb45a9f3e02f13117c668e77fffd","modified":1640864776560},{"_id":"themes/next/languages/fr.yml","hash":"3e2f89d4bb4441d33ecc7b5a4ee114f627603391","modified":1640864776561},{"_id":"themes/next/languages/hu.yml","hash":"0ea89ffaefd02a10494995f05a2a59d5e5679a28","modified":1640864776561},{"_id":"themes/next/languages/id.yml","hash":"7599bb0ecf278beb8fde3d17bfc148a3241aef82","modified":1640864776561},{"_id":"themes/next/languages/it.yml","hash":"46222f468e66789e9ba13095809eb5e5b63edf30","modified":1640864776561},{"_id":"themes/next/languages/ja.yml","hash":"bf279d0eb1911806d01a12f27261fbc76a3bb3f9","modified":1640864776562},{"_id":"themes/next/languages/ko.yml","hash":"af4be6cb394abd4e2e9a728418897d2ed4cc5315","modified":1640864776562},{"_id":"themes/next/languages/nl.yml","hash":"9749cf90b250e631dd550a4f32ada3bb20f66dd0","modified":1640864776562},{"_id":"themes/next/languages/pt.yml","hash":"f6606dd0b916a465c233f24bd9a70adce34dc8d6","modified":1640864776563},{"_id":"themes/next/languages/ru.yml","hash":"012abc694cf9de281a0610f95f79c594f0a16562","modified":1640864776563},{"_id":"themes/next/languages/pt-BR.yml","hash":"69aa3bef5710b61dc9a0f3b3a8f52f88c4d08c00","modified":1640864776562},{"_id":"themes/next/languages/uk.yml","hash":"69ef00b1b8225920fcefff6a6b6f2f3aad00b4ce","modified":1640864776564},{"_id":"themes/next/languages/vi.yml","hash":"6a578cc28773bd764f4418110500478f185d6efa","modified":1640864776564},{"_id":"themes/next/languages/zh-CN.yml","hash":"81d73e21402dad729053a3041390435f43136a68","modified":1640864776564},{"_id":"themes/next/languages/tr.yml","hash":"c4e9ab7e047ae13a19f147c6bec163c3ba2c6898","modified":1640864776563},{"_id":"themes/next/languages/zh-HK.yml","hash":"92ccee40c234626bf0142152949811ebe39fcef2","modified":1640864776564},{"_id":"themes/next/layout/_layout.swig","hash":"9554bd0f5c5a0438aa7b64065be5561c374d260e","modified":1640864776565},{"_id":"themes/next/languages/zh-TW.yml","hash":"cf0740648725983fb88409d6501876f8b79db41d","modified":1640864776565},{"_id":"themes/next/layout/category.swig","hash":"c546b017a956faaa5f5643c7c8a363af7ac9d6b9","modified":1640864776586},{"_id":"themes/next/layout/archive.swig","hash":"d9bca77f6dcfef71e300a294f731bead11ce199f","modified":1640864776585},{"_id":"themes/next/layout/index.swig","hash":"8dfd96fb6f833dd5d037de800813105654e8e8e6","modified":1640864776586},{"_id":"themes/next/scripts/renderer.js","hash":"e3658eea97b1183ee2e9f676231e53f7994741f6","modified":1640864776596},{"_id":"themes/next/layout/post.swig","hash":"5f0b5ba2e0a5b763be5e7e96611865e33bba24d7","modified":1640864776586},{"_id":"themes/next/layout/tag.swig","hash":"d44ff8755727f6532e86fc9fc8dc631200ffe161","modified":1640864776587},{"_id":"themes/next/.github/ISSUE_TEMPLATE/bug-report.md","hash":"e67146befddec3a0dc47dc80d1109070c71d5d04","modified":1640864776540},{"_id":"themes/next/layout/page.swig","hash":"357d916694d4c9a0fd1140fa56d3d17e067d8b52","modified":1640864776586},{"_id":"themes/next/.github/ISSUE_TEMPLATE/question.md","hash":"59275aa0582f793fee7be67904dcf52ad33a7181","modified":1640864776541},{"_id":"themes/next/.github/ISSUE_TEMPLATE/other.md","hash":"d5aa1a3323639a36bcd9a401484b67537043cd3c","modified":1640864776541},{"_id":"themes/next/.github/ISSUE_TEMPLATE/feature-request.md","hash":"6beeca0f45a429cd932b6e648617f548ff64c27c","modified":1640864776541},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"54e6a067ed95268eab6be2ba040a7e9b1907928e","modified":1640864776552},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"a9cfe5ac9ef727a8650b2b6584482751a26b1460","modified":1640864776553},{"_id":"themes/next/docs/ru/README.md","hash":"1e5ddb26ad6f931f8c06ce2120f257ff38b74fdf","modified":1640864776554},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"cb8e39c377fc4a14aaf133b4d1338a48560e9e65","modified":1640864776554},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"3202be9a8d31986caac640e7a4c7ce22e99917eb","modified":1640864776555},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"2d868cd271d78b08775e28c5b976de8836da4455","modified":1640864776556},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"7e6f227f2aaf30f400d4c065650a4e3d0d61b9e1","modified":1640864776555},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"611f2930c2b281b80543531b1bf33d082531456a","modified":1640864776556},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"716111dd36d276f463c707dfcc9937fea2a1cf7a","modified":1640864776557},{"_id":"themes/next/docs/zh-CN/README.md","hash":"8f7c0d0b766024152591d4ccfac715c8e18b37f3","modified":1640864776558},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"0d46f9f50cf2e4183970adce705d1041155b0d37","modified":1640864776558},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"50ab381c27611d5bf97bb3907b5ca9998f28187d","modified":1640864776557},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"b3201934b966bc731eaf8a4dad4ba4bdcd300c10","modified":1640864776558},{"_id":"themes/next/layout/_scripts/index.swig","hash":"1822eaf55bbb4bec88871c324fc18ad95580ccb4","modified":1640864776573},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"7b9e0f776a5be6c3f95bc7f394e1424ba02ba93b","modified":1640864776573},{"_id":"themes/next/layout/_scripts/three.swig","hash":"6b092c6d882b2dfa5273e1b3f60b244cb7c29fcd","modified":1640864776575},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"244ca2d74ee0d497c87572c6a26b43c62a952673","modified":1640864776576},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"30ade8c806d7826cc50a4a3e46a9e6213fddf333","modified":1640864776565},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"5bffdb1448caca7db7b1f84e1693e6657a106d50","modified":1640864776566},{"_id":"themes/next/layout/_scripts/pjax.swig","hash":"ccff5a773644d33ff22f6b45b6734f52b048f22b","modified":1640864776574},{"_id":"themes/next/layout/_macro/post.swig","hash":"c3fd56bac90ce45a0c79ddfe68beb223ad0d72b4","modified":1640864776566},{"_id":"themes/next/layout/_partials/languages.swig","hash":"c3ea82604a5853fb44c5f4e4663cbe912aa5dcf8","modified":1640864776569},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"2de77d533c91532a8a4052000244d0c1693370df","modified":1640864776570},{"_id":"themes/next/layout/_partials/footer.swig","hash":"e031914c98f082d918ece4c35fdd0a5be1c4e845","modified":1640864776567},{"_id":"themes/next/layout/_third-party/index.swig","hash":"c6b63cbc80938e6e09578b8c67e01adf13a9e3bd","modified":1640864776580},{"_id":"themes/next/layout/_partials/widgets.swig","hash":"5392dcbb504266f0f61d5b8219914068ef9cdc25","modified":1640864776573},{"_id":"themes/next/layout/_partials/comments.swig","hash":"142efb4c6b73d8f736f6784804b40d5871333172","modified":1640864776566},{"_id":"themes/next/scripts/events/index.js","hash":"5c355f10fe8c948a7f7cd28bd8120adb7595ebde","modified":1640864776589},{"_id":"themes/next/scripts/helpers/engine.js","hash":"eb6b8bbc1dce4846cd5e0fac0452dbff56d07b5d","modified":1640864776595},{"_id":"themes/next/scripts/helpers/font.js","hash":"8fb1c0fc745df28e20b96222974402aab6d13a79","modified":1640864776596},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"b8d7ddfa4baa9b8d6b9066a634aa81c6243beec9","modified":1640864776596},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"4044129368d0e2811859a9661cad8ab47118bc32","modified":1640864776596},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"ad321db012cea520066deb0639335e9bc0dcc343","modified":1640864776594},{"_id":"themes/next/scripts/filters/front-matter.js","hash":"305d03c1e45782988809298c3e3b3c5d5ee438aa","modified":1640864776594},{"_id":"themes/next/scripts/filters/locals.js","hash":"a5e7d05d3bd2ae6dcffad5a8ea0f72c6e55dbd02","modified":1640864776594},{"_id":"themes/next/scripts/filters/minify.js","hash":"21196a48cb127bf476ce598f25f24e8a53ef50c2","modified":1640864776595},{"_id":"themes/next/scripts/filters/post.js","hash":"57f2d817578dd97e206942604365e936a49854de","modified":1640864776595},{"_id":"themes/next/scripts/tags/button.js","hash":"bb0e8abbc0a6d5b3a1a75a23976f2ac3075aab31","modified":1640864776597},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"e2d0184bc4a557e1017395b80ff46880078d8537","modified":1640864776597},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"840536754121e0da5968f5ad235f29200fc5d769","modified":1640864776597},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"93ccd3f99d3cb42674f29183c756df63acb5d7f8","modified":1640864776598},{"_id":"themes/next/scripts/tags/label.js","hash":"fc83f4e1be2c34e81cb79938f4f99973eba1ea60","modified":1640864776598},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"81134494ff0134c0dae1b3815caf6606fccd4e46","modified":1640864776598},{"_id":"themes/next/layout/_third-party/baidu-push.swig","hash":"28b0a7e843ec4365db1963646659a153753cd746","modified":1640864776577},{"_id":"themes/next/scripts/tags/note.js","hash":"1fdf4f95810fdb983bfd5ad4c4f13fedd4ea2f8d","modified":1640864776598},{"_id":"themes/next/scripts/tags/tabs.js","hash":"c70a4a66fd0c28c98ccb6c5d5f398972e5574d28","modified":1640864776599},{"_id":"themes/next/scripts/tags/pdf.js","hash":"37b53661ad00a01a2ca7d2e4a5ad3a926073f8e2","modified":1640864776599},{"_id":"themes/next/scripts/tags/video.js","hash":"944293fec96e568d9b09bc1280d5dbc9ee1bbd17","modified":1640864776599},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"269102fc5e46bd1ce75abdcce161f0570ae70e2f","modified":1640864776581},{"_id":"themes/next/layout/_third-party/quicklink.swig","hash":"5ae5adcd6f63ed98b2071e4f7e5e38c4d7d24e1b","modified":1640864776581},{"_id":"themes/next/source/css/_colors.styl","hash":"11aef31a8e76f0f332a274a8bfd4537b73d4f88f","modified":1640864776600},{"_id":"themes/next/source/css/_mixins.styl","hash":"072a3fa473c19b20ccd7536a656cda044dbdae0a","modified":1640864776623},{"_id":"themes/next/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1640864776631},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1640864776630},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1640864776630},{"_id":"themes/next/source/css/main.styl","hash":"815ef30987d02f3d76dbe4b5ee3a72135a152678","modified":1640864776630},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1640864776632},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1640864776631},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1640864776631},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1640864776632},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1640864776634},{"_id":"themes/next/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1640864776633},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1640864776633},{"_id":"themes/next/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1640864776633},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1640864776633},{"_id":"themes/next/source/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1640864776634},{"_id":"themes/next/source/images/spongeBob-01.jpg","hash":"dddb7f3b3979933ac54452e3931268872af1f045","modified":1640916318645},{"_id":"themes/next/source/js/algolia-search.js","hash":"6a813410e33824d7acc65a369a2983912bb3420c","modified":1640864776634},{"_id":"themes/next/source/js/bookmark.js","hash":"9f05fd3672789311dc0cf5b37e40dc654cb04a2a","modified":1640864776635},{"_id":"themes/next/source/js/local-search.js","hash":"cfa6a0f3f9c2bc759ee507668a21f4e8f250f42a","modified":1640864776635},{"_id":"themes/next/source/js/utils.js","hash":"26a82e46fdcadc7c3c2c56a7267284b61a26f7f3","modified":1640864776637},{"_id":"themes/next/source/js/next-boot.js","hash":"250d8dcd6322e69e3fbadd0f3e37081c97b47c52","modified":1640864776635},{"_id":"themes/next/source/js/motion.js","hash":"d5aa1a08cdf3c8d1d8d550fb1801274cc41e5874","modified":1640864776635},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"34495d408e8467555afee489500b8aad98c52079","modified":1640864776575},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"0b44f400ec00d2b5add5ee96c11d22465c432376","modified":1640864776575},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"0b44f400ec00d2b5add5ee96c11d22465c432376","modified":1640864776575},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"34495d408e8467555afee489500b8aad98c52079","modified":1640864776575},{"_id":"themes/next/source/lib/anime.min.js","hash":"960be51132134acd65c2017cc8a5d69cb419a0cd","modified":1640864776637},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"90cce9f407e9490756ba99580e3eb09f55b05eaa","modified":1640864776567},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"7d638e413f2548fc990c4a467dd03de6c81fc960","modified":1640864776567},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"91056a6c98cca63ff8cc6956e531ee3faf4b8ad9","modified":1640864776568},{"_id":"themes/next/layout/_scripts/pages/schedule.swig","hash":"34c05e9d73b0f081db70990c296b6d6a0f8ea2ca","modified":1640864776574},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"0dd316f153c492c0a03bd0273d50fa322bc81f11","modified":1640864776568},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"90d3eaba6fbe69bee465ddd67c467fd2c0239dc4","modified":1640864776568},{"_id":"themes/next/layout/_partials/header/menu-item.swig","hash":"4baa86ca631168fc6388d27f4b1b501b40c877a8","modified":1640864776568},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"bed6cc2b48cf2655036ba39c9bae73a295228a4d","modified":1640864776569},{"_id":"themes/next/layout/_partials/page/page-header.swig","hash":"8d4e3dd0d3631ce0b21bc15c259f6ac886de631d","modified":1640864776569},{"_id":"themes/next/layout/_partials/post/post-copyright.swig","hash":"f2eb455c8bf13533427254f0c9b4b17b2498168b","modified":1640864776570},{"_id":"themes/next/layout/_partials/page/breadcrumb.swig","hash":"91c0addb33006619faa4c32e5d66874e25f1e9b3","modified":1640864776569},{"_id":"themes/next/layout/_partials/post/post-footer.swig","hash":"ce712c110b5ce8aacba7a86b0558ff89700675c9","modified":1640864776571},{"_id":"themes/next/layout/_partials/post/post-followme.swig","hash":"d8f785c062c6b0763a778bd4a252e6f5fee0e432","modified":1640864776571},{"_id":"themes/next/layout/_partials/post/post-reward.swig","hash":"f349a226e5370075bb6924e60da8b0170c7cfcc1","modified":1640864776571},{"_id":"themes/next/layout/_partials/post/post-related.swig","hash":"bc7b047a6246df07767373644b1637d91c3a88b1","modified":1640864776571},{"_id":"themes/next/layout/_partials/search/algolia-search.swig","hash":"98fd1f5df044f4534e1d4ca9ab092ba5761739a9","modified":1640864776572},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"a6c761d5193cb6f22e9422dbbcf209e05471b0ed","modified":1640864776572},{"_id":"themes/next/layout/_partials/sidebar/site-overview.swig","hash":"7b2ef5db9615267a24b884388925de1e9b447c1f","modified":1640864776573},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"128f7d679bb4d53b29203d598d217f029a66dee7","modified":1640864776572},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"85b60e222712ca3b2c4dc2039de2dc36b8d82940","modified":1640864776577},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"91c2cb900c76224c5814eeb842d1d5f517f9bf05","modified":1640864776577},{"_id":"themes/next/layout/_third-party/chat/tidio.swig","hash":"fb94ee487d75e484e59b7fba96e989f699ff8a83","modified":1640864776578},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"b8819bd056f8a580c5556d4415836a906ed5d7a4","modified":1640864776576},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"84adaadd83ce447fa9da2cff19006334c9fcbff9","modified":1640864776576},{"_id":"themes/next/layout/_third-party/chat/chatra.swig","hash":"2642e8aef5afbe23a2a76efdc955dab2ee04ed48","modified":1640864776578},{"_id":"themes/next/layout/_third-party/comments/disqusjs.swig","hash":"a42f97eda3748583bac2253c47fe5dfa54f07b8f","modified":1640864776579},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"606ad14a29320157df9b8f33738282c51bb393d9","modified":1640864776579},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"1b29b99fa921f12c25d3dc95facdf84ef7bb1b5c","modified":1640864776578},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"ae2707d6e47582bb470c075649ec7bad86a6d5a9","modified":1640864776579},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"9298e6d6c4a62a0862fc0f4060ed99779d7b68cb","modified":1640864776578},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"59df21fcfe9d0ada8cee3188cb1075529c1c3eb8","modified":1640864776580},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"3d91899ca079e84d95087b882526d291e6f53918","modified":1640864776579},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"276f523e414d4aa7f350a8f2fd3df8a3d8ea9656","modified":1640864776580},{"_id":"themes/next/layout/_third-party/search/algolia-search.swig","hash":"fd726aad77a57b288f07d6998ec29291c67c7cbb","modified":1640864776582},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.swig","hash":"d2f0e4c598410ec33785abe302c7ea7492bb791a","modified":1640864776583},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"58296a5c1883f26464c2a5ccf734c19f5fbf395a","modified":1640864776582},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"1f34b2d3c753a3589ab6c462880bd4eb7df09914","modified":1640864776580},{"_id":"themes/next/layout/_third-party/statistics/cnzz-analytics.swig","hash":"53a0760c75d5aaabb3ce8e8aa8e003510d59807f","modified":1640864776583},{"_id":"themes/next/layout/_third-party/search/swiftype.swig","hash":"aa6ab95b8b76611694613defb4bf25003d1b927f","modified":1640864776583},{"_id":"themes/next/layout/_third-party/statistics/index.swig","hash":"964cd6bac668cf6d211a2624fbef3948cfdece55","modified":1640864776584},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.swig","hash":"c171ea94e9afbba97f06856904264da331559463","modified":1640864776584},{"_id":"themes/next/scripts/events/lib/config.js","hash":"aefe3b38a22bc155d485e39187f23e4f2ee5680a","modified":1640864776589},{"_id":"themes/next/scripts/events/lib/injects-point.js","hash":"08496b71c9939718e7955704d219e44d7109247b","modified":1640864776590},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"e73f697bb160b223fdde783237148be5f41c1d78","modified":1640864776590},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"2f22f48f7370470cef78561a47c2a47c78035385","modified":1640864776591},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"0c3bea89d64bc12c1bbe6f208a83773c6fb5375a","modified":1640864776591},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"713056d33dbcd8e9748205c5680b456c21174f4e","modified":1640864776591},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"3a80559df0b670ccb065ea9d3bb587d0b61be3a4","modified":1640864776592},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"67cf90d9a2428c14eb113a64bdd213c22a019aef","modified":1640864776592},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"323a47df6ded894944a2647db44556d6163e67c4","modified":1640864776592},{"_id":"themes/next/scripts/filters/comment/valine.js","hash":"851359f5ff90f733a9bd7fe677edbee8b8ac714c","modified":1640864776593},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"a4f3153ac76a7ffdf6cc70f52f1b2cc218ed393e","modified":1640864776593},{"_id":"themes/next/layout/_third-party/tags/mermaid.swig","hash":"619338ddacf01e3df812e66a997e778f672f4726","modified":1640864776585},{"_id":"themes/next/layout/_third-party/statistics/firestore.swig","hash":"01d94354d07e72cad47100482068b6be69fcc033","modified":1640864776584},{"_id":"themes/next/layout/_third-party/tags/pdf.swig","hash":"5a223b60406cee7438cfe3a5e41d1284425aa7a5","modified":1640864776585},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"4e33774b1fe6d0a51f3a428c54c5e600e83bf154","modified":1640864776629},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"5980abbbbeacd8541121f436fa414d24ad5e97c2","modified":1640864776629},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"583ff1e7a2ca889f1f54eb0ca793894466823c7c","modified":1640864776628},{"_id":"themes/next/source/css/_variables/base.styl","hash":"ad680efdfb2f86546182bf3f59886efbcf3c1b2d","modified":1640864776630},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"c22b58af3327236ec54d5706501aa5a20e15012e","modified":1640864776629},{"_id":"themes/next/source/js/schemes/muse.js","hash":"a18559a9c332199efad0100cf84bb0c23fc0f17a","modified":1640864776636},{"_id":"themes/next/source/js/schemes/pisces.js","hash":"b85a6e2af1387fe64b51e7cd3e2da8616e6f5a3f","modified":1640864776636},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"d17236df3b4d6def1e4e81133ef4729c390de3ac","modified":1640864776601},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"0534b329d279a6f255112b3305ff92c810f31724","modified":1640864776600},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1640864776640},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"c52648a7b09f9fe37858f5694fcc1ffc709ad147","modified":1640864776606},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"510a6f0ba7485dd54ce347cca890ab52c4957081","modified":1640864776600},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"a2ee16cac29a82cfce26804c160286fcbee94161","modified":1640864776610},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1640864776640},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"4b068d0d898f4e624937503f0e1428993050bd65","modified":1640864776616},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"7a95c27762e1303bf06ee808c63f616cb192fcaf","modified":1640864776610},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"45f4badac6ec45cf24355f6157aece1d4d3f1134","modified":1640864776615},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"5540c9259cb7895a5f10a289c7937e5470a7c134","modified":1640864776614},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"b619f39e18398422e0ac4999d8f042a5eaebe9cd","modified":1640864776618},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"43045d115f8fe95732c446aa45bf1c97609ff2a5","modified":1640864776619},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"6d740699fb6a7640647a8fd77c4ea4992d8d6437","modified":1640864776618},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"f317d2e3886e94f5fbb8781c2e68edd19669ff58","modified":1640864776619},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"20e0e3e3eba384930c022e21511214d244b4c9e7","modified":1640864776623},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"e1c29b81a32273a0dedd926cda199a71aea72624","modified":1640864776625},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"b9e87d32da24264bda247c1526afe140c858b0ef","modified":1640864776624},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"8674bd88df076a1dfe4023ed6750ded1f5b00223","modified":1640864776625},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"12b265f82840f27112ca2b1be497677f20f87545","modified":1640864776624},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"4b7f057dbb53efd7cbe7eac7835a793ab3cbb135","modified":1640864776626},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"e342b8f8e11a3a6aa5a029912c9778c25bf5d135","modified":1640864776624},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"c5142739e01e9f25c8b32b2209af85c787bb2b42","modified":1640864776625},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"716e8b0f056bf6393e6bc6969ac84598ab8e7a6f","modified":1640864776625},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"49c76bc723d3952abb613d9d68398ed7305da999","modified":1640864776626},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"9898323ee5a7ac2a5d4f633c653112280beb2643","modified":1640864776626},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5de34e1d8a290751641ae456c942410852d5e809","modified":1640864776627},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"2d3e05015796a790abd9d68957a5c698c0c9f9b6","modified":1640864776626},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"558794fced306339b98dc2b0ee7f0576802f1355","modified":1640864776627},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"0a9f0d9eb042595502d200fb8c65efb0e6c89aa9","modified":1640864776627},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"25c2a7930da14f023329df20f38df2728057fb4d","modified":1640864776627},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"25c2a7930da14f023329df20f38df2728057fb4d","modified":1640864776628},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"dc9318992ce2eb086ebaa2fe56b325e56d24098b","modified":1640864776628},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"b69ac38b9da8c9c1b7de696fdeea7f9d7705213a","modified":1640864776628},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1640864776639},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","hash":"82e34d28f8a1169b20b60101d5bb0446deba3514","modified":1640864776638},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"236a039b0900f4267de566b46f62314ad967d30f","modified":1640864776601},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"f6f05f02d50f742c84ee5122016c0563a8bb2cf9","modified":1640864776602},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"18edddb2ffb3f85a68e4367f81e06c461e07bc25","modified":1640864776601},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"97974c231b4659b8aa5e9321c4d54db5c816d0db","modified":1640864776602},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"a52f8cae599099231866298ed831fdf76c9b6717","modified":1640864776602},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"97dec98d0403097d66822f1c90b50b2890c84698","modified":1640864776603},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"6cf78a379bb656cc0abb4ab80fcae60152ce41ad","modified":1640864776601},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"70b3eb9d36543ab92796ac163544e9cf51b7c1e6","modified":1640864776603},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"9af620eba5ccceea21a0e3bc69f6f1fa7637c2f3","modified":1640864776603},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"57b9a179675f1536e017cba457b6ac575e397c4f","modified":1640864776604},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"0dfb97703a519d9438f64f9e41ab1dd37381f733","modified":1640864776604},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"09dda2667628d1f91b2e37d8fc6df1413f961b64","modified":1640864776605},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"66fc406796b6efe6cea76550573b7a632112406a","modified":1640864776605},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"93ba8172c0d2c37d738e6dbd44fcd5a2e23b92f3","modified":1640864776604},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"5cc9e7394c927065c688cba5edd6e0a27587f1d8","modified":1640864776605},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"2c24829d95c742eb9e8316ebf2fbe9f2c168b59a","modified":1640864776604},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"b87f4a06c0db893df4f756f24be182e1a4751f24","modified":1640864776606},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"b266d2ce5e2b117be01537889e839a69004dc0bb","modified":1640864776605},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"fcd64c23d17775b3635325f6758b648d932e79b5","modified":1640864776606},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"d83102771df652769e51ddfd041cf5f4ca1a041d","modified":1640864776607},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"bad99f4cccb93b3cefe990a2c85124e60698d32e","modified":1640864776607},{"_id":"themes/next/source/css/_common/outline/footer/footer.styl","hash":"7eeb22c5696f8e0c95161dc57703973cf81c8c12","modified":1640864776608},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"8ed7a9d5dfac592de703421b543978095129aa5b","modified":1640864776607},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1f6b0d3ab227697ca115e57fd61122ea7950e19d","modified":1640864776607},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"b31c86d1a4f89837f9187bed646bda96b2cd286c","modified":1640864776608},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"b4f4bae437d4f994af93cf142494ffcd86bae46b","modified":1640864776608},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"7a3a56b10ab714c0e2ed240d0939deeecdcad167","modified":1640864776609},{"_id":"themes/next/source/css/_common/outline/header/header.styl","hash":"300058ca12e81013e77ba01fe66ac210525768b6","modified":1640864776609},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"3d16ac0f4ccaeed868c246d4d49bde543d1f62cb","modified":1640864776609},{"_id":"themes/next/source/css/_common/outline/header/headerband.styl","hash":"6d5f26646e2914474f295de8bf6dc327d4acd529","modified":1640864776609},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"b8c816fba0a9b4a35fbae03ba5b1b2da96ba2687","modified":1640864776610},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"357f825f0a649b2e28cba1481d4c9a0cb402e43a","modified":1640864776611},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"096f908c08ce553e482aadfd3e767a0145191093","modified":1640864776611},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"49722d555a2edb18094bb2cb3d7336dd72051b93","modified":1640864776611},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"12f7eaf6b56624cbc411528562d6bb848ff97039","modified":1640864776612},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"525242ce9e912c4adfe5134347c67dbdb9e98e3d","modified":1640864776611},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"fa0a2ea57b7b4ce75b5d18c264af2d92ea3192f9","modified":1640864776612},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"b11b04737a1a0fea3bd9f0081d96ee6c015358d4","modified":1640864776612},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar.styl","hash":"5d540f683018745a5ed1d6f635df28ea610c1244","modified":1640864776613},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"67a1fcb33535122d41acd24f1f49cf02c89b88fa","modified":1640864776613},{"_id":"themes/next/source/css/_common/scaffolding/highlight/diff.styl","hash":"83bd737f663a8461e66985af8ddbfc0a731fc939","modified":1640864776617},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"4079e616fbf36112dec0674c1e0713d1d9769068","modified":1640864776617},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"098b4bdf49c7300490f959386d5d1185a32543f6","modified":1640864776612},{"_id":"themes/next/source/css/_common/scaffolding/highlight/theme.styl","hash":"c911045b2ce9a66e38d9dd30c7ed078abbc10cbf","modified":1640864776618},{"_id":"themes/next/source/css/_common/scaffolding/highlight/highlight.styl","hash":"80488259271bcfe38031f4c2e902463daba9336b","modified":1640864776617},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"8b7aafb911850c73074cdb6cc87abe4ac8c12e99","modified":1640864776621},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"ceacfa6218f6084c71a230b086e5d2708d29927e","modified":1640864776620},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"adaf0f580fccf4158169eeaf534a18005b39a760","modified":1640864776621},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"aca7bb220fc14ef2a8f96282d2a95a96a9238d46","modified":1640864776620},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"3256e39f281f06751a1c0145d9806a0e56d68170","modified":1640864776622},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"03a5bcecc0b12231462ef6ffe432fa77ee71beff","modified":1640864776622},{"_id":"themes/next/source/css/_common/scaffolding/tags/tags.styl","hash":"51d46fa3c7c6b691c61a2c2b0ac005c97cfbf72b","modified":1640864776622},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1640864776640},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1640864776639},{"_id":"themes/next/source/images/spirited_away.jpg","hash":"64b73d3e34129c69857505ff9ffc813eaf4a1dc5","modified":1640866644147},{"_id":"themes/next/source/images/longmao-02.jpg","hash":"375ea9b1f01939f4ffc55b45da3699e3659325d4","modified":1640913641851},{"_id":"themes/next/source/images/longmao-01.jpg","hash":"65a069a8380cfb089c68e9690f008c820a0616dd","modified":1640911070609},{"_id":"public/about/index.html","hash":"cab06acf8f02ea81f8725a275d3ccc88f20877e7","modified":1641285960135},{"_id":"public/categories/index.html","hash":"814856f041aede10d2d1085bd43f39d393f549ad","modified":1641285960135},{"_id":"public/tags/index.html","hash":"ac1f81824bddae543431406195824e5707ae0114","modified":1641285960135},{"_id":"public/2021/12/31/C++基础/类/隐式类型转换/index.html","hash":"696fa3cd40cb2e8c94968ba673182a7be781d2ff","modified":1641285960135},{"_id":"public/2021/12/31/C++基础/STL/自定义比较器/index.html","hash":"075087edbe5498ad68a7f54b0ce44fe0e29bf71c","modified":1641285960135},{"_id":"public/2021/12/31/C++基础/回调函数/index.html","hash":"25cf5e0bf528ac2b179de2aa497c386dfd0359e8","modified":1641285960135},{"_id":"public/2021/12/30/hello-world/index.html","hash":"3c58a9d96bf42037d00673efff148757026abcc8","modified":1641285960135},{"_id":"public/categories/我为什么这么菜/index.html","hash":"e5474976d32a3e028fa3f4184f5a6a5926ddc6b5","modified":1641285960135},{"_id":"public/categories/English/index.html","hash":"45c52521f32400b4a4bc1c82c5847be1a64bdc1d","modified":1641285960135},{"_id":"public/categories/C/index.html","hash":"7fdd7145c1c06a283b338b12c19c9a777e065165","modified":1641285960135},{"_id":"public/archives/index.html","hash":"d15c6f904c3f6e9b29b312e53e2b567d60fa071d","modified":1641285960135},{"_id":"public/archives/page/2/index.html","hash":"d5f50aab2a5354a86279b1df4fb30e0abcd00daa","modified":1641285960135},{"_id":"public/archives/2021/index.html","hash":"5fb81dce163ebc7f9da72f0055a75b6dc1335aca","modified":1641285960135},{"_id":"public/archives/2021/page/2/index.html","hash":"3c8460824d57cd3e74a2b2d66cde507ae8273a7a","modified":1641285960135},{"_id":"public/archives/2021/11/index.html","hash":"f52f84cb2338a8039fbd85738fe53ff8455855ee","modified":1641285960135},{"_id":"public/archives/2021/12/index.html","hash":"f098e2fdbfe46a4516e6cb7273c480d1982d20c9","modified":1641285960135},{"_id":"public/archives/2021/12/page/2/index.html","hash":"b6608fad6edab6321db606b856d8c5086257c87e","modified":1641285960135},{"_id":"public/tags/C-C/index.html","hash":"db32ef1a0eb2adf1a911b696ff769e68736b8c70","modified":1641285960135},{"_id":"public/tags/Grammar/index.html","hash":"370a6b9bb9bca5252e5a0ee5ff0a1cd3b4e6af03","modified":1641285960135},{"_id":"public/tags/STL/index.html","hash":"5c5b6acf0d24220f650040d39e4940898442d6b8","modified":1641285960135},{"_id":"public/2021/12/31/C++基础/类/访问控制与继承/index.html","hash":"af6402848e8713554b72c46d68bba515a52f127e","modified":1641285960135},{"_id":"public/2021/12/31/C++基础/类/虚函数专题/index.html","hash":"7dffb62710e7c9b2f4b060180c4156c055f6b21d","modified":1641285960135},{"_id":"public/2021/12/31/C++基础/类/名字查找与继承/index.html","hash":"3bd0c62c9ec4c4f36ed3567cdfe8e8a2c846bc39","modified":1641285960135},{"_id":"public/2021/12/31/C++基础/STL/关联容器/关联容器基础/index.html","hash":"7cdaf084c2f14e512cf9a2640a9177a70d7fe6db","modified":1641285960135},{"_id":"public/2021/12/31/C++基础/智能指针/index.html","hash":"e07462dde1567a7e761c165065d94bd27a712c8e","modified":1641285960135},{"_id":"public/2021/12/31/C++基础/初始化/index.html","hash":"0f1cf58e34b336b9f85404be664b13ce8d7f8ad0","modified":1641285960135},{"_id":"public/2021/12/31/C++基础/static-const关键字总结/index.html","hash":"df65ad8e90992596776053d13cd81971dbcae725","modified":1641285960135},{"_id":"public/2021/12/31/C++基础/extern-大型项目工程中使用全局变量/index.html","hash":"b2aaf08165cd45b4cd3af08c39f29193fae91347","modified":1641285960135},{"_id":"public/2021/12/20/英语/定语从句专题/index.html","hash":"805819d8861a7d26071d6e4270007e42b47fa88a","modified":1641285960135},{"_id":"public/2021/12/03/C++基础/STL/顺序容器/顺序容器基础/index.html","hash":"7b38bfd4e98f3d29a6aa92118b1ef3335038241f","modified":1641285960135},{"_id":"public/2021/11/24/C++基础/拷贝控制/拷贝初始化/index.html","hash":"0ad6957c64a0b333710643b4385781e3c4e85853","modified":1641285960135},{"_id":"public/2021/11/13/英语/虚拟语气专题/index.html","hash":"a7f5baf58a8e3379911d9515575904f1ac710cf2","modified":1641285960135},{"_id":"public/2021/11/10/C++基础/字符串输入/index.html","hash":"ea244c6dbb5d0eb233ed633793e35b3badb0fd4f","modified":1641285960135},{"_id":"public/index.html","hash":"022106618877fdc82d712a99e15b5730a7ca5b49","modified":1641285960135},{"_id":"public/page/2/index.html","hash":"974b063a6edf3e70b3dedb220ea2a4f5ccce0b0d","modified":1641285960135},{"_id":"public/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1641285960135},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1641285960135},{"_id":"public/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1641285960135},{"_id":"public/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1641285960135},{"_id":"public/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1641285960135},{"_id":"public/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1641285960135},{"_id":"public/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1641285960135},{"_id":"public/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1641285960135},{"_id":"public/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1641285960135},{"_id":"public/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1641285960135},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1641285960135},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1641285960135},{"_id":"public/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1641285960135},{"_id":"public/images/spongeBob-01.jpg","hash":"dddb7f3b3979933ac54452e3931268872af1f045","modified":1641285960135},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1641285960135},{"_id":"public/live2dw/assets/exp/f00.exp.json","hash":"84073a497ddb6e56c6cfc244a0fb217ba473abf9","modified":1641285960135},{"_id":"public/live2dw/assets/moc/z16.512/texture_00.png","hash":"251b9f944fb1575c01a62b8a9d7522fe76954b3b","modified":1641285960135},{"_id":"public/live2dw/assets/moc/z16.256/texture_00.png","hash":"19f22619c246067d519aa1e6e477497cc4342414","modified":1641285960135},{"_id":"public/live2dw/assets/z16.model.json","hash":"e69f3d2ecc9bf51b3972ad9df8f6aaa31956910c","modified":1641285960135},{"_id":"public/live2dw/assets/z16.physics.json","hash":"67f13f60030d7e4c7f824c001ab5254ce4b9bafd","modified":1641285960135},{"_id":"public/live2dw/lib/L2Dwidget.min.js","hash":"5f1a807437cc723bcadc3791d37add5ceed566a2","modified":1641285960135},{"_id":"public/live2dw/assets/mtn/idle.mtn","hash":"f6b879d9f1d096509a7edbc971b8fdd9697932e9","modified":1641285960135},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1641285960135},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1641285960135},{"_id":"public/js/algolia-search.js","hash":"498d233eb5c7af6940baf94c1a1c36fdf1dd2636","modified":1641285960135},{"_id":"public/js/bookmark.js","hash":"9734ebcb9b83489686f5c2da67dc9e6157e988ad","modified":1641285960135},{"_id":"public/js/local-search.js","hash":"35ccf100d8f9c0fd6bfbb7fa88c2a76c42a69110","modified":1641285960135},{"_id":"public/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1641285960135},{"_id":"public/js/utils.js","hash":"730cca7f164eaf258661a61ff3f769851ff1e5da","modified":1641285960135},{"_id":"public/js/next-boot.js","hash":"a1b0636423009d4a4e4cea97bcbf1842bfab582c","modified":1641285960135},{"_id":"public/js/schemes/pisces.js","hash":"0ac5ce155bc58c972fe21c4c447f85e6f8755c62","modified":1641285960135},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1641285960135},{"_id":"public/js/schemes/muse.js","hash":"1eb9b88103ddcf8827b1a7cbc56471a9c5592d53","modified":1641285960135},{"_id":"public/css/main.css","hash":"610fdbd4808547fe092a6f65ae756cdf52b86f2b","modified":1641285960135},{"_id":"public/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1641285960135},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1641285960135},{"_id":"public/lib/font-awesome/css/all.min.css","hash":"0038dc97c79451578b7bd48af60ba62282b4082b","modified":1641285960135},{"_id":"public/live2dw/assets/moc/z16.moc","hash":"6b0241e80e94664d694b43ad05333960de2550c1","modified":1641285960135},{"_id":"public/live2dw/assets/moc/z16.1024/texture_00.png","hash":"c4f7c067d7d37601490554438ab801fce1feb92d","modified":1641285960135},{"_id":"public/images/spirited_away.jpg","hash":"64b73d3e34129c69857505ff9ffc813eaf4a1dc5","modified":1641285960135},{"_id":"public/live2dw/lib/L2Dwidget.min.js.map","hash":"3290fe2df45f065b51a1cd7b24ec325cbf9bb5ce","modified":1641285960135},{"_id":"public/live2dw/lib/L2Dwidget.0.min.js","hash":"35bb5b588b6de25c9be2dd51d3fd331feafac02d","modified":1641285960135},{"_id":"public/images/longmao-02.jpg","hash":"375ea9b1f01939f4ffc55b45da3699e3659325d4","modified":1641285960135},{"_id":"public/live2dw/lib/L2Dwidget.0.min.js.map","hash":"35e71cc2a130199efb167b9a06939576602f0d75","modified":1641285960135},{"_id":"public/images/longmao-01.jpg","hash":"65a069a8380cfb089c68e9690f008c820a0616dd","modified":1641285960135},{"_id":"source/_posts/英语/名词性从句/主语从句.md","hash":"bc22ea1c7ff17521729faccafab1d8d4fe67f926","modified":1641287507668}],"Category":[{"name":"我为什么这么菜~~","_id":"ckxzva9fk00097cu30ccdewtq"},{"name":"English","_id":"ckxzva9fr000e7cu3bfps6s75"},{"name":"C++","_id":"ckxzva9g0000y7cu3df0rdgzg"}],"Data":[{"_id":"styles","data":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}],"Page":[{"title":"about","date":"2021-12-31T02:30:37.000Z","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2021-12-31 10:30:37\n---\n","updated":"2021-12-31T02:33:33.028Z","path":"about/index.html","comments":1,"layout":"page","_id":"ckxzva9f700007cu38o5lf7l5","content":"","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":""},{"title":"categories","type":"categories","layout":"categories","date":"2021-12-31T02:28:04.000Z","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ntype: categories\nlayout: \"categories\"\ndate: 2021-12-31 10:28:04\n---\n","updated":"2021-12-31T02:28:59.398Z","path":"categories/index.html","comments":1,"_id":"ckxzva9fd00027cu31uuahdmw","content":"","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":""},{"title":"tags","type":"tags","layout":"tags","date":"2021-12-31T02:22:09.000Z","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ntype: tags\nlayout: \"tags\"\ndate: 2021-12-31 10:22:09\n---\n","updated":"2021-12-31T02:23:01.101Z","path":"tags/index.html","comments":1,"_id":"ckxzva9ff00047cu3bf4n8ytt","content":"","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":""}],"Post":[{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"date":"2021-12-30T11:08:25.774Z","updated":"2021-12-30T11:08:25.774Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckxzva9f900017cu3cqqz418q","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"_content":"### 1. 在多个文件中使用全局变量\n\n如果要在多个文件中使用外部（全局）变量，只需要在一个文件中包含该变量的定义（单定义规则），但在**使用该变量的其他所有文件中**，都必须使用关键字`extern`声明它：\n\n```cpp\n//file01.cpp\nextern int cats = 20; //定义\nint dogs = 22; \t\t  //定义\nint fleas;\t\t  \t  //还是定义，默认初始化为0\n```\n\n```cpp\n// file02.cpp\n// use cats and dogs from file01.cpp\n//非定义，仅声明\nextern int cats;\nextern int dogs;\n```\n\n```cpp\n//file98.cpp\n//use cats, dogs, and fleas from file01.cpp\nextern int cats;\nextern int dogs;\nextern int fleas;\n```\n\n> `file01.cpp` 中 `cats` 的`extern`是可以省略的，效果一样\n\n### 2. 不能在函数体内部初始化一个`extern`变量\n\n![extern](D:\\Hugo\\Sites\\Puppy's\\static\\images\\extern-大型项目工程中使用全局变量\\image-20211101202636295.png)\n\n原因：[c++ - Why does initializing an extern variable inside a function give an error? - Stack Overflow](https://stackoverflow.com/questions/17090354/why-does-initializing-an-extern-variable-inside-a-function-give-an-error)\n\n`extern`变量告诉编译器，整个项目中的所有同名`symbol`，都指的是同一个`externally defined i`，所以如果允许在函数内初始化（定义）一个被`extern`标记的变量，就会有==多重定义==的风险\n\n例如：\n\n```cpp\n#include <iostream>\nusing namespace std;\n\nextern int i; // 同一个 externally defined i\nint i = 10;\nvoid test()\n{\n    std::cout << \"Hi\" << i << std::endl;\n}\n\nint main()\n{\n    extern int i; // 这个 extern 会影响到其作用域内的所有 i，但是会被局部 i 屏蔽\n    i++;\n    test();\n}\n```\n\n","source":"_posts/C++基础/extern-大型项目工程中使用全局变量.md","raw":"### 1. 在多个文件中使用全局变量\n\n如果要在多个文件中使用外部（全局）变量，只需要在一个文件中包含该变量的定义（单定义规则），但在**使用该变量的其他所有文件中**，都必须使用关键字`extern`声明它：\n\n```cpp\n//file01.cpp\nextern int cats = 20; //定义\nint dogs = 22; \t\t  //定义\nint fleas;\t\t  \t  //还是定义，默认初始化为0\n```\n\n```cpp\n// file02.cpp\n// use cats and dogs from file01.cpp\n//非定义，仅声明\nextern int cats;\nextern int dogs;\n```\n\n```cpp\n//file98.cpp\n//use cats, dogs, and fleas from file01.cpp\nextern int cats;\nextern int dogs;\nextern int fleas;\n```\n\n> `file01.cpp` 中 `cats` 的`extern`是可以省略的，效果一样\n\n### 2. 不能在函数体内部初始化一个`extern`变量\n\n![extern](D:\\Hugo\\Sites\\Puppy's\\static\\images\\extern-大型项目工程中使用全局变量\\image-20211101202636295.png)\n\n原因：[c++ - Why does initializing an extern variable inside a function give an error? - Stack Overflow](https://stackoverflow.com/questions/17090354/why-does-initializing-an-extern-variable-inside-a-function-give-an-error)\n\n`extern`变量告诉编译器，整个项目中的所有同名`symbol`，都指的是同一个`externally defined i`，所以如果允许在函数内初始化（定义）一个被`extern`标记的变量，就会有==多重定义==的风险\n\n例如：\n\n```cpp\n#include <iostream>\nusing namespace std;\n\nextern int i; // 同一个 externally defined i\nint i = 10;\nvoid test()\n{\n    std::cout << \"Hi\" << i << std::endl;\n}\n\nint main()\n{\n    extern int i; // 这个 extern 会影响到其作用域内的所有 i，但是会被局部 i 屏蔽\n    i++;\n    test();\n}\n```\n\n","slug":"C++基础/extern-大型项目工程中使用全局变量","published":1,"date":"2021-12-31T02:09:01.467Z","updated":"2021-12-15T12:30:20.728Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckxzva9fd00037cu301pt67zy","content":"<h3 id=\"1-在多个文件中使用全局变量\"><a href=\"#1-在多个文件中使用全局变量\" class=\"headerlink\" title=\"1. 在多个文件中使用全局变量\"></a>1. 在多个文件中使用全局变量</h3><p>如果要在多个文件中使用外部（全局）变量，只需要在一个文件中包含该变量的定义（单定义规则），但在<strong>使用该变量的其他所有文件中</strong>，都必须使用关键字<code>extern</code>声明它：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//file01.cpp</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> cats = <span class=\"number\">20</span>; <span class=\"comment\">//定义</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> dogs = <span class=\"number\">22</span>; \t\t  <span class=\"comment\">//定义</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> fleas;\t\t  \t  <span class=\"comment\">//还是定义，默认初始化为0</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// file02.cpp</span></span><br><span class=\"line\"><span class=\"comment\">// use cats and dogs from file01.cpp</span></span><br><span class=\"line\"><span class=\"comment\">//非定义，仅声明</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> cats;</span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> dogs;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//file98.cpp</span></span><br><span class=\"line\"><span class=\"comment\">//use cats, dogs, and fleas from file01.cpp</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> cats;</span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> dogs;</span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> fleas;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>file01.cpp</code> 中 <code>cats</code> 的<code>extern</code>是可以省略的，效果一样</p>\n</blockquote>\n<h3 id=\"2-不能在函数体内部初始化一个extern变量\"><a href=\"#2-不能在函数体内部初始化一个extern变量\" class=\"headerlink\" title=\"2. 不能在函数体内部初始化一个extern变量\"></a>2. 不能在函数体内部初始化一个<code>extern</code>变量</h3><p><img src=\"D:\\Hugo\\Sites\\Puppy's\\static\\images\\extern-大型项目工程中使用全局变量\\image-20211101202636295.png\" alt=\"extern\"></p>\n<p>原因：<a href=\"https://stackoverflow.com/questions/17090354/why-does-initializing-an-extern-variable-inside-a-function-give-an-error\">c++ - Why does initializing an extern variable inside a function give an error? - Stack Overflow</a></p>\n<p><code>extern</code>变量告诉编译器，整个项目中的所有同名<code>symbol</code>，都指的是同一个<code>externally defined i</code>，所以如果允许在函数内初始化（定义）一个被<code>extern</code>标记的变量，就会有==多重定义==的风险</p>\n<p>例如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> i; <span class=\"comment\">// 同一个 externally defined i</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Hi&quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> i; <span class=\"comment\">// 这个 extern 会影响到其作用域内的所有 i，但是会被局部 i 屏蔽</span></span><br><span class=\"line\">    i++;</span><br><span class=\"line\">    <span class=\"built_in\">test</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<h3 id=\"1-在多个文件中使用全局变量\"><a href=\"#1-在多个文件中使用全局变量\" class=\"headerlink\" title=\"1. 在多个文件中使用全局变量\"></a>1. 在多个文件中使用全局变量</h3><p>如果要在多个文件中使用外部（全局）变量，只需要在一个文件中包含该变量的定义（单定义规则），但在<strong>使用该变量的其他所有文件中</strong>，都必须使用关键字<code>extern</code>声明它：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//file01.cpp</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> cats = <span class=\"number\">20</span>; <span class=\"comment\">//定义</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> dogs = <span class=\"number\">22</span>; \t\t  <span class=\"comment\">//定义</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> fleas;\t\t  \t  <span class=\"comment\">//还是定义，默认初始化为0</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// file02.cpp</span></span><br><span class=\"line\"><span class=\"comment\">// use cats and dogs from file01.cpp</span></span><br><span class=\"line\"><span class=\"comment\">//非定义，仅声明</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> cats;</span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> dogs;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//file98.cpp</span></span><br><span class=\"line\"><span class=\"comment\">//use cats, dogs, and fleas from file01.cpp</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> cats;</span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> dogs;</span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> fleas;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>file01.cpp</code> 中 <code>cats</code> 的<code>extern</code>是可以省略的，效果一样</p>\n</blockquote>\n<h3 id=\"2-不能在函数体内部初始化一个extern变量\"><a href=\"#2-不能在函数体内部初始化一个extern变量\" class=\"headerlink\" title=\"2. 不能在函数体内部初始化一个extern变量\"></a>2. 不能在函数体内部初始化一个<code>extern</code>变量</h3><p><img src=\"D:\\Hugo\\Sites\\Puppy's\\static\\images\\extern-大型项目工程中使用全局变量\\image-20211101202636295.png\" alt=\"extern\"></p>\n<p>原因：<a href=\"https://stackoverflow.com/questions/17090354/why-does-initializing-an-extern-variable-inside-a-function-give-an-error\">c++ - Why does initializing an extern variable inside a function give an error? - Stack Overflow</a></p>\n<p><code>extern</code>变量告诉编译器，整个项目中的所有同名<code>symbol</code>，都指的是同一个<code>externally defined i</code>，所以如果允许在函数内初始化（定义）一个被<code>extern</code>标记的变量，就会有==多重定义==的风险</p>\n<p>例如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> i; <span class=\"comment\">// 同一个 externally defined i</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Hi&quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> i; <span class=\"comment\">// 这个 extern 会影响到其作用域内的所有 i，但是会被局部 i 屏蔽</span></span><br><span class=\"line\">    i++;</span><br><span class=\"line\">    <span class=\"built_in\">test</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"_content":"# C++初始化那些事儿\n\n## 初始化 vs 赋值💢\n\n初始化**不等于**赋值，这是两个完全不同的操作\n\n==初始化==：**创建变量时**赋予其一个初始值\n\n==赋值==：把对象的**当前值擦除**，再用一个新值**替换**\n\n## 列表初始化\n\nC++初始化有很多种形式，这也是初始化问题复杂性的一个体现。 例如，想要定义一个名为 `units_sold` 的 `int` 变量并初始化为 `0`，以下 4 条语句都能做到这一点：\n\n```c++\nint units_sold = 0;  //最正常的方式\nint units_sold = {0}; //列表初始化\nint units_sold{0}; // ?\nint units_sold(0); // ?\n```\n\n当用于内置类型的变量时，如果**列表初始化**存在**丢失信息**的风险，则编译器将**报错**：\n\n```c++\nlong double ld = 3.1415026536;\nint a{ld}, b = {ld}; // 列表初始化，报错，转换未执行，因为存在丢失信息（精度）的风险\nint c(ld), d = ld; // 正常，转换执行，虽然确实丢失了精度\n```\n\n## 默认初始化\n\n如果**定义变量**的时候**没有指定初值**，则变量被**默认初始化（default initialized）**，此时变量被赋予“**默认值**”\n\n>  **默认值到底是什么？**\n>\n>  ==内置类型==\n>\n>  由定义的位置决定：\n>\n>  1. **任何函数之外**的变量，它**被初始化为 ==0==**\n>  2. **在函数体内部**，将**不被初始化**，其值是==**未定义**==的，是**不能被访问**的\n>\n>  ==类对象==\n>\n>  **==类自己决定==**其变量的**初始化方式**、**初始化值**、**是否允许不经初始化变量就定义出对象**\n>\n>  绝大多数类都支持**无须显示初始化而定义对象**，它会给没有初始化的**类内变量**提供一个合适的**默认值**\n>\n>  ```c++\n>  std::string empty; // 默认值为空串\n>  Sales_item item; // item的默认值是什么，由 Sales_item 这个类自己定义\n>  ```\n>\n>  一些类要求每个对象都显示初始化， 如果没有就会报错\n\n## 直接初始化、拷贝初始化\n\n\n\n直接初始化：要求编译器使用**普通的函数匹配**，选择与我们提供的参数**最匹配**的构造函数（也可能最佳匹配上**拷构**）\n\n拷贝初始化：要求编译器将**右侧运算对象**拷贝到正在创建的对象中，需要的话可以进行类型转换\n\n\n\n> **拷初**一般调用**拷构**，但也可能调用**移构**\n\n\n\n```\nstring dots(10, '.');   //直初\nstring s(dots);  \t\t//使用了拷构的直初\nstring s = dots; \t\t//拷初\nstring null_book = \"9999\";  //拷初\nstring nines = string(100, '9'); //拷初\n```\n\n\n\n> 哪里有临时量生成？ 拷初的参数是 const& 肯定没有临时量\n\n\n\n发生拷初的常见情况\n\n1. `=`\n2. 非引用传参\n3. 非引用返回\n\n\n\n## 数组的初始化\n\n### 数组的初始化规则\n\n1. ==只有==在==定义==数组的时候才能使用初始化，以后就不能使用了\n\n```c++\nint cards[4] = {3,6,8,10}; //okay\nint hand[4];\nhand[4] = {5, 6, 7, 9}; //not allowed，可以使用下标一一赋值\n```\n\n2. ==不允许==数组间赋值\n\n```c++\nhand = cards; // not allowed\n```\n\n3. 允许==部分初始化==，剩余的默认采用==值初始化==\n\n### c++11新特性\n\n#### 列表初始化新特性\n\n```c++\ndouble earnings[4] {1.2e4, 1.6e4}; // 列表初始化，省略等号是可以的\nunsigned int counts[10] = {}; //所有10个元素都为0\nlong plifs[] = {25, 92, 3.0}; //报错，列表初始化禁止缩窄转换\n```\n\n关于`缩窄转换`[C++11 narrowing convertions(缩窄转换)_dai_peixian的专栏-CSDN博客_缩窄转换](https://blog.csdn.net/dai_peixian/article/details/52767057)\n\n## string初始化\n\n![初始化string](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211109100945293.png)\n\n<center style=\"color:#C0C0C0;text-decoration:underline\">Primer C++ 第五版，P76</center>\n\n## vector初始化\n\n```c++\nvector<T> v1;    // 空vector，默认初始化\nvector<T> v2(v1); //拷贝初始化，要求两个vector对象的类型必须相同\nvector<T> v2 = v1; //同上\nvector<T> v3(n,val); // v3包含n个重复元素，每个元素的值都是val\nvector<T> v4(n); // v4包含n个元素，每个元素都被值初始化（如果是内置类型，0，如果是类类型，则执行类定义默认初始化）\nvector<T> v5{a,b,c...} //列表初始化\nvector<T> v6 = {a,b,c...} //同上 \n```\n\n> 如果使用了花括号，但是提供的值不能用来完成列表初始化，编译器就会考虑用提供的值来构造 vector 对象\n>\n> ```c++\n> vector<string> v7{10};  //v7有10个默认初始化元素\n> vector<string> v8{10, \"hi\"}; //v8 有10个值为\"hi\"的元素\n> ```\n\n\n\n","source":"_posts/C++基础/初始化.md","raw":"# C++初始化那些事儿\n\n## 初始化 vs 赋值💢\n\n初始化**不等于**赋值，这是两个完全不同的操作\n\n==初始化==：**创建变量时**赋予其一个初始值\n\n==赋值==：把对象的**当前值擦除**，再用一个新值**替换**\n\n## 列表初始化\n\nC++初始化有很多种形式，这也是初始化问题复杂性的一个体现。 例如，想要定义一个名为 `units_sold` 的 `int` 变量并初始化为 `0`，以下 4 条语句都能做到这一点：\n\n```c++\nint units_sold = 0;  //最正常的方式\nint units_sold = {0}; //列表初始化\nint units_sold{0}; // ?\nint units_sold(0); // ?\n```\n\n当用于内置类型的变量时，如果**列表初始化**存在**丢失信息**的风险，则编译器将**报错**：\n\n```c++\nlong double ld = 3.1415026536;\nint a{ld}, b = {ld}; // 列表初始化，报错，转换未执行，因为存在丢失信息（精度）的风险\nint c(ld), d = ld; // 正常，转换执行，虽然确实丢失了精度\n```\n\n## 默认初始化\n\n如果**定义变量**的时候**没有指定初值**，则变量被**默认初始化（default initialized）**，此时变量被赋予“**默认值**”\n\n>  **默认值到底是什么？**\n>\n>  ==内置类型==\n>\n>  由定义的位置决定：\n>\n>  1. **任何函数之外**的变量，它**被初始化为 ==0==**\n>  2. **在函数体内部**，将**不被初始化**，其值是==**未定义**==的，是**不能被访问**的\n>\n>  ==类对象==\n>\n>  **==类自己决定==**其变量的**初始化方式**、**初始化值**、**是否允许不经初始化变量就定义出对象**\n>\n>  绝大多数类都支持**无须显示初始化而定义对象**，它会给没有初始化的**类内变量**提供一个合适的**默认值**\n>\n>  ```c++\n>  std::string empty; // 默认值为空串\n>  Sales_item item; // item的默认值是什么，由 Sales_item 这个类自己定义\n>  ```\n>\n>  一些类要求每个对象都显示初始化， 如果没有就会报错\n\n## 直接初始化、拷贝初始化\n\n\n\n直接初始化：要求编译器使用**普通的函数匹配**，选择与我们提供的参数**最匹配**的构造函数（也可能最佳匹配上**拷构**）\n\n拷贝初始化：要求编译器将**右侧运算对象**拷贝到正在创建的对象中，需要的话可以进行类型转换\n\n\n\n> **拷初**一般调用**拷构**，但也可能调用**移构**\n\n\n\n```\nstring dots(10, '.');   //直初\nstring s(dots);  \t\t//使用了拷构的直初\nstring s = dots; \t\t//拷初\nstring null_book = \"9999\";  //拷初\nstring nines = string(100, '9'); //拷初\n```\n\n\n\n> 哪里有临时量生成？ 拷初的参数是 const& 肯定没有临时量\n\n\n\n发生拷初的常见情况\n\n1. `=`\n2. 非引用传参\n3. 非引用返回\n\n\n\n## 数组的初始化\n\n### 数组的初始化规则\n\n1. ==只有==在==定义==数组的时候才能使用初始化，以后就不能使用了\n\n```c++\nint cards[4] = {3,6,8,10}; //okay\nint hand[4];\nhand[4] = {5, 6, 7, 9}; //not allowed，可以使用下标一一赋值\n```\n\n2. ==不允许==数组间赋值\n\n```c++\nhand = cards; // not allowed\n```\n\n3. 允许==部分初始化==，剩余的默认采用==值初始化==\n\n### c++11新特性\n\n#### 列表初始化新特性\n\n```c++\ndouble earnings[4] {1.2e4, 1.6e4}; // 列表初始化，省略等号是可以的\nunsigned int counts[10] = {}; //所有10个元素都为0\nlong plifs[] = {25, 92, 3.0}; //报错，列表初始化禁止缩窄转换\n```\n\n关于`缩窄转换`[C++11 narrowing convertions(缩窄转换)_dai_peixian的专栏-CSDN博客_缩窄转换](https://blog.csdn.net/dai_peixian/article/details/52767057)\n\n## string初始化\n\n![初始化string](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211109100945293.png)\n\n<center style=\"color:#C0C0C0;text-decoration:underline\">Primer C++ 第五版，P76</center>\n\n## vector初始化\n\n```c++\nvector<T> v1;    // 空vector，默认初始化\nvector<T> v2(v1); //拷贝初始化，要求两个vector对象的类型必须相同\nvector<T> v2 = v1; //同上\nvector<T> v3(n,val); // v3包含n个重复元素，每个元素的值都是val\nvector<T> v4(n); // v4包含n个元素，每个元素都被值初始化（如果是内置类型，0，如果是类类型，则执行类定义默认初始化）\nvector<T> v5{a,b,c...} //列表初始化\nvector<T> v6 = {a,b,c...} //同上 \n```\n\n> 如果使用了花括号，但是提供的值不能用来完成列表初始化，编译器就会考虑用提供的值来构造 vector 对象\n>\n> ```c++\n> vector<string> v7{10};  //v7有10个默认初始化元素\n> vector<string> v8{10, \"hi\"}; //v8 有10个值为\"hi\"的元素\n> ```\n\n\n\n","slug":"C++基础/初始化","published":1,"date":"2021-12-31T02:09:01.483Z","updated":"2021-12-31T03:03:28.815Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckxzva9ff00057cu3bzj5ajgw","content":"<h1 id=\"C-初始化那些事儿\"><a href=\"#C-初始化那些事儿\" class=\"headerlink\" title=\"C++初始化那些事儿\"></a>C++初始化那些事儿</h1><h2 id=\"初始化-vs-赋值💢\"><a href=\"#初始化-vs-赋值💢\" class=\"headerlink\" title=\"初始化 vs 赋值💢\"></a>初始化 vs 赋值💢</h2><p>初始化<strong>不等于</strong>赋值，这是两个完全不同的操作</p>\n<p>==初始化==：<strong>创建变量时</strong>赋予其一个初始值</p>\n<p>==赋值==：把对象的<strong>当前值擦除</strong>，再用一个新值<strong>替换</strong></p>\n<h2 id=\"列表初始化\"><a href=\"#列表初始化\" class=\"headerlink\" title=\"列表初始化\"></a>列表初始化</h2><p>C++初始化有很多种形式，这也是初始化问题复杂性的一个体现。 例如，想要定义一个名为 <code>units_sold</code> 的 <code>int</code> 变量并初始化为 <code>0</code>，以下 4 条语句都能做到这一点：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> units_sold = <span class=\"number\">0</span>;  <span class=\"comment\">//最正常的方式</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> units_sold = &#123;<span class=\"number\">0</span>&#125;; <span class=\"comment\">//列表初始化</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> units_sold&#123;<span class=\"number\">0</span>&#125;; <span class=\"comment\">// ?</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">units_sold</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>; <span class=\"comment\">// ?</span></span><br></pre></td></tr></table></figure>\n\n<p>当用于内置类型的变量时，如果<strong>列表初始化</strong>存在<strong>丢失信息</strong>的风险，则编译器将<strong>报错</strong>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">double</span> ld = <span class=\"number\">3.1415026536</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> a&#123;ld&#125;, b = &#123;ld&#125;; <span class=\"comment\">// 列表初始化，报错，转换未执行，因为存在丢失信息（精度）的风险</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">c</span><span class=\"params\">(ld)</span>, d </span>= ld; <span class=\"comment\">// 正常，转换执行，虽然确实丢失了精度</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"默认初始化\"><a href=\"#默认初始化\" class=\"headerlink\" title=\"默认初始化\"></a>默认初始化</h2><p>如果<strong>定义变量</strong>的时候<strong>没有指定初值</strong>，则变量被<strong>默认初始化（default initialized）</strong>，此时变量被赋予“<strong>默认值</strong>”</p>\n<blockquote>\n<p> <strong>默认值到底是什么？</strong></p>\n<p> ==内置类型==</p>\n<p> 由定义的位置决定：</p>\n<ol>\n<li><strong>任何函数之外</strong>的变量，它<strong>被初始化为 ==0==</strong></li>\n<li><strong>在函数体内部</strong>，将<strong>不被初始化</strong>，其值是==<strong>未定义</strong>==的，是<strong>不能被访问</strong>的</li>\n</ol>\n<p> ==类对象==</p>\n<p> <strong>==类自己决定==<strong>其变量的</strong>初始化方式</strong>、<strong>初始化值</strong>、<strong>是否允许不经初始化变量就定义出对象</strong></p>\n<p> 绝大多数类都支持<strong>无须显示初始化而定义对象</strong>，它会给没有初始化的<strong>类内变量</strong>提供一个合适的<strong>默认值</strong></p>\n <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::string empty; <span class=\"comment\">// 默认值为空串</span></span><br><span class=\"line\">Sales_item item; <span class=\"comment\">// item的默认值是什么，由 Sales_item 这个类自己定义</span></span><br></pre></td></tr></table></figure>\n\n<p> 一些类要求每个对象都显示初始化， 如果没有就会报错</p>\n</blockquote>\n<h2 id=\"直接初始化、拷贝初始化\"><a href=\"#直接初始化、拷贝初始化\" class=\"headerlink\" title=\"直接初始化、拷贝初始化\"></a>直接初始化、拷贝初始化</h2><p>直接初始化：要求编译器使用<strong>普通的函数匹配</strong>，选择与我们提供的参数<strong>最匹配</strong>的构造函数（也可能最佳匹配上<strong>拷构</strong>）</p>\n<p>拷贝初始化：要求编译器将<strong>右侧运算对象</strong>拷贝到正在创建的对象中，需要的话可以进行类型转换</p>\n<blockquote>\n<p><strong>拷初</strong>一般调用<strong>拷构</strong>，但也可能调用<strong>移构</strong></p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string dots(10, &#x27;.&#x27;);   //直初</span><br><span class=\"line\">string s(dots);  \t\t//使用了拷构的直初</span><br><span class=\"line\">string s = dots; \t\t//拷初</span><br><span class=\"line\">string null_book = &quot;9999&quot;;  //拷初</span><br><span class=\"line\">string nines = string(100, &#x27;9&#x27;); //拷初</span><br></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p>哪里有临时量生成？ 拷初的参数是 const&amp; 肯定没有临时量</p>\n</blockquote>\n<p>发生拷初的常见情况</p>\n<ol>\n<li><code>=</code></li>\n<li>非引用传参</li>\n<li>非引用返回</li>\n</ol>\n<h2 id=\"数组的初始化\"><a href=\"#数组的初始化\" class=\"headerlink\" title=\"数组的初始化\"></a>数组的初始化</h2><h3 id=\"数组的初始化规则\"><a href=\"#数组的初始化规则\" class=\"headerlink\" title=\"数组的初始化规则\"></a>数组的初始化规则</h3><ol>\n<li>==只有==在==定义==数组的时候才能使用初始化，以后就不能使用了</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> cards[<span class=\"number\">4</span>] = &#123;<span class=\"number\">3</span>,<span class=\"number\">6</span>,<span class=\"number\">8</span>,<span class=\"number\">10</span>&#125;; <span class=\"comment\">//okay</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> hand[<span class=\"number\">4</span>];</span><br><span class=\"line\">hand[<span class=\"number\">4</span>] = &#123;<span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>&#125;; <span class=\"comment\">//not allowed，可以使用下标一一赋值</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>==不允许==数组间赋值</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hand = cards; <span class=\"comment\">// not allowed</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>允许==部分初始化==，剩余的默认采用==值初始化==</li>\n</ol>\n<h3 id=\"c-11新特性\"><a href=\"#c-11新特性\" class=\"headerlink\" title=\"c++11新特性\"></a>c++11新特性</h3><h4 id=\"列表初始化新特性\"><a href=\"#列表初始化新特性\" class=\"headerlink\" title=\"列表初始化新特性\"></a>列表初始化新特性</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">double</span> earnings[<span class=\"number\">4</span>] &#123;<span class=\"number\">1.2e4</span>, <span class=\"number\">1.6e4</span>&#125;; <span class=\"comment\">// 列表初始化，省略等号是可以的</span></span><br><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> counts[<span class=\"number\">10</span>] = &#123;&#125;; <span class=\"comment\">//所有10个元素都为0</span></span><br><span class=\"line\"><span class=\"keyword\">long</span> plifs[] = &#123;<span class=\"number\">25</span>, <span class=\"number\">92</span>, <span class=\"number\">3.0</span>&#125;; <span class=\"comment\">//报错，列表初始化禁止缩窄转换</span></span><br></pre></td></tr></table></figure>\n\n<p>关于<code>缩窄转换</code><a href=\"https://blog.csdn.net/dai_peixian/article/details/52767057\">C++11 narrowing convertions(缩窄转换)_dai_peixian的专栏-CSDN博客_缩窄转换</a></p>\n<h2 id=\"string初始化\"><a href=\"#string初始化\" class=\"headerlink\" title=\"string初始化\"></a>string初始化</h2><p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211109100945293.png\" alt=\"初始化string\"></p>\n<center style=\"color:#C0C0C0;text-decoration:underline\">Primer C++ 第五版，P76</center>\n\n<h2 id=\"vector初始化\"><a href=\"#vector初始化\" class=\"headerlink\" title=\"vector初始化\"></a>vector初始化</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;T&gt; v1;    <span class=\"comment\">// 空vector，默认初始化</span></span><br><span class=\"line\"><span class=\"function\">vector&lt;T&gt; <span class=\"title\">v2</span><span class=\"params\">(v1)</span></span>; <span class=\"comment\">//拷贝初始化，要求两个vector对象的类型必须相同</span></span><br><span class=\"line\">vector&lt;T&gt; v2 = v1; <span class=\"comment\">//同上</span></span><br><span class=\"line\"><span class=\"function\">vector&lt;T&gt; <span class=\"title\">v3</span><span class=\"params\">(n,val)</span></span>; <span class=\"comment\">// v3包含n个重复元素，每个元素的值都是val</span></span><br><span class=\"line\"><span class=\"function\">vector&lt;T&gt; <span class=\"title\">v4</span><span class=\"params\">(n)</span></span>; <span class=\"comment\">// v4包含n个元素，每个元素都被值初始化（如果是内置类型，0，如果是类类型，则执行类定义默认初始化）</span></span><br><span class=\"line\">vector&lt;T&gt; v5&#123;a,b,c...&#125; <span class=\"comment\">//列表初始化</span></span><br><span class=\"line\">vector&lt;T&gt; v6 = &#123;a,b,c...&#125; <span class=\"comment\">//同上 </span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>如果使用了花括号，但是提供的值不能用来完成列表初始化，编译器就会考虑用提供的值来构造 vector 对象</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;string&gt; v7&#123;<span class=\"number\">10</span>&#125;;  <span class=\"comment\">//v7有10个默认初始化元素</span></span><br><span class=\"line\">vector&lt;string&gt; v8&#123;<span class=\"number\">10</span>, <span class=\"string\">&quot;hi&quot;</span>&#125;; <span class=\"comment\">//v8 有10个值为&quot;hi&quot;的元素</span></span><br></pre></td></tr></table></figure>\n</blockquote>\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<h1 id=\"C-初始化那些事儿\"><a href=\"#C-初始化那些事儿\" class=\"headerlink\" title=\"C++初始化那些事儿\"></a>C++初始化那些事儿</h1><h2 id=\"初始化-vs-赋值💢\"><a href=\"#初始化-vs-赋值💢\" class=\"headerlink\" title=\"初始化 vs 赋值💢\"></a>初始化 vs 赋值💢</h2><p>初始化<strong>不等于</strong>赋值，这是两个完全不同的操作</p>\n<p>==初始化==：<strong>创建变量时</strong>赋予其一个初始值</p>\n<p>==赋值==：把对象的<strong>当前值擦除</strong>，再用一个新值<strong>替换</strong></p>\n<h2 id=\"列表初始化\"><a href=\"#列表初始化\" class=\"headerlink\" title=\"列表初始化\"></a>列表初始化</h2><p>C++初始化有很多种形式，这也是初始化问题复杂性的一个体现。 例如，想要定义一个名为 <code>units_sold</code> 的 <code>int</code> 变量并初始化为 <code>0</code>，以下 4 条语句都能做到这一点：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> units_sold = <span class=\"number\">0</span>;  <span class=\"comment\">//最正常的方式</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> units_sold = &#123;<span class=\"number\">0</span>&#125;; <span class=\"comment\">//列表初始化</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> units_sold&#123;<span class=\"number\">0</span>&#125;; <span class=\"comment\">// ?</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">units_sold</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>; <span class=\"comment\">// ?</span></span><br></pre></td></tr></table></figure>\n\n<p>当用于内置类型的变量时，如果<strong>列表初始化</strong>存在<strong>丢失信息</strong>的风险，则编译器将<strong>报错</strong>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">double</span> ld = <span class=\"number\">3.1415026536</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> a&#123;ld&#125;, b = &#123;ld&#125;; <span class=\"comment\">// 列表初始化，报错，转换未执行，因为存在丢失信息（精度）的风险</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">c</span><span class=\"params\">(ld)</span>, d </span>= ld; <span class=\"comment\">// 正常，转换执行，虽然确实丢失了精度</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"默认初始化\"><a href=\"#默认初始化\" class=\"headerlink\" title=\"默认初始化\"></a>默认初始化</h2><p>如果<strong>定义变量</strong>的时候<strong>没有指定初值</strong>，则变量被<strong>默认初始化（default initialized）</strong>，此时变量被赋予“<strong>默认值</strong>”</p>\n<blockquote>\n<p> <strong>默认值到底是什么？</strong></p>\n<p> ==内置类型==</p>\n<p> 由定义的位置决定：</p>\n<ol>\n<li><strong>任何函数之外</strong>的变量，它<strong>被初始化为 ==0==</strong></li>\n<li><strong>在函数体内部</strong>，将<strong>不被初始化</strong>，其值是==<strong>未定义</strong>==的，是<strong>不能被访问</strong>的</li>\n</ol>\n<p> ==类对象==</p>\n<p> <strong>==类自己决定==<strong>其变量的</strong>初始化方式</strong>、<strong>初始化值</strong>、<strong>是否允许不经初始化变量就定义出对象</strong></p>\n<p> 绝大多数类都支持<strong>无须显示初始化而定义对象</strong>，它会给没有初始化的<strong>类内变量</strong>提供一个合适的<strong>默认值</strong></p>\n <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::string empty; <span class=\"comment\">// 默认值为空串</span></span><br><span class=\"line\">Sales_item item; <span class=\"comment\">// item的默认值是什么，由 Sales_item 这个类自己定义</span></span><br></pre></td></tr></table></figure>\n\n<p> 一些类要求每个对象都显示初始化， 如果没有就会报错</p>\n</blockquote>\n<h2 id=\"直接初始化、拷贝初始化\"><a href=\"#直接初始化、拷贝初始化\" class=\"headerlink\" title=\"直接初始化、拷贝初始化\"></a>直接初始化、拷贝初始化</h2><p>直接初始化：要求编译器使用<strong>普通的函数匹配</strong>，选择与我们提供的参数<strong>最匹配</strong>的构造函数（也可能最佳匹配上<strong>拷构</strong>）</p>\n<p>拷贝初始化：要求编译器将<strong>右侧运算对象</strong>拷贝到正在创建的对象中，需要的话可以进行类型转换</p>\n<blockquote>\n<p><strong>拷初</strong>一般调用<strong>拷构</strong>，但也可能调用<strong>移构</strong></p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string dots(10, &#x27;.&#x27;);   //直初</span><br><span class=\"line\">string s(dots);  \t\t//使用了拷构的直初</span><br><span class=\"line\">string s = dots; \t\t//拷初</span><br><span class=\"line\">string null_book = &quot;9999&quot;;  //拷初</span><br><span class=\"line\">string nines = string(100, &#x27;9&#x27;); //拷初</span><br></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p>哪里有临时量生成？ 拷初的参数是 const&amp; 肯定没有临时量</p>\n</blockquote>\n<p>发生拷初的常见情况</p>\n<ol>\n<li><code>=</code></li>\n<li>非引用传参</li>\n<li>非引用返回</li>\n</ol>\n<h2 id=\"数组的初始化\"><a href=\"#数组的初始化\" class=\"headerlink\" title=\"数组的初始化\"></a>数组的初始化</h2><h3 id=\"数组的初始化规则\"><a href=\"#数组的初始化规则\" class=\"headerlink\" title=\"数组的初始化规则\"></a>数组的初始化规则</h3><ol>\n<li>==只有==在==定义==数组的时候才能使用初始化，以后就不能使用了</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> cards[<span class=\"number\">4</span>] = &#123;<span class=\"number\">3</span>,<span class=\"number\">6</span>,<span class=\"number\">8</span>,<span class=\"number\">10</span>&#125;; <span class=\"comment\">//okay</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> hand[<span class=\"number\">4</span>];</span><br><span class=\"line\">hand[<span class=\"number\">4</span>] = &#123;<span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>&#125;; <span class=\"comment\">//not allowed，可以使用下标一一赋值</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>==不允许==数组间赋值</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hand = cards; <span class=\"comment\">// not allowed</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>允许==部分初始化==，剩余的默认采用==值初始化==</li>\n</ol>\n<h3 id=\"c-11新特性\"><a href=\"#c-11新特性\" class=\"headerlink\" title=\"c++11新特性\"></a>c++11新特性</h3><h4 id=\"列表初始化新特性\"><a href=\"#列表初始化新特性\" class=\"headerlink\" title=\"列表初始化新特性\"></a>列表初始化新特性</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">double</span> earnings[<span class=\"number\">4</span>] &#123;<span class=\"number\">1.2e4</span>, <span class=\"number\">1.6e4</span>&#125;; <span class=\"comment\">// 列表初始化，省略等号是可以的</span></span><br><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> counts[<span class=\"number\">10</span>] = &#123;&#125;; <span class=\"comment\">//所有10个元素都为0</span></span><br><span class=\"line\"><span class=\"keyword\">long</span> plifs[] = &#123;<span class=\"number\">25</span>, <span class=\"number\">92</span>, <span class=\"number\">3.0</span>&#125;; <span class=\"comment\">//报错，列表初始化禁止缩窄转换</span></span><br></pre></td></tr></table></figure>\n\n<p>关于<code>缩窄转换</code><a href=\"https://blog.csdn.net/dai_peixian/article/details/52767057\">C++11 narrowing convertions(缩窄转换)_dai_peixian的专栏-CSDN博客_缩窄转换</a></p>\n<h2 id=\"string初始化\"><a href=\"#string初始化\" class=\"headerlink\" title=\"string初始化\"></a>string初始化</h2><p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211109100945293.png\" alt=\"初始化string\"></p>\n<center style=\"color:#C0C0C0;text-decoration:underline\">Primer C++ 第五版，P76</center>\n\n<h2 id=\"vector初始化\"><a href=\"#vector初始化\" class=\"headerlink\" title=\"vector初始化\"></a>vector初始化</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;T&gt; v1;    <span class=\"comment\">// 空vector，默认初始化</span></span><br><span class=\"line\"><span class=\"function\">vector&lt;T&gt; <span class=\"title\">v2</span><span class=\"params\">(v1)</span></span>; <span class=\"comment\">//拷贝初始化，要求两个vector对象的类型必须相同</span></span><br><span class=\"line\">vector&lt;T&gt; v2 = v1; <span class=\"comment\">//同上</span></span><br><span class=\"line\"><span class=\"function\">vector&lt;T&gt; <span class=\"title\">v3</span><span class=\"params\">(n,val)</span></span>; <span class=\"comment\">// v3包含n个重复元素，每个元素的值都是val</span></span><br><span class=\"line\"><span class=\"function\">vector&lt;T&gt; <span class=\"title\">v4</span><span class=\"params\">(n)</span></span>; <span class=\"comment\">// v4包含n个元素，每个元素都被值初始化（如果是内置类型，0，如果是类类型，则执行类定义默认初始化）</span></span><br><span class=\"line\">vector&lt;T&gt; v5&#123;a,b,c...&#125; <span class=\"comment\">//列表初始化</span></span><br><span class=\"line\">vector&lt;T&gt; v6 = &#123;a,b,c...&#125; <span class=\"comment\">//同上 </span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>如果使用了花括号，但是提供的值不能用来完成列表初始化，编译器就会考虑用提供的值来构造 vector 对象</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;string&gt; v7&#123;<span class=\"number\">10</span>&#125;;  <span class=\"comment\">//v7有10个默认初始化元素</span></span><br><span class=\"line\">vector&lt;string&gt; v8&#123;<span class=\"number\">10</span>, <span class=\"string\">&quot;hi&quot;</span>&#125;; <span class=\"comment\">//v8 有10个值为&quot;hi&quot;的元素</span></span><br></pre></td></tr></table></figure>\n</blockquote>\n"},{"_content":"## 1. static\n\n### static 的引入\n\n函数中的`static`，既可以控制此变量的访问范围，又可以使此变量的值保存至下一次调用\n\n类中的`static`，需要一个对象服务于整个类， 同时又力求不破坏类的封装性\n\n### static 的存储\n\n在 linux 系统中，程序在内存中的分布如下所示：\n\n![image-20211214120006624](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211214120006624.png)\n\n`static`数据成员无论是全局变量还是局部变量都存储在全局/静态区域，在**编译期**就为其分配内存，在程序结束时释放\n\n**全局（静态）存储区：分为DATA段、BSS段**\n\nDATA段（全局初始化区）：存放**已经初始化**的全局变量和`static`变量\n\nBSS段（全局未初始化区）：存放**未初始化**的全局变量和`static`变量\n\n程序运行结束时自动释放，其中BSS段在程序执行**之前**会被系统自动清零，**所以未初始化的全局变量和`static`变量在程序执行之前已经为 0**\n\n### `static` 的四个作用\n\n1. **隐藏**\n\n   同时编译多个文件的时候，所有未加`static`的全局变量和函数都具有全局可见性，别的源文件也能访问（`extern`）。而加了`static`的变量以及函数就只在本文件可见，其他源文件不能够访问\n\n   ```cpp\n   //file1\n   int error = 20; //external declaration\n   ...\n   --------------------------------------\n   //file2\n   int error = 5;  // 报错，多重定义error\n   void froobish(){\n       cout << errors; //报错\n       ...\n   }\n   ```\n\n   上面的代码会报多重定义错误，但如果一个文件定义了`static`外部（全局）变量，其名称与另一个文件中声明的常规外部变量相同，则在该文件中，静态变量将**隐藏**常规外部变量\n\n   ```cpp\n   //file1\n   int error = 20; //external declaration\n   ...\n   --------------------------------------\n   //file2\n   static int error = 5;  // 隐藏其他文件的同名变量\n   void froobish(){\n       cout << errors; // 输出 error ： 5\n       ...\n   }\n   ```\n\n2. **保持**变量内容的持久（`static`变量中的记忆功能与全局生存期）\n\n   存储在**静态数据区**的变量会在程序刚开始运行时就完成初始化， 也是**唯一的一次初始化**\n\n   > 如果作为`static`局部变量在**函数内**定义，它的**生存期**为整个源程序，但是其**作用域**仍与自动变量相同，只能在定义该变量的函数内使用该变量。退出函数后，尽管该变量还继续存在，但不能使用它\n\n3. **默认初始化**\n\n   在静态数据区，内存中所有字节默认都是0x00\n\n### **面向对象的static**\n\n1. 类的静态成员变量\n\n   - 属于类，使用前**必须**在类外进行初始化，编译器不会自动为其赋值\n\n   ```cpp\n   int A::a = 0;\n   ```\n\n   > 不要在头文件中定义（初始化）静态数据成员，在大多数情况下，这样做会引起重复定义的错误\n\n   - 多个对象共享，在内存中只占一份空间\n   - 既可以通过对象名引用，也可以通过类名引用\n\n2. 类的静态成员函数\n\n   - 没有`this`指针\n   - 只能访问静态成员，不能访问非静态成员\n\n3. 类的对象**可以**使用静态成员函数**和**非静态成员函数\n\n4. 静态成员函数**不能**使用非静态成员\n\n5. 类的非静态成员函数**可以**调用静态成员函数，反之不能\n\n> 静态资源属于类，是在类初始化的时候加载的，而非静态资源是类实例化对象的时候加载的。类的初始化早于类实例化对象，所以对于静态资源来说，它是不可能知道类中有哪些非静态资源的，但非静态资源却认识类中早已存在的静态资源\n\n参考资料：\n\nhttps://www.cnblogs.com/33debug/p/7223869.html\n\nhttps://www.daimajiaoliu.com/daima/479591b11900404\n\nhttps://blog.csdn.net/xiajun07061225/article/details/6955226\n\n## 2. const\n\n","source":"_posts/C++基础/static-const关键字总结.md","raw":"## 1. static\n\n### static 的引入\n\n函数中的`static`，既可以控制此变量的访问范围，又可以使此变量的值保存至下一次调用\n\n类中的`static`，需要一个对象服务于整个类， 同时又力求不破坏类的封装性\n\n### static 的存储\n\n在 linux 系统中，程序在内存中的分布如下所示：\n\n![image-20211214120006624](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211214120006624.png)\n\n`static`数据成员无论是全局变量还是局部变量都存储在全局/静态区域，在**编译期**就为其分配内存，在程序结束时释放\n\n**全局（静态）存储区：分为DATA段、BSS段**\n\nDATA段（全局初始化区）：存放**已经初始化**的全局变量和`static`变量\n\nBSS段（全局未初始化区）：存放**未初始化**的全局变量和`static`变量\n\n程序运行结束时自动释放，其中BSS段在程序执行**之前**会被系统自动清零，**所以未初始化的全局变量和`static`变量在程序执行之前已经为 0**\n\n### `static` 的四个作用\n\n1. **隐藏**\n\n   同时编译多个文件的时候，所有未加`static`的全局变量和函数都具有全局可见性，别的源文件也能访问（`extern`）。而加了`static`的变量以及函数就只在本文件可见，其他源文件不能够访问\n\n   ```cpp\n   //file1\n   int error = 20; //external declaration\n   ...\n   --------------------------------------\n   //file2\n   int error = 5;  // 报错，多重定义error\n   void froobish(){\n       cout << errors; //报错\n       ...\n   }\n   ```\n\n   上面的代码会报多重定义错误，但如果一个文件定义了`static`外部（全局）变量，其名称与另一个文件中声明的常规外部变量相同，则在该文件中，静态变量将**隐藏**常规外部变量\n\n   ```cpp\n   //file1\n   int error = 20; //external declaration\n   ...\n   --------------------------------------\n   //file2\n   static int error = 5;  // 隐藏其他文件的同名变量\n   void froobish(){\n       cout << errors; // 输出 error ： 5\n       ...\n   }\n   ```\n\n2. **保持**变量内容的持久（`static`变量中的记忆功能与全局生存期）\n\n   存储在**静态数据区**的变量会在程序刚开始运行时就完成初始化， 也是**唯一的一次初始化**\n\n   > 如果作为`static`局部变量在**函数内**定义，它的**生存期**为整个源程序，但是其**作用域**仍与自动变量相同，只能在定义该变量的函数内使用该变量。退出函数后，尽管该变量还继续存在，但不能使用它\n\n3. **默认初始化**\n\n   在静态数据区，内存中所有字节默认都是0x00\n\n### **面向对象的static**\n\n1. 类的静态成员变量\n\n   - 属于类，使用前**必须**在类外进行初始化，编译器不会自动为其赋值\n\n   ```cpp\n   int A::a = 0;\n   ```\n\n   > 不要在头文件中定义（初始化）静态数据成员，在大多数情况下，这样做会引起重复定义的错误\n\n   - 多个对象共享，在内存中只占一份空间\n   - 既可以通过对象名引用，也可以通过类名引用\n\n2. 类的静态成员函数\n\n   - 没有`this`指针\n   - 只能访问静态成员，不能访问非静态成员\n\n3. 类的对象**可以**使用静态成员函数**和**非静态成员函数\n\n4. 静态成员函数**不能**使用非静态成员\n\n5. 类的非静态成员函数**可以**调用静态成员函数，反之不能\n\n> 静态资源属于类，是在类初始化的时候加载的，而非静态资源是类实例化对象的时候加载的。类的初始化早于类实例化对象，所以对于静态资源来说，它是不可能知道类中有哪些非静态资源的，但非静态资源却认识类中早已存在的静态资源\n\n参考资料：\n\nhttps://www.cnblogs.com/33debug/p/7223869.html\n\nhttps://www.daimajiaoliu.com/daima/479591b11900404\n\nhttps://blog.csdn.net/xiajun07061225/article/details/6955226\n\n## 2. const\n\n","slug":"C++基础/static-const关键字总结","published":1,"date":"2021-12-31T02:09:01.474Z","updated":"2021-12-15T12:55:04.114Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckxzva9fh00067cu31j441ist","content":"<h2 id=\"1-static\"><a href=\"#1-static\" class=\"headerlink\" title=\"1. static\"></a>1. static</h2><h3 id=\"static-的引入\"><a href=\"#static-的引入\" class=\"headerlink\" title=\"static 的引入\"></a>static 的引入</h3><p>函数中的<code>static</code>，既可以控制此变量的访问范围，又可以使此变量的值保存至下一次调用</p>\n<p>类中的<code>static</code>，需要一个对象服务于整个类， 同时又力求不破坏类的封装性</p>\n<h3 id=\"static-的存储\"><a href=\"#static-的存储\" class=\"headerlink\" title=\"static 的存储\"></a>static 的存储</h3><p>在 linux 系统中，程序在内存中的分布如下所示：</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211214120006624.png\" alt=\"image-20211214120006624\"></p>\n<p><code>static</code>数据成员无论是全局变量还是局部变量都存储在全局/静态区域，在<strong>编译期</strong>就为其分配内存，在程序结束时释放</p>\n<p><strong>全局（静态）存储区：分为DATA段、BSS段</strong></p>\n<p>DATA段（全局初始化区）：存放<strong>已经初始化</strong>的全局变量和<code>static</code>变量</p>\n<p>BSS段（全局未初始化区）：存放<strong>未初始化</strong>的全局变量和<code>static</code>变量</p>\n<p>程序运行结束时自动释放，其中BSS段在程序执行<strong>之前</strong>会被系统自动清零，<strong>所以未初始化的全局变量和<code>static</code>变量在程序执行之前已经为 0</strong></p>\n<h3 id=\"static-的四个作用\"><a href=\"#static-的四个作用\" class=\"headerlink\" title=\"static 的四个作用\"></a><code>static</code> 的四个作用</h3><ol>\n<li><p><strong>隐藏</strong></p>\n<p>同时编译多个文件的时候，所有未加<code>static</code>的全局变量和函数都具有全局可见性，别的源文件也能访问（<code>extern</code>）。而加了<code>static</code>的变量以及函数就只在本文件可见，其他源文件不能够访问</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//file1</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> error = <span class=\"number\">20</span>; <span class=\"comment\">//external declaration</span></span><br><span class=\"line\">...</span><br><span class=\"line\">--------------------------------------</span><br><span class=\"line\"><span class=\"comment\">//file2</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> error = <span class=\"number\">5</span>;  <span class=\"comment\">// 报错，多重定义error</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">froobish</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cout &lt;&lt; errors; <span class=\"comment\">//报错</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码会报多重定义错误，但如果一个文件定义了<code>static</code>外部（全局）变量，其名称与另一个文件中声明的常规外部变量相同，则在该文件中，静态变量将<strong>隐藏</strong>常规外部变量</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//file1</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> error = <span class=\"number\">20</span>; <span class=\"comment\">//external declaration</span></span><br><span class=\"line\">...</span><br><span class=\"line\">--------------------------------------</span><br><span class=\"line\"><span class=\"comment\">//file2</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> error = <span class=\"number\">5</span>;  <span class=\"comment\">// 隐藏其他文件的同名变量</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">froobish</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cout &lt;&lt; errors; <span class=\"comment\">// 输出 error ： 5</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>保持</strong>变量内容的持久（<code>static</code>变量中的记忆功能与全局生存期）</p>\n<p>存储在<strong>静态数据区</strong>的变量会在程序刚开始运行时就完成初始化， 也是<strong>唯一的一次初始化</strong></p>\n<blockquote>\n<p>如果作为<code>static</code>局部变量在<strong>函数内</strong>定义，它的<strong>生存期</strong>为整个源程序，但是其<strong>作用域</strong>仍与自动变量相同，只能在定义该变量的函数内使用该变量。退出函数后，尽管该变量还继续存在，但不能使用它</p>\n</blockquote>\n</li>\n<li><p><strong>默认初始化</strong></p>\n<p>在静态数据区，内存中所有字节默认都是0x00</p>\n</li>\n</ol>\n<h3 id=\"面向对象的static\"><a href=\"#面向对象的static\" class=\"headerlink\" title=\"面向对象的static\"></a><strong>面向对象的static</strong></h3><ol>\n<li><p>类的静态成员变量</p>\n<ul>\n<li>属于类，使用前<strong>必须</strong>在类外进行初始化，编译器不会自动为其赋值</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> A::a = <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>不要在头文件中定义（初始化）静态数据成员，在大多数情况下，这样做会引起重复定义的错误</p>\n</blockquote>\n<ul>\n<li>多个对象共享，在内存中只占一份空间</li>\n<li>既可以通过对象名引用，也可以通过类名引用</li>\n</ul>\n</li>\n<li><p>类的静态成员函数</p>\n<ul>\n<li>没有<code>this</code>指针</li>\n<li>只能访问静态成员，不能访问非静态成员</li>\n</ul>\n</li>\n<li><p>类的对象<strong>可以</strong>使用静态成员函数<strong>和</strong>非静态成员函数</p>\n</li>\n<li><p>静态成员函数<strong>不能</strong>使用非静态成员</p>\n</li>\n<li><p>类的非静态成员函数<strong>可以</strong>调用静态成员函数，反之不能</p>\n</li>\n</ol>\n<blockquote>\n<p>静态资源属于类，是在类初始化的时候加载的，而非静态资源是类实例化对象的时候加载的。类的初始化早于类实例化对象，所以对于静态资源来说，它是不可能知道类中有哪些非静态资源的，但非静态资源却认识类中早已存在的静态资源</p>\n</blockquote>\n<p>参考资料：</p>\n<p><a href=\"https://www.cnblogs.com/33debug/p/7223869.html\">https://www.cnblogs.com/33debug/p/7223869.html</a></p>\n<p><a href=\"https://www.daimajiaoliu.com/daima/479591b11900404\">https://www.daimajiaoliu.com/daima/479591b11900404</a></p>\n<p><a href=\"https://blog.csdn.net/xiajun07061225/article/details/6955226\">https://blog.csdn.net/xiajun07061225/article/details/6955226</a></p>\n<h2 id=\"2-const\"><a href=\"#2-const\" class=\"headerlink\" title=\"2. const\"></a>2. const</h2>","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<h2 id=\"1-static\"><a href=\"#1-static\" class=\"headerlink\" title=\"1. static\"></a>1. static</h2><h3 id=\"static-的引入\"><a href=\"#static-的引入\" class=\"headerlink\" title=\"static 的引入\"></a>static 的引入</h3><p>函数中的<code>static</code>，既可以控制此变量的访问范围，又可以使此变量的值保存至下一次调用</p>\n<p>类中的<code>static</code>，需要一个对象服务于整个类， 同时又力求不破坏类的封装性</p>\n<h3 id=\"static-的存储\"><a href=\"#static-的存储\" class=\"headerlink\" title=\"static 的存储\"></a>static 的存储</h3><p>在 linux 系统中，程序在内存中的分布如下所示：</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211214120006624.png\" alt=\"image-20211214120006624\"></p>\n<p><code>static</code>数据成员无论是全局变量还是局部变量都存储在全局/静态区域，在<strong>编译期</strong>就为其分配内存，在程序结束时释放</p>\n<p><strong>全局（静态）存储区：分为DATA段、BSS段</strong></p>\n<p>DATA段（全局初始化区）：存放<strong>已经初始化</strong>的全局变量和<code>static</code>变量</p>\n<p>BSS段（全局未初始化区）：存放<strong>未初始化</strong>的全局变量和<code>static</code>变量</p>\n<p>程序运行结束时自动释放，其中BSS段在程序执行<strong>之前</strong>会被系统自动清零，<strong>所以未初始化的全局变量和<code>static</code>变量在程序执行之前已经为 0</strong></p>\n<h3 id=\"static-的四个作用\"><a href=\"#static-的四个作用\" class=\"headerlink\" title=\"static 的四个作用\"></a><code>static</code> 的四个作用</h3><ol>\n<li><p><strong>隐藏</strong></p>\n<p>同时编译多个文件的时候，所有未加<code>static</code>的全局变量和函数都具有全局可见性，别的源文件也能访问（<code>extern</code>）。而加了<code>static</code>的变量以及函数就只在本文件可见，其他源文件不能够访问</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//file1</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> error = <span class=\"number\">20</span>; <span class=\"comment\">//external declaration</span></span><br><span class=\"line\">...</span><br><span class=\"line\">--------------------------------------</span><br><span class=\"line\"><span class=\"comment\">//file2</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> error = <span class=\"number\">5</span>;  <span class=\"comment\">// 报错，多重定义error</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">froobish</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cout &lt;&lt; errors; <span class=\"comment\">//报错</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码会报多重定义错误，但如果一个文件定义了<code>static</code>外部（全局）变量，其名称与另一个文件中声明的常规外部变量相同，则在该文件中，静态变量将<strong>隐藏</strong>常规外部变量</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//file1</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> error = <span class=\"number\">20</span>; <span class=\"comment\">//external declaration</span></span><br><span class=\"line\">...</span><br><span class=\"line\">--------------------------------------</span><br><span class=\"line\"><span class=\"comment\">//file2</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> error = <span class=\"number\">5</span>;  <span class=\"comment\">// 隐藏其他文件的同名变量</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">froobish</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cout &lt;&lt; errors; <span class=\"comment\">// 输出 error ： 5</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>保持</strong>变量内容的持久（<code>static</code>变量中的记忆功能与全局生存期）</p>\n<p>存储在<strong>静态数据区</strong>的变量会在程序刚开始运行时就完成初始化， 也是<strong>唯一的一次初始化</strong></p>\n<blockquote>\n<p>如果作为<code>static</code>局部变量在<strong>函数内</strong>定义，它的<strong>生存期</strong>为整个源程序，但是其<strong>作用域</strong>仍与自动变量相同，只能在定义该变量的函数内使用该变量。退出函数后，尽管该变量还继续存在，但不能使用它</p>\n</blockquote>\n</li>\n<li><p><strong>默认初始化</strong></p>\n<p>在静态数据区，内存中所有字节默认都是0x00</p>\n</li>\n</ol>\n<h3 id=\"面向对象的static\"><a href=\"#面向对象的static\" class=\"headerlink\" title=\"面向对象的static\"></a><strong>面向对象的static</strong></h3><ol>\n<li><p>类的静态成员变量</p>\n<ul>\n<li>属于类，使用前<strong>必须</strong>在类外进行初始化，编译器不会自动为其赋值</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> A::a = <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>不要在头文件中定义（初始化）静态数据成员，在大多数情况下，这样做会引起重复定义的错误</p>\n</blockquote>\n<ul>\n<li>多个对象共享，在内存中只占一份空间</li>\n<li>既可以通过对象名引用，也可以通过类名引用</li>\n</ul>\n</li>\n<li><p>类的静态成员函数</p>\n<ul>\n<li>没有<code>this</code>指针</li>\n<li>只能访问静态成员，不能访问非静态成员</li>\n</ul>\n</li>\n<li><p>类的对象<strong>可以</strong>使用静态成员函数<strong>和</strong>非静态成员函数</p>\n</li>\n<li><p>静态成员函数<strong>不能</strong>使用非静态成员</p>\n</li>\n<li><p>类的非静态成员函数<strong>可以</strong>调用静态成员函数，反之不能</p>\n</li>\n</ol>\n<blockquote>\n<p>静态资源属于类，是在类初始化的时候加载的，而非静态资源是类实例化对象的时候加载的。类的初始化早于类实例化对象，所以对于静态资源来说，它是不可能知道类中有哪些非静态资源的，但非静态资源却认识类中早已存在的静态资源</p>\n</blockquote>\n<p>参考资料：</p>\n<p><a href=\"https://www.cnblogs.com/33debug/p/7223869.html\">https://www.cnblogs.com/33debug/p/7223869.html</a></p>\n<p><a href=\"https://www.daimajiaoliu.com/daima/479591b11900404\">https://www.daimajiaoliu.com/daima/479591b11900404</a></p>\n<p><a href=\"https://blog.csdn.net/xiajun07061225/article/details/6955226\">https://blog.csdn.net/xiajun07061225/article/details/6955226</a></p>\n<h2 id=\"2-const\"><a href=\"#2-const\" class=\"headerlink\" title=\"2. const\"></a>2. const</h2>"},{"title":"字符串输入这些麻烦事儿","date":"2021-11-09T16:00:00.000Z","draft":false,"_content":"\n## 1. cin\n\n`cin`使用**空白**（空格、制表符和换行符）来确定字符串的**结束位置**，`cin`只能读取一个单词，读取到空格就结束了，然后将读到的字符串放到数组中，并在结尾添加空字符`'\\0'`。       \n\n`cin`将换行符**保留**在输入队列中。\n\n#### 1.1 while(cin)用法\n\n`istream` 类提供了一个可以将 `istream` 对象（如 `cin`）转换为 `bool` 值的函数。\n\n当 `cin` 出现在需要 `bool` 值的地方（例如 `while` 条件中）`cin`将被转换为`bool`值。读取成功返回 `true`，否则就返回 `false`。\n\n常见用法如下：\n\n1. 每次读取一个字符，直到遇到EOF\n\n   ```c++\n   cin.get(ch);\n   while(cin){  // 单飘一个cin，用来测试是否到文件尾了，当遇到文件结束符EOF时，终止\n       ...\n       cin.get(ch);  //如果读取没成功，会将失败标记置位\n   }   \n   ```\n\n   或者\n\n   ```c++\n   while(cin.get(ch)){\n       ...\n   }\n   ```\n\n   \n\n2. 循环输入，处理输入，遇到换行符终止\n\n   ```c++\n   vector<int> arr;\n   int num;\n   while(cin>>num){\n       arr.push_back(num);\n       if(cin.get()=='\\n'){\n           break;\n       }\n   }\n   ```\n\n   \n\n## 2. cin.getline()、cin.get()\n\n#### 2.1 cin.getline()\n\n```c++\nistream& getline (char* s, streamsize n );\n```\n\n遇到换行符停止读入，**不保存**换行符，用空字符替代换行符，加到数组后面\n\n接受两个参数\n\n1. 第一个是要接受读进来的字符串的字符数组的地址\n\n2. 第二个是要读取的字符数 `n`\n\n注意：`n` 不能超过字符数组的大小，且 `n` 已经计入了 `'\\0'`，也就是说有效允许读入字符数应该是 `n-1`\n\n#### 2.2 cin.get()\n\n`cin.get()`有几种变体：\n\n1. 接受的参数与`cin.getline()`一样，但是**保留换行符在输入队列中**（和`cin`一样）\n\n2. 不带任何参数\n\n   `cin.get();` 它可用来读取**下一个字符**（可以是换行符）\n\n3. 带一个char参数\n\n   ```c++\n   cin.get(char &_Ch)\n   ```\n\n## 3. string类成员函数getline()\n\n读取一整行，直到遇到**换行符**（换行符也被读入，但是抛弃它，**不存**）\n\n```c++\nstring str;\ngetline(cin,str);\n```\n\n","source":"_posts/C++基础/字符串输入.md","raw":"---\ntitle: \"字符串输入这些麻烦事儿\"\ndate: 2021-11-10\ndraft: false\ntags: [\"C/C++\"]\ncategories: [\"我为什么这么菜~~\"]\n---\n\n## 1. cin\n\n`cin`使用**空白**（空格、制表符和换行符）来确定字符串的**结束位置**，`cin`只能读取一个单词，读取到空格就结束了，然后将读到的字符串放到数组中，并在结尾添加空字符`'\\0'`。       \n\n`cin`将换行符**保留**在输入队列中。\n\n#### 1.1 while(cin)用法\n\n`istream` 类提供了一个可以将 `istream` 对象（如 `cin`）转换为 `bool` 值的函数。\n\n当 `cin` 出现在需要 `bool` 值的地方（例如 `while` 条件中）`cin`将被转换为`bool`值。读取成功返回 `true`，否则就返回 `false`。\n\n常见用法如下：\n\n1. 每次读取一个字符，直到遇到EOF\n\n   ```c++\n   cin.get(ch);\n   while(cin){  // 单飘一个cin，用来测试是否到文件尾了，当遇到文件结束符EOF时，终止\n       ...\n       cin.get(ch);  //如果读取没成功，会将失败标记置位\n   }   \n   ```\n\n   或者\n\n   ```c++\n   while(cin.get(ch)){\n       ...\n   }\n   ```\n\n   \n\n2. 循环输入，处理输入，遇到换行符终止\n\n   ```c++\n   vector<int> arr;\n   int num;\n   while(cin>>num){\n       arr.push_back(num);\n       if(cin.get()=='\\n'){\n           break;\n       }\n   }\n   ```\n\n   \n\n## 2. cin.getline()、cin.get()\n\n#### 2.1 cin.getline()\n\n```c++\nistream& getline (char* s, streamsize n );\n```\n\n遇到换行符停止读入，**不保存**换行符，用空字符替代换行符，加到数组后面\n\n接受两个参数\n\n1. 第一个是要接受读进来的字符串的字符数组的地址\n\n2. 第二个是要读取的字符数 `n`\n\n注意：`n` 不能超过字符数组的大小，且 `n` 已经计入了 `'\\0'`，也就是说有效允许读入字符数应该是 `n-1`\n\n#### 2.2 cin.get()\n\n`cin.get()`有几种变体：\n\n1. 接受的参数与`cin.getline()`一样，但是**保留换行符在输入队列中**（和`cin`一样）\n\n2. 不带任何参数\n\n   `cin.get();` 它可用来读取**下一个字符**（可以是换行符）\n\n3. 带一个char参数\n\n   ```c++\n   cin.get(char &_Ch)\n   ```\n\n## 3. string类成员函数getline()\n\n读取一整行，直到遇到**换行符**（换行符也被读入，但是抛弃它，**不存**）\n\n```c++\nstring str;\ngetline(cin,str);\n```\n\n","slug":"C++基础/字符串输入","published":1,"updated":"2021-12-06T06:43:06.365Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckxzva9fi00077cu3earvf4mp","content":"<h2 id=\"1-cin\"><a href=\"#1-cin\" class=\"headerlink\" title=\"1. cin\"></a>1. cin</h2><p><code>cin</code>使用<strong>空白</strong>（空格、制表符和换行符）来确定字符串的<strong>结束位置</strong>，<code>cin</code>只能读取一个单词，读取到空格就结束了，然后将读到的字符串放到数组中，并在结尾添加空字符<code>&#39;\\0&#39;</code>。       </p>\n<p><code>cin</code>将换行符<strong>保留</strong>在输入队列中。</p>\n<h4 id=\"1-1-while-cin-用法\"><a href=\"#1-1-while-cin-用法\" class=\"headerlink\" title=\"1.1 while(cin)用法\"></a>1.1 while(cin)用法</h4><p><code>istream</code> 类提供了一个可以将 <code>istream</code> 对象（如 <code>cin</code>）转换为 <code>bool</code> 值的函数。</p>\n<p>当 <code>cin</code> 出现在需要 <code>bool</code> 值的地方（例如 <code>while</code> 条件中）<code>cin</code>将被转换为<code>bool</code>值。读取成功返回 <code>true</code>，否则就返回 <code>false</code>。</p>\n<p>常见用法如下：</p>\n<ol>\n<li><p>每次读取一个字符，直到遇到EOF</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cin.<span class=\"built_in\">get</span>(ch);</span><br><span class=\"line\"><span class=\"keyword\">while</span>(cin)&#123;  <span class=\"comment\">// 单飘一个cin，用来测试是否到文件尾了，当遇到文件结束符EOF时，终止</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    cin.<span class=\"built_in\">get</span>(ch);  <span class=\"comment\">//如果读取没成功，会将失败标记置位</span></span><br><span class=\"line\">&#125;   </span><br></pre></td></tr></table></figure>\n\n<p>或者</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(cin.<span class=\"built_in\">get</span>(ch))&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>循环输入，处理输入，遇到换行符终止</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;<span class=\"keyword\">int</span>&gt; arr;</span><br><span class=\"line\"><span class=\"keyword\">int</span> num;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(cin&gt;&gt;num)&#123;</span><br><span class=\"line\">    arr.<span class=\"built_in\">push_back</span>(num);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(cin.<span class=\"built_in\">get</span>()==<span class=\"string\">&#x27;\\n&#x27;</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"2-cin-getline-、cin-get\"><a href=\"#2-cin-getline-、cin-get\" class=\"headerlink\" title=\"2. cin.getline()、cin.get()\"></a>2. cin.getline()、cin.get()</h2><h4 id=\"2-1-cin-getline\"><a href=\"#2-1-cin-getline\" class=\"headerlink\" title=\"2.1 cin.getline()\"></a>2.1 cin.getline()</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">istream&amp; <span class=\"title\">getline</span> <span class=\"params\">(<span class=\"keyword\">char</span>* s, streamsize n )</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>遇到换行符停止读入，<strong>不保存</strong>换行符，用空字符替代换行符，加到数组后面</p>\n<p>接受两个参数</p>\n<ol>\n<li><p>第一个是要接受读进来的字符串的字符数组的地址</p>\n</li>\n<li><p>第二个是要读取的字符数 <code>n</code></p>\n</li>\n</ol>\n<p>注意：<code>n</code> 不能超过字符数组的大小，且 <code>n</code> 已经计入了 <code>&#39;\\0&#39;</code>，也就是说有效允许读入字符数应该是 <code>n-1</code></p>\n<h4 id=\"2-2-cin-get\"><a href=\"#2-2-cin-get\" class=\"headerlink\" title=\"2.2 cin.get()\"></a>2.2 cin.get()</h4><p><code>cin.get()</code>有几种变体：</p>\n<ol>\n<li><p>接受的参数与<code>cin.getline()</code>一样，但是<strong>保留换行符在输入队列中</strong>（和<code>cin</code>一样）</p>\n</li>\n<li><p>不带任何参数</p>\n<p><code>cin.get();</code> 它可用来读取<strong>下一个字符</strong>（可以是换行符）</p>\n</li>\n<li><p>带一个char参数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cin.<span class=\"built_in\">get</span>(<span class=\"keyword\">char</span> &amp;_Ch)</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"3-string类成员函数getline\"><a href=\"#3-string类成员函数getline\" class=\"headerlink\" title=\"3. string类成员函数getline()\"></a>3. string类成员函数getline()</h2><p>读取一整行，直到遇到<strong>换行符</strong>（换行符也被读入，但是抛弃它，<strong>不存</strong>）</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string str;</span><br><span class=\"line\"><span class=\"built_in\">getline</span>(cin,str);</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<h2 id=\"1-cin\"><a href=\"#1-cin\" class=\"headerlink\" title=\"1. cin\"></a>1. cin</h2><p><code>cin</code>使用<strong>空白</strong>（空格、制表符和换行符）来确定字符串的<strong>结束位置</strong>，<code>cin</code>只能读取一个单词，读取到空格就结束了，然后将读到的字符串放到数组中，并在结尾添加空字符<code>&#39;\\0&#39;</code>。       </p>\n<p><code>cin</code>将换行符<strong>保留</strong>在输入队列中。</p>\n<h4 id=\"1-1-while-cin-用法\"><a href=\"#1-1-while-cin-用法\" class=\"headerlink\" title=\"1.1 while(cin)用法\"></a>1.1 while(cin)用法</h4><p><code>istream</code> 类提供了一个可以将 <code>istream</code> 对象（如 <code>cin</code>）转换为 <code>bool</code> 值的函数。</p>\n<p>当 <code>cin</code> 出现在需要 <code>bool</code> 值的地方（例如 <code>while</code> 条件中）<code>cin</code>将被转换为<code>bool</code>值。读取成功返回 <code>true</code>，否则就返回 <code>false</code>。</p>\n<p>常见用法如下：</p>\n<ol>\n<li><p>每次读取一个字符，直到遇到EOF</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cin.<span class=\"built_in\">get</span>(ch);</span><br><span class=\"line\"><span class=\"keyword\">while</span>(cin)&#123;  <span class=\"comment\">// 单飘一个cin，用来测试是否到文件尾了，当遇到文件结束符EOF时，终止</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    cin.<span class=\"built_in\">get</span>(ch);  <span class=\"comment\">//如果读取没成功，会将失败标记置位</span></span><br><span class=\"line\">&#125;   </span><br></pre></td></tr></table></figure>\n\n<p>或者</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(cin.<span class=\"built_in\">get</span>(ch))&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>循环输入，处理输入，遇到换行符终止</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;<span class=\"keyword\">int</span>&gt; arr;</span><br><span class=\"line\"><span class=\"keyword\">int</span> num;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(cin&gt;&gt;num)&#123;</span><br><span class=\"line\">    arr.<span class=\"built_in\">push_back</span>(num);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(cin.<span class=\"built_in\">get</span>()==<span class=\"string\">&#x27;\\n&#x27;</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"2-cin-getline-、cin-get\"><a href=\"#2-cin-getline-、cin-get\" class=\"headerlink\" title=\"2. cin.getline()、cin.get()\"></a>2. cin.getline()、cin.get()</h2><h4 id=\"2-1-cin-getline\"><a href=\"#2-1-cin-getline\" class=\"headerlink\" title=\"2.1 cin.getline()\"></a>2.1 cin.getline()</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">istream&amp; <span class=\"title\">getline</span> <span class=\"params\">(<span class=\"keyword\">char</span>* s, streamsize n )</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>遇到换行符停止读入，<strong>不保存</strong>换行符，用空字符替代换行符，加到数组后面</p>\n<p>接受两个参数</p>\n<ol>\n<li><p>第一个是要接受读进来的字符串的字符数组的地址</p>\n</li>\n<li><p>第二个是要读取的字符数 <code>n</code></p>\n</li>\n</ol>\n<p>注意：<code>n</code> 不能超过字符数组的大小，且 <code>n</code> 已经计入了 <code>&#39;\\0&#39;</code>，也就是说有效允许读入字符数应该是 <code>n-1</code></p>\n<h4 id=\"2-2-cin-get\"><a href=\"#2-2-cin-get\" class=\"headerlink\" title=\"2.2 cin.get()\"></a>2.2 cin.get()</h4><p><code>cin.get()</code>有几种变体：</p>\n<ol>\n<li><p>接受的参数与<code>cin.getline()</code>一样，但是<strong>保留换行符在输入队列中</strong>（和<code>cin</code>一样）</p>\n</li>\n<li><p>不带任何参数</p>\n<p><code>cin.get();</code> 它可用来读取<strong>下一个字符</strong>（可以是换行符）</p>\n</li>\n<li><p>带一个char参数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cin.<span class=\"built_in\">get</span>(<span class=\"keyword\">char</span> &amp;_Ch)</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"3-string类成员函数getline\"><a href=\"#3-string类成员函数getline\" class=\"headerlink\" title=\"3. string类成员函数getline()\"></a>3. string类成员函数getline()</h2><p>读取一整行，直到遇到<strong>换行符</strong>（换行符也被读入，但是抛弃它，<strong>不存</strong>）</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string str;</span><br><span class=\"line\"><span class=\"built_in\">getline</span>(cin,str);</span><br></pre></td></tr></table></figure>\n\n"},{"_content":"### 回调函数\n\n学习回调函数的基础是**函数指针**，你还要搞清楚回调函数的**应用场景**。\n\n[函数指针](./函数指针.md)\n\n一个回调函数的例子，不明白为什么会出错，先挖【坑】\n\n```c++\n#include <iostream>\nusing namespace std;\n\ntypedef void (*ff)(char);\n\nvoid ftest1(ff) {\n\tcout << \"ftest1 is called!\" << endl;\n\tchar y = 'a';\n\tff(y);\n}\n\nvoid ftest2(char a)\n{\n\tcout << \"ftest2 is called!\" << endl;\n}\n\nint main(int argc, char** argv) {\n\tftest1(ftest2);\n\treturn 0;\n}\n```\n\n\n","source":"_posts/C++基础/回调函数.md","raw":"### 回调函数\n\n学习回调函数的基础是**函数指针**，你还要搞清楚回调函数的**应用场景**。\n\n[函数指针](./函数指针.md)\n\n一个回调函数的例子，不明白为什么会出错，先挖【坑】\n\n```c++\n#include <iostream>\nusing namespace std;\n\ntypedef void (*ff)(char);\n\nvoid ftest1(ff) {\n\tcout << \"ftest1 is called!\" << endl;\n\tchar y = 'a';\n\tff(y);\n}\n\nvoid ftest2(char a)\n{\n\tcout << \"ftest2 is called!\" << endl;\n}\n\nint main(int argc, char** argv) {\n\tftest1(ftest2);\n\treturn 0;\n}\n```\n\n\n","slug":"C++基础/回调函数","published":1,"date":"2021-12-31T02:09:01.490Z","updated":"2021-12-03T12:29:04.046Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckxzva9fj00087cu31waf0w8z","content":"<h3 id=\"回调函数\"><a href=\"#回调函数\" class=\"headerlink\" title=\"回调函数\"></a>回调函数</h3><p>学习回调函数的基础是<strong>函数指针</strong>，你还要搞清楚回调函数的<strong>应用场景</strong>。</p>\n<p><a href=\"./%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88.md\">函数指针</a></p>\n<p>一个回调函数的例子，不明白为什么会出错，先挖【坑】</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">void</span> <span class=\"params\">(*ff)</span><span class=\"params\">(<span class=\"keyword\">char</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ftest1</span><span class=\"params\">(ff)</span> </span>&#123;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;ftest1 is called!&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> y = <span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">ff</span>(y);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ftest2</span><span class=\"params\">(<span class=\"keyword\">char</span> a)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;ftest2 is called!&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">ftest1</span>(ftest2);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<h3 id=\"回调函数\"><a href=\"#回调函数\" class=\"headerlink\" title=\"回调函数\"></a>回调函数</h3><p>学习回调函数的基础是<strong>函数指针</strong>，你还要搞清楚回调函数的<strong>应用场景</strong>。</p>\n<p><a href=\"./%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88.md\">函数指针</a></p>\n<p>一个回调函数的例子，不明白为什么会出错，先挖【坑】</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">void</span> <span class=\"params\">(*ff)</span><span class=\"params\">(<span class=\"keyword\">char</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ftest1</span><span class=\"params\">(ff)</span> </span>&#123;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;ftest1 is called!&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> y = <span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">ff</span>(y);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ftest2</span><span class=\"params\">(<span class=\"keyword\">char</span> a)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;ftest2 is called!&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">ftest1</span>(ftest2);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n"},{"_content":"### 三种智能指针\n\n`shared_ptr`允许多个指针指向同一个对象\n\n`unique_ptr`独占所指向的对象\n\n`weak_ptr`是一种弱引用\n\n这三种类型都定义在`memory`头文件\n\n类似于`vector`，智能指针也是模板，需要在**尖括号**中提供“指针可以指向的类型”信息\n\n```cpp\nshared_ptr<string> p1;\nshared_ptr<list<int>> p2;\n```\n\n默认初始化的智能指针中保存着一个空指针，解引用一个智能指针返回它所指向的对象\n\n```cpp\nif(p1 && p1->empty())   // 判断 p1 是不是空（指向一个空指针），如果 p1 不为空，则它指向一个 string，调用 string 的 empty 函数判断这个 string 是不是个空字符串\n    *p1 = \"hi\";   // 如果 p1 指向一个空字符串，则解引用 p1，将一个新值赋予 p1\n```\n\n`shared_ptr`和`unique_ptr`都支持的操作（表12.1）：\n\n![image-20211221163543360](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211221163543360.png)\n\n`shared_ptr`独有的操作（表12.2）：\n\n![image-20211221163802706](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211221163802706.png)\n\n### `make_shared`函数\n\n此函数在动态内存中分配一个对象并初始化它，<u>返回指向此对象的`shared_ptr`</u>，`make_shared`同样定义在`memory`头文件中\n\n```cpp\nshared_ptr<int> p3 = make_shared<int>(42);   // 指向一个值为 42 的 int 的 shared_ptr\nshared_ptr<string> p4 = make_shared<string>(10, '9');  // p4 指向一个值为\"999999999\"的string\nshared_ptr<int> p5 = make_shared<int>(); \t\t\t   // p5 指向一个值初始化的int\n```\n\n类似于顺序容器的`emplace`，`make_shared`用它的参数来**构造**给定类型的对象，例如，调用`make_shared<string>`时传递的参数必须与`string`的某个构造函数相匹配，如果不传递参数，就会**值初始化**\n\n利用`auto`：\n\n```cpp\nauto p6 = make_shared<vector<string>>();\t\t// p6指向一个动态分配的空vector<string>\n```\n\n### 和`new`结合使用\n\n可以用 `new` 返回的指针来初始化智能指针\n\n```cpp\nshared_ptr<int> p2(new int(42));   \t\t\t\t// p2 指向一个值为 42 的 int\n```\n\n 接受指针参数的智能指针的构造函数是 explicit 的，因此，**不能**将一个**内置指针隐式转换**为一个智能指针，必须使用**直接初始化**形式来初始化一个智能指针\n\n```cpp\nshared_ptr<int> p1 = new int(1024); \t\t\t// 错误，无法隐式转换，必须使用直接初始化的形式\nshared_ptr<int> p2(new int(1024));\t\t\t\t// 正确，直接初始化\n```\n\n```cpp\nshared_ptr<int> clone(int p) {\n    return new int(p);\t\t\t\t\t\t\t// 错误，不能隐式转换\n    return shared_ptr<int>(new int(p));\t\t\t// 正确\n}\n```\n\n### shared_ptr的引用计数\n\n每个 `shared_ptr` 都有一个关联的计数器，无论何时我们**拷贝**一个 `shared_ptr`，计数器都会递增。\n\n```cpp\nauto p = make_shared<int>(42); \t\t\t\t// p 指向的对象只有 p 一个引用者\nauto q(p);\t\t\t\t\t\t\t\t\t// p 和 q 指向相同的对象，此对象有两个引用者\n```\n\n这三种情况都会使计数器**递增**：\n\n1. 用一个 `shared_ptr` 初始化另一个 `shared_ptr`\n2. 将它作为参数传递给一个函数\n3. 作为函数的返回值\n\n当我们给 `shared_ptr` 赋予一个新值，或是 `shared_ptr` 被销毁，计数器就会**递减**\n\n一旦一个 shared_ptr 的计数器变为 0，它就会**自动释放**自己所管理的对象\n\n```cpp\nauto r = make_shared<int>(42);  \t\t// r 指向的 int 只有一个引用者\nr = q; \t\t\t\t\t\t\t\t\t// 递减 r 原来指向的对象的引用计数，r 原来所指向的对象已经没有引用者，会自动释放\n\t\t\t\t\t\t\t\t\t\t// 递增 q 指向的对象的引用计数\n```\n\nshared_ptr 常用成员函数：\n\n- use_count()\n- reset()\n- release()\n\n### weak_ptr\n\nweak_ptr 用来解决 shared_ptr 相互引用时的死锁问题，如果两个 shared_ptr 相互引用，那么这两个指针的引用计数永远不可能下降为 0，资源永远不会释放\n\nweak_ptr 是对对象的一种弱引用，不会增加对象的引用计数\n\n死锁举例：\n\n```cpp\nclass B;\nclass A\n{\npublic:\n    shared_ptr<B> pb_;\n    ~A()\n    {\n        cout<<\"A delete\\n\";\n    }\n};\nclass B\n{\npublic:\n    shared_ptr<A> pa_;\n    ~B()\n    {\n        cout<<\"B delete\\n\";\n    }\n};\n \nvoid fun()\n{\n    shared_ptr<B> pb(new B());    // 指向 B 的智能指针\n    shared_ptr<A> pa(new A());\t  // 指向 A 的智能指针\n    pb->pa_ = pa;\n    pa->pb_ = pb;\n    cout<<pb.use_count()<<endl;\n    cout<<pa.use_count()<<endl;\n}\n \nint main()\n{\n    fun();\n    return 0;\n}\n```\n\n![image-20211225170641418](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211225170641418.png)\n\n`fun` 函数中 `pa`，`pb` 之间互相引用，两个资源的引用计数为 `2`，当要跳出函数时，智能指针 `pa`，`pb` 析构时两个资源引用计数会减一，但是两者引用计数还是为 `1`，导致跳出函数时资源没有被释放（A，B的析构函数没有被调用），如果把其中一个改为 `weak_ptr` 就可以了，我们把类 A 里面的 `shared_ptr<B> pb_ ;` 改为 `weak_ptr<B> pb_;` \n\n这样的话，资源 B 的引用开始就只有 1，当 `pb` 析构时，B 的计数变为 0，B 得到释放，B 释放的同时也会使 A 的计数减一，同时 pa 析构时使 A 的计数减一，那么 A 的计数为0，A 得到释放。\n\n### 简单实现一个 `shared_ptr`\n\n","source":"_posts/C++基础/智能指针.md","raw":"### 三种智能指针\n\n`shared_ptr`允许多个指针指向同一个对象\n\n`unique_ptr`独占所指向的对象\n\n`weak_ptr`是一种弱引用\n\n这三种类型都定义在`memory`头文件\n\n类似于`vector`，智能指针也是模板，需要在**尖括号**中提供“指针可以指向的类型”信息\n\n```cpp\nshared_ptr<string> p1;\nshared_ptr<list<int>> p2;\n```\n\n默认初始化的智能指针中保存着一个空指针，解引用一个智能指针返回它所指向的对象\n\n```cpp\nif(p1 && p1->empty())   // 判断 p1 是不是空（指向一个空指针），如果 p1 不为空，则它指向一个 string，调用 string 的 empty 函数判断这个 string 是不是个空字符串\n    *p1 = \"hi\";   // 如果 p1 指向一个空字符串，则解引用 p1，将一个新值赋予 p1\n```\n\n`shared_ptr`和`unique_ptr`都支持的操作（表12.1）：\n\n![image-20211221163543360](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211221163543360.png)\n\n`shared_ptr`独有的操作（表12.2）：\n\n![image-20211221163802706](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211221163802706.png)\n\n### `make_shared`函数\n\n此函数在动态内存中分配一个对象并初始化它，<u>返回指向此对象的`shared_ptr`</u>，`make_shared`同样定义在`memory`头文件中\n\n```cpp\nshared_ptr<int> p3 = make_shared<int>(42);   // 指向一个值为 42 的 int 的 shared_ptr\nshared_ptr<string> p4 = make_shared<string>(10, '9');  // p4 指向一个值为\"999999999\"的string\nshared_ptr<int> p5 = make_shared<int>(); \t\t\t   // p5 指向一个值初始化的int\n```\n\n类似于顺序容器的`emplace`，`make_shared`用它的参数来**构造**给定类型的对象，例如，调用`make_shared<string>`时传递的参数必须与`string`的某个构造函数相匹配，如果不传递参数，就会**值初始化**\n\n利用`auto`：\n\n```cpp\nauto p6 = make_shared<vector<string>>();\t\t// p6指向一个动态分配的空vector<string>\n```\n\n### 和`new`结合使用\n\n可以用 `new` 返回的指针来初始化智能指针\n\n```cpp\nshared_ptr<int> p2(new int(42));   \t\t\t\t// p2 指向一个值为 42 的 int\n```\n\n 接受指针参数的智能指针的构造函数是 explicit 的，因此，**不能**将一个**内置指针隐式转换**为一个智能指针，必须使用**直接初始化**形式来初始化一个智能指针\n\n```cpp\nshared_ptr<int> p1 = new int(1024); \t\t\t// 错误，无法隐式转换，必须使用直接初始化的形式\nshared_ptr<int> p2(new int(1024));\t\t\t\t// 正确，直接初始化\n```\n\n```cpp\nshared_ptr<int> clone(int p) {\n    return new int(p);\t\t\t\t\t\t\t// 错误，不能隐式转换\n    return shared_ptr<int>(new int(p));\t\t\t// 正确\n}\n```\n\n### shared_ptr的引用计数\n\n每个 `shared_ptr` 都有一个关联的计数器，无论何时我们**拷贝**一个 `shared_ptr`，计数器都会递增。\n\n```cpp\nauto p = make_shared<int>(42); \t\t\t\t// p 指向的对象只有 p 一个引用者\nauto q(p);\t\t\t\t\t\t\t\t\t// p 和 q 指向相同的对象，此对象有两个引用者\n```\n\n这三种情况都会使计数器**递增**：\n\n1. 用一个 `shared_ptr` 初始化另一个 `shared_ptr`\n2. 将它作为参数传递给一个函数\n3. 作为函数的返回值\n\n当我们给 `shared_ptr` 赋予一个新值，或是 `shared_ptr` 被销毁，计数器就会**递减**\n\n一旦一个 shared_ptr 的计数器变为 0，它就会**自动释放**自己所管理的对象\n\n```cpp\nauto r = make_shared<int>(42);  \t\t// r 指向的 int 只有一个引用者\nr = q; \t\t\t\t\t\t\t\t\t// 递减 r 原来指向的对象的引用计数，r 原来所指向的对象已经没有引用者，会自动释放\n\t\t\t\t\t\t\t\t\t\t// 递增 q 指向的对象的引用计数\n```\n\nshared_ptr 常用成员函数：\n\n- use_count()\n- reset()\n- release()\n\n### weak_ptr\n\nweak_ptr 用来解决 shared_ptr 相互引用时的死锁问题，如果两个 shared_ptr 相互引用，那么这两个指针的引用计数永远不可能下降为 0，资源永远不会释放\n\nweak_ptr 是对对象的一种弱引用，不会增加对象的引用计数\n\n死锁举例：\n\n```cpp\nclass B;\nclass A\n{\npublic:\n    shared_ptr<B> pb_;\n    ~A()\n    {\n        cout<<\"A delete\\n\";\n    }\n};\nclass B\n{\npublic:\n    shared_ptr<A> pa_;\n    ~B()\n    {\n        cout<<\"B delete\\n\";\n    }\n};\n \nvoid fun()\n{\n    shared_ptr<B> pb(new B());    // 指向 B 的智能指针\n    shared_ptr<A> pa(new A());\t  // 指向 A 的智能指针\n    pb->pa_ = pa;\n    pa->pb_ = pb;\n    cout<<pb.use_count()<<endl;\n    cout<<pa.use_count()<<endl;\n}\n \nint main()\n{\n    fun();\n    return 0;\n}\n```\n\n![image-20211225170641418](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211225170641418.png)\n\n`fun` 函数中 `pa`，`pb` 之间互相引用，两个资源的引用计数为 `2`，当要跳出函数时，智能指针 `pa`，`pb` 析构时两个资源引用计数会减一，但是两者引用计数还是为 `1`，导致跳出函数时资源没有被释放（A，B的析构函数没有被调用），如果把其中一个改为 `weak_ptr` 就可以了，我们把类 A 里面的 `shared_ptr<B> pb_ ;` 改为 `weak_ptr<B> pb_;` \n\n这样的话，资源 B 的引用开始就只有 1，当 `pb` 析构时，B 的计数变为 0，B 得到释放，B 释放的同时也会使 A 的计数减一，同时 pa 析构时使 A 的计数减一，那么 A 的计数为0，A 得到释放。\n\n### 简单实现一个 `shared_ptr`\n\n","slug":"C++基础/智能指针","published":1,"date":"2021-12-31T02:09:01.533Z","updated":"2021-12-30T10:09:34.895Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckxzva9fn000b7cu30pel3s6e","content":"<h3 id=\"三种智能指针\"><a href=\"#三种智能指针\" class=\"headerlink\" title=\"三种智能指针\"></a>三种智能指针</h3><p><code>shared_ptr</code>允许多个指针指向同一个对象</p>\n<p><code>unique_ptr</code>独占所指向的对象</p>\n<p><code>weak_ptr</code>是一种弱引用</p>\n<p>这三种类型都定义在<code>memory</code>头文件</p>\n<p>类似于<code>vector</code>，智能指针也是模板，需要在<strong>尖括号</strong>中提供“指针可以指向的类型”信息</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shared_ptr&lt;string&gt; p1;</span><br><span class=\"line\">shared_ptr&lt;list&lt;<span class=\"keyword\">int</span>&gt;&gt; p2;</span><br></pre></td></tr></table></figure>\n\n<p>默认初始化的智能指针中保存着一个空指针，解引用一个智能指针返回它所指向的对象</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(p1 &amp;&amp; p1-&gt;<span class=\"built_in\">empty</span>())   <span class=\"comment\">// 判断 p1 是不是空（指向一个空指针），如果 p1 不为空，则它指向一个 string，调用 string 的 empty 函数判断这个 string 是不是个空字符串</span></span><br><span class=\"line\">    *p1 = <span class=\"string\">&quot;hi&quot;</span>;   <span class=\"comment\">// 如果 p1 指向一个空字符串，则解引用 p1，将一个新值赋予 p1</span></span><br></pre></td></tr></table></figure>\n\n<p><code>shared_ptr</code>和<code>unique_ptr</code>都支持的操作（表12.1）：</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211221163543360.png\" alt=\"image-20211221163543360\"></p>\n<p><code>shared_ptr</code>独有的操作（表12.2）：</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211221163802706.png\" alt=\"image-20211221163802706\"></p>\n<h3 id=\"make-shared函数\"><a href=\"#make-shared函数\" class=\"headerlink\" title=\"make_shared函数\"></a><code>make_shared</code>函数</h3><p>此函数在动态内存中分配一个对象并初始化它，<u>返回指向此对象的<code>shared_ptr</code></u>，<code>make_shared</code>同样定义在<code>memory</code>头文件中</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shared_ptr&lt;<span class=\"keyword\">int</span>&gt; p3 = make_shared&lt;<span class=\"keyword\">int</span>&gt;(<span class=\"number\">42</span>);   <span class=\"comment\">// 指向一个值为 42 的 int 的 shared_ptr</span></span><br><span class=\"line\">shared_ptr&lt;string&gt; p4 = make_shared&lt;string&gt;(<span class=\"number\">10</span>, <span class=\"string\">&#x27;9&#x27;</span>);  <span class=\"comment\">// p4 指向一个值为&quot;999999999&quot;的string</span></span><br><span class=\"line\">shared_ptr&lt;<span class=\"keyword\">int</span>&gt; p5 = make_shared&lt;<span class=\"keyword\">int</span>&gt;(); \t\t\t   <span class=\"comment\">// p5 指向一个值初始化的int</span></span><br></pre></td></tr></table></figure>\n\n<p>类似于顺序容器的<code>emplace</code>，<code>make_shared</code>用它的参数来<strong>构造</strong>给定类型的对象，例如，调用<code>make_shared&lt;string&gt;</code>时传递的参数必须与<code>string</code>的某个构造函数相匹配，如果不传递参数，就会<strong>值初始化</strong></p>\n<p>利用<code>auto</code>：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> p6 = make_shared&lt;vector&lt;string&gt;&gt;();\t\t<span class=\"comment\">// p6指向一个动态分配的空vector&lt;string&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"和new结合使用\"><a href=\"#和new结合使用\" class=\"headerlink\" title=\"和new结合使用\"></a>和<code>new</code>结合使用</h3><p>可以用 <code>new</code> 返回的指针来初始化智能指针</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">shared_ptr&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">p2</span><span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"number\">42</span>))</span></span>;   \t\t\t\t<span class=\"comment\">// p2 指向一个值为 42 的 int</span></span><br></pre></td></tr></table></figure>\n\n<p> 接受指针参数的智能指针的构造函数是 explicit 的，因此，<strong>不能</strong>将一个<strong>内置指针隐式转换</strong>为一个智能指针，必须使用<strong>直接初始化</strong>形式来初始化一个智能指针</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shared_ptr&lt;<span class=\"keyword\">int</span>&gt; p1 = <span class=\"keyword\">new</span> <span class=\"built_in\"><span class=\"keyword\">int</span></span>(<span class=\"number\">1024</span>); \t\t\t<span class=\"comment\">// 错误，无法隐式转换，必须使用直接初始化的形式</span></span><br><span class=\"line\"><span class=\"function\">shared_ptr&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">p2</span><span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"number\">1024</span>))</span></span>;\t\t\t\t<span class=\"comment\">// 正确，直接初始化</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">shared_ptr&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">clone</span><span class=\"params\">(<span class=\"keyword\">int</span> p)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\"><span class=\"keyword\">int</span></span>(p);\t\t\t\t\t\t\t<span class=\"comment\">// 错误，不能隐式转换</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> shared_ptr&lt;<span class=\"keyword\">int</span>&gt;(<span class=\"keyword\">new</span> <span class=\"built_in\"><span class=\"keyword\">int</span></span>(p));\t\t\t<span class=\"comment\">// 正确</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"shared-ptr的引用计数\"><a href=\"#shared-ptr的引用计数\" class=\"headerlink\" title=\"shared_ptr的引用计数\"></a>shared_ptr的引用计数</h3><p>每个 <code>shared_ptr</code> 都有一个关联的计数器，无论何时我们<strong>拷贝</strong>一个 <code>shared_ptr</code>，计数器都会递增。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> p = make_shared&lt;<span class=\"keyword\">int</span>&gt;(<span class=\"number\">42</span>); \t\t\t\t<span class=\"comment\">// p 指向的对象只有 p 一个引用者</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">auto</span> <span class=\"title\">q</span><span class=\"params\">(p)</span></span>;\t\t\t\t\t\t\t\t\t<span class=\"comment\">// p 和 q 指向相同的对象，此对象有两个引用者</span></span><br></pre></td></tr></table></figure>\n\n<p>这三种情况都会使计数器<strong>递增</strong>：</p>\n<ol>\n<li>用一个 <code>shared_ptr</code> 初始化另一个 <code>shared_ptr</code></li>\n<li>将它作为参数传递给一个函数</li>\n<li>作为函数的返回值</li>\n</ol>\n<p>当我们给 <code>shared_ptr</code> 赋予一个新值，或是 <code>shared_ptr</code> 被销毁，计数器就会<strong>递减</strong></p>\n<p>一旦一个 shared_ptr 的计数器变为 0，它就会<strong>自动释放</strong>自己所管理的对象</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> r = make_shared&lt;<span class=\"keyword\">int</span>&gt;(<span class=\"number\">42</span>);  \t\t<span class=\"comment\">// r 指向的 int 只有一个引用者</span></span><br><span class=\"line\">r = q; \t\t\t\t\t\t\t\t\t<span class=\"comment\">// 递减 r 原来指向的对象的引用计数，r 原来所指向的对象已经没有引用者，会自动释放</span></span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">// 递增 q 指向的对象的引用计数</span></span><br></pre></td></tr></table></figure>\n\n<p>shared_ptr 常用成员函数：</p>\n<ul>\n<li>use_count()</li>\n<li>reset()</li>\n<li>release()</li>\n</ul>\n<h3 id=\"weak-ptr\"><a href=\"#weak-ptr\" class=\"headerlink\" title=\"weak_ptr\"></a>weak_ptr</h3><p>weak_ptr 用来解决 shared_ptr 相互引用时的死锁问题，如果两个 shared_ptr 相互引用，那么这两个指针的引用计数永远不可能下降为 0，资源永远不会释放</p>\n<p>weak_ptr 是对对象的一种弱引用，不会增加对象的引用计数</p>\n<p>死锁举例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    shared_ptr&lt;B&gt; pb_;</span><br><span class=\"line\">    ~<span class=\"built_in\">A</span>()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;A delete\\n&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    shared_ptr&lt;A&gt; pa_;</span><br><span class=\"line\">    ~<span class=\"built_in\">B</span>()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;B delete\\n&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fun</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">shared_ptr&lt;B&gt; <span class=\"title\">pb</span><span class=\"params\">(<span class=\"keyword\">new</span> B())</span></span>;    <span class=\"comment\">// 指向 B 的智能指针</span></span><br><span class=\"line\">    <span class=\"function\">shared_ptr&lt;A&gt; <span class=\"title\">pa</span><span class=\"params\">(<span class=\"keyword\">new</span> A())</span></span>;\t  <span class=\"comment\">// 指向 A 的智能指针</span></span><br><span class=\"line\">    pb-&gt;pa_ = pa;</span><br><span class=\"line\">    pa-&gt;pb_ = pb;</span><br><span class=\"line\">    cout&lt;&lt;pb.<span class=\"built_in\">use_count</span>()&lt;&lt;endl;</span><br><span class=\"line\">    cout&lt;&lt;pa.<span class=\"built_in\">use_count</span>()&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">fun</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211225170641418.png\" alt=\"image-20211225170641418\"></p>\n<p><code>fun</code> 函数中 <code>pa</code>，<code>pb</code> 之间互相引用，两个资源的引用计数为 <code>2</code>，当要跳出函数时，智能指针 <code>pa</code>，<code>pb</code> 析构时两个资源引用计数会减一，但是两者引用计数还是为 <code>1</code>，导致跳出函数时资源没有被释放（A，B的析构函数没有被调用），如果把其中一个改为 <code>weak_ptr</code> 就可以了，我们把类 A 里面的 <code>shared_ptr&lt;B&gt; pb_ ;</code> 改为 <code>weak_ptr&lt;B&gt; pb_;</code> </p>\n<p>这样的话，资源 B 的引用开始就只有 1，当 <code>pb</code> 析构时，B 的计数变为 0，B 得到释放，B 释放的同时也会使 A 的计数减一，同时 pa 析构时使 A 的计数减一，那么 A 的计数为0，A 得到释放。</p>\n<h3 id=\"简单实现一个-shared-ptr\"><a href=\"#简单实现一个-shared-ptr\" class=\"headerlink\" title=\"简单实现一个 shared_ptr\"></a>简单实现一个 <code>shared_ptr</code></h3>","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<h3 id=\"三种智能指针\"><a href=\"#三种智能指针\" class=\"headerlink\" title=\"三种智能指针\"></a>三种智能指针</h3><p><code>shared_ptr</code>允许多个指针指向同一个对象</p>\n<p><code>unique_ptr</code>独占所指向的对象</p>\n<p><code>weak_ptr</code>是一种弱引用</p>\n<p>这三种类型都定义在<code>memory</code>头文件</p>\n<p>类似于<code>vector</code>，智能指针也是模板，需要在<strong>尖括号</strong>中提供“指针可以指向的类型”信息</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shared_ptr&lt;string&gt; p1;</span><br><span class=\"line\">shared_ptr&lt;list&lt;<span class=\"keyword\">int</span>&gt;&gt; p2;</span><br></pre></td></tr></table></figure>\n\n<p>默认初始化的智能指针中保存着一个空指针，解引用一个智能指针返回它所指向的对象</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(p1 &amp;&amp; p1-&gt;<span class=\"built_in\">empty</span>())   <span class=\"comment\">// 判断 p1 是不是空（指向一个空指针），如果 p1 不为空，则它指向一个 string，调用 string 的 empty 函数判断这个 string 是不是个空字符串</span></span><br><span class=\"line\">    *p1 = <span class=\"string\">&quot;hi&quot;</span>;   <span class=\"comment\">// 如果 p1 指向一个空字符串，则解引用 p1，将一个新值赋予 p1</span></span><br></pre></td></tr></table></figure>\n\n<p><code>shared_ptr</code>和<code>unique_ptr</code>都支持的操作（表12.1）：</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211221163543360.png\" alt=\"image-20211221163543360\"></p>\n<p><code>shared_ptr</code>独有的操作（表12.2）：</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211221163802706.png\" alt=\"image-20211221163802706\"></p>\n<h3 id=\"make-shared函数\"><a href=\"#make-shared函数\" class=\"headerlink\" title=\"make_shared函数\"></a><code>make_shared</code>函数</h3><p>此函数在动态内存中分配一个对象并初始化它，<u>返回指向此对象的<code>shared_ptr</code></u>，<code>make_shared</code>同样定义在<code>memory</code>头文件中</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shared_ptr&lt;<span class=\"keyword\">int</span>&gt; p3 = make_shared&lt;<span class=\"keyword\">int</span>&gt;(<span class=\"number\">42</span>);   <span class=\"comment\">// 指向一个值为 42 的 int 的 shared_ptr</span></span><br><span class=\"line\">shared_ptr&lt;string&gt; p4 = make_shared&lt;string&gt;(<span class=\"number\">10</span>, <span class=\"string\">&#x27;9&#x27;</span>);  <span class=\"comment\">// p4 指向一个值为&quot;999999999&quot;的string</span></span><br><span class=\"line\">shared_ptr&lt;<span class=\"keyword\">int</span>&gt; p5 = make_shared&lt;<span class=\"keyword\">int</span>&gt;(); \t\t\t   <span class=\"comment\">// p5 指向一个值初始化的int</span></span><br></pre></td></tr></table></figure>\n\n<p>类似于顺序容器的<code>emplace</code>，<code>make_shared</code>用它的参数来<strong>构造</strong>给定类型的对象，例如，调用<code>make_shared&lt;string&gt;</code>时传递的参数必须与<code>string</code>的某个构造函数相匹配，如果不传递参数，就会<strong>值初始化</strong></p>\n<p>利用<code>auto</code>：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> p6 = make_shared&lt;vector&lt;string&gt;&gt;();\t\t<span class=\"comment\">// p6指向一个动态分配的空vector&lt;string&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"和new结合使用\"><a href=\"#和new结合使用\" class=\"headerlink\" title=\"和new结合使用\"></a>和<code>new</code>结合使用</h3><p>可以用 <code>new</code> 返回的指针来初始化智能指针</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">shared_ptr&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">p2</span><span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"number\">42</span>))</span></span>;   \t\t\t\t<span class=\"comment\">// p2 指向一个值为 42 的 int</span></span><br></pre></td></tr></table></figure>\n\n<p> 接受指针参数的智能指针的构造函数是 explicit 的，因此，<strong>不能</strong>将一个<strong>内置指针隐式转换</strong>为一个智能指针，必须使用<strong>直接初始化</strong>形式来初始化一个智能指针</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shared_ptr&lt;<span class=\"keyword\">int</span>&gt; p1 = <span class=\"keyword\">new</span> <span class=\"built_in\"><span class=\"keyword\">int</span></span>(<span class=\"number\">1024</span>); \t\t\t<span class=\"comment\">// 错误，无法隐式转换，必须使用直接初始化的形式</span></span><br><span class=\"line\"><span class=\"function\">shared_ptr&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">p2</span><span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"number\">1024</span>))</span></span>;\t\t\t\t<span class=\"comment\">// 正确，直接初始化</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">shared_ptr&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">clone</span><span class=\"params\">(<span class=\"keyword\">int</span> p)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\"><span class=\"keyword\">int</span></span>(p);\t\t\t\t\t\t\t<span class=\"comment\">// 错误，不能隐式转换</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> shared_ptr&lt;<span class=\"keyword\">int</span>&gt;(<span class=\"keyword\">new</span> <span class=\"built_in\"><span class=\"keyword\">int</span></span>(p));\t\t\t<span class=\"comment\">// 正确</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"shared-ptr的引用计数\"><a href=\"#shared-ptr的引用计数\" class=\"headerlink\" title=\"shared_ptr的引用计数\"></a>shared_ptr的引用计数</h3><p>每个 <code>shared_ptr</code> 都有一个关联的计数器，无论何时我们<strong>拷贝</strong>一个 <code>shared_ptr</code>，计数器都会递增。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> p = make_shared&lt;<span class=\"keyword\">int</span>&gt;(<span class=\"number\">42</span>); \t\t\t\t<span class=\"comment\">// p 指向的对象只有 p 一个引用者</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">auto</span> <span class=\"title\">q</span><span class=\"params\">(p)</span></span>;\t\t\t\t\t\t\t\t\t<span class=\"comment\">// p 和 q 指向相同的对象，此对象有两个引用者</span></span><br></pre></td></tr></table></figure>\n\n<p>这三种情况都会使计数器<strong>递增</strong>：</p>\n<ol>\n<li>用一个 <code>shared_ptr</code> 初始化另一个 <code>shared_ptr</code></li>\n<li>将它作为参数传递给一个函数</li>\n<li>作为函数的返回值</li>\n</ol>\n<p>当我们给 <code>shared_ptr</code> 赋予一个新值，或是 <code>shared_ptr</code> 被销毁，计数器就会<strong>递减</strong></p>\n<p>一旦一个 shared_ptr 的计数器变为 0，它就会<strong>自动释放</strong>自己所管理的对象</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> r = make_shared&lt;<span class=\"keyword\">int</span>&gt;(<span class=\"number\">42</span>);  \t\t<span class=\"comment\">// r 指向的 int 只有一个引用者</span></span><br><span class=\"line\">r = q; \t\t\t\t\t\t\t\t\t<span class=\"comment\">// 递减 r 原来指向的对象的引用计数，r 原来所指向的对象已经没有引用者，会自动释放</span></span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">// 递增 q 指向的对象的引用计数</span></span><br></pre></td></tr></table></figure>\n\n<p>shared_ptr 常用成员函数：</p>\n<ul>\n<li>use_count()</li>\n<li>reset()</li>\n<li>release()</li>\n</ul>\n<h3 id=\"weak-ptr\"><a href=\"#weak-ptr\" class=\"headerlink\" title=\"weak_ptr\"></a>weak_ptr</h3><p>weak_ptr 用来解决 shared_ptr 相互引用时的死锁问题，如果两个 shared_ptr 相互引用，那么这两个指针的引用计数永远不可能下降为 0，资源永远不会释放</p>\n<p>weak_ptr 是对对象的一种弱引用，不会增加对象的引用计数</p>\n<p>死锁举例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    shared_ptr&lt;B&gt; pb_;</span><br><span class=\"line\">    ~<span class=\"built_in\">A</span>()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;A delete\\n&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    shared_ptr&lt;A&gt; pa_;</span><br><span class=\"line\">    ~<span class=\"built_in\">B</span>()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;B delete\\n&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fun</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">shared_ptr&lt;B&gt; <span class=\"title\">pb</span><span class=\"params\">(<span class=\"keyword\">new</span> B())</span></span>;    <span class=\"comment\">// 指向 B 的智能指针</span></span><br><span class=\"line\">    <span class=\"function\">shared_ptr&lt;A&gt; <span class=\"title\">pa</span><span class=\"params\">(<span class=\"keyword\">new</span> A())</span></span>;\t  <span class=\"comment\">// 指向 A 的智能指针</span></span><br><span class=\"line\">    pb-&gt;pa_ = pa;</span><br><span class=\"line\">    pa-&gt;pb_ = pb;</span><br><span class=\"line\">    cout&lt;&lt;pb.<span class=\"built_in\">use_count</span>()&lt;&lt;endl;</span><br><span class=\"line\">    cout&lt;&lt;pa.<span class=\"built_in\">use_count</span>()&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">fun</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211225170641418.png\" alt=\"image-20211225170641418\"></p>\n<p><code>fun</code> 函数中 <code>pa</code>，<code>pb</code> 之间互相引用，两个资源的引用计数为 <code>2</code>，当要跳出函数时，智能指针 <code>pa</code>，<code>pb</code> 析构时两个资源引用计数会减一，但是两者引用计数还是为 <code>1</code>，导致跳出函数时资源没有被释放（A，B的析构函数没有被调用），如果把其中一个改为 <code>weak_ptr</code> 就可以了，我们把类 A 里面的 <code>shared_ptr&lt;B&gt; pb_ ;</code> 改为 <code>weak_ptr&lt;B&gt; pb_;</code> </p>\n<p>这样的话，资源 B 的引用开始就只有 1，当 <code>pb</code> 析构时，B 的计数变为 0，B 得到释放，B 释放的同时也会使 A 的计数减一，同时 pa 析构时使 A 的计数减一，那么 A 的计数为0，A 得到释放。</p>\n<h3 id=\"简单实现一个-shared-ptr\"><a href=\"#简单实现一个-shared-ptr\" class=\"headerlink\" title=\"简单实现一个 shared_ptr\"></a>简单实现一个 <code>shared_ptr</code></h3>"},{"title":"【专题】定语从句","date":"2021-12-19T16:00:00.000Z","draft":false,"_content":"\n\n\n什么是定语从句？\n\n用一句话作定语，通常用来修饰名词、代词，被修饰的词称为`先行词`\n\n### 一、限制性定语从句\n\n引导词**代替先行词**，在定语从句**充当成分**\n\n> 对比宾语从句中，`that`不充当任何成分，可以省略\n\n#### 1. 关系代词：\n\n- 指代**人**：`who`（在从句中充当主语、宾语）、`whom`（充当宾语）\n\n  The man `who(that) robbed him` has been arrested.\n\n  The girl `whom I saw` told me to come back today.\n\n  The friend `with whom I was traveling` spoke French.\n\n- 指代**物**：`which`（主、宾）\n\n  The car `which (that) I hired` broke down.\n\n  I don't like the novel `which you are reading`.\n\n- 指代**人或物**：`that`（主、宾），`whose`（定语，意思是`谁的`）\n\n  I like the girl `whose eyes are very big`.\n\n#### 2. 关系副词：\n\n- `when`（时间状语）：指代**时间**\n\n  At the time `when` I saw him, he was quite strong.\n\n  I will never forget the day `when (on which)` I came to Beijing.\n\n- where`（地点状语）：表示地点`\n\n  This is the village `where` I was born.\n\n  The police searched the house `where (in which)` he lived.\n\n- `why`（原因状语）：`why`的先行词只能是`reason`\n\n  I don't know the reason `why (for which)` he is angry.\n\n### 3. 省略\n\n- 在**限制性定语从句**中，当关系代词在从句中作**宾语**时，一般都可以**省略**\n\n  Have you got everything (`that`) you need?\n\n  That's the only thing (`that`) we can do now.\n\n  You can take any room (`that`) you like.\n\n- **口语**中，在从句作**主语**也可以**省略**\n\n  There's a strange man (`that`) lives in that small village.\n\n  There's something (`that`) keeps worrying me.\n\n#### 4. 有些表示时间的定语从句并不由when引导\n\nThis was the first `time` I had serious trouble with my boss.\n\nEvery `time` the telephone rings, he gets nervous.\n\n#### 5. way后也可跟定语从句，不需要关系代词或副词\n\nI didn't like the way he eyed me. 【应该是方式状语？】\n\n### 二、非限制性定语从句\n\n**非限制性定语从句**对所修饰的词没有限制词义的作用，而只是补充说明，通常都有逗号，译成中文时，多翻译为并列句\n\n限制性定语从句拿掉以后，句子意思常发生变化。而**非限制性定语**从句拿掉以后，对剩下部分没有太大影响\n\n> 注意非限制性定语从句中**不能**使用**关系代词 that** 和**关系副词 why**，也**不能**省略任何关系副词\n\nPeter, `who` had been driving all day, suggested stopping at the next town.\n\nPaul, `whom` everyone suspected, turned out to be innocent.\n\nThe 9:30 train, `which` is usually very punctual, was late today.\n\nSunday is a holiday, `when` people do not go to work.\n\n#### 非限制性定语从句中，which 和 whom 和 of 或其他介词连用\n\nThe buses, `most of which` were already full, were surrounded by an angry crowd.\n\nShe had eight children, `three of whom` lived to grow up. ( three of whom 在从句中作主语 )\n\nHer sons, `both of whom` work abroad, ring her up every week. \n\nI met the fruit-pickers, `several of whom` were college students.\n\n#### which 有时代表一个句子\n\nThey rely on themselves, `which` is much better.\n\nHe invited us to dinner, `which` was very kind of him.\n\nHe changed his mind, `which` made me very angry.\n\nShe was very patient towards the children, `which` her husband seldom was. \n\n","source":"_posts/英语/定语从句专题.md","raw":"---\ntitle: \"【专题】定语从句\"\ndate: 2021-12-20\ndraft: false\ntags: [\"Grammar\"]\ncategories: [\"English\"]\n---\n\n\n\n什么是定语从句？\n\n用一句话作定语，通常用来修饰名词、代词，被修饰的词称为`先行词`\n\n### 一、限制性定语从句\n\n引导词**代替先行词**，在定语从句**充当成分**\n\n> 对比宾语从句中，`that`不充当任何成分，可以省略\n\n#### 1. 关系代词：\n\n- 指代**人**：`who`（在从句中充当主语、宾语）、`whom`（充当宾语）\n\n  The man `who(that) robbed him` has been arrested.\n\n  The girl `whom I saw` told me to come back today.\n\n  The friend `with whom I was traveling` spoke French.\n\n- 指代**物**：`which`（主、宾）\n\n  The car `which (that) I hired` broke down.\n\n  I don't like the novel `which you are reading`.\n\n- 指代**人或物**：`that`（主、宾），`whose`（定语，意思是`谁的`）\n\n  I like the girl `whose eyes are very big`.\n\n#### 2. 关系副词：\n\n- `when`（时间状语）：指代**时间**\n\n  At the time `when` I saw him, he was quite strong.\n\n  I will never forget the day `when (on which)` I came to Beijing.\n\n- where`（地点状语）：表示地点`\n\n  This is the village `where` I was born.\n\n  The police searched the house `where (in which)` he lived.\n\n- `why`（原因状语）：`why`的先行词只能是`reason`\n\n  I don't know the reason `why (for which)` he is angry.\n\n### 3. 省略\n\n- 在**限制性定语从句**中，当关系代词在从句中作**宾语**时，一般都可以**省略**\n\n  Have you got everything (`that`) you need?\n\n  That's the only thing (`that`) we can do now.\n\n  You can take any room (`that`) you like.\n\n- **口语**中，在从句作**主语**也可以**省略**\n\n  There's a strange man (`that`) lives in that small village.\n\n  There's something (`that`) keeps worrying me.\n\n#### 4. 有些表示时间的定语从句并不由when引导\n\nThis was the first `time` I had serious trouble with my boss.\n\nEvery `time` the telephone rings, he gets nervous.\n\n#### 5. way后也可跟定语从句，不需要关系代词或副词\n\nI didn't like the way he eyed me. 【应该是方式状语？】\n\n### 二、非限制性定语从句\n\n**非限制性定语从句**对所修饰的词没有限制词义的作用，而只是补充说明，通常都有逗号，译成中文时，多翻译为并列句\n\n限制性定语从句拿掉以后，句子意思常发生变化。而**非限制性定语**从句拿掉以后，对剩下部分没有太大影响\n\n> 注意非限制性定语从句中**不能**使用**关系代词 that** 和**关系副词 why**，也**不能**省略任何关系副词\n\nPeter, `who` had been driving all day, suggested stopping at the next town.\n\nPaul, `whom` everyone suspected, turned out to be innocent.\n\nThe 9:30 train, `which` is usually very punctual, was late today.\n\nSunday is a holiday, `when` people do not go to work.\n\n#### 非限制性定语从句中，which 和 whom 和 of 或其他介词连用\n\nThe buses, `most of which` were already full, were surrounded by an angry crowd.\n\nShe had eight children, `three of whom` lived to grow up. ( three of whom 在从句中作主语 )\n\nHer sons, `both of whom` work abroad, ring her up every week. \n\nI met the fruit-pickers, `several of whom` were college students.\n\n#### which 有时代表一个句子\n\nThey rely on themselves, `which` is much better.\n\nHe invited us to dinner, `which` was very kind of him.\n\nHe changed his mind, `which` made me very angry.\n\nShe was very patient towards the children, `which` her husband seldom was. \n\n","slug":"英语/定语从句专题","published":1,"updated":"2022-01-04T08:44:59.772Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckxzva9fo000c7cu3geclgj0x","content":"<p>什么是定语从句？</p>\n<p>用一句话作定语，通常用来修饰名词、代词，被修饰的词称为<code>先行词</code></p>\n<h3 id=\"一、限制性定语从句\"><a href=\"#一、限制性定语从句\" class=\"headerlink\" title=\"一、限制性定语从句\"></a>一、限制性定语从句</h3><p>引导词<strong>代替先行词</strong>，在定语从句<strong>充当成分</strong></p>\n<blockquote>\n<p>对比宾语从句中，<code>that</code>不充当任何成分，可以省略</p>\n</blockquote>\n<h4 id=\"1-关系代词：\"><a href=\"#1-关系代词：\" class=\"headerlink\" title=\"1. 关系代词：\"></a>1. 关系代词：</h4><ul>\n<li><p>指代<strong>人</strong>：<code>who</code>（在从句中充当主语、宾语）、<code>whom</code>（充当宾语）</p>\n<p>The man <code>who(that) robbed him</code> has been arrested.</p>\n<p>The girl <code>whom I saw</code> told me to come back today.</p>\n<p>The friend <code>with whom I was traveling</code> spoke French.</p>\n</li>\n<li><p>指代<strong>物</strong>：<code>which</code>（主、宾）</p>\n<p>The car <code>which (that) I hired</code> broke down.</p>\n<p>I don’t like the novel <code>which you are reading</code>.</p>\n</li>\n<li><p>指代<strong>人或物</strong>：<code>that</code>（主、宾），<code>whose</code>（定语，意思是<code>谁的</code>）</p>\n<p>I like the girl <code>whose eyes are very big</code>.</p>\n</li>\n</ul>\n<h4 id=\"2-关系副词：\"><a href=\"#2-关系副词：\" class=\"headerlink\" title=\"2. 关系副词：\"></a>2. 关系副词：</h4><ul>\n<li><p><code>when</code>（时间状语）：指代<strong>时间</strong></p>\n<p>At the time <code>when</code> I saw him, he was quite strong.</p>\n<p>I will never forget the day <code>when (on which)</code> I came to Beijing.</p>\n</li>\n<li><p>where<code>（地点状语）：表示地点</code></p>\n<p>This is the village <code>where</code> I was born.</p>\n<p>The police searched the house <code>where (in which)</code> he lived.</p>\n</li>\n<li><p><code>why</code>（原因状语）：<code>why</code>的先行词只能是<code>reason</code></p>\n<p>I don’t know the reason <code>why (for which)</code> he is angry.</p>\n</li>\n</ul>\n<h3 id=\"3-省略\"><a href=\"#3-省略\" class=\"headerlink\" title=\"3. 省略\"></a>3. 省略</h3><ul>\n<li><p>在<strong>限制性定语从句</strong>中，当关系代词在从句中作<strong>宾语</strong>时，一般都可以<strong>省略</strong></p>\n<p>Have you got everything (<code>that</code>) you need?</p>\n<p>That’s the only thing (<code>that</code>) we can do now.</p>\n<p>You can take any room (<code>that</code>) you like.</p>\n</li>\n<li><p><strong>口语</strong>中，在从句作<strong>主语</strong>也可以<strong>省略</strong></p>\n<p>There’s a strange man (<code>that</code>) lives in that small village.</p>\n<p>There’s something (<code>that</code>) keeps worrying me.</p>\n</li>\n</ul>\n<h4 id=\"4-有些表示时间的定语从句并不由when引导\"><a href=\"#4-有些表示时间的定语从句并不由when引导\" class=\"headerlink\" title=\"4. 有些表示时间的定语从句并不由when引导\"></a>4. 有些表示时间的定语从句并不由when引导</h4><p>This was the first <code>time</code> I had serious trouble with my boss.</p>\n<p>Every <code>time</code> the telephone rings, he gets nervous.</p>\n<h4 id=\"5-way后也可跟定语从句，不需要关系代词或副词\"><a href=\"#5-way后也可跟定语从句，不需要关系代词或副词\" class=\"headerlink\" title=\"5. way后也可跟定语从句，不需要关系代词或副词\"></a>5. way后也可跟定语从句，不需要关系代词或副词</h4><p>I didn’t like the way he eyed me. 【应该是方式状语？】</p>\n<h3 id=\"二、非限制性定语从句\"><a href=\"#二、非限制性定语从句\" class=\"headerlink\" title=\"二、非限制性定语从句\"></a>二、非限制性定语从句</h3><p><strong>非限制性定语从句</strong>对所修饰的词没有限制词义的作用，而只是补充说明，通常都有逗号，译成中文时，多翻译为并列句</p>\n<p>限制性定语从句拿掉以后，句子意思常发生变化。而<strong>非限制性定语</strong>从句拿掉以后，对剩下部分没有太大影响</p>\n<blockquote>\n<p>注意非限制性定语从句中<strong>不能</strong>使用<strong>关系代词 that</strong> 和<strong>关系副词 why</strong>，也<strong>不能</strong>省略任何关系副词</p>\n</blockquote>\n<p>Peter, <code>who</code> had been driving all day, suggested stopping at the next town.</p>\n<p>Paul, <code>whom</code> everyone suspected, turned out to be innocent.</p>\n<p>The 9:30 train, <code>which</code> is usually very punctual, was late today.</p>\n<p>Sunday is a holiday, <code>when</code> people do not go to work.</p>\n<h4 id=\"非限制性定语从句中，which-和-whom-和-of-或其他介词连用\"><a href=\"#非限制性定语从句中，which-和-whom-和-of-或其他介词连用\" class=\"headerlink\" title=\"非限制性定语从句中，which 和 whom 和 of 或其他介词连用\"></a>非限制性定语从句中，which 和 whom 和 of 或其他介词连用</h4><p>The buses, <code>most of which</code> were already full, were surrounded by an angry crowd.</p>\n<p>She had eight children, <code>three of whom</code> lived to grow up. ( three of whom 在从句中作主语 )</p>\n<p>Her sons, <code>both of whom</code> work abroad, ring her up every week. </p>\n<p>I met the fruit-pickers, <code>several of whom</code> were college students.</p>\n<h4 id=\"which-有时代表一个句子\"><a href=\"#which-有时代表一个句子\" class=\"headerlink\" title=\"which 有时代表一个句子\"></a>which 有时代表一个句子</h4><p>They rely on themselves, <code>which</code> is much better.</p>\n<p>He invited us to dinner, <code>which</code> was very kind of him.</p>\n<p>He changed his mind, <code>which</code> made me very angry.</p>\n<p>She was very patient towards the children, <code>which</code> her husband seldom was. </p>\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<p>什么是定语从句？</p>\n<p>用一句话作定语，通常用来修饰名词、代词，被修饰的词称为<code>先行词</code></p>\n<h3 id=\"一、限制性定语从句\"><a href=\"#一、限制性定语从句\" class=\"headerlink\" title=\"一、限制性定语从句\"></a>一、限制性定语从句</h3><p>引导词<strong>代替先行词</strong>，在定语从句<strong>充当成分</strong></p>\n<blockquote>\n<p>对比宾语从句中，<code>that</code>不充当任何成分，可以省略</p>\n</blockquote>\n<h4 id=\"1-关系代词：\"><a href=\"#1-关系代词：\" class=\"headerlink\" title=\"1. 关系代词：\"></a>1. 关系代词：</h4><ul>\n<li><p>指代<strong>人</strong>：<code>who</code>（在从句中充当主语、宾语）、<code>whom</code>（充当宾语）</p>\n<p>The man <code>who(that) robbed him</code> has been arrested.</p>\n<p>The girl <code>whom I saw</code> told me to come back today.</p>\n<p>The friend <code>with whom I was traveling</code> spoke French.</p>\n</li>\n<li><p>指代<strong>物</strong>：<code>which</code>（主、宾）</p>\n<p>The car <code>which (that) I hired</code> broke down.</p>\n<p>I don’t like the novel <code>which you are reading</code>.</p>\n</li>\n<li><p>指代<strong>人或物</strong>：<code>that</code>（主、宾），<code>whose</code>（定语，意思是<code>谁的</code>）</p>\n<p>I like the girl <code>whose eyes are very big</code>.</p>\n</li>\n</ul>\n<h4 id=\"2-关系副词：\"><a href=\"#2-关系副词：\" class=\"headerlink\" title=\"2. 关系副词：\"></a>2. 关系副词：</h4><ul>\n<li><p><code>when</code>（时间状语）：指代<strong>时间</strong></p>\n<p>At the time <code>when</code> I saw him, he was quite strong.</p>\n<p>I will never forget the day <code>when (on which)</code> I came to Beijing.</p>\n</li>\n<li><p>where<code>（地点状语）：表示地点</code></p>\n<p>This is the village <code>where</code> I was born.</p>\n<p>The police searched the house <code>where (in which)</code> he lived.</p>\n</li>\n<li><p><code>why</code>（原因状语）：<code>why</code>的先行词只能是<code>reason</code></p>\n<p>I don’t know the reason <code>why (for which)</code> he is angry.</p>\n</li>\n</ul>\n<h3 id=\"3-省略\"><a href=\"#3-省略\" class=\"headerlink\" title=\"3. 省略\"></a>3. 省略</h3><ul>\n<li><p>在<strong>限制性定语从句</strong>中，当关系代词在从句中作<strong>宾语</strong>时，一般都可以<strong>省略</strong></p>\n<p>Have you got everything (<code>that</code>) you need?</p>\n<p>That’s the only thing (<code>that</code>) we can do now.</p>\n<p>You can take any room (<code>that</code>) you like.</p>\n</li>\n<li><p><strong>口语</strong>中，在从句作<strong>主语</strong>也可以<strong>省略</strong></p>\n<p>There’s a strange man (<code>that</code>) lives in that small village.</p>\n<p>There’s something (<code>that</code>) keeps worrying me.</p>\n</li>\n</ul>\n<h4 id=\"4-有些表示时间的定语从句并不由when引导\"><a href=\"#4-有些表示时间的定语从句并不由when引导\" class=\"headerlink\" title=\"4. 有些表示时间的定语从句并不由when引导\"></a>4. 有些表示时间的定语从句并不由when引导</h4><p>This was the first <code>time</code> I had serious trouble with my boss.</p>\n<p>Every <code>time</code> the telephone rings, he gets nervous.</p>\n<h4 id=\"5-way后也可跟定语从句，不需要关系代词或副词\"><a href=\"#5-way后也可跟定语从句，不需要关系代词或副词\" class=\"headerlink\" title=\"5. way后也可跟定语从句，不需要关系代词或副词\"></a>5. way后也可跟定语从句，不需要关系代词或副词</h4><p>I didn’t like the way he eyed me. 【应该是方式状语？】</p>\n<h3 id=\"二、非限制性定语从句\"><a href=\"#二、非限制性定语从句\" class=\"headerlink\" title=\"二、非限制性定语从句\"></a>二、非限制性定语从句</h3><p><strong>非限制性定语从句</strong>对所修饰的词没有限制词义的作用，而只是补充说明，通常都有逗号，译成中文时，多翻译为并列句</p>\n<p>限制性定语从句拿掉以后，句子意思常发生变化。而<strong>非限制性定语</strong>从句拿掉以后，对剩下部分没有太大影响</p>\n<blockquote>\n<p>注意非限制性定语从句中<strong>不能</strong>使用<strong>关系代词 that</strong> 和<strong>关系副词 why</strong>，也<strong>不能</strong>省略任何关系副词</p>\n</blockquote>\n<p>Peter, <code>who</code> had been driving all day, suggested stopping at the next town.</p>\n<p>Paul, <code>whom</code> everyone suspected, turned out to be innocent.</p>\n<p>The 9:30 train, <code>which</code> is usually very punctual, was late today.</p>\n<p>Sunday is a holiday, <code>when</code> people do not go to work.</p>\n<h4 id=\"非限制性定语从句中，which-和-whom-和-of-或其他介词连用\"><a href=\"#非限制性定语从句中，which-和-whom-和-of-或其他介词连用\" class=\"headerlink\" title=\"非限制性定语从句中，which 和 whom 和 of 或其他介词连用\"></a>非限制性定语从句中，which 和 whom 和 of 或其他介词连用</h4><p>The buses, <code>most of which</code> were already full, were surrounded by an angry crowd.</p>\n<p>She had eight children, <code>three of whom</code> lived to grow up. ( three of whom 在从句中作主语 )</p>\n<p>Her sons, <code>both of whom</code> work abroad, ring her up every week. </p>\n<p>I met the fruit-pickers, <code>several of whom</code> were college students.</p>\n<h4 id=\"which-有时代表一个句子\"><a href=\"#which-有时代表一个句子\" class=\"headerlink\" title=\"which 有时代表一个句子\"></a>which 有时代表一个句子</h4><p>They rely on themselves, <code>which</code> is much better.</p>\n<p>He invited us to dinner, <code>which</code> was very kind of him.</p>\n<p>He changed his mind, <code>which</code> made me very angry.</p>\n<p>She was very patient towards the children, <code>which</code> her husband seldom was. </p>\n"},{"title":"【专题】虚拟语气","date":"2021-11-12T16:00:00.000Z","draft":false,"_content":"\n\n\n虚拟语气在形式上分为三类\n\n1. **现在**虚拟语气——动词原形\n\n   *God `bless` you.* \n\n2. **过去**虚拟语气——和陈述语气的过去时相同，但动词 `be` 要用 `were`\n\n   *If only I `were` not so nervous. // 我要是不那么紧张就好了*\n\n   *She treated me as though I `were` a stranger.*\n\n3. **过去完成**形式——和陈述语气中的过去完成时相同\n\n   *I wish I `hadn't done` so.*\n\n   *If only I `had listened` to your advice.*\n\n[If only](https://dictionary.cambridge.org/grammar/british-grammar/if-only) 用法\n\n### 1. 虚拟条件句\n\n#### 1.1 表示**与（现在、将来）事实相反**的情况或**可能性不大**\n\n| 条件从句                    | 主句                       |\n| --------------------------- | -------------------------- |\n| 过去式（通常 **be->were**） | would/might/could + **do** |\n\n*If I `were` you, I`'d plant` some trees round the house.* 如果我是你，我就会在房子周围种些树（你还没种，未来可能种）\n\n*If I `had` a map I `would lend` it to you.* 如果我有地图，我就借给你（但是我还没有，未来可能有）\n\n*If I `dyed` my hair blue everyone `would` laugh at me.*  如果我把我的头发染成蓝色（还没染，未来小概率染）\n\n*//从句用`If it were not for`，表示“若不是”*\n\n*If `it weren't for` Ruth, you `wouldn't be` anywhere. //要不是Ruth，你不会有任何成就*\n\n*If `it weren't for` your help, we `would be` in serious trouble.*\n\n#### 1.2 表示与过去事实相反\n\n| 条件从句        | 主句                                     |\n| --------------- | ---------------------------------------- |\n| If **had done** | would/might/could/should **have done**** |\n\n*If anything `had happend`, he `would have` let us know.*  如果发生了什么，他**早**就通知我们了（没发生什么已经是事实了）\n\n*If Hanyu `had recieved` the present, she `should` have thanked me.*  如果HY收到了礼物（表明HY没有受到礼物已经是事实了），她早就谢谢我了\n\n*If I `had been` Nancy, I `wouldn't have` left him.* 如果我是南希，我不会离开他（南希已经离开了他）\n\n\n\n`had not been for` 表示 “要不是“\n\n*If it `hadn't been` for your timely help, we `would have` got into serious trouble.*\n\n#### 1.3 错综时间条件句\n\n有些条件句主句谓语和从句谓语在时间上并不一致（不符合上述两点）\n\n*If you `had taken` her advice, you `wouldn't be` in such trouble now.*\n\n*If he `were leaving`, you `should have` heard about it.*\n\n#### 1.4 含蓄条件句\n\n隐含的条件句\n\n*I might see her personally, it `would be` better.*\n\n*I did not press the point as it `would be` useless.*\n\n*In the old days she `would have` argued.*\n\n*I `wouldn't worry` about it.*\n\n#### 1.5 委婉客气的语气，情态动词的使用（should, would, could, might）\n\n*`Would` you mind shutting the window?*\n\n*`Would` you tell me how to ...*\n\n*`Could` you lend me your computer?*\n\n*If necessary, you `might` shorten it.*\n\n### 2. 虚拟语气在某些从句中的应用\n\n#### 2.1 宾语从句\n\n1. `wish`\n\n   a. 与**现在**事实相反（**be->were**），**过去式**\n\n   *I wish I `had` more time.*   还没有更多时间，但可能有\n\n   *I wish I `could` help you.* 我希望我能帮你（还没帮，未来可能帮，I wish I had helped you. 我希望我已经帮你，没帮已经是过去的事实了）\n\n   *I wish I `were`(was) young again.  // 用 was 也行*\n\n   b. 与**过去**事实相反，**过去完成时**，常表示**遗憾**\n\n   *I wish I `had thought` what she really want.*  我没想过她真正想要什么，已经是事实了\n\n   *I wish I `had restrained` my emotion.*  我没有控制我的情感，已经是事实了\n\n   c. 谈论**将来**的愿望，从句用 `would、could、might + do`\n\n   *I wish I `could` do something for you in return. 我希望我能做点什么回报你*\n\n2. `would rather`\n\n   谓语多用**过去式**，表**现在、将来**\n\n   *I'd rather you `told` me the truth.*  我宁愿你给我讲真话\n\n   \n\n   suppose 虚拟+宾语从句（如果是对将来的假设，动词用过去时）\n\n   *Suppose her father turned her out of doors!*\n\n3. `suggest`、`demand`、`insist`、`ask`等表示要求、命令、建议一类的动词\n\n   从句用 `should + do`，但是 `should` 一般省略\n\n   *The doctor advised that he `change` the job.*\n\n   *I propose that sb (should) `be` ...*\n\n   *He commanded that we (should) `attack` at once.*\n\n#### 2.2 主语从句、表语从句、同位语从句\n\n从句用 `(should) do`\n\n**主语从句**\n\n*It's important that he `work` hard.*\n\n*It's _________ you `(should) not be` seen here. // 你不该出现在这里，这很...*\n\n`should do` 有时表达“竟然”的情感色彩\n\n*It seems so unfair that this `should happen` to me.*\n\n*It's strange that she `should be` so late. //真奇怪，她竟然来得这么晚*\n\n**表语从句**\n\n*Her idea was that they `should lock` up the house.*\n\n**同位语从句**\n\n*They expressed the wish that they `(should) be` given more free time.*\n\n#### 3. 状语从句\n\n- `as if`、`as though`\n\n  表示**现在**情况用**过去式**，表示**过去**情况用**过去完成形式**\n\n  *I have loved you as if you `were` my son.*\n\n  *I remember it as if it `happened` last night.*\n\n  *He looks as though he `had known` Millie for years.* \n\n  在 `look`、`seem`、`taste`、`smell` 后，`as if` 引导的从句可用**陈述**语气，大概率事件\n\n  *It looks as if they `are` in a terrible hurry.*\n\n  *The meat tastes as if it `has` gone bad.*\n\n  `as if (though)` 引导**表语从句**\n\n  *You look as if you `didn't` care.*\n\n- **让步状语从句**\n\n  *Whether she `be(is)` right or wrong, we will support her.*\n\n- **目的状语**\n\n  从句谓语多用 would、should、could、might\n\n  *I hired a boat so that I `could` go fish.*\n\n  *He left early in order that the children `would` not be alone in the house.*\n\n- **be+形容词，should+动词原形**（张道真认为形容词后的从句为状语从句，有些认为是宾语从句）\n\n  *I'm `surprised` that you `should` press the suggestion. //我很奇怪你竟然坚持你的建议*\n\n  *They're especially `anxious` that you `should` come.  //他们特别期盼你能来*\n\n### 虚拟语气的一些其他用法\n\n只记录了较常见的\n\n- `It's (high) time` 后的定语从句中的虚拟语气\n\n  多用**过去虚拟**语气\n\n  *It's time we `went`.*\n\n  *It's time we `were` leaving.*\n\n  *It's high time you `made` up your mind.*\n\n- `would have thought`\n\n  *Who `would have thought` to see you here!  //谁能想到会在这里看到你！*\n\n  *Who `would have thought` it was going to break like that?*  \n\n\n\n参考资料：[张道真实用英语语法](https://book.douban.com/subject/1210225/)\n\n","source":"_posts/英语/虚拟语气专题.md","raw":"---\ntitle: \"【专题】虚拟语气\"\ndate: 2021-11-13\ndraft: false\ntags: [\"Grammar\"]\ncategories: [\"English\"]\n---\n\n\n\n虚拟语气在形式上分为三类\n\n1. **现在**虚拟语气——动词原形\n\n   *God `bless` you.* \n\n2. **过去**虚拟语气——和陈述语气的过去时相同，但动词 `be` 要用 `were`\n\n   *If only I `were` not so nervous. // 我要是不那么紧张就好了*\n\n   *She treated me as though I `were` a stranger.*\n\n3. **过去完成**形式——和陈述语气中的过去完成时相同\n\n   *I wish I `hadn't done` so.*\n\n   *If only I `had listened` to your advice.*\n\n[If only](https://dictionary.cambridge.org/grammar/british-grammar/if-only) 用法\n\n### 1. 虚拟条件句\n\n#### 1.1 表示**与（现在、将来）事实相反**的情况或**可能性不大**\n\n| 条件从句                    | 主句                       |\n| --------------------------- | -------------------------- |\n| 过去式（通常 **be->were**） | would/might/could + **do** |\n\n*If I `were` you, I`'d plant` some trees round the house.* 如果我是你，我就会在房子周围种些树（你还没种，未来可能种）\n\n*If I `had` a map I `would lend` it to you.* 如果我有地图，我就借给你（但是我还没有，未来可能有）\n\n*If I `dyed` my hair blue everyone `would` laugh at me.*  如果我把我的头发染成蓝色（还没染，未来小概率染）\n\n*//从句用`If it were not for`，表示“若不是”*\n\n*If `it weren't for` Ruth, you `wouldn't be` anywhere. //要不是Ruth，你不会有任何成就*\n\n*If `it weren't for` your help, we `would be` in serious trouble.*\n\n#### 1.2 表示与过去事实相反\n\n| 条件从句        | 主句                                     |\n| --------------- | ---------------------------------------- |\n| If **had done** | would/might/could/should **have done**** |\n\n*If anything `had happend`, he `would have` let us know.*  如果发生了什么，他**早**就通知我们了（没发生什么已经是事实了）\n\n*If Hanyu `had recieved` the present, she `should` have thanked me.*  如果HY收到了礼物（表明HY没有受到礼物已经是事实了），她早就谢谢我了\n\n*If I `had been` Nancy, I `wouldn't have` left him.* 如果我是南希，我不会离开他（南希已经离开了他）\n\n\n\n`had not been for` 表示 “要不是“\n\n*If it `hadn't been` for your timely help, we `would have` got into serious trouble.*\n\n#### 1.3 错综时间条件句\n\n有些条件句主句谓语和从句谓语在时间上并不一致（不符合上述两点）\n\n*If you `had taken` her advice, you `wouldn't be` in such trouble now.*\n\n*If he `were leaving`, you `should have` heard about it.*\n\n#### 1.4 含蓄条件句\n\n隐含的条件句\n\n*I might see her personally, it `would be` better.*\n\n*I did not press the point as it `would be` useless.*\n\n*In the old days she `would have` argued.*\n\n*I `wouldn't worry` about it.*\n\n#### 1.5 委婉客气的语气，情态动词的使用（should, would, could, might）\n\n*`Would` you mind shutting the window?*\n\n*`Would` you tell me how to ...*\n\n*`Could` you lend me your computer?*\n\n*If necessary, you `might` shorten it.*\n\n### 2. 虚拟语气在某些从句中的应用\n\n#### 2.1 宾语从句\n\n1. `wish`\n\n   a. 与**现在**事实相反（**be->were**），**过去式**\n\n   *I wish I `had` more time.*   还没有更多时间，但可能有\n\n   *I wish I `could` help you.* 我希望我能帮你（还没帮，未来可能帮，I wish I had helped you. 我希望我已经帮你，没帮已经是过去的事实了）\n\n   *I wish I `were`(was) young again.  // 用 was 也行*\n\n   b. 与**过去**事实相反，**过去完成时**，常表示**遗憾**\n\n   *I wish I `had thought` what she really want.*  我没想过她真正想要什么，已经是事实了\n\n   *I wish I `had restrained` my emotion.*  我没有控制我的情感，已经是事实了\n\n   c. 谈论**将来**的愿望，从句用 `would、could、might + do`\n\n   *I wish I `could` do something for you in return. 我希望我能做点什么回报你*\n\n2. `would rather`\n\n   谓语多用**过去式**，表**现在、将来**\n\n   *I'd rather you `told` me the truth.*  我宁愿你给我讲真话\n\n   \n\n   suppose 虚拟+宾语从句（如果是对将来的假设，动词用过去时）\n\n   *Suppose her father turned her out of doors!*\n\n3. `suggest`、`demand`、`insist`、`ask`等表示要求、命令、建议一类的动词\n\n   从句用 `should + do`，但是 `should` 一般省略\n\n   *The doctor advised that he `change` the job.*\n\n   *I propose that sb (should) `be` ...*\n\n   *He commanded that we (should) `attack` at once.*\n\n#### 2.2 主语从句、表语从句、同位语从句\n\n从句用 `(should) do`\n\n**主语从句**\n\n*It's important that he `work` hard.*\n\n*It's _________ you `(should) not be` seen here. // 你不该出现在这里，这很...*\n\n`should do` 有时表达“竟然”的情感色彩\n\n*It seems so unfair that this `should happen` to me.*\n\n*It's strange that she `should be` so late. //真奇怪，她竟然来得这么晚*\n\n**表语从句**\n\n*Her idea was that they `should lock` up the house.*\n\n**同位语从句**\n\n*They expressed the wish that they `(should) be` given more free time.*\n\n#### 3. 状语从句\n\n- `as if`、`as though`\n\n  表示**现在**情况用**过去式**，表示**过去**情况用**过去完成形式**\n\n  *I have loved you as if you `were` my son.*\n\n  *I remember it as if it `happened` last night.*\n\n  *He looks as though he `had known` Millie for years.* \n\n  在 `look`、`seem`、`taste`、`smell` 后，`as if` 引导的从句可用**陈述**语气，大概率事件\n\n  *It looks as if they `are` in a terrible hurry.*\n\n  *The meat tastes as if it `has` gone bad.*\n\n  `as if (though)` 引导**表语从句**\n\n  *You look as if you `didn't` care.*\n\n- **让步状语从句**\n\n  *Whether she `be(is)` right or wrong, we will support her.*\n\n- **目的状语**\n\n  从句谓语多用 would、should、could、might\n\n  *I hired a boat so that I `could` go fish.*\n\n  *He left early in order that the children `would` not be alone in the house.*\n\n- **be+形容词，should+动词原形**（张道真认为形容词后的从句为状语从句，有些认为是宾语从句）\n\n  *I'm `surprised` that you `should` press the suggestion. //我很奇怪你竟然坚持你的建议*\n\n  *They're especially `anxious` that you `should` come.  //他们特别期盼你能来*\n\n### 虚拟语气的一些其他用法\n\n只记录了较常见的\n\n- `It's (high) time` 后的定语从句中的虚拟语气\n\n  多用**过去虚拟**语气\n\n  *It's time we `went`.*\n\n  *It's time we `were` leaving.*\n\n  *It's high time you `made` up your mind.*\n\n- `would have thought`\n\n  *Who `would have thought` to see you here!  //谁能想到会在这里看到你！*\n\n  *Who `would have thought` it was going to break like that?*  \n\n\n\n参考资料：[张道真实用英语语法](https://book.douban.com/subject/1210225/)\n\n","slug":"英语/虚拟语气专题","published":1,"updated":"2021-12-31T02:10:35.486Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckxzva9fp000d7cu37usm3efu","content":"<p>虚拟语气在形式上分为三类</p>\n<ol>\n<li><p><strong>现在</strong>虚拟语气——动词原形</p>\n<p><em>God <code>bless</code> you.</em> </p>\n</li>\n<li><p><strong>过去</strong>虚拟语气——和陈述语气的过去时相同，但动词 <code>be</code> 要用 <code>were</code></p>\n<p><em>If only I <code>were</code> not so nervous. // 我要是不那么紧张就好了</em></p>\n<p><em>She treated me as though I <code>were</code> a stranger.</em></p>\n</li>\n<li><p><strong>过去完成</strong>形式——和陈述语气中的过去完成时相同</p>\n<p><em>I wish I <code>hadn&#39;t done</code> so.</em></p>\n<p><em>If only I <code>had listened</code> to your advice.</em></p>\n</li>\n</ol>\n<p><a href=\"https://dictionary.cambridge.org/grammar/british-grammar/if-only\">If only</a> 用法</p>\n<h3 id=\"1-虚拟条件句\"><a href=\"#1-虚拟条件句\" class=\"headerlink\" title=\"1. 虚拟条件句\"></a>1. 虚拟条件句</h3><h4 id=\"1-1-表示与（现在、将来）事实相反的情况或可能性不大\"><a href=\"#1-1-表示与（现在、将来）事实相反的情况或可能性不大\" class=\"headerlink\" title=\"1.1 表示与（现在、将来）事实相反的情况或可能性不大\"></a>1.1 表示<strong>与（现在、将来）事实相反</strong>的情况或<strong>可能性不大</strong></h4><table>\n<thead>\n<tr>\n<th>条件从句</th>\n<th>主句</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>过去式（通常 <strong>be-&gt;were</strong>）</td>\n<td>would/might/could + <strong>do</strong></td>\n</tr>\n</tbody></table>\n<p><em>If I <code>were</code> you, I<code>&#39;d plant</code> some trees round the house.</em> 如果我是你，我就会在房子周围种些树（你还没种，未来可能种）</p>\n<p><em>If I <code>had</code> a map I <code>would lend</code> it to you.</em> 如果我有地图，我就借给你（但是我还没有，未来可能有）</p>\n<p><em>If I <code>dyed</code> my hair blue everyone <code>would</code> laugh at me.</em>  如果我把我的头发染成蓝色（还没染，未来小概率染）</p>\n<p><em>//从句用<code>If it were not for</code>，表示“若不是”</em></p>\n<p><em>If <code>it weren&#39;t for</code> Ruth, you <code>wouldn&#39;t be</code> anywhere. //要不是Ruth，你不会有任何成就</em></p>\n<p><em>If <code>it weren&#39;t for</code> your help, we <code>would be</code> in serious trouble.</em></p>\n<h4 id=\"1-2-表示与过去事实相反\"><a href=\"#1-2-表示与过去事实相反\" class=\"headerlink\" title=\"1.2 表示与过去事实相反\"></a>1.2 表示与过去事实相反</h4><table>\n<thead>\n<tr>\n<th>条件从句</th>\n<th>主句</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>If <strong>had done</strong></td>\n<td>would/might/could/should <strong>have done</strong>**</td>\n</tr>\n</tbody></table>\n<p><em>If anything <code>had happend</code>, he <code>would have</code> let us know.</em>  如果发生了什么，他<strong>早</strong>就通知我们了（没发生什么已经是事实了）</p>\n<p><em>If Hanyu <code>had recieved</code> the present, she <code>should</code> have thanked me.</em>  如果HY收到了礼物（表明HY没有受到礼物已经是事实了），她早就谢谢我了</p>\n<p><em>If I <code>had been</code> Nancy, I <code>wouldn&#39;t have</code> left him.</em> 如果我是南希，我不会离开他（南希已经离开了他）</p>\n<p><code>had not been for</code> 表示 “要不是“</p>\n<p><em>If it <code>hadn&#39;t been</code> for your timely help, we <code>would have</code> got into serious trouble.</em></p>\n<h4 id=\"1-3-错综时间条件句\"><a href=\"#1-3-错综时间条件句\" class=\"headerlink\" title=\"1.3 错综时间条件句\"></a>1.3 错综时间条件句</h4><p>有些条件句主句谓语和从句谓语在时间上并不一致（不符合上述两点）</p>\n<p><em>If you <code>had taken</code> her advice, you <code>wouldn&#39;t be</code> in such trouble now.</em></p>\n<p><em>If he <code>were leaving</code>, you <code>should have</code> heard about it.</em></p>\n<h4 id=\"1-4-含蓄条件句\"><a href=\"#1-4-含蓄条件句\" class=\"headerlink\" title=\"1.4 含蓄条件句\"></a>1.4 含蓄条件句</h4><p>隐含的条件句</p>\n<p><em>I might see her personally, it <code>would be</code> better.</em></p>\n<p><em>I did not press the point as it <code>would be</code> useless.</em></p>\n<p><em>In the old days she <code>would have</code> argued.</em></p>\n<p><em>I <code>wouldn&#39;t worry</code> about it.</em></p>\n<h4 id=\"1-5-委婉客气的语气，情态动词的使用（should-would-could-might）\"><a href=\"#1-5-委婉客气的语气，情态动词的使用（should-would-could-might）\" class=\"headerlink\" title=\"1.5 委婉客气的语气，情态动词的使用（should, would, could, might）\"></a>1.5 委婉客气的语气，情态动词的使用（should, would, could, might）</h4><p><em><code>Would</code> you mind shutting the window?</em></p>\n<p><em><code>Would</code> you tell me how to …</em></p>\n<p><em><code>Could</code> you lend me your computer?</em></p>\n<p><em>If necessary, you <code>might</code> shorten it.</em></p>\n<h3 id=\"2-虚拟语气在某些从句中的应用\"><a href=\"#2-虚拟语气在某些从句中的应用\" class=\"headerlink\" title=\"2. 虚拟语气在某些从句中的应用\"></a>2. 虚拟语气在某些从句中的应用</h3><h4 id=\"2-1-宾语从句\"><a href=\"#2-1-宾语从句\" class=\"headerlink\" title=\"2.1 宾语从句\"></a>2.1 宾语从句</h4><ol>\n<li><p><code>wish</code></p>\n<p>a. 与<strong>现在</strong>事实相反（<strong>be-&gt;were</strong>），<strong>过去式</strong></p>\n<p><em>I wish I <code>had</code> more time.</em>   还没有更多时间，但可能有</p>\n<p><em>I wish I <code>could</code> help you.</em> 我希望我能帮你（还没帮，未来可能帮，I wish I had helped you. 我希望我已经帮你，没帮已经是过去的事实了）</p>\n<p><em>I wish I <code>were</code>(was) young again.  // 用 was 也行</em></p>\n<p>b. 与<strong>过去</strong>事实相反，<strong>过去完成时</strong>，常表示<strong>遗憾</strong></p>\n<p><em>I wish I <code>had thought</code> what she really want.</em>  我没想过她真正想要什么，已经是事实了</p>\n<p><em>I wish I <code>had restrained</code> my emotion.</em>  我没有控制我的情感，已经是事实了</p>\n<p>c. 谈论<strong>将来</strong>的愿望，从句用 <code>would、could、might + do</code></p>\n<p><em>I wish I <code>could</code> do something for you in return. 我希望我能做点什么回报你</em></p>\n</li>\n<li><p><code>would rather</code></p>\n<p>谓语多用<strong>过去式</strong>，表<strong>现在、将来</strong></p>\n<p><em>I’d rather you <code>told</code> me the truth.</em>  我宁愿你给我讲真话</p>\n<p>suppose 虚拟+宾语从句（如果是对将来的假设，动词用过去时）</p>\n<p><em>Suppose her father turned her out of doors!</em></p>\n</li>\n<li><p><code>suggest</code>、<code>demand</code>、<code>insist</code>、<code>ask</code>等表示要求、命令、建议一类的动词</p>\n<p>从句用 <code>should + do</code>，但是 <code>should</code> 一般省略</p>\n<p><em>The doctor advised that he <code>change</code> the job.</em></p>\n<p><em>I propose that sb (should) <code>be</code> …</em></p>\n<p><em>He commanded that we (should) <code>attack</code> at once.</em></p>\n</li>\n</ol>\n<h4 id=\"2-2-主语从句、表语从句、同位语从句\"><a href=\"#2-2-主语从句、表语从句、同位语从句\" class=\"headerlink\" title=\"2.2 主语从句、表语从句、同位语从句\"></a>2.2 主语从句、表语从句、同位语从句</h4><p>从句用 <code>(should) do</code></p>\n<p><strong>主语从句</strong></p>\n<p><em>It’s important that he <code>work</code> hard.</em></p>\n<p><em>It’s _________ you <code>(should) not be</code> seen here. // 你不该出现在这里，这很…</em></p>\n<p><code>should do</code> 有时表达“竟然”的情感色彩</p>\n<p><em>It seems so unfair that this <code>should happen</code> to me.</em></p>\n<p><em>It’s strange that she <code>should be</code> so late. //真奇怪，她竟然来得这么晚</em></p>\n<p><strong>表语从句</strong></p>\n<p><em>Her idea was that they <code>should lock</code> up the house.</em></p>\n<p><strong>同位语从句</strong></p>\n<p><em>They expressed the wish that they <code>(should) be</code> given more free time.</em></p>\n<h4 id=\"3-状语从句\"><a href=\"#3-状语从句\" class=\"headerlink\" title=\"3. 状语从句\"></a>3. 状语从句</h4><ul>\n<li><p><code>as if</code>、<code>as though</code></p>\n<p>表示<strong>现在</strong>情况用<strong>过去式</strong>，表示<strong>过去</strong>情况用<strong>过去完成形式</strong></p>\n<p><em>I have loved you as if you <code>were</code> my son.</em></p>\n<p><em>I remember it as if it <code>happened</code> last night.</em></p>\n<p><em>He looks as though he <code>had known</code> Millie for years.</em> </p>\n<p>在 <code>look</code>、<code>seem</code>、<code>taste</code>、<code>smell</code> 后，<code>as if</code> 引导的从句可用<strong>陈述</strong>语气，大概率事件</p>\n<p><em>It looks as if they <code>are</code> in a terrible hurry.</em></p>\n<p><em>The meat tastes as if it <code>has</code> gone bad.</em></p>\n<p><code>as if (though)</code> 引导<strong>表语从句</strong></p>\n<p><em>You look as if you <code>didn&#39;t</code> care.</em></p>\n</li>\n<li><p><strong>让步状语从句</strong></p>\n<p><em>Whether she <code>be(is)</code> right or wrong, we will support her.</em></p>\n</li>\n<li><p><strong>目的状语</strong></p>\n<p>从句谓语多用 would、should、could、might</p>\n<p><em>I hired a boat so that I <code>could</code> go fish.</em></p>\n<p><em>He left early in order that the children <code>would</code> not be alone in the house.</em></p>\n</li>\n<li><p><strong>be+形容词，should+动词原形</strong>（张道真认为形容词后的从句为状语从句，有些认为是宾语从句）</p>\n<p><em>I’m <code>surprised</code> that you <code>should</code> press the suggestion. //我很奇怪你竟然坚持你的建议</em></p>\n<p><em>They’re especially <code>anxious</code> that you <code>should</code> come.  //他们特别期盼你能来</em></p>\n</li>\n</ul>\n<h3 id=\"虚拟语气的一些其他用法\"><a href=\"#虚拟语气的一些其他用法\" class=\"headerlink\" title=\"虚拟语气的一些其他用法\"></a>虚拟语气的一些其他用法</h3><p>只记录了较常见的</p>\n<ul>\n<li><p><code>It&#39;s (high) time</code> 后的定语从句中的虚拟语气</p>\n<p>多用<strong>过去虚拟</strong>语气</p>\n<p><em>It’s time we <code>went</code>.</em></p>\n<p><em>It’s time we <code>were</code> leaving.</em></p>\n<p><em>It’s high time you <code>made</code> up your mind.</em></p>\n</li>\n<li><p><code>would have thought</code></p>\n<p><em>Who <code>would have thought</code> to see you here!  //谁能想到会在这里看到你！</em></p>\n<p><em>Who <code>would have thought</code> it was going to break like that?</em>  </p>\n</li>\n</ul>\n<p>参考资料：<a href=\"https://book.douban.com/subject/1210225/\">张道真实用英语语法</a></p>\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<p>虚拟语气在形式上分为三类</p>\n<ol>\n<li><p><strong>现在</strong>虚拟语气——动词原形</p>\n<p><em>God <code>bless</code> you.</em> </p>\n</li>\n<li><p><strong>过去</strong>虚拟语气——和陈述语气的过去时相同，但动词 <code>be</code> 要用 <code>were</code></p>\n<p><em>If only I <code>were</code> not so nervous. // 我要是不那么紧张就好了</em></p>\n<p><em>She treated me as though I <code>were</code> a stranger.</em></p>\n</li>\n<li><p><strong>过去完成</strong>形式——和陈述语气中的过去完成时相同</p>\n<p><em>I wish I <code>hadn&#39;t done</code> so.</em></p>\n<p><em>If only I <code>had listened</code> to your advice.</em></p>\n</li>\n</ol>\n<p><a href=\"https://dictionary.cambridge.org/grammar/british-grammar/if-only\">If only</a> 用法</p>\n<h3 id=\"1-虚拟条件句\"><a href=\"#1-虚拟条件句\" class=\"headerlink\" title=\"1. 虚拟条件句\"></a>1. 虚拟条件句</h3><h4 id=\"1-1-表示与（现在、将来）事实相反的情况或可能性不大\"><a href=\"#1-1-表示与（现在、将来）事实相反的情况或可能性不大\" class=\"headerlink\" title=\"1.1 表示与（现在、将来）事实相反的情况或可能性不大\"></a>1.1 表示<strong>与（现在、将来）事实相反</strong>的情况或<strong>可能性不大</strong></h4><table>\n<thead>\n<tr>\n<th>条件从句</th>\n<th>主句</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>过去式（通常 <strong>be-&gt;were</strong>）</td>\n<td>would/might/could + <strong>do</strong></td>\n</tr>\n</tbody></table>\n<p><em>If I <code>were</code> you, I<code>&#39;d plant</code> some trees round the house.</em> 如果我是你，我就会在房子周围种些树（你还没种，未来可能种）</p>\n<p><em>If I <code>had</code> a map I <code>would lend</code> it to you.</em> 如果我有地图，我就借给你（但是我还没有，未来可能有）</p>\n<p><em>If I <code>dyed</code> my hair blue everyone <code>would</code> laugh at me.</em>  如果我把我的头发染成蓝色（还没染，未来小概率染）</p>\n<p><em>//从句用<code>If it were not for</code>，表示“若不是”</em></p>\n<p><em>If <code>it weren&#39;t for</code> Ruth, you <code>wouldn&#39;t be</code> anywhere. //要不是Ruth，你不会有任何成就</em></p>\n<p><em>If <code>it weren&#39;t for</code> your help, we <code>would be</code> in serious trouble.</em></p>\n<h4 id=\"1-2-表示与过去事实相反\"><a href=\"#1-2-表示与过去事实相反\" class=\"headerlink\" title=\"1.2 表示与过去事实相反\"></a>1.2 表示与过去事实相反</h4><table>\n<thead>\n<tr>\n<th>条件从句</th>\n<th>主句</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>If <strong>had done</strong></td>\n<td>would/might/could/should <strong>have done</strong>**</td>\n</tr>\n</tbody></table>\n<p><em>If anything <code>had happend</code>, he <code>would have</code> let us know.</em>  如果发生了什么，他<strong>早</strong>就通知我们了（没发生什么已经是事实了）</p>\n<p><em>If Hanyu <code>had recieved</code> the present, she <code>should</code> have thanked me.</em>  如果HY收到了礼物（表明HY没有受到礼物已经是事实了），她早就谢谢我了</p>\n<p><em>If I <code>had been</code> Nancy, I <code>wouldn&#39;t have</code> left him.</em> 如果我是南希，我不会离开他（南希已经离开了他）</p>\n<p><code>had not been for</code> 表示 “要不是“</p>\n<p><em>If it <code>hadn&#39;t been</code> for your timely help, we <code>would have</code> got into serious trouble.</em></p>\n<h4 id=\"1-3-错综时间条件句\"><a href=\"#1-3-错综时间条件句\" class=\"headerlink\" title=\"1.3 错综时间条件句\"></a>1.3 错综时间条件句</h4><p>有些条件句主句谓语和从句谓语在时间上并不一致（不符合上述两点）</p>\n<p><em>If you <code>had taken</code> her advice, you <code>wouldn&#39;t be</code> in such trouble now.</em></p>\n<p><em>If he <code>were leaving</code>, you <code>should have</code> heard about it.</em></p>\n<h4 id=\"1-4-含蓄条件句\"><a href=\"#1-4-含蓄条件句\" class=\"headerlink\" title=\"1.4 含蓄条件句\"></a>1.4 含蓄条件句</h4><p>隐含的条件句</p>\n<p><em>I might see her personally, it <code>would be</code> better.</em></p>\n<p><em>I did not press the point as it <code>would be</code> useless.</em></p>\n<p><em>In the old days she <code>would have</code> argued.</em></p>\n<p><em>I <code>wouldn&#39;t worry</code> about it.</em></p>\n<h4 id=\"1-5-委婉客气的语气，情态动词的使用（should-would-could-might）\"><a href=\"#1-5-委婉客气的语气，情态动词的使用（should-would-could-might）\" class=\"headerlink\" title=\"1.5 委婉客气的语气，情态动词的使用（should, would, could, might）\"></a>1.5 委婉客气的语气，情态动词的使用（should, would, could, might）</h4><p><em><code>Would</code> you mind shutting the window?</em></p>\n<p><em><code>Would</code> you tell me how to …</em></p>\n<p><em><code>Could</code> you lend me your computer?</em></p>\n<p><em>If necessary, you <code>might</code> shorten it.</em></p>\n<h3 id=\"2-虚拟语气在某些从句中的应用\"><a href=\"#2-虚拟语气在某些从句中的应用\" class=\"headerlink\" title=\"2. 虚拟语气在某些从句中的应用\"></a>2. 虚拟语气在某些从句中的应用</h3><h4 id=\"2-1-宾语从句\"><a href=\"#2-1-宾语从句\" class=\"headerlink\" title=\"2.1 宾语从句\"></a>2.1 宾语从句</h4><ol>\n<li><p><code>wish</code></p>\n<p>a. 与<strong>现在</strong>事实相反（<strong>be-&gt;were</strong>），<strong>过去式</strong></p>\n<p><em>I wish I <code>had</code> more time.</em>   还没有更多时间，但可能有</p>\n<p><em>I wish I <code>could</code> help you.</em> 我希望我能帮你（还没帮，未来可能帮，I wish I had helped you. 我希望我已经帮你，没帮已经是过去的事实了）</p>\n<p><em>I wish I <code>were</code>(was) young again.  // 用 was 也行</em></p>\n<p>b. 与<strong>过去</strong>事实相反，<strong>过去完成时</strong>，常表示<strong>遗憾</strong></p>\n<p><em>I wish I <code>had thought</code> what she really want.</em>  我没想过她真正想要什么，已经是事实了</p>\n<p><em>I wish I <code>had restrained</code> my emotion.</em>  我没有控制我的情感，已经是事实了</p>\n<p>c. 谈论<strong>将来</strong>的愿望，从句用 <code>would、could、might + do</code></p>\n<p><em>I wish I <code>could</code> do something for you in return. 我希望我能做点什么回报你</em></p>\n</li>\n<li><p><code>would rather</code></p>\n<p>谓语多用<strong>过去式</strong>，表<strong>现在、将来</strong></p>\n<p><em>I’d rather you <code>told</code> me the truth.</em>  我宁愿你给我讲真话</p>\n<p>suppose 虚拟+宾语从句（如果是对将来的假设，动词用过去时）</p>\n<p><em>Suppose her father turned her out of doors!</em></p>\n</li>\n<li><p><code>suggest</code>、<code>demand</code>、<code>insist</code>、<code>ask</code>等表示要求、命令、建议一类的动词</p>\n<p>从句用 <code>should + do</code>，但是 <code>should</code> 一般省略</p>\n<p><em>The doctor advised that he <code>change</code> the job.</em></p>\n<p><em>I propose that sb (should) <code>be</code> …</em></p>\n<p><em>He commanded that we (should) <code>attack</code> at once.</em></p>\n</li>\n</ol>\n<h4 id=\"2-2-主语从句、表语从句、同位语从句\"><a href=\"#2-2-主语从句、表语从句、同位语从句\" class=\"headerlink\" title=\"2.2 主语从句、表语从句、同位语从句\"></a>2.2 主语从句、表语从句、同位语从句</h4><p>从句用 <code>(should) do</code></p>\n<p><strong>主语从句</strong></p>\n<p><em>It’s important that he <code>work</code> hard.</em></p>\n<p><em>It’s _________ you <code>(should) not be</code> seen here. // 你不该出现在这里，这很…</em></p>\n<p><code>should do</code> 有时表达“竟然”的情感色彩</p>\n<p><em>It seems so unfair that this <code>should happen</code> to me.</em></p>\n<p><em>It’s strange that she <code>should be</code> so late. //真奇怪，她竟然来得这么晚</em></p>\n<p><strong>表语从句</strong></p>\n<p><em>Her idea was that they <code>should lock</code> up the house.</em></p>\n<p><strong>同位语从句</strong></p>\n<p><em>They expressed the wish that they <code>(should) be</code> given more free time.</em></p>\n<h4 id=\"3-状语从句\"><a href=\"#3-状语从句\" class=\"headerlink\" title=\"3. 状语从句\"></a>3. 状语从句</h4><ul>\n<li><p><code>as if</code>、<code>as though</code></p>\n<p>表示<strong>现在</strong>情况用<strong>过去式</strong>，表示<strong>过去</strong>情况用<strong>过去完成形式</strong></p>\n<p><em>I have loved you as if you <code>were</code> my son.</em></p>\n<p><em>I remember it as if it <code>happened</code> last night.</em></p>\n<p><em>He looks as though he <code>had known</code> Millie for years.</em> </p>\n<p>在 <code>look</code>、<code>seem</code>、<code>taste</code>、<code>smell</code> 后，<code>as if</code> 引导的从句可用<strong>陈述</strong>语气，大概率事件</p>\n<p><em>It looks as if they <code>are</code> in a terrible hurry.</em></p>\n<p><em>The meat tastes as if it <code>has</code> gone bad.</em></p>\n<p><code>as if (though)</code> 引导<strong>表语从句</strong></p>\n<p><em>You look as if you <code>didn&#39;t</code> care.</em></p>\n</li>\n<li><p><strong>让步状语从句</strong></p>\n<p><em>Whether she <code>be(is)</code> right or wrong, we will support her.</em></p>\n</li>\n<li><p><strong>目的状语</strong></p>\n<p>从句谓语多用 would、should、could、might</p>\n<p><em>I hired a boat so that I <code>could</code> go fish.</em></p>\n<p><em>He left early in order that the children <code>would</code> not be alone in the house.</em></p>\n</li>\n<li><p><strong>be+形容词，should+动词原形</strong>（张道真认为形容词后的从句为状语从句，有些认为是宾语从句）</p>\n<p><em>I’m <code>surprised</code> that you <code>should</code> press the suggestion. //我很奇怪你竟然坚持你的建议</em></p>\n<p><em>They’re especially <code>anxious</code> that you <code>should</code> come.  //他们特别期盼你能来</em></p>\n</li>\n</ul>\n<h3 id=\"虚拟语气的一些其他用法\"><a href=\"#虚拟语气的一些其他用法\" class=\"headerlink\" title=\"虚拟语气的一些其他用法\"></a>虚拟语气的一些其他用法</h3><p>只记录了较常见的</p>\n<ul>\n<li><p><code>It&#39;s (high) time</code> 后的定语从句中的虚拟语气</p>\n<p>多用<strong>过去虚拟</strong>语气</p>\n<p><em>It’s time we <code>went</code>.</em></p>\n<p><em>It’s time we <code>were</code> leaving.</em></p>\n<p><em>It’s high time you <code>made</code> up your mind.</em></p>\n</li>\n<li><p><code>would have thought</code></p>\n<p><em>Who <code>would have thought</code> to see you here!  //谁能想到会在这里看到你！</em></p>\n<p><em>Who <code>would have thought</code> it was going to break like that?</em>  </p>\n</li>\n</ul>\n<p>参考资料：<a href=\"https://book.douban.com/subject/1210225/\">张道真实用英语语法</a></p>\n"},{"_content":"### 有序容器(map, set, multimap, multiset)自定义比较器\n\n#### 1. 函数指针\n\n```c++\nbool my_fun(const my_Class &a, const my_Class &b){\n    return a.length() < b.length();\n}\nint main(){\n    set<my_Class, decltype(my_fun)*> st(my_fun); // 构造函数的参数也可以写为 st(&my_fun)\n    return 0;\n}\n```\n\n> 定义 set 的第二个参数应该是函数指针\n\n```c++\ndecltype(my_fun)*  //decltype的结果仅仅是函数类型，只有加上 * 才能获得函数指针\n```\n\n用 `my_fun` 或 `&my_fun` 作为构造函数的参数\n\n> 对函数名来讲，加不加星号（都表示函数类型），取不取地址（都表示函数地址，函数指针类型），没区别\n\n#### 2. 仿函数\n\n#### 3. Lambda表达式\n\n","source":"_posts/C++基础/STL/自定义比较器.md","raw":"### 有序容器(map, set, multimap, multiset)自定义比较器\n\n#### 1. 函数指针\n\n```c++\nbool my_fun(const my_Class &a, const my_Class &b){\n    return a.length() < b.length();\n}\nint main(){\n    set<my_Class, decltype(my_fun)*> st(my_fun); // 构造函数的参数也可以写为 st(&my_fun)\n    return 0;\n}\n```\n\n> 定义 set 的第二个参数应该是函数指针\n\n```c++\ndecltype(my_fun)*  //decltype的结果仅仅是函数类型，只有加上 * 才能获得函数指针\n```\n\n用 `my_fun` 或 `&my_fun` 作为构造函数的参数\n\n> 对函数名来讲，加不加星号（都表示函数类型），取不取地址（都表示函数地址，函数指针类型），没区别\n\n#### 2. 仿函数\n\n#### 3. Lambda表达式\n\n","slug":"C++基础/STL/自定义比较器","published":1,"date":"2021-12-31T02:09:01.548Z","updated":"2021-11-13T11:43:11.375Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckxzva9fr000h7cu30mv3bggt","content":"<h3 id=\"有序容器-map-set-multimap-multiset-自定义比较器\"><a href=\"#有序容器-map-set-multimap-multiset-自定义比较器\" class=\"headerlink\" title=\"有序容器(map, set, multimap, multiset)自定义比较器\"></a>有序容器(map, set, multimap, multiset)自定义比较器</h3><h4 id=\"1-函数指针\"><a href=\"#1-函数指针\" class=\"headerlink\" title=\"1. 函数指针\"></a>1. 函数指针</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">my_fun</span><span class=\"params\">(<span class=\"keyword\">const</span> my_Class &amp;a, <span class=\"keyword\">const</span> my_Class &amp;b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a.<span class=\"built_in\">length</span>() &lt; b.<span class=\"built_in\">length</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">set&lt;my_Class, <span class=\"title\">decltype</span><span class=\"params\">(my_fun)</span>*&gt; <span class=\"title\">st</span><span class=\"params\">(my_fun)</span></span>; <span class=\"comment\">// 构造函数的参数也可以写为 st(&amp;my_fun)</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>定义 set 的第二个参数应该是函数指针</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">decltype</span>(my_fun)*  <span class=\"comment\">//decltype的结果仅仅是函数类型，只有加上 * 才能获得函数指针</span></span><br></pre></td></tr></table></figure>\n\n<p>用 <code>my_fun</code> 或 <code>&amp;my_fun</code> 作为构造函数的参数</p>\n<blockquote>\n<p>对函数名来讲，加不加星号（都表示函数类型），取不取地址（都表示函数地址，函数指针类型），没区别</p>\n</blockquote>\n<h4 id=\"2-仿函数\"><a href=\"#2-仿函数\" class=\"headerlink\" title=\"2. 仿函数\"></a>2. 仿函数</h4><h4 id=\"3-Lambda表达式\"><a href=\"#3-Lambda表达式\" class=\"headerlink\" title=\"3. Lambda表达式\"></a>3. Lambda表达式</h4>","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<h3 id=\"有序容器-map-set-multimap-multiset-自定义比较器\"><a href=\"#有序容器-map-set-multimap-multiset-自定义比较器\" class=\"headerlink\" title=\"有序容器(map, set, multimap, multiset)自定义比较器\"></a>有序容器(map, set, multimap, multiset)自定义比较器</h3><h4 id=\"1-函数指针\"><a href=\"#1-函数指针\" class=\"headerlink\" title=\"1. 函数指针\"></a>1. 函数指针</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">my_fun</span><span class=\"params\">(<span class=\"keyword\">const</span> my_Class &amp;a, <span class=\"keyword\">const</span> my_Class &amp;b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a.<span class=\"built_in\">length</span>() &lt; b.<span class=\"built_in\">length</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">set&lt;my_Class, <span class=\"title\">decltype</span><span class=\"params\">(my_fun)</span>*&gt; <span class=\"title\">st</span><span class=\"params\">(my_fun)</span></span>; <span class=\"comment\">// 构造函数的参数也可以写为 st(&amp;my_fun)</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>定义 set 的第二个参数应该是函数指针</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">decltype</span>(my_fun)*  <span class=\"comment\">//decltype的结果仅仅是函数类型，只有加上 * 才能获得函数指针</span></span><br></pre></td></tr></table></figure>\n\n<p>用 <code>my_fun</code> 或 <code>&amp;my_fun</code> 作为构造函数的参数</p>\n<blockquote>\n<p>对函数名来讲，加不加星号（都表示函数类型），取不取地址（都表示函数地址，函数指针类型），没区别</p>\n</blockquote>\n<h4 id=\"2-仿函数\"><a href=\"#2-仿函数\" class=\"headerlink\" title=\"2. 仿函数\"></a>2. 仿函数</h4><h4 id=\"3-Lambda表达式\"><a href=\"#3-Lambda表达式\" class=\"headerlink\" title=\"3. Lambda表达式\"></a>3. Lambda表达式</h4>"},{"title":"拷贝初始化那些事儿","date":"2021-11-23T16:00:00.000Z","draft":false,"_content":"\n### 拷贝构造函数\n\n要么只有一个参数，此参数是自身类类型的常引用，要么多个参数，第一个参数为自身类类型的常引用，其他参数都有默认值\n\n```cpp\nclass Foo {\npublic:\n    Foo();\n    Foo(const  Foo&);  //可以用初始化列表，或在花括号里一一拷贝\n};\n```\n\n### 合成拷贝构造函数\n\n如果没有为类定义一个拷贝构造函数，编译器会自动生成一个合成拷贝构造函数，类自动生成的合成拷贝构造函数执行**浅拷贝**，依次拷贝每个非 `static` 成员\n\n### 直接初始化（无`=`号）\n\n匹配最佳的构造函数（注意也有可能匹配上拷贝构造函数）\n\n### 拷贝初始化\n\n使用拷贝初始化的常见四种情况：\n\n1. `=`号\n2. 函数非引用形参\n3. 函数非引用返回类型 \n4. 用花括号列表初始化一个数组中的元素或一个聚合类中的成员\n\n\n\n拷贝初始化有时候会使用**移动构造函数**而非**拷贝构造函数**\n\n```cpp\nclass Foo{\npublic:\n    Foo(Foo &&f){} //移动构造函数\n    Foo& operator=(Foo f){}\n};\n```\n\n观察：\n\n```cpp\n    Foo& operator=(Foo f){} //单一的赋值运算符实现了拷贝赋值运算符和移动赋值运算符两种可能\n```\n\n此运算符有一个非引用参数，所以要进行拷贝初始化\n\n依赖于实参的类型，拷贝初始化要么使用拷贝构造函数，要么使用移动构造函数——左值被拷贝，右值被移动\n\n```cpp\nhp = hp2; \t\t\t\t//拷贝构造函数来拷贝hp2\nhp = std::move(hp2);    //移动构造函数移动hp2\n```\n\n\n\n### 为什么拷贝构造函数自己的参数必须是引用类型？\n\n如果不是引用，则会调用拷贝构造函数，形成拷贝构造函数调用拷贝构造函数的死循环\n\n### 编译器可以绕过拷贝/移动构造函数\n\n拷贝初始化中，编译器可以选择跳过拷贝/移动构造函数，直接创建对象\n\n```cpp\nstring null_book = \"9999\"; //拷贝初始化\n```\n\n> **隐式类型转换（转换构造函数）**：只接受一个实参，或者其他参数都有默认参数\n>\n> 在需要类对象的时候，编译器可以根据已经有的一个参数，调用转换构造函数，自动创建一个（临时）对象\n\n正常来讲，字符串字面值`\"9999\"` 是`const char*`类型，由于要进行拷贝初始化，`=`号右边需要一个`string`对象，所以根据**隐式类型转换**，在需要`string`对象的时候，可以调用相应的**转换构造函数**，自动创建一个临时`string`对象：\n\n```cpp\nstring (const char* s); //from c-string (4)\t转换构造函数\n```\n\n有了临时`string`对象后，按理说要调用拷贝构造函数，完成对`null_book`的拷贝初始化\n\n然而，这里**并没有**调用拷贝构造函数，经测试**也没有**调用移动构造函数，原因是编译器对拷贝初始化表达式进行了改写\n\n把\n\n```cpp\nstring null_book = \"9999\"; //拷贝初始化\n```\n\n改写为\n\n```cpp\nstring null_book(\"9999\"); // 使临时对象成为要创建的对象\n```\n\n按理说被改写后应该属于（调用拷贝构造函数的）直接初始化\n\n但是在利用转换构造函数生成临时`string`对象后\n\n编译器直接使临时对象成为要创建的对象（编译器优化），所以没有调用拷贝/移动构造函数\n\n其他例子：\n\n```cpp\nclass Foo {\npublic:\n    Foo() = default;\n    Foo(const Foo& other) :len(other.len) { cout << \"拷贝构造函数！\" << endl; }  //拷贝构造函数\n    Foo(int length) :len(length) { cout << \"转换构造函数\" << endl; } \t\t       //转换构造函数\n    Foo(Foo&&) { cout << \"移动构造函数\" << endl; } \t\t\t\t\t\t\t   //移动构造函数\n    Foo& temp_f(Foo temp) {\n        return *this;\n    }\nprivate:\n    int len;\n};\n\nint main() {\n    Foo c = 10; //本身为拷贝初始化，编译器将其改写为下一行的语句，不会调用拷贝/移动构造函数！\n    Foo c(10);  //不会调用拷贝/移动构造函数！\n    c.temp_f(10); // 虽然形参非引用，但是也不会调用拷贝/移动构造函数！\n    return 0;\n}\n```\n\n解析一下这个：\n\n```cpp\nc.temp_f(10); // 虽然形参非引用，但是也不会调用拷贝/移动构造函数！\n```\n\n形参非引用，参数`10`被作为参数传入，先会调用转换构造函数，使`10`被隐式转换为一个`Foo临时对象`\n\n注意，这个对象是临时的，临时量具有常量性（`const`属性）\n\n常量性意味着：\n\n1. 如果`temp_f`的形参是`左值引用&`，将会报错，左值引用不能接受一个`const`值\n\n2. 如果`temp_f`的形参是`常量引用const&`或`右值引用&&`，不会报错，因为是引用了，当然也不会调用拷贝构造函数\n\n3. 如果`temp_f`的形参是`普通左值`：\n\n   ```cpp\n   Foo& temp_f(Foo temp);\n   ```\n\n   普通左值可以接受`const值`或`右值`，因为这就`直接拷贝`了，`const值`或`右值`没有被改变的风险\n\n   例如：\n\n   ```cpp\n   int i = 42;const int ci = i;int j = ci;  // ci的常量特征仅仅在执行改变ci的操作时才会发挥作用，一旦拷贝完成，新的对象就和原来的对象没什么关系了\n   ```\n\n   然后按理来说，函数形参非引用，应该是个拷贝初始化，调用拷贝构造函数\n\n   但是没有！因为传给 temp_f 是一个**匿名临时对象**！\n\n   只有一个对象对另一个同类型的对象进行初始化才会调用拷贝构造函数，但是<u>匿名对象对另一个同类型的对象初始化**不会**调用拷贝构造函数</u>，因为c++**编译器**对这种情况进行**优化**，直接将匿名对象转化为该对象，不需要进行额外的内存分配，提高了效率；\n\n   编译器在此时进行了优化，绕过了拷贝/移动构造函数，将`Foo临时对象`直接创建了`Foo对象`作为形参，所以并没有调用拷贝/移动构造函数！\n\n   参考解析：https://blog.csdn.net/weicao1990/article/details/81629955\n\n   > 即使编译器略过了拷贝/移动构造函数，但在这个程序点上，拷贝/移动构造函数必须是可存在且可访问的（必须是`public`的，不能是`private`）\n\n\n### 拷贝赋值运算符\n\n注意区分赋值和初始化\n\n返回类型为引用，形参为常引用：\n\n```cpp\nclass Foo {\npublic:\n    Foo& operator=(const Foo&); //赋值运算符\n}\n```\n\n> 拷贝赋值运算符=重载赋值运算符\n>\n> 重载赋值运算符的参数表示运算符的**运算对象**\n>\n> 如果一个运算符是成员函数（**赋值运算符必须定义为成员函数**），则其第一个参数肯定是**隐式this参数**，这也是该运算符的（**左侧**）运算对象\n>\n> - 如果是一元运算符，就只有这一个运算对象\n> - 如果是二元运算符（例如赋值运算符），其**右侧**运算对象作为**显示**参数传递\n\n如果类没有定义自己的拷贝赋值运算符，编译器会自动合成一个合成拷贝赋值运算符\n\n但是**合成拷贝赋值运算符**实行**浅**拷贝：\n\n![原生赋值运算符](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211124194517073.png)\n\n所以当对象中存在指针成员变量， 应该自定义新的拷贝赋值构造函数，执行**深**拷贝\n\n### 2. 对象移动\n\n#### 2.1 右值引用\n\n符号：`&&`\n\n右值引用只能绑定到一个将要销毁的对象（临时对象）\n\n左值引用不能被绑定到要求转换的表达式，字面常量或是返回右值的表达式，但右值引用可以，但不能将一个右值引用直接绑定到一个左值上\n\n- 返回左值的表达式（可以被`左值引用`绑定）：返回左值引用的函数，包括赋值、下标、解引用和前置递增/递减运算符\n- 返回右值的表达式（可以被`const左值引用`、`右值引用&&`绑定）：返回非引用类型的函数，包括算数、关系、位以及后置递增/递减运算符\n\n变量是持久的，包括右值引用类型的左值，所以<u>不能将一个右值引用绑定到一个右值引用类型的变量上</u>：\n\n```cpp\nint &&rr1 = 42;\nint &&rr2 = rr1; //错误！变量表达式 rr1 是左值\n```\n\n`std::move`显示地将左值转变为右值\n\n#### 2.2 移动构造函数（移动语义）\n\n以移动而非深拷贝的方式初始化含有指针成员的类对象\n\n移动构造函数的第一个参数为右值引用，任何额外的参数都必须有默认实参\n\n1. 指针资源交接\n2. 原来的指针应该指向`nullptr`\n\n浅拷贝+销毁=移动\n\n```cpp\n#include <iostream>\nusing namespace std;\nclass demo{\npublic:\n    demo():num(new int(0)){\n        cout<<\"construct!\"<<endl;\n    }\n    demo(const demo &d):num(new int(*d.num)){\n        cout<<\"copy construct!\"<<endl;\n    }\n    //添加移动构造函数\n    demo(demo &&d):num(d.num){\n        d.num = NULL;\n        cout<<\"move construct!\"<<endl;\n    }\n    ~demo(){\n        cout<<\"class destruct!\"<<endl;\n    }\nprivate:\n    int *num;\n};\ndemo get_demo(){\n    return demo();\n}\nint main(){\n    demo a = get_demo();\n    return 0;\n}\n\n//结果：为 demo 类添加移动构造函数之后，使用临时对象初始化 a 对象过程中产生的 2 次拷贝操作，都由移动构造函数完成\n```\n\n> 当类中同时包含拷贝构造函数和移动构造函数时，如果使用**临时对象**初始化当前类的对象，编译器会**优先调用移动构造函数**来完成此操作。\n>\n> 只有当类中没有合适的移动构造函数时，编译器才会退而求其次，用拷贝构造函数**代替**移动构造函数（赋值运算符的情况类类似）\n\n#### 2.3 移动赋值运算符\n\n```cpp\nStrVec& StrVec::operator=(StrVec &&rhs) {\n    //直接检测自赋值\n    if (this != &rhs) { //rhs是个右值引用变量表达式，所以它是个左值，所以可以对它取地址\n        free();    \t\t//释放已有元素\n        elements = rhs.elements; // 从rhs接管资源\n        first_free = rhs.first_free;\n        cap = rhs.cap;\n        // 将rhs置于可析构状态\n        rhs.elements = rhs.first_free = rhs.cap = nullptr;\n    }\n    return *this;\n}\n```\n\n#### 2.4 合成的移动操作\n\n如果一个类定义了自己的拷贝构造函数、拷贝赋值运算符或者析构函数，编译器就**不会自动合成**移动构造函数和移动赋值运算符\n\n仅当一个类没有定义任何自己版本的拷贝控制成员（三大件），且类的每个非static数据成员都可以移动时，编译器才会自动合成移动构造函数或移动赋值运算符\n\n可移动：\n\n- 内置类型总是可移动的\n- 类类型，要求该类有对应的移动操作\n\n```cpp\n//编译器会为X和hasX合成移动操作\nstruct X {\n    int i;  \t\t\t//内置类型可以移动\n    std::string s; \t\t//string定义了自己的移动操作\n};\nstruct hasX {\n    X mem;\t\t\t\t// X有合成的移动操作\n};\nX x, x2 = std::move(x); \t  //使用合成的移动构造操作\nhasX hx, hx2 = std::move(hx); //使用合成的移动构造函数\n```\n\n\n\n\n\n","source":"_posts/C++基础/拷贝控制/拷贝初始化.md","raw":"---\ntitle: \"拷贝初始化那些事儿\"\ndate: 2021-11-24\ndraft: false\ntags: [\"C/C++\"]\ncategories: [\"我为什么这么菜~~\"]\n\n---\n\n### 拷贝构造函数\n\n要么只有一个参数，此参数是自身类类型的常引用，要么多个参数，第一个参数为自身类类型的常引用，其他参数都有默认值\n\n```cpp\nclass Foo {\npublic:\n    Foo();\n    Foo(const  Foo&);  //可以用初始化列表，或在花括号里一一拷贝\n};\n```\n\n### 合成拷贝构造函数\n\n如果没有为类定义一个拷贝构造函数，编译器会自动生成一个合成拷贝构造函数，类自动生成的合成拷贝构造函数执行**浅拷贝**，依次拷贝每个非 `static` 成员\n\n### 直接初始化（无`=`号）\n\n匹配最佳的构造函数（注意也有可能匹配上拷贝构造函数）\n\n### 拷贝初始化\n\n使用拷贝初始化的常见四种情况：\n\n1. `=`号\n2. 函数非引用形参\n3. 函数非引用返回类型 \n4. 用花括号列表初始化一个数组中的元素或一个聚合类中的成员\n\n\n\n拷贝初始化有时候会使用**移动构造函数**而非**拷贝构造函数**\n\n```cpp\nclass Foo{\npublic:\n    Foo(Foo &&f){} //移动构造函数\n    Foo& operator=(Foo f){}\n};\n```\n\n观察：\n\n```cpp\n    Foo& operator=(Foo f){} //单一的赋值运算符实现了拷贝赋值运算符和移动赋值运算符两种可能\n```\n\n此运算符有一个非引用参数，所以要进行拷贝初始化\n\n依赖于实参的类型，拷贝初始化要么使用拷贝构造函数，要么使用移动构造函数——左值被拷贝，右值被移动\n\n```cpp\nhp = hp2; \t\t\t\t//拷贝构造函数来拷贝hp2\nhp = std::move(hp2);    //移动构造函数移动hp2\n```\n\n\n\n### 为什么拷贝构造函数自己的参数必须是引用类型？\n\n如果不是引用，则会调用拷贝构造函数，形成拷贝构造函数调用拷贝构造函数的死循环\n\n### 编译器可以绕过拷贝/移动构造函数\n\n拷贝初始化中，编译器可以选择跳过拷贝/移动构造函数，直接创建对象\n\n```cpp\nstring null_book = \"9999\"; //拷贝初始化\n```\n\n> **隐式类型转换（转换构造函数）**：只接受一个实参，或者其他参数都有默认参数\n>\n> 在需要类对象的时候，编译器可以根据已经有的一个参数，调用转换构造函数，自动创建一个（临时）对象\n\n正常来讲，字符串字面值`\"9999\"` 是`const char*`类型，由于要进行拷贝初始化，`=`号右边需要一个`string`对象，所以根据**隐式类型转换**，在需要`string`对象的时候，可以调用相应的**转换构造函数**，自动创建一个临时`string`对象：\n\n```cpp\nstring (const char* s); //from c-string (4)\t转换构造函数\n```\n\n有了临时`string`对象后，按理说要调用拷贝构造函数，完成对`null_book`的拷贝初始化\n\n然而，这里**并没有**调用拷贝构造函数，经测试**也没有**调用移动构造函数，原因是编译器对拷贝初始化表达式进行了改写\n\n把\n\n```cpp\nstring null_book = \"9999\"; //拷贝初始化\n```\n\n改写为\n\n```cpp\nstring null_book(\"9999\"); // 使临时对象成为要创建的对象\n```\n\n按理说被改写后应该属于（调用拷贝构造函数的）直接初始化\n\n但是在利用转换构造函数生成临时`string`对象后\n\n编译器直接使临时对象成为要创建的对象（编译器优化），所以没有调用拷贝/移动构造函数\n\n其他例子：\n\n```cpp\nclass Foo {\npublic:\n    Foo() = default;\n    Foo(const Foo& other) :len(other.len) { cout << \"拷贝构造函数！\" << endl; }  //拷贝构造函数\n    Foo(int length) :len(length) { cout << \"转换构造函数\" << endl; } \t\t       //转换构造函数\n    Foo(Foo&&) { cout << \"移动构造函数\" << endl; } \t\t\t\t\t\t\t   //移动构造函数\n    Foo& temp_f(Foo temp) {\n        return *this;\n    }\nprivate:\n    int len;\n};\n\nint main() {\n    Foo c = 10; //本身为拷贝初始化，编译器将其改写为下一行的语句，不会调用拷贝/移动构造函数！\n    Foo c(10);  //不会调用拷贝/移动构造函数！\n    c.temp_f(10); // 虽然形参非引用，但是也不会调用拷贝/移动构造函数！\n    return 0;\n}\n```\n\n解析一下这个：\n\n```cpp\nc.temp_f(10); // 虽然形参非引用，但是也不会调用拷贝/移动构造函数！\n```\n\n形参非引用，参数`10`被作为参数传入，先会调用转换构造函数，使`10`被隐式转换为一个`Foo临时对象`\n\n注意，这个对象是临时的，临时量具有常量性（`const`属性）\n\n常量性意味着：\n\n1. 如果`temp_f`的形参是`左值引用&`，将会报错，左值引用不能接受一个`const`值\n\n2. 如果`temp_f`的形参是`常量引用const&`或`右值引用&&`，不会报错，因为是引用了，当然也不会调用拷贝构造函数\n\n3. 如果`temp_f`的形参是`普通左值`：\n\n   ```cpp\n   Foo& temp_f(Foo temp);\n   ```\n\n   普通左值可以接受`const值`或`右值`，因为这就`直接拷贝`了，`const值`或`右值`没有被改变的风险\n\n   例如：\n\n   ```cpp\n   int i = 42;const int ci = i;int j = ci;  // ci的常量特征仅仅在执行改变ci的操作时才会发挥作用，一旦拷贝完成，新的对象就和原来的对象没什么关系了\n   ```\n\n   然后按理来说，函数形参非引用，应该是个拷贝初始化，调用拷贝构造函数\n\n   但是没有！因为传给 temp_f 是一个**匿名临时对象**！\n\n   只有一个对象对另一个同类型的对象进行初始化才会调用拷贝构造函数，但是<u>匿名对象对另一个同类型的对象初始化**不会**调用拷贝构造函数</u>，因为c++**编译器**对这种情况进行**优化**，直接将匿名对象转化为该对象，不需要进行额外的内存分配，提高了效率；\n\n   编译器在此时进行了优化，绕过了拷贝/移动构造函数，将`Foo临时对象`直接创建了`Foo对象`作为形参，所以并没有调用拷贝/移动构造函数！\n\n   参考解析：https://blog.csdn.net/weicao1990/article/details/81629955\n\n   > 即使编译器略过了拷贝/移动构造函数，但在这个程序点上，拷贝/移动构造函数必须是可存在且可访问的（必须是`public`的，不能是`private`）\n\n\n### 拷贝赋值运算符\n\n注意区分赋值和初始化\n\n返回类型为引用，形参为常引用：\n\n```cpp\nclass Foo {\npublic:\n    Foo& operator=(const Foo&); //赋值运算符\n}\n```\n\n> 拷贝赋值运算符=重载赋值运算符\n>\n> 重载赋值运算符的参数表示运算符的**运算对象**\n>\n> 如果一个运算符是成员函数（**赋值运算符必须定义为成员函数**），则其第一个参数肯定是**隐式this参数**，这也是该运算符的（**左侧**）运算对象\n>\n> - 如果是一元运算符，就只有这一个运算对象\n> - 如果是二元运算符（例如赋值运算符），其**右侧**运算对象作为**显示**参数传递\n\n如果类没有定义自己的拷贝赋值运算符，编译器会自动合成一个合成拷贝赋值运算符\n\n但是**合成拷贝赋值运算符**实行**浅**拷贝：\n\n![原生赋值运算符](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211124194517073.png)\n\n所以当对象中存在指针成员变量， 应该自定义新的拷贝赋值构造函数，执行**深**拷贝\n\n### 2. 对象移动\n\n#### 2.1 右值引用\n\n符号：`&&`\n\n右值引用只能绑定到一个将要销毁的对象（临时对象）\n\n左值引用不能被绑定到要求转换的表达式，字面常量或是返回右值的表达式，但右值引用可以，但不能将一个右值引用直接绑定到一个左值上\n\n- 返回左值的表达式（可以被`左值引用`绑定）：返回左值引用的函数，包括赋值、下标、解引用和前置递增/递减运算符\n- 返回右值的表达式（可以被`const左值引用`、`右值引用&&`绑定）：返回非引用类型的函数，包括算数、关系、位以及后置递增/递减运算符\n\n变量是持久的，包括右值引用类型的左值，所以<u>不能将一个右值引用绑定到一个右值引用类型的变量上</u>：\n\n```cpp\nint &&rr1 = 42;\nint &&rr2 = rr1; //错误！变量表达式 rr1 是左值\n```\n\n`std::move`显示地将左值转变为右值\n\n#### 2.2 移动构造函数（移动语义）\n\n以移动而非深拷贝的方式初始化含有指针成员的类对象\n\n移动构造函数的第一个参数为右值引用，任何额外的参数都必须有默认实参\n\n1. 指针资源交接\n2. 原来的指针应该指向`nullptr`\n\n浅拷贝+销毁=移动\n\n```cpp\n#include <iostream>\nusing namespace std;\nclass demo{\npublic:\n    demo():num(new int(0)){\n        cout<<\"construct!\"<<endl;\n    }\n    demo(const demo &d):num(new int(*d.num)){\n        cout<<\"copy construct!\"<<endl;\n    }\n    //添加移动构造函数\n    demo(demo &&d):num(d.num){\n        d.num = NULL;\n        cout<<\"move construct!\"<<endl;\n    }\n    ~demo(){\n        cout<<\"class destruct!\"<<endl;\n    }\nprivate:\n    int *num;\n};\ndemo get_demo(){\n    return demo();\n}\nint main(){\n    demo a = get_demo();\n    return 0;\n}\n\n//结果：为 demo 类添加移动构造函数之后，使用临时对象初始化 a 对象过程中产生的 2 次拷贝操作，都由移动构造函数完成\n```\n\n> 当类中同时包含拷贝构造函数和移动构造函数时，如果使用**临时对象**初始化当前类的对象，编译器会**优先调用移动构造函数**来完成此操作。\n>\n> 只有当类中没有合适的移动构造函数时，编译器才会退而求其次，用拷贝构造函数**代替**移动构造函数（赋值运算符的情况类类似）\n\n#### 2.3 移动赋值运算符\n\n```cpp\nStrVec& StrVec::operator=(StrVec &&rhs) {\n    //直接检测自赋值\n    if (this != &rhs) { //rhs是个右值引用变量表达式，所以它是个左值，所以可以对它取地址\n        free();    \t\t//释放已有元素\n        elements = rhs.elements; // 从rhs接管资源\n        first_free = rhs.first_free;\n        cap = rhs.cap;\n        // 将rhs置于可析构状态\n        rhs.elements = rhs.first_free = rhs.cap = nullptr;\n    }\n    return *this;\n}\n```\n\n#### 2.4 合成的移动操作\n\n如果一个类定义了自己的拷贝构造函数、拷贝赋值运算符或者析构函数，编译器就**不会自动合成**移动构造函数和移动赋值运算符\n\n仅当一个类没有定义任何自己版本的拷贝控制成员（三大件），且类的每个非static数据成员都可以移动时，编译器才会自动合成移动构造函数或移动赋值运算符\n\n可移动：\n\n- 内置类型总是可移动的\n- 类类型，要求该类有对应的移动操作\n\n```cpp\n//编译器会为X和hasX合成移动操作\nstruct X {\n    int i;  \t\t\t//内置类型可以移动\n    std::string s; \t\t//string定义了自己的移动操作\n};\nstruct hasX {\n    X mem;\t\t\t\t// X有合成的移动操作\n};\nX x, x2 = std::move(x); \t  //使用合成的移动构造操作\nhasX hx, hx2 = std::move(hx); //使用合成的移动构造函数\n```\n\n\n\n\n\n","slug":"C++基础/拷贝控制/拷贝初始化","published":1,"updated":"2021-12-06T08:03:37.616Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckxzva9fs000i7cu38awh4tgw","content":"<h3 id=\"拷贝构造函数\"><a href=\"#拷贝构造函数\" class=\"headerlink\" title=\"拷贝构造函数\"></a>拷贝构造函数</h3><p>要么只有一个参数，此参数是自身类类型的常引用，要么多个参数，第一个参数为自身类类型的常引用，其他参数都有默认值</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Foo</span>();</span><br><span class=\"line\">    <span class=\"built_in\">Foo</span>(<span class=\"keyword\">const</span>  Foo&amp;);  <span class=\"comment\">//可以用初始化列表，或在花括号里一一拷贝</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"合成拷贝构造函数\"><a href=\"#合成拷贝构造函数\" class=\"headerlink\" title=\"合成拷贝构造函数\"></a>合成拷贝构造函数</h3><p>如果没有为类定义一个拷贝构造函数，编译器会自动生成一个合成拷贝构造函数，类自动生成的合成拷贝构造函数执行<strong>浅拷贝</strong>，依次拷贝每个非 <code>static</code> 成员</p>\n<h3 id=\"直接初始化（无-号）\"><a href=\"#直接初始化（无-号）\" class=\"headerlink\" title=\"直接初始化（无=号）\"></a>直接初始化（无<code>=</code>号）</h3><p>匹配最佳的构造函数（注意也有可能匹配上拷贝构造函数）</p>\n<h3 id=\"拷贝初始化\"><a href=\"#拷贝初始化\" class=\"headerlink\" title=\"拷贝初始化\"></a>拷贝初始化</h3><p>使用拷贝初始化的常见四种情况：</p>\n<ol>\n<li><code>=</code>号</li>\n<li>函数非引用形参</li>\n<li>函数非引用返回类型 </li>\n<li>用花括号列表初始化一个数组中的元素或一个聚合类中的成员</li>\n</ol>\n<p>拷贝初始化有时候会使用<strong>移动构造函数</strong>而非<strong>拷贝构造函数</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Foo</span>(Foo &amp;&amp;f)&#123;&#125; <span class=\"comment\">//移动构造函数</span></span><br><span class=\"line\">    Foo&amp; <span class=\"keyword\">operator</span>=(Foo f)&#123;&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>观察：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Foo&amp; <span class=\"keyword\">operator</span>=(Foo f)&#123;&#125; <span class=\"comment\">//单一的赋值运算符实现了拷贝赋值运算符和移动赋值运算符两种可能</span></span><br></pre></td></tr></table></figure>\n\n<p>此运算符有一个非引用参数，所以要进行拷贝初始化</p>\n<p>依赖于实参的类型，拷贝初始化要么使用拷贝构造函数，要么使用移动构造函数——左值被拷贝，右值被移动</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hp = hp2; \t\t\t\t<span class=\"comment\">//拷贝构造函数来拷贝hp2</span></span><br><span class=\"line\">hp = std::<span class=\"built_in\">move</span>(hp2);    <span class=\"comment\">//移动构造函数移动hp2</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"为什么拷贝构造函数自己的参数必须是引用类型？\"><a href=\"#为什么拷贝构造函数自己的参数必须是引用类型？\" class=\"headerlink\" title=\"为什么拷贝构造函数自己的参数必须是引用类型？\"></a>为什么拷贝构造函数自己的参数必须是引用类型？</h3><p>如果不是引用，则会调用拷贝构造函数，形成拷贝构造函数调用拷贝构造函数的死循环</p>\n<h3 id=\"编译器可以绕过拷贝-移动构造函数\"><a href=\"#编译器可以绕过拷贝-移动构造函数\" class=\"headerlink\" title=\"编译器可以绕过拷贝/移动构造函数\"></a>编译器可以绕过拷贝/移动构造函数</h3><p>拷贝初始化中，编译器可以选择跳过拷贝/移动构造函数，直接创建对象</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string null_book = <span class=\"string\">&quot;9999&quot;</span>; <span class=\"comment\">//拷贝初始化</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><strong>隐式类型转换（转换构造函数）</strong>：只接受一个实参，或者其他参数都有默认参数</p>\n<p>在需要类对象的时候，编译器可以根据已经有的一个参数，调用转换构造函数，自动创建一个（临时）对象</p>\n</blockquote>\n<p>正常来讲，字符串字面值<code>&quot;9999&quot;</code> 是<code>const char*</code>类型，由于要进行拷贝初始化，<code>=</code>号右边需要一个<code>string</code>对象，所以根据<strong>隐式类型转换</strong>，在需要<code>string</code>对象的时候，可以调用相应的<strong>转换构造函数</strong>，自动创建一个临时<code>string</code>对象：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">string</span> (<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* s); <span class=\"comment\">//from c-string (4)\t转换构造函数</span></span><br></pre></td></tr></table></figure>\n\n<p>有了临时<code>string</code>对象后，按理说要调用拷贝构造函数，完成对<code>null_book</code>的拷贝初始化</p>\n<p>然而，这里<strong>并没有</strong>调用拷贝构造函数，经测试<strong>也没有</strong>调用移动构造函数，原因是编译器对拷贝初始化表达式进行了改写</p>\n<p>把</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string null_book = <span class=\"string\">&quot;9999&quot;</span>; <span class=\"comment\">//拷贝初始化</span></span><br></pre></td></tr></table></figure>\n\n<p>改写为</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">string <span class=\"title\">null_book</span><span class=\"params\">(<span class=\"string\">&quot;9999&quot;</span>)</span></span>; <span class=\"comment\">// 使临时对象成为要创建的对象</span></span><br></pre></td></tr></table></figure>\n\n<p>按理说被改写后应该属于（调用拷贝构造函数的）直接初始化</p>\n<p>但是在利用转换构造函数生成临时<code>string</code>对象后</p>\n<p>编译器直接使临时对象成为要创建的对象（编译器优化），所以没有调用拷贝/移动构造函数</p>\n<p>其他例子：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Foo</span>() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\">    <span class=\"built_in\">Foo</span>(<span class=\"keyword\">const</span> Foo&amp; other) :<span class=\"built_in\">len</span>(other.len) &#123; cout &lt;&lt; <span class=\"string\">&quot;拷贝构造函数！&quot;</span> &lt;&lt; endl; &#125;  <span class=\"comment\">//拷贝构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">Foo</span>(<span class=\"keyword\">int</span> length) :<span class=\"built_in\">len</span>(length) &#123; cout &lt;&lt; <span class=\"string\">&quot;转换构造函数&quot;</span> &lt;&lt; endl; &#125; \t\t       <span class=\"comment\">//转换构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">Foo</span>(Foo&amp;&amp;) &#123; cout &lt;&lt; <span class=\"string\">&quot;移动构造函数&quot;</span> &lt;&lt; endl; &#125; \t\t\t\t\t\t\t   <span class=\"comment\">//移动构造函数</span></span><br><span class=\"line\">    <span class=\"function\">Foo&amp; <span class=\"title\">temp_f</span><span class=\"params\">(Foo temp)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Foo c = <span class=\"number\">10</span>; <span class=\"comment\">//本身为拷贝初始化，编译器将其改写为下一行的语句，不会调用拷贝/移动构造函数！</span></span><br><span class=\"line\">    <span class=\"function\">Foo <span class=\"title\">c</span><span class=\"params\">(<span class=\"number\">10</span>)</span></span>;  <span class=\"comment\">//不会调用拷贝/移动构造函数！</span></span><br><span class=\"line\">    c.<span class=\"built_in\">temp_f</span>(<span class=\"number\">10</span>); <span class=\"comment\">// 虽然形参非引用，但是也不会调用拷贝/移动构造函数！</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>解析一下这个：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">c.<span class=\"built_in\">temp_f</span>(<span class=\"number\">10</span>); <span class=\"comment\">// 虽然形参非引用，但是也不会调用拷贝/移动构造函数！</span></span><br></pre></td></tr></table></figure>\n\n<p>形参非引用，参数<code>10</code>被作为参数传入，先会调用转换构造函数，使<code>10</code>被隐式转换为一个<code>Foo临时对象</code></p>\n<p>注意，这个对象是临时的，临时量具有常量性（<code>const</code>属性）</p>\n<p>常量性意味着：</p>\n<ol>\n<li><p>如果<code>temp_f</code>的形参是<code>左值引用&amp;</code>，将会报错，左值引用不能接受一个<code>const</code>值</p>\n</li>\n<li><p>如果<code>temp_f</code>的形参是<code>常量引用const&amp;</code>或<code>右值引用&amp;&amp;</code>，不会报错，因为是引用了，当然也不会调用拷贝构造函数</p>\n</li>\n<li><p>如果<code>temp_f</code>的形参是<code>普通左值</code>：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Foo&amp; <span class=\"title\">temp_f</span><span class=\"params\">(Foo temp)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>普通左值可以接受<code>const值</code>或<code>右值</code>，因为这就<code>直接拷贝</code>了，<code>const值</code>或<code>右值</code>没有被改变的风险</p>\n<p>例如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">42</span>;<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> ci = i;<span class=\"keyword\">int</span> j = ci;  <span class=\"comment\">// ci的常量特征仅仅在执行改变ci的操作时才会发挥作用，一旦拷贝完成，新的对象就和原来的对象没什么关系了</span></span><br></pre></td></tr></table></figure>\n\n<p>然后按理来说，函数形参非引用，应该是个拷贝初始化，调用拷贝构造函数</p>\n<p>但是没有！因为传给 temp_f 是一个<strong>匿名临时对象</strong>！</p>\n<p>只有一个对象对另一个同类型的对象进行初始化才会调用拷贝构造函数，但是<u>匿名对象对另一个同类型的对象初始化<strong>不会</strong>调用拷贝构造函数</u>，因为c++<strong>编译器</strong>对这种情况进行<strong>优化</strong>，直接将匿名对象转化为该对象，不需要进行额外的内存分配，提高了效率；</p>\n<p>编译器在此时进行了优化，绕过了拷贝/移动构造函数，将<code>Foo临时对象</code>直接创建了<code>Foo对象</code>作为形参，所以并没有调用拷贝/移动构造函数！</p>\n<p>参考解析：<a href=\"https://blog.csdn.net/weicao1990/article/details/81629955\">https://blog.csdn.net/weicao1990/article/details/81629955</a></p>\n<blockquote>\n<p>即使编译器略过了拷贝/移动构造函数，但在这个程序点上，拷贝/移动构造函数必须是可存在且可访问的（必须是<code>public</code>的，不能是<code>private</code>）</p>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"拷贝赋值运算符\"><a href=\"#拷贝赋值运算符\" class=\"headerlink\" title=\"拷贝赋值运算符\"></a>拷贝赋值运算符</h3><p>注意区分赋值和初始化</p>\n<p>返回类型为引用，形参为常引用：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Foo&amp; <span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> Foo&amp;); <span class=\"comment\">//赋值运算符</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>拷贝赋值运算符=重载赋值运算符</p>\n<p>重载赋值运算符的参数表示运算符的<strong>运算对象</strong></p>\n<p>如果一个运算符是成员函数（<strong>赋值运算符必须定义为成员函数</strong>），则其第一个参数肯定是<strong>隐式this参数</strong>，这也是该运算符的（<strong>左侧</strong>）运算对象</p>\n<ul>\n<li>如果是一元运算符，就只有这一个运算对象</li>\n<li>如果是二元运算符（例如赋值运算符），其<strong>右侧</strong>运算对象作为<strong>显示</strong>参数传递</li>\n</ul>\n</blockquote>\n<p>如果类没有定义自己的拷贝赋值运算符，编译器会自动合成一个合成拷贝赋值运算符</p>\n<p>但是<strong>合成拷贝赋值运算符</strong>实行<strong>浅</strong>拷贝：</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211124194517073.png\" alt=\"原生赋值运算符\"></p>\n<p>所以当对象中存在指针成员变量， 应该自定义新的拷贝赋值构造函数，执行<strong>深</strong>拷贝</p>\n<h3 id=\"2-对象移动\"><a href=\"#2-对象移动\" class=\"headerlink\" title=\"2. 对象移动\"></a>2. 对象移动</h3><h4 id=\"2-1-右值引用\"><a href=\"#2-1-右值引用\" class=\"headerlink\" title=\"2.1 右值引用\"></a>2.1 右值引用</h4><p>符号：<code>&amp;&amp;</code></p>\n<p>右值引用只能绑定到一个将要销毁的对象（临时对象）</p>\n<p>左值引用不能被绑定到要求转换的表达式，字面常量或是返回右值的表达式，但右值引用可以，但不能将一个右值引用直接绑定到一个左值上</p>\n<ul>\n<li>返回左值的表达式（可以被<code>左值引用</code>绑定）：返回左值引用的函数，包括赋值、下标、解引用和前置递增/递减运算符</li>\n<li>返回右值的表达式（可以被<code>const左值引用</code>、<code>右值引用&amp;&amp;</code>绑定）：返回非引用类型的函数，包括算数、关系、位以及后置递增/递减运算符</li>\n</ul>\n<p>变量是持久的，包括右值引用类型的左值，所以<u>不能将一个右值引用绑定到一个右值引用类型的变量上</u>：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> &amp;&amp;rr1 = <span class=\"number\">42</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> &amp;&amp;rr2 = rr1; <span class=\"comment\">//错误！变量表达式 rr1 是左值</span></span><br></pre></td></tr></table></figure>\n\n<p><code>std::move</code>显示地将左值转变为右值</p>\n<h4 id=\"2-2-移动构造函数（移动语义）\"><a href=\"#2-2-移动构造函数（移动语义）\" class=\"headerlink\" title=\"2.2 移动构造函数（移动语义）\"></a>2.2 移动构造函数（移动语义）</h4><p>以移动而非深拷贝的方式初始化含有指针成员的类对象</p>\n<p>移动构造函数的第一个参数为右值引用，任何额外的参数都必须有默认实参</p>\n<ol>\n<li>指针资源交接</li>\n<li>原来的指针应该指向<code>nullptr</code></li>\n</ol>\n<p>浅拷贝+销毁=移动</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">demo</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">demo</span>():<span class=\"built_in\">num</span>(<span class=\"keyword\">new</span> <span class=\"built_in\"><span class=\"keyword\">int</span></span>(<span class=\"number\">0</span>))&#123;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;construct!&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">demo</span>(<span class=\"keyword\">const</span> demo &amp;d):<span class=\"built_in\">num</span>(<span class=\"keyword\">new</span> <span class=\"built_in\"><span class=\"keyword\">int</span></span>(*d.num))&#123;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;copy construct!&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//添加移动构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">demo</span>(demo &amp;&amp;d):<span class=\"built_in\">num</span>(d.num)&#123;</span><br><span class=\"line\">        d.num = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;move construct!&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ~<span class=\"built_in\">demo</span>()&#123;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;class destruct!&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *num;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\">demo <span class=\"title\">get_demo</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">demo</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    demo a = <span class=\"built_in\">get_demo</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//结果：为 demo 类添加移动构造函数之后，使用临时对象初始化 a 对象过程中产生的 2 次拷贝操作，都由移动构造函数完成</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>当类中同时包含拷贝构造函数和移动构造函数时，如果使用<strong>临时对象</strong>初始化当前类的对象，编译器会<strong>优先调用移动构造函数</strong>来完成此操作。</p>\n<p>只有当类中没有合适的移动构造函数时，编译器才会退而求其次，用拷贝构造函数<strong>代替</strong>移动构造函数（赋值运算符的情况类类似）</p>\n</blockquote>\n<h4 id=\"2-3-移动赋值运算符\"><a href=\"#2-3-移动赋值运算符\" class=\"headerlink\" title=\"2.3 移动赋值运算符\"></a>2.3 移动赋值运算符</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">StrVec&amp; StrVec::<span class=\"keyword\">operator</span>=(StrVec &amp;&amp;rhs) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//直接检测自赋值</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> != &amp;rhs) &#123; <span class=\"comment\">//rhs是个右值引用变量表达式，所以它是个左值，所以可以对它取地址</span></span><br><span class=\"line\">        <span class=\"built_in\">free</span>();    \t\t<span class=\"comment\">//释放已有元素</span></span><br><span class=\"line\">        elements = rhs.elements; <span class=\"comment\">// 从rhs接管资源</span></span><br><span class=\"line\">        first_free = rhs.first_free;</span><br><span class=\"line\">        cap = rhs.cap;</span><br><span class=\"line\">        <span class=\"comment\">// 将rhs置于可析构状态</span></span><br><span class=\"line\">        rhs.elements = rhs.first_free = rhs.cap = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-4-合成的移动操作\"><a href=\"#2-4-合成的移动操作\" class=\"headerlink\" title=\"2.4 合成的移动操作\"></a>2.4 合成的移动操作</h4><p>如果一个类定义了自己的拷贝构造函数、拷贝赋值运算符或者析构函数，编译器就<strong>不会自动合成</strong>移动构造函数和移动赋值运算符</p>\n<p>仅当一个类没有定义任何自己版本的拷贝控制成员（三大件），且类的每个非static数据成员都可以移动时，编译器才会自动合成移动构造函数或移动赋值运算符</p>\n<p>可移动：</p>\n<ul>\n<li>内置类型总是可移动的</li>\n<li>类类型，要求该类有对应的移动操作</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//编译器会为X和hasX合成移动操作</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">X</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;  \t\t\t<span class=\"comment\">//内置类型可以移动</span></span><br><span class=\"line\">    std::string s; \t\t<span class=\"comment\">//string定义了自己的移动操作</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">hasX</span> &#123;</span></span><br><span class=\"line\">    X mem;\t\t\t\t<span class=\"comment\">// X有合成的移动操作</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">X x, x2 = std::<span class=\"built_in\">move</span>(x); \t  <span class=\"comment\">//使用合成的移动构造操作</span></span><br><span class=\"line\">hasX hx, hx2 = std::<span class=\"built_in\">move</span>(hx); <span class=\"comment\">//使用合成的移动构造函数</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<h3 id=\"拷贝构造函数\"><a href=\"#拷贝构造函数\" class=\"headerlink\" title=\"拷贝构造函数\"></a>拷贝构造函数</h3><p>要么只有一个参数，此参数是自身类类型的常引用，要么多个参数，第一个参数为自身类类型的常引用，其他参数都有默认值</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Foo</span>();</span><br><span class=\"line\">    <span class=\"built_in\">Foo</span>(<span class=\"keyword\">const</span>  Foo&amp;);  <span class=\"comment\">//可以用初始化列表，或在花括号里一一拷贝</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"合成拷贝构造函数\"><a href=\"#合成拷贝构造函数\" class=\"headerlink\" title=\"合成拷贝构造函数\"></a>合成拷贝构造函数</h3><p>如果没有为类定义一个拷贝构造函数，编译器会自动生成一个合成拷贝构造函数，类自动生成的合成拷贝构造函数执行<strong>浅拷贝</strong>，依次拷贝每个非 <code>static</code> 成员</p>\n<h3 id=\"直接初始化（无-号）\"><a href=\"#直接初始化（无-号）\" class=\"headerlink\" title=\"直接初始化（无=号）\"></a>直接初始化（无<code>=</code>号）</h3><p>匹配最佳的构造函数（注意也有可能匹配上拷贝构造函数）</p>\n<h3 id=\"拷贝初始化\"><a href=\"#拷贝初始化\" class=\"headerlink\" title=\"拷贝初始化\"></a>拷贝初始化</h3><p>使用拷贝初始化的常见四种情况：</p>\n<ol>\n<li><code>=</code>号</li>\n<li>函数非引用形参</li>\n<li>函数非引用返回类型 </li>\n<li>用花括号列表初始化一个数组中的元素或一个聚合类中的成员</li>\n</ol>\n<p>拷贝初始化有时候会使用<strong>移动构造函数</strong>而非<strong>拷贝构造函数</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Foo</span>(Foo &amp;&amp;f)&#123;&#125; <span class=\"comment\">//移动构造函数</span></span><br><span class=\"line\">    Foo&amp; <span class=\"keyword\">operator</span>=(Foo f)&#123;&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>观察：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Foo&amp; <span class=\"keyword\">operator</span>=(Foo f)&#123;&#125; <span class=\"comment\">//单一的赋值运算符实现了拷贝赋值运算符和移动赋值运算符两种可能</span></span><br></pre></td></tr></table></figure>\n\n<p>此运算符有一个非引用参数，所以要进行拷贝初始化</p>\n<p>依赖于实参的类型，拷贝初始化要么使用拷贝构造函数，要么使用移动构造函数——左值被拷贝，右值被移动</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hp = hp2; \t\t\t\t<span class=\"comment\">//拷贝构造函数来拷贝hp2</span></span><br><span class=\"line\">hp = std::<span class=\"built_in\">move</span>(hp2);    <span class=\"comment\">//移动构造函数移动hp2</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"为什么拷贝构造函数自己的参数必须是引用类型？\"><a href=\"#为什么拷贝构造函数自己的参数必须是引用类型？\" class=\"headerlink\" title=\"为什么拷贝构造函数自己的参数必须是引用类型？\"></a>为什么拷贝构造函数自己的参数必须是引用类型？</h3><p>如果不是引用，则会调用拷贝构造函数，形成拷贝构造函数调用拷贝构造函数的死循环</p>\n<h3 id=\"编译器可以绕过拷贝-移动构造函数\"><a href=\"#编译器可以绕过拷贝-移动构造函数\" class=\"headerlink\" title=\"编译器可以绕过拷贝/移动构造函数\"></a>编译器可以绕过拷贝/移动构造函数</h3><p>拷贝初始化中，编译器可以选择跳过拷贝/移动构造函数，直接创建对象</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string null_book = <span class=\"string\">&quot;9999&quot;</span>; <span class=\"comment\">//拷贝初始化</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><strong>隐式类型转换（转换构造函数）</strong>：只接受一个实参，或者其他参数都有默认参数</p>\n<p>在需要类对象的时候，编译器可以根据已经有的一个参数，调用转换构造函数，自动创建一个（临时）对象</p>\n</blockquote>\n<p>正常来讲，字符串字面值<code>&quot;9999&quot;</code> 是<code>const char*</code>类型，由于要进行拷贝初始化，<code>=</code>号右边需要一个<code>string</code>对象，所以根据<strong>隐式类型转换</strong>，在需要<code>string</code>对象的时候，可以调用相应的<strong>转换构造函数</strong>，自动创建一个临时<code>string</code>对象：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">string</span> (<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* s); <span class=\"comment\">//from c-string (4)\t转换构造函数</span></span><br></pre></td></tr></table></figure>\n\n<p>有了临时<code>string</code>对象后，按理说要调用拷贝构造函数，完成对<code>null_book</code>的拷贝初始化</p>\n<p>然而，这里<strong>并没有</strong>调用拷贝构造函数，经测试<strong>也没有</strong>调用移动构造函数，原因是编译器对拷贝初始化表达式进行了改写</p>\n<p>把</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string null_book = <span class=\"string\">&quot;9999&quot;</span>; <span class=\"comment\">//拷贝初始化</span></span><br></pre></td></tr></table></figure>\n\n<p>改写为</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">string <span class=\"title\">null_book</span><span class=\"params\">(<span class=\"string\">&quot;9999&quot;</span>)</span></span>; <span class=\"comment\">// 使临时对象成为要创建的对象</span></span><br></pre></td></tr></table></figure>\n\n<p>按理说被改写后应该属于（调用拷贝构造函数的）直接初始化</p>\n<p>但是在利用转换构造函数生成临时<code>string</code>对象后</p>\n<p>编译器直接使临时对象成为要创建的对象（编译器优化），所以没有调用拷贝/移动构造函数</p>\n<p>其他例子：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Foo</span>() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\">    <span class=\"built_in\">Foo</span>(<span class=\"keyword\">const</span> Foo&amp; other) :<span class=\"built_in\">len</span>(other.len) &#123; cout &lt;&lt; <span class=\"string\">&quot;拷贝构造函数！&quot;</span> &lt;&lt; endl; &#125;  <span class=\"comment\">//拷贝构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">Foo</span>(<span class=\"keyword\">int</span> length) :<span class=\"built_in\">len</span>(length) &#123; cout &lt;&lt; <span class=\"string\">&quot;转换构造函数&quot;</span> &lt;&lt; endl; &#125; \t\t       <span class=\"comment\">//转换构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">Foo</span>(Foo&amp;&amp;) &#123; cout &lt;&lt; <span class=\"string\">&quot;移动构造函数&quot;</span> &lt;&lt; endl; &#125; \t\t\t\t\t\t\t   <span class=\"comment\">//移动构造函数</span></span><br><span class=\"line\">    <span class=\"function\">Foo&amp; <span class=\"title\">temp_f</span><span class=\"params\">(Foo temp)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Foo c = <span class=\"number\">10</span>; <span class=\"comment\">//本身为拷贝初始化，编译器将其改写为下一行的语句，不会调用拷贝/移动构造函数！</span></span><br><span class=\"line\">    <span class=\"function\">Foo <span class=\"title\">c</span><span class=\"params\">(<span class=\"number\">10</span>)</span></span>;  <span class=\"comment\">//不会调用拷贝/移动构造函数！</span></span><br><span class=\"line\">    c.<span class=\"built_in\">temp_f</span>(<span class=\"number\">10</span>); <span class=\"comment\">// 虽然形参非引用，但是也不会调用拷贝/移动构造函数！</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>解析一下这个：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">c.<span class=\"built_in\">temp_f</span>(<span class=\"number\">10</span>); <span class=\"comment\">// 虽然形参非引用，但是也不会调用拷贝/移动构造函数！</span></span><br></pre></td></tr></table></figure>\n\n<p>形参非引用，参数<code>10</code>被作为参数传入，先会调用转换构造函数，使<code>10</code>被隐式转换为一个<code>Foo临时对象</code></p>\n<p>注意，这个对象是临时的，临时量具有常量性（<code>const</code>属性）</p>\n<p>常量性意味着：</p>\n<ol>\n<li><p>如果<code>temp_f</code>的形参是<code>左值引用&amp;</code>，将会报错，左值引用不能接受一个<code>const</code>值</p>\n</li>\n<li><p>如果<code>temp_f</code>的形参是<code>常量引用const&amp;</code>或<code>右值引用&amp;&amp;</code>，不会报错，因为是引用了，当然也不会调用拷贝构造函数</p>\n</li>\n<li><p>如果<code>temp_f</code>的形参是<code>普通左值</code>：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Foo&amp; <span class=\"title\">temp_f</span><span class=\"params\">(Foo temp)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>普通左值可以接受<code>const值</code>或<code>右值</code>，因为这就<code>直接拷贝</code>了，<code>const值</code>或<code>右值</code>没有被改变的风险</p>\n<p>例如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">42</span>;<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> ci = i;<span class=\"keyword\">int</span> j = ci;  <span class=\"comment\">// ci的常量特征仅仅在执行改变ci的操作时才会发挥作用，一旦拷贝完成，新的对象就和原来的对象没什么关系了</span></span><br></pre></td></tr></table></figure>\n\n<p>然后按理来说，函数形参非引用，应该是个拷贝初始化，调用拷贝构造函数</p>\n<p>但是没有！因为传给 temp_f 是一个<strong>匿名临时对象</strong>！</p>\n<p>只有一个对象对另一个同类型的对象进行初始化才会调用拷贝构造函数，但是<u>匿名对象对另一个同类型的对象初始化<strong>不会</strong>调用拷贝构造函数</u>，因为c++<strong>编译器</strong>对这种情况进行<strong>优化</strong>，直接将匿名对象转化为该对象，不需要进行额外的内存分配，提高了效率；</p>\n<p>编译器在此时进行了优化，绕过了拷贝/移动构造函数，将<code>Foo临时对象</code>直接创建了<code>Foo对象</code>作为形参，所以并没有调用拷贝/移动构造函数！</p>\n<p>参考解析：<a href=\"https://blog.csdn.net/weicao1990/article/details/81629955\">https://blog.csdn.net/weicao1990/article/details/81629955</a></p>\n<blockquote>\n<p>即使编译器略过了拷贝/移动构造函数，但在这个程序点上，拷贝/移动构造函数必须是可存在且可访问的（必须是<code>public</code>的，不能是<code>private</code>）</p>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"拷贝赋值运算符\"><a href=\"#拷贝赋值运算符\" class=\"headerlink\" title=\"拷贝赋值运算符\"></a>拷贝赋值运算符</h3><p>注意区分赋值和初始化</p>\n<p>返回类型为引用，形参为常引用：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Foo&amp; <span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> Foo&amp;); <span class=\"comment\">//赋值运算符</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>拷贝赋值运算符=重载赋值运算符</p>\n<p>重载赋值运算符的参数表示运算符的<strong>运算对象</strong></p>\n<p>如果一个运算符是成员函数（<strong>赋值运算符必须定义为成员函数</strong>），则其第一个参数肯定是<strong>隐式this参数</strong>，这也是该运算符的（<strong>左侧</strong>）运算对象</p>\n<ul>\n<li>如果是一元运算符，就只有这一个运算对象</li>\n<li>如果是二元运算符（例如赋值运算符），其<strong>右侧</strong>运算对象作为<strong>显示</strong>参数传递</li>\n</ul>\n</blockquote>\n<p>如果类没有定义自己的拷贝赋值运算符，编译器会自动合成一个合成拷贝赋值运算符</p>\n<p>但是<strong>合成拷贝赋值运算符</strong>实行<strong>浅</strong>拷贝：</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211124194517073.png\" alt=\"原生赋值运算符\"></p>\n<p>所以当对象中存在指针成员变量， 应该自定义新的拷贝赋值构造函数，执行<strong>深</strong>拷贝</p>\n<h3 id=\"2-对象移动\"><a href=\"#2-对象移动\" class=\"headerlink\" title=\"2. 对象移动\"></a>2. 对象移动</h3><h4 id=\"2-1-右值引用\"><a href=\"#2-1-右值引用\" class=\"headerlink\" title=\"2.1 右值引用\"></a>2.1 右值引用</h4><p>符号：<code>&amp;&amp;</code></p>\n<p>右值引用只能绑定到一个将要销毁的对象（临时对象）</p>\n<p>左值引用不能被绑定到要求转换的表达式，字面常量或是返回右值的表达式，但右值引用可以，但不能将一个右值引用直接绑定到一个左值上</p>\n<ul>\n<li>返回左值的表达式（可以被<code>左值引用</code>绑定）：返回左值引用的函数，包括赋值、下标、解引用和前置递增/递减运算符</li>\n<li>返回右值的表达式（可以被<code>const左值引用</code>、<code>右值引用&amp;&amp;</code>绑定）：返回非引用类型的函数，包括算数、关系、位以及后置递增/递减运算符</li>\n</ul>\n<p>变量是持久的，包括右值引用类型的左值，所以<u>不能将一个右值引用绑定到一个右值引用类型的变量上</u>：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> &amp;&amp;rr1 = <span class=\"number\">42</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> &amp;&amp;rr2 = rr1; <span class=\"comment\">//错误！变量表达式 rr1 是左值</span></span><br></pre></td></tr></table></figure>\n\n<p><code>std::move</code>显示地将左值转变为右值</p>\n<h4 id=\"2-2-移动构造函数（移动语义）\"><a href=\"#2-2-移动构造函数（移动语义）\" class=\"headerlink\" title=\"2.2 移动构造函数（移动语义）\"></a>2.2 移动构造函数（移动语义）</h4><p>以移动而非深拷贝的方式初始化含有指针成员的类对象</p>\n<p>移动构造函数的第一个参数为右值引用，任何额外的参数都必须有默认实参</p>\n<ol>\n<li>指针资源交接</li>\n<li>原来的指针应该指向<code>nullptr</code></li>\n</ol>\n<p>浅拷贝+销毁=移动</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">demo</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">demo</span>():<span class=\"built_in\">num</span>(<span class=\"keyword\">new</span> <span class=\"built_in\"><span class=\"keyword\">int</span></span>(<span class=\"number\">0</span>))&#123;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;construct!&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">demo</span>(<span class=\"keyword\">const</span> demo &amp;d):<span class=\"built_in\">num</span>(<span class=\"keyword\">new</span> <span class=\"built_in\"><span class=\"keyword\">int</span></span>(*d.num))&#123;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;copy construct!&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//添加移动构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">demo</span>(demo &amp;&amp;d):<span class=\"built_in\">num</span>(d.num)&#123;</span><br><span class=\"line\">        d.num = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;move construct!&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ~<span class=\"built_in\">demo</span>()&#123;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;class destruct!&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *num;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\">demo <span class=\"title\">get_demo</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">demo</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    demo a = <span class=\"built_in\">get_demo</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//结果：为 demo 类添加移动构造函数之后，使用临时对象初始化 a 对象过程中产生的 2 次拷贝操作，都由移动构造函数完成</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>当类中同时包含拷贝构造函数和移动构造函数时，如果使用<strong>临时对象</strong>初始化当前类的对象，编译器会<strong>优先调用移动构造函数</strong>来完成此操作。</p>\n<p>只有当类中没有合适的移动构造函数时，编译器才会退而求其次，用拷贝构造函数<strong>代替</strong>移动构造函数（赋值运算符的情况类类似）</p>\n</blockquote>\n<h4 id=\"2-3-移动赋值运算符\"><a href=\"#2-3-移动赋值运算符\" class=\"headerlink\" title=\"2.3 移动赋值运算符\"></a>2.3 移动赋值运算符</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">StrVec&amp; StrVec::<span class=\"keyword\">operator</span>=(StrVec &amp;&amp;rhs) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//直接检测自赋值</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> != &amp;rhs) &#123; <span class=\"comment\">//rhs是个右值引用变量表达式，所以它是个左值，所以可以对它取地址</span></span><br><span class=\"line\">        <span class=\"built_in\">free</span>();    \t\t<span class=\"comment\">//释放已有元素</span></span><br><span class=\"line\">        elements = rhs.elements; <span class=\"comment\">// 从rhs接管资源</span></span><br><span class=\"line\">        first_free = rhs.first_free;</span><br><span class=\"line\">        cap = rhs.cap;</span><br><span class=\"line\">        <span class=\"comment\">// 将rhs置于可析构状态</span></span><br><span class=\"line\">        rhs.elements = rhs.first_free = rhs.cap = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-4-合成的移动操作\"><a href=\"#2-4-合成的移动操作\" class=\"headerlink\" title=\"2.4 合成的移动操作\"></a>2.4 合成的移动操作</h4><p>如果一个类定义了自己的拷贝构造函数、拷贝赋值运算符或者析构函数，编译器就<strong>不会自动合成</strong>移动构造函数和移动赋值运算符</p>\n<p>仅当一个类没有定义任何自己版本的拷贝控制成员（三大件），且类的每个非static数据成员都可以移动时，编译器才会自动合成移动构造函数或移动赋值运算符</p>\n<p>可移动：</p>\n<ul>\n<li>内置类型总是可移动的</li>\n<li>类类型，要求该类有对应的移动操作</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//编译器会为X和hasX合成移动操作</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">X</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;  \t\t\t<span class=\"comment\">//内置类型可以移动</span></span><br><span class=\"line\">    std::string s; \t\t<span class=\"comment\">//string定义了自己的移动操作</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">hasX</span> &#123;</span></span><br><span class=\"line\">    X mem;\t\t\t\t<span class=\"comment\">// X有合成的移动操作</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">X x, x2 = std::<span class=\"built_in\">move</span>(x); \t  <span class=\"comment\">//使用合成的移动构造操作</span></span><br><span class=\"line\">hasX hx, hx2 = std::<span class=\"built_in\">move</span>(hx); <span class=\"comment\">//使用合成的移动构造函数</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n"},{"_content":"## 继承中的类作用域\n\n如果一个名字在派生类作用域内无法正确解析，则编译器将在外层的基类作用域中寻找该名字的定义：\n\n![image-20211202155500117](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211202155500117.png)\n\n正因为类作用域有这种继承嵌套的关系，所以派生类才能像使用自己的成员一样使用基类的成员（所以虽然放在派生类那里，实际上还是基类的成员）\n\n### 1. 重载 vs. 覆盖 vs. 隐藏\n\n#### 1.1 重载\n\n1. 在同一个类中（与继承关系无关）\n2. `函数名`一样，`形参列表`（数目、类型、排列顺序）**不**一样\n3. 返回类型**随便**\n\n#### 1.2 覆盖\n\n1. 基类和派生类的关系\n\n2. 要求基类的是虚函数（如果虚函数被继承，则所有派生类中它都是虚函数）\n\n3. 函数名、形参列表**相同**\n\n4. 返回类型要么**相同**，要么可以自动类型转换\n\n   > 如果 `D` 由 `B` 派生得到，则基类的虚函数可以返回 `B*` 而派生类的对应函数可以返回 `D*`（要求从 `D` 到 `B` 的类型转换是可访问的）\n\n#### 1.3 隐藏\n\n不仅仅是函数，普通类成员也可以隐藏\n\n1. 基类和派生类的关系\n2. **同名** & **排除**覆盖的情况\n\n### 2. 名字查找与继承\n\n假定我们调用 `p->mem()` 或 `obj.mem()`，则依次执行以下4个步骤\n\n1. 首先确定 `p` 的静态类型\n\n2. 在 p 中的静态类型对应的类中查找 `mem`。\n\n   > - 查找名字，编译器从静态类型开始向上查找，直到找到就停止，或者到达继承链的顶端还没有找到，则编译器报错\n   >\n   > - 我们能使用哪些成员仍然是由静态类型决定的\n\n3. 一旦找到了 `mem`，就进行常规的类型检查，以确认对于当前找到的 mem，本次调用是否合法\n\n4. 假设调用合法，则编译器将根据调用的**是否是虚函数**而产生不同的代码：\n\n   - 如果**是虚函数**，且我们是**通过引用或指针**进行调用，则编译器产生的代码将进行动态绑定，在运行时确定到底运行该虚函数的哪个版本，依据对象的动态类型\n   - 如果**不是虚函数**，或者我们是**通过对象（而非引用或指针）**进行的调用，则编译器将产生一个常规的函数调用\n\n\n\n","source":"_posts/C++基础/类/名字查找与继承.md","raw":"## 继承中的类作用域\n\n如果一个名字在派生类作用域内无法正确解析，则编译器将在外层的基类作用域中寻找该名字的定义：\n\n![image-20211202155500117](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211202155500117.png)\n\n正因为类作用域有这种继承嵌套的关系，所以派生类才能像使用自己的成员一样使用基类的成员（所以虽然放在派生类那里，实际上还是基类的成员）\n\n### 1. 重载 vs. 覆盖 vs. 隐藏\n\n#### 1.1 重载\n\n1. 在同一个类中（与继承关系无关）\n2. `函数名`一样，`形参列表`（数目、类型、排列顺序）**不**一样\n3. 返回类型**随便**\n\n#### 1.2 覆盖\n\n1. 基类和派生类的关系\n\n2. 要求基类的是虚函数（如果虚函数被继承，则所有派生类中它都是虚函数）\n\n3. 函数名、形参列表**相同**\n\n4. 返回类型要么**相同**，要么可以自动类型转换\n\n   > 如果 `D` 由 `B` 派生得到，则基类的虚函数可以返回 `B*` 而派生类的对应函数可以返回 `D*`（要求从 `D` 到 `B` 的类型转换是可访问的）\n\n#### 1.3 隐藏\n\n不仅仅是函数，普通类成员也可以隐藏\n\n1. 基类和派生类的关系\n2. **同名** & **排除**覆盖的情况\n\n### 2. 名字查找与继承\n\n假定我们调用 `p->mem()` 或 `obj.mem()`，则依次执行以下4个步骤\n\n1. 首先确定 `p` 的静态类型\n\n2. 在 p 中的静态类型对应的类中查找 `mem`。\n\n   > - 查找名字，编译器从静态类型开始向上查找，直到找到就停止，或者到达继承链的顶端还没有找到，则编译器报错\n   >\n   > - 我们能使用哪些成员仍然是由静态类型决定的\n\n3. 一旦找到了 `mem`，就进行常规的类型检查，以确认对于当前找到的 mem，本次调用是否合法\n\n4. 假设调用合法，则编译器将根据调用的**是否是虚函数**而产生不同的代码：\n\n   - 如果**是虚函数**，且我们是**通过引用或指针**进行调用，则编译器产生的代码将进行动态绑定，在运行时确定到底运行该虚函数的哪个版本，依据对象的动态类型\n   - 如果**不是虚函数**，或者我们是**通过对象（而非引用或指针）**进行的调用，则编译器将产生一个常规的函数调用\n\n\n\n","slug":"C++基础/类/名字查找与继承","published":1,"date":"2021-12-31T02:09:01.608Z","updated":"2021-12-03T11:23:10.431Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckxzva9ft000k7cu3b8mqgnh0","content":"<h2 id=\"继承中的类作用域\"><a href=\"#继承中的类作用域\" class=\"headerlink\" title=\"继承中的类作用域\"></a>继承中的类作用域</h2><p>如果一个名字在派生类作用域内无法正确解析，则编译器将在外层的基类作用域中寻找该名字的定义：</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211202155500117.png\" alt=\"image-20211202155500117\"></p>\n<p>正因为类作用域有这种继承嵌套的关系，所以派生类才能像使用自己的成员一样使用基类的成员（所以虽然放在派生类那里，实际上还是基类的成员）</p>\n<h3 id=\"1-重载-vs-覆盖-vs-隐藏\"><a href=\"#1-重载-vs-覆盖-vs-隐藏\" class=\"headerlink\" title=\"1. 重载 vs. 覆盖 vs. 隐藏\"></a>1. 重载 vs. 覆盖 vs. 隐藏</h3><h4 id=\"1-1-重载\"><a href=\"#1-1-重载\" class=\"headerlink\" title=\"1.1 重载\"></a>1.1 重载</h4><ol>\n<li>在同一个类中（与继承关系无关）</li>\n<li><code>函数名</code>一样，<code>形参列表</code>（数目、类型、排列顺序）<strong>不</strong>一样</li>\n<li>返回类型<strong>随便</strong></li>\n</ol>\n<h4 id=\"1-2-覆盖\"><a href=\"#1-2-覆盖\" class=\"headerlink\" title=\"1.2 覆盖\"></a>1.2 覆盖</h4><ol>\n<li><p>基类和派生类的关系</p>\n</li>\n<li><p>要求基类的是虚函数（如果虚函数被继承，则所有派生类中它都是虚函数）</p>\n</li>\n<li><p>函数名、形参列表<strong>相同</strong></p>\n</li>\n<li><p>返回类型要么<strong>相同</strong>，要么可以自动类型转换</p>\n<blockquote>\n<p>如果 <code>D</code> 由 <code>B</code> 派生得到，则基类的虚函数可以返回 <code>B*</code> 而派生类的对应函数可以返回 <code>D*</code>（要求从 <code>D</code> 到 <code>B</code> 的类型转换是可访问的）</p>\n</blockquote>\n</li>\n</ol>\n<h4 id=\"1-3-隐藏\"><a href=\"#1-3-隐藏\" class=\"headerlink\" title=\"1.3 隐藏\"></a>1.3 隐藏</h4><p>不仅仅是函数，普通类成员也可以隐藏</p>\n<ol>\n<li>基类和派生类的关系</li>\n<li><strong>同名</strong> &amp; <strong>排除</strong>覆盖的情况</li>\n</ol>\n<h3 id=\"2-名字查找与继承\"><a href=\"#2-名字查找与继承\" class=\"headerlink\" title=\"2. 名字查找与继承\"></a>2. 名字查找与继承</h3><p>假定我们调用 <code>p-&gt;mem()</code> 或 <code>obj.mem()</code>，则依次执行以下4个步骤</p>\n<ol>\n<li><p>首先确定 <code>p</code> 的静态类型</p>\n</li>\n<li><p>在 p 中的静态类型对应的类中查找 <code>mem</code>。</p>\n<blockquote>\n<ul>\n<li><p>查找名字，编译器从静态类型开始向上查找，直到找到就停止，或者到达继承链的顶端还没有找到，则编译器报错</p>\n</li>\n<li><p>我们能使用哪些成员仍然是由静态类型决定的</p>\n</li>\n</ul>\n</blockquote>\n</li>\n<li><p>一旦找到了 <code>mem</code>，就进行常规的类型检查，以确认对于当前找到的 mem，本次调用是否合法</p>\n</li>\n<li><p>假设调用合法，则编译器将根据调用的<strong>是否是虚函数</strong>而产生不同的代码：</p>\n<ul>\n<li>如果<strong>是虚函数</strong>，且我们是<strong>通过引用或指针</strong>进行调用，则编译器产生的代码将进行动态绑定，在运行时确定到底运行该虚函数的哪个版本，依据对象的动态类型</li>\n<li>如果<strong>不是虚函数</strong>，或者我们是<strong>通过对象（而非引用或指针）</strong>进行的调用，则编译器将产生一个常规的函数调用</li>\n</ul>\n</li>\n</ol>\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<h2 id=\"继承中的类作用域\"><a href=\"#继承中的类作用域\" class=\"headerlink\" title=\"继承中的类作用域\"></a>继承中的类作用域</h2><p>如果一个名字在派生类作用域内无法正确解析，则编译器将在外层的基类作用域中寻找该名字的定义：</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211202155500117.png\" alt=\"image-20211202155500117\"></p>\n<p>正因为类作用域有这种继承嵌套的关系，所以派生类才能像使用自己的成员一样使用基类的成员（所以虽然放在派生类那里，实际上还是基类的成员）</p>\n<h3 id=\"1-重载-vs-覆盖-vs-隐藏\"><a href=\"#1-重载-vs-覆盖-vs-隐藏\" class=\"headerlink\" title=\"1. 重载 vs. 覆盖 vs. 隐藏\"></a>1. 重载 vs. 覆盖 vs. 隐藏</h3><h4 id=\"1-1-重载\"><a href=\"#1-1-重载\" class=\"headerlink\" title=\"1.1 重载\"></a>1.1 重载</h4><ol>\n<li>在同一个类中（与继承关系无关）</li>\n<li><code>函数名</code>一样，<code>形参列表</code>（数目、类型、排列顺序）<strong>不</strong>一样</li>\n<li>返回类型<strong>随便</strong></li>\n</ol>\n<h4 id=\"1-2-覆盖\"><a href=\"#1-2-覆盖\" class=\"headerlink\" title=\"1.2 覆盖\"></a>1.2 覆盖</h4><ol>\n<li><p>基类和派生类的关系</p>\n</li>\n<li><p>要求基类的是虚函数（如果虚函数被继承，则所有派生类中它都是虚函数）</p>\n</li>\n<li><p>函数名、形参列表<strong>相同</strong></p>\n</li>\n<li><p>返回类型要么<strong>相同</strong>，要么可以自动类型转换</p>\n<blockquote>\n<p>如果 <code>D</code> 由 <code>B</code> 派生得到，则基类的虚函数可以返回 <code>B*</code> 而派生类的对应函数可以返回 <code>D*</code>（要求从 <code>D</code> 到 <code>B</code> 的类型转换是可访问的）</p>\n</blockquote>\n</li>\n</ol>\n<h4 id=\"1-3-隐藏\"><a href=\"#1-3-隐藏\" class=\"headerlink\" title=\"1.3 隐藏\"></a>1.3 隐藏</h4><p>不仅仅是函数，普通类成员也可以隐藏</p>\n<ol>\n<li>基类和派生类的关系</li>\n<li><strong>同名</strong> &amp; <strong>排除</strong>覆盖的情况</li>\n</ol>\n<h3 id=\"2-名字查找与继承\"><a href=\"#2-名字查找与继承\" class=\"headerlink\" title=\"2. 名字查找与继承\"></a>2. 名字查找与继承</h3><p>假定我们调用 <code>p-&gt;mem()</code> 或 <code>obj.mem()</code>，则依次执行以下4个步骤</p>\n<ol>\n<li><p>首先确定 <code>p</code> 的静态类型</p>\n</li>\n<li><p>在 p 中的静态类型对应的类中查找 <code>mem</code>。</p>\n<blockquote>\n<ul>\n<li><p>查找名字，编译器从静态类型开始向上查找，直到找到就停止，或者到达继承链的顶端还没有找到，则编译器报错</p>\n</li>\n<li><p>我们能使用哪些成员仍然是由静态类型决定的</p>\n</li>\n</ul>\n</blockquote>\n</li>\n<li><p>一旦找到了 <code>mem</code>，就进行常规的类型检查，以确认对于当前找到的 mem，本次调用是否合法</p>\n</li>\n<li><p>假设调用合法，则编译器将根据调用的<strong>是否是虚函数</strong>而产生不同的代码：</p>\n<ul>\n<li>如果<strong>是虚函数</strong>，且我们是<strong>通过引用或指针</strong>进行调用，则编译器产生的代码将进行动态绑定，在运行时确定到底运行该虚函数的哪个版本，依据对象的动态类型</li>\n<li>如果<strong>不是虚函数</strong>，或者我们是<strong>通过对象（而非引用或指针）</strong>进行的调用，则编译器将产生一个常规的函数调用</li>\n</ul>\n</li>\n</ol>\n"},{"_content":"### \n\n\n\n### 1. 访问控制初探\n\n| 修饰符  | 类内成员函数、友元（类的实现者） | 类对象（普通用户） |\n| ------- | -------------------------------- | ------------------ |\n| public  | :heavy_check_mark:               | :heavy_check_mark: |\n| private | :heavy_check_mark:               | ❌                  |\n| protect | :heavy_check_mark:               | ❌                  |\n\n### 2. 友元函数\n\n```cpp\nclass Box\n{\npublic:\n   friend void printWidth(Box box);\n   void setWidth( double wid );\nprivate:\n   double width;    \n};\n\nvoid printWidth(Box box)\n{\n   /* 因为 printWidth() 是 Box 的友元，它可以直接访问该类的任何成员 */\n   cout << \"Width of box : \" << box.width <<endl;\n}\n```\n\n1. 友元函数**定义在类的外部**\n2. **有权访问**类的<u>所有**私有（private）**和**保护（protected）**成员</u>\n\n> `Box` 类对象作为 `printWidth` 的参数，然后友元函数定义中直接使用 `box.width`，因为有了友元，类的用户（类对象）也能直接访问 `private` 成员了\n\n### 3. protected\n\n对于基类的 protected 成员\n\n- <u>基类的用户（对象）</u>**不**可访问 `protected` 成员（类似于 `private`）\n\n- 基类的成员和友元当然能访问基类的 `protected` 成员\n\n- 派生类的成员和友元也能访问基类的 `protected` 成员（这里没有说明继承方式的影响）\n\n- 派生类的成员或友元只能访问**派生类对象**的**基类部分**的 `protected` 成员，**不能**通过**基类对象**访问 `protected` 成员\n\n  ```cpp\n  class Base {\n  public:\n      void pub_mem() {\n          cout << prot_mem << endl;\n      }\n  protected:\n      int prot_mem;\n  private:\n      char priv_mem;\n  };\n  \n  class Sneaky :public Base {\n  public:\n      \n      void clobber(Sneaky& s) {\n          cout << s.prot_mem << endl; //可以通过派生类对象访问该对象基类部分的 protected 成员\n          prot_mem = 1;\t\t\t    //这里可以理解为：通过this对象（仍是派生类对象）访问该对象基类部分的 protected 成员\n      }\n  \n      void cloober(Base& b) {\n          cout << b.prot_mem << endl; //错误，不能访问基类对象的 protected 成员\n          b.pub_mem();\n      }\n  };\n  ```\n\n  不论 `void cloober(Base& b)` 是派生类的成员或友元，它都**不能**访问**基类对象**的 protected 成员\n\n  > 注意在 `cloober` 中使用 `b.prot_mem` 理解为<u>`cloober`访问基类对象的 `protected` 成员</u>，而不是理解为<u>基类对象访问基类的 `protected` 成员</u>\n  >\n  > 如果 `b.prot_mem` 不在 `Sneaky` 的成员/友元函数中，而是在 `main` 函数中，那也是错误的“类对象不能访问类的 protected 成员\n\n  可以这样理解：因为对于一个**基类对象**而言，它本身就有“类对象不能访问类的 protected 成员“ 这个限制，而且基类对象的眼中是没有派生的概念的，所以凭什么一个派生类的成员/友元遇到它就要搞特殊啊，所以派生类对于<u>一个基类对象的 protected 成员</u>没有任何访问特权\n\n### 4. 公有、私有和受保护继承\n\n> 如果访问说明符被忽略掉了，则关键字`class`对应的默认访问说明符是`private`，关键字`struct`对应的`public`\n\n#### 1. `继承方式`（`派生访问说明符`）对于`派生类的成员/友元`能否访问其`直接基类的成员`<u>没有什么影响</u>，对基类成员的访问权限**只与**`基类中的访问说明符`有关\n\n#### 2. `继承方式`的目的是控制`派生类对象`（包括派生类的派生类在内——孙子）对于`基类成员`的访问权限\n\n```cpp\nclass Base {\npublic:\n    void pub_mem();\nprotected:\n    int prot_mem;\nprivate:\n    char priv_mem;\n};\n\nstruct Pub_Derv :public Base {\n    int f() { return prot_mem; }  //正确，派生类能访问protected成员\n\tchar g() { return priv_mem; } //错误，派生类无权访问private成员，即使priv_mem继承下来了\n    //（我有个想法，既然priv_mem继承下来了，给Pub_Derv自己也复制了一份，Pub_Derv类的成员/友元应该能访问自己的piv_mem，即使它是private的，但是事实是它不行!）\n    //继承的是基类的成员，它还是 Base::priv_mem，只是说位置在派生类的内存地址范围内，但是其前缀还是 Base:: 还是属于基类！所以派生类不能访问它——基类的private\n};\n\nstruct Priv_Derv :private Base {\n    int f() { return prot_mem; } //private的继承方式不影响派生类的访问权限\n\n};\n\nPub_Derv d1;   \t\t//继承自Base的成员是public的\nPriv_Derv d2; \t\t//继承自Base的成员是private的\nd1.pub_mem(); \t\t//正确，pub_mem()在派生类中是public的\nd2.pub_mem();\t\t//错误，pub_mem()在派生类中是private的\n```\n\n- `公有继承` ：派生类成员将遵循其原有的访问说明符（该是啥还是啥）\n- `私有继承`：继承过来的东西都是私有的，派生类对象不能直接访问\n- `保护继承`：基类的`public`成员将变为`protected`，其他两个不变\n\n> 继承方式类似于规定一种`上限`，任何超过这个上限的都要降级为这个上限。规定上限对于已经在上限中的元素是无影响的\n\n#### 3. 孙子的访问权限\n\n继承方式（派生类访问说明符）还可以控制继承自派生类的新类的访问权限\n\n```cpp\nstruct Derived_from_Public : public Pub_Derv {\n    int use_base() { return prot_mem; }  //正确，Base::prot_mem在Pub_Derv中仍然是protected的，所以Pub_Derv的儿子可以访问\n}\n\nstruct Derived_from_Private : public Priv_Derv {\n\tint use_base() { return prot_mem; } //错误，Base::prot_mem在Priv_Derv中是private的（由于private继承），所以Priv_Derv的儿子无权访问它直接基类的private成员\n}\n```\n\n### 5. 派生类向基类转换的可访问性\n\n即动态绑定，假定 `D` 继承自 `B`：\n\n- 仅当 `D` **公有继承** B 时，用户代码（main函数中）才能使用派生类向基类的转换；如果 `D` **受保护继承**或**私有继承**于 `B`，用户代码**不能**使用该转换\n- 不论 `D` 以什么方式继承 `B`，`D` 的<u>成员/友元</u>**总是能**使用派生类向基类的转换\n- 对于 `B` 的孙子，如果 `D` 继承 `B` 的方式是 `public` 的或 `protected`，则 <u>`D` 的派生类</u>的成员/友元可以使用 `D` 向 `B` 的类型转换。反之，如果 `D` 继承 `B` 的方式是 `private` 的，则不能使用 \n\n","source":"_posts/C++基础/类/访问控制与继承.md","raw":"### \n\n\n\n### 1. 访问控制初探\n\n| 修饰符  | 类内成员函数、友元（类的实现者） | 类对象（普通用户） |\n| ------- | -------------------------------- | ------------------ |\n| public  | :heavy_check_mark:               | :heavy_check_mark: |\n| private | :heavy_check_mark:               | ❌                  |\n| protect | :heavy_check_mark:               | ❌                  |\n\n### 2. 友元函数\n\n```cpp\nclass Box\n{\npublic:\n   friend void printWidth(Box box);\n   void setWidth( double wid );\nprivate:\n   double width;    \n};\n\nvoid printWidth(Box box)\n{\n   /* 因为 printWidth() 是 Box 的友元，它可以直接访问该类的任何成员 */\n   cout << \"Width of box : \" << box.width <<endl;\n}\n```\n\n1. 友元函数**定义在类的外部**\n2. **有权访问**类的<u>所有**私有（private）**和**保护（protected）**成员</u>\n\n> `Box` 类对象作为 `printWidth` 的参数，然后友元函数定义中直接使用 `box.width`，因为有了友元，类的用户（类对象）也能直接访问 `private` 成员了\n\n### 3. protected\n\n对于基类的 protected 成员\n\n- <u>基类的用户（对象）</u>**不**可访问 `protected` 成员（类似于 `private`）\n\n- 基类的成员和友元当然能访问基类的 `protected` 成员\n\n- 派生类的成员和友元也能访问基类的 `protected` 成员（这里没有说明继承方式的影响）\n\n- 派生类的成员或友元只能访问**派生类对象**的**基类部分**的 `protected` 成员，**不能**通过**基类对象**访问 `protected` 成员\n\n  ```cpp\n  class Base {\n  public:\n      void pub_mem() {\n          cout << prot_mem << endl;\n      }\n  protected:\n      int prot_mem;\n  private:\n      char priv_mem;\n  };\n  \n  class Sneaky :public Base {\n  public:\n      \n      void clobber(Sneaky& s) {\n          cout << s.prot_mem << endl; //可以通过派生类对象访问该对象基类部分的 protected 成员\n          prot_mem = 1;\t\t\t    //这里可以理解为：通过this对象（仍是派生类对象）访问该对象基类部分的 protected 成员\n      }\n  \n      void cloober(Base& b) {\n          cout << b.prot_mem << endl; //错误，不能访问基类对象的 protected 成员\n          b.pub_mem();\n      }\n  };\n  ```\n\n  不论 `void cloober(Base& b)` 是派生类的成员或友元，它都**不能**访问**基类对象**的 protected 成员\n\n  > 注意在 `cloober` 中使用 `b.prot_mem` 理解为<u>`cloober`访问基类对象的 `protected` 成员</u>，而不是理解为<u>基类对象访问基类的 `protected` 成员</u>\n  >\n  > 如果 `b.prot_mem` 不在 `Sneaky` 的成员/友元函数中，而是在 `main` 函数中，那也是错误的“类对象不能访问类的 protected 成员\n\n  可以这样理解：因为对于一个**基类对象**而言，它本身就有“类对象不能访问类的 protected 成员“ 这个限制，而且基类对象的眼中是没有派生的概念的，所以凭什么一个派生类的成员/友元遇到它就要搞特殊啊，所以派生类对于<u>一个基类对象的 protected 成员</u>没有任何访问特权\n\n### 4. 公有、私有和受保护继承\n\n> 如果访问说明符被忽略掉了，则关键字`class`对应的默认访问说明符是`private`，关键字`struct`对应的`public`\n\n#### 1. `继承方式`（`派生访问说明符`）对于`派生类的成员/友元`能否访问其`直接基类的成员`<u>没有什么影响</u>，对基类成员的访问权限**只与**`基类中的访问说明符`有关\n\n#### 2. `继承方式`的目的是控制`派生类对象`（包括派生类的派生类在内——孙子）对于`基类成员`的访问权限\n\n```cpp\nclass Base {\npublic:\n    void pub_mem();\nprotected:\n    int prot_mem;\nprivate:\n    char priv_mem;\n};\n\nstruct Pub_Derv :public Base {\n    int f() { return prot_mem; }  //正确，派生类能访问protected成员\n\tchar g() { return priv_mem; } //错误，派生类无权访问private成员，即使priv_mem继承下来了\n    //（我有个想法，既然priv_mem继承下来了，给Pub_Derv自己也复制了一份，Pub_Derv类的成员/友元应该能访问自己的piv_mem，即使它是private的，但是事实是它不行!）\n    //继承的是基类的成员，它还是 Base::priv_mem，只是说位置在派生类的内存地址范围内，但是其前缀还是 Base:: 还是属于基类！所以派生类不能访问它——基类的private\n};\n\nstruct Priv_Derv :private Base {\n    int f() { return prot_mem; } //private的继承方式不影响派生类的访问权限\n\n};\n\nPub_Derv d1;   \t\t//继承自Base的成员是public的\nPriv_Derv d2; \t\t//继承自Base的成员是private的\nd1.pub_mem(); \t\t//正确，pub_mem()在派生类中是public的\nd2.pub_mem();\t\t//错误，pub_mem()在派生类中是private的\n```\n\n- `公有继承` ：派生类成员将遵循其原有的访问说明符（该是啥还是啥）\n- `私有继承`：继承过来的东西都是私有的，派生类对象不能直接访问\n- `保护继承`：基类的`public`成员将变为`protected`，其他两个不变\n\n> 继承方式类似于规定一种`上限`，任何超过这个上限的都要降级为这个上限。规定上限对于已经在上限中的元素是无影响的\n\n#### 3. 孙子的访问权限\n\n继承方式（派生类访问说明符）还可以控制继承自派生类的新类的访问权限\n\n```cpp\nstruct Derived_from_Public : public Pub_Derv {\n    int use_base() { return prot_mem; }  //正确，Base::prot_mem在Pub_Derv中仍然是protected的，所以Pub_Derv的儿子可以访问\n}\n\nstruct Derived_from_Private : public Priv_Derv {\n\tint use_base() { return prot_mem; } //错误，Base::prot_mem在Priv_Derv中是private的（由于private继承），所以Priv_Derv的儿子无权访问它直接基类的private成员\n}\n```\n\n### 5. 派生类向基类转换的可访问性\n\n即动态绑定，假定 `D` 继承自 `B`：\n\n- 仅当 `D` **公有继承** B 时，用户代码（main函数中）才能使用派生类向基类的转换；如果 `D` **受保护继承**或**私有继承**于 `B`，用户代码**不能**使用该转换\n- 不论 `D` 以什么方式继承 `B`，`D` 的<u>成员/友元</u>**总是能**使用派生类向基类的转换\n- 对于 `B` 的孙子，如果 `D` 继承 `B` 的方式是 `public` 的或 `protected`，则 <u>`D` 的派生类</u>的成员/友元可以使用 `D` 向 `B` 的类型转换。反之，如果 `D` 继承 `B` 的方式是 `private` 的，则不能使用 \n\n","slug":"C++基础/类/访问控制与继承","published":1,"date":"2021-12-31T02:09:01.624Z","updated":"2021-12-21T07:57:22.107Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckxzva9fw000o7cu39bqgh5h3","content":"<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><h3 id=\"1-访问控制初探\"><a href=\"#1-访问控制初探\" class=\"headerlink\" title=\"1. 访问控制初探\"></a>1. 访问控制初探</h3><table>\n<thead>\n<tr>\n<th>修饰符</th>\n<th>类内成员函数、友元（类的实现者）</th>\n<th>类对象（普通用户）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>public</td>\n<td>:heavy_check_mark:</td>\n<td>:heavy_check_mark:</td>\n</tr>\n<tr>\n<td>private</td>\n<td>:heavy_check_mark:</td>\n<td>❌</td>\n</tr>\n<tr>\n<td>protect</td>\n<td>:heavy_check_mark:</td>\n<td>❌</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-友元函数\"><a href=\"#2-友元函数\" class=\"headerlink\" title=\"2. 友元函数\"></a>2. 友元函数</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Box</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">friend</span> <span class=\"keyword\">void</span> <span class=\"title\">printWidth</span><span class=\"params\">(Box box)</span></span>;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setWidth</span><span class=\"params\">( <span class=\"keyword\">double</span> wid )</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">   <span class=\"keyword\">double</span> width;    </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printWidth</span><span class=\"params\">(Box box)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">/* 因为 printWidth() 是 Box 的友元，它可以直接访问该类的任何成员 */</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Width of box : &quot;</span> &lt;&lt; box.width &lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>友元函数<strong>定义在类的外部</strong></li>\n<li><strong>有权访问</strong>类的<u>所有<strong>私有（private）</strong>和<strong>保护（protected）</strong>成员</u></li>\n</ol>\n<blockquote>\n<p><code>Box</code> 类对象作为 <code>printWidth</code> 的参数，然后友元函数定义中直接使用 <code>box.width</code>，因为有了友元，类的用户（类对象）也能直接访问 <code>private</code> 成员了</p>\n</blockquote>\n<h3 id=\"3-protected\"><a href=\"#3-protected\" class=\"headerlink\" title=\"3. protected\"></a>3. protected</h3><p>对于基类的 protected 成员</p>\n<ul>\n<li><p><u>基类的用户（对象）</u><strong>不</strong>可访问 <code>protected</code> 成员（类似于 <code>private</code>）</p>\n</li>\n<li><p>基类的成员和友元当然能访问基类的 <code>protected</code> 成员</p>\n</li>\n<li><p>派生类的成员和友元也能访问基类的 <code>protected</code> 成员（这里没有说明继承方式的影响）</p>\n</li>\n<li><p>派生类的成员或友元只能访问<strong>派生类对象</strong>的<strong>基类部分</strong>的 <code>protected</code> 成员，<strong>不能</strong>通过<strong>基类对象</strong>访问 <code>protected</code> 成员</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pub_mem</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        cout &lt;&lt; prot_mem &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> prot_mem;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">char</span> priv_mem;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sneaky</span> :</span><span class=\"keyword\">public</span> Base &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">clobber</span><span class=\"params\">(Sneaky&amp; s)</span> </span>&#123;</span><br><span class=\"line\">        cout &lt;&lt; s.prot_mem &lt;&lt; endl; <span class=\"comment\">//可以通过派生类对象访问该对象基类部分的 protected 成员</span></span><br><span class=\"line\">        prot_mem = <span class=\"number\">1</span>;\t\t\t    <span class=\"comment\">//这里可以理解为：通过this对象（仍是派生类对象）访问该对象基类部分的 protected 成员</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">cloober</span><span class=\"params\">(Base&amp; b)</span> </span>&#123;</span><br><span class=\"line\">        cout &lt;&lt; b.prot_mem &lt;&lt; endl; <span class=\"comment\">//错误，不能访问基类对象的 protected 成员</span></span><br><span class=\"line\">        b.<span class=\"built_in\">pub_mem</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>不论 <code>void cloober(Base&amp; b)</code> 是派生类的成员或友元，它都<strong>不能</strong>访问<strong>基类对象</strong>的 protected 成员</p>\n<blockquote>\n<p>注意在 <code>cloober</code> 中使用 <code>b.prot_mem</code> 理解为<u><code>cloober</code>访问基类对象的 <code>protected</code> 成员</u>，而不是理解为<u>基类对象访问基类的 <code>protected</code> 成员</u></p>\n<p>如果 <code>b.prot_mem</code> 不在 <code>Sneaky</code> 的成员/友元函数中，而是在 <code>main</code> 函数中，那也是错误的“类对象不能访问类的 protected 成员</p>\n</blockquote>\n<p>可以这样理解：因为对于一个<strong>基类对象</strong>而言，它本身就有“类对象不能访问类的 protected 成员“ 这个限制，而且基类对象的眼中是没有派生的概念的，所以凭什么一个派生类的成员/友元遇到它就要搞特殊啊，所以派生类对于<u>一个基类对象的 protected 成员</u>没有任何访问特权</p>\n</li>\n</ul>\n<h3 id=\"4-公有、私有和受保护继承\"><a href=\"#4-公有、私有和受保护继承\" class=\"headerlink\" title=\"4. 公有、私有和受保护继承\"></a>4. 公有、私有和受保护继承</h3><blockquote>\n<p>如果访问说明符被忽略掉了，则关键字<code>class</code>对应的默认访问说明符是<code>private</code>，关键字<code>struct</code>对应的<code>public</code></p>\n</blockquote>\n<h4 id=\"1-继承方式（派生访问说明符）对于派生类的成员-友元能否访问其直接基类的成员没有什么影响，对基类成员的访问权限只与基类中的访问说明符有关\"><a href=\"#1-继承方式（派生访问说明符）对于派生类的成员-友元能否访问其直接基类的成员没有什么影响，对基类成员的访问权限只与基类中的访问说明符有关\" class=\"headerlink\" title=\"1. 继承方式（派生访问说明符）对于派生类的成员/友元能否访问其直接基类的成员没有什么影响，对基类成员的访问权限只与基类中的访问说明符有关\"></a>1. <code>继承方式</code>（<code>派生访问说明符</code>）对于<code>派生类的成员/友元</code>能否访问其<code>直接基类的成员</code><u>没有什么影响</u>，对基类成员的访问权限<strong>只与</strong><code>基类中的访问说明符</code>有关</h4><h4 id=\"2-继承方式的目的是控制派生类对象（包括派生类的派生类在内——孙子）对于基类成员的访问权限\"><a href=\"#2-继承方式的目的是控制派生类对象（包括派生类的派生类在内——孙子）对于基类成员的访问权限\" class=\"headerlink\" title=\"2. 继承方式的目的是控制派生类对象（包括派生类的派生类在内——孙子）对于基类成员的访问权限\"></a>2. <code>继承方式</code>的目的是控制<code>派生类对象</code>（包括派生类的派生类在内——孙子）对于<code>基类成员</code>的访问权限</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pub_mem</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> prot_mem;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">char</span> priv_mem;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Pub_Derv</span> :</span><span class=\"keyword\">public</span> Base &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">f</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> prot_mem; &#125;  <span class=\"comment\">//正确，派生类能访问protected成员</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">char</span> <span class=\"title\">g</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> priv_mem; &#125; <span class=\"comment\">//错误，派生类无权访问private成员，即使priv_mem继承下来了</span></span><br><span class=\"line\">    <span class=\"comment\">//（我有个想法，既然priv_mem继承下来了，给Pub_Derv自己也复制了一份，Pub_Derv类的成员/友元应该能访问自己的piv_mem，即使它是private的，但是事实是它不行!）</span></span><br><span class=\"line\">    <span class=\"comment\">//继承的是基类的成员，它还是 Base::priv_mem，只是说位置在派生类的内存地址范围内，但是其前缀还是 Base:: 还是属于基类！所以派生类不能访问它——基类的private</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Priv_Derv</span> :</span><span class=\"keyword\">private</span> Base &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">f</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> prot_mem; &#125; <span class=\"comment\">//private的继承方式不影响派生类的访问权限</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Pub_Derv d1;   \t\t<span class=\"comment\">//继承自Base的成员是public的</span></span><br><span class=\"line\">Priv_Derv d2; \t\t<span class=\"comment\">//继承自Base的成员是private的</span></span><br><span class=\"line\">d1.<span class=\"built_in\">pub_mem</span>(); \t\t<span class=\"comment\">//正确，pub_mem()在派生类中是public的</span></span><br><span class=\"line\">d2.<span class=\"built_in\">pub_mem</span>();\t\t<span class=\"comment\">//错误，pub_mem()在派生类中是private的</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>公有继承</code> ：派生类成员将遵循其原有的访问说明符（该是啥还是啥）</li>\n<li><code>私有继承</code>：继承过来的东西都是私有的，派生类对象不能直接访问</li>\n<li><code>保护继承</code>：基类的<code>public</code>成员将变为<code>protected</code>，其他两个不变</li>\n</ul>\n<blockquote>\n<p>继承方式类似于规定一种<code>上限</code>，任何超过这个上限的都要降级为这个上限。规定上限对于已经在上限中的元素是无影响的</p>\n</blockquote>\n<h4 id=\"3-孙子的访问权限\"><a href=\"#3-孙子的访问权限\" class=\"headerlink\" title=\"3. 孙子的访问权限\"></a>3. 孙子的访问权限</h4><p>继承方式（派生类访问说明符）还可以控制继承自派生类的新类的访问权限</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Derived_from_Public</span> :</span> <span class=\"keyword\">public</span> Pub_Derv &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">use_base</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> prot_mem; &#125;  <span class=\"comment\">//正确，Base::prot_mem在Pub_Derv中仍然是protected的，所以Pub_Derv的儿子可以访问</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Derived_from_Private</span> :</span> <span class=\"keyword\">public</span> Priv_Derv &#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">use_base</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> prot_mem; &#125; <span class=\"comment\">//错误，Base::prot_mem在Priv_Derv中是private的（由于private继承），所以Priv_Derv的儿子无权访问它直接基类的private成员</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-派生类向基类转换的可访问性\"><a href=\"#5-派生类向基类转换的可访问性\" class=\"headerlink\" title=\"5. 派生类向基类转换的可访问性\"></a>5. 派生类向基类转换的可访问性</h3><p>即动态绑定，假定 <code>D</code> 继承自 <code>B</code>：</p>\n<ul>\n<li>仅当 <code>D</code> <strong>公有继承</strong> B 时，用户代码（main函数中）才能使用派生类向基类的转换；如果 <code>D</code> <strong>受保护继承</strong>或<strong>私有继承</strong>于 <code>B</code>，用户代码<strong>不能</strong>使用该转换</li>\n<li>不论 <code>D</code> 以什么方式继承 <code>B</code>，<code>D</code> 的<u>成员/友元</u><strong>总是能</strong>使用派生类向基类的转换</li>\n<li>对于 <code>B</code> 的孙子，如果 <code>D</code> 继承 <code>B</code> 的方式是 <code>public</code> 的或 <code>protected</code>，则 <u><code>D</code> 的派生类</u>的成员/友元可以使用 <code>D</code> 向 <code>B</code> 的类型转换。反之，如果 <code>D</code> 继承 <code>B</code> 的方式是 <code>private</code> 的，则不能使用 </li>\n</ul>\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><h3 id=\"1-访问控制初探\"><a href=\"#1-访问控制初探\" class=\"headerlink\" title=\"1. 访问控制初探\"></a>1. 访问控制初探</h3><table>\n<thead>\n<tr>\n<th>修饰符</th>\n<th>类内成员函数、友元（类的实现者）</th>\n<th>类对象（普通用户）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>public</td>\n<td>:heavy_check_mark:</td>\n<td>:heavy_check_mark:</td>\n</tr>\n<tr>\n<td>private</td>\n<td>:heavy_check_mark:</td>\n<td>❌</td>\n</tr>\n<tr>\n<td>protect</td>\n<td>:heavy_check_mark:</td>\n<td>❌</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-友元函数\"><a href=\"#2-友元函数\" class=\"headerlink\" title=\"2. 友元函数\"></a>2. 友元函数</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Box</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">friend</span> <span class=\"keyword\">void</span> <span class=\"title\">printWidth</span><span class=\"params\">(Box box)</span></span>;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setWidth</span><span class=\"params\">( <span class=\"keyword\">double</span> wid )</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">   <span class=\"keyword\">double</span> width;    </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printWidth</span><span class=\"params\">(Box box)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">/* 因为 printWidth() 是 Box 的友元，它可以直接访问该类的任何成员 */</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Width of box : &quot;</span> &lt;&lt; box.width &lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>友元函数<strong>定义在类的外部</strong></li>\n<li><strong>有权访问</strong>类的<u>所有<strong>私有（private）</strong>和<strong>保护（protected）</strong>成员</u></li>\n</ol>\n<blockquote>\n<p><code>Box</code> 类对象作为 <code>printWidth</code> 的参数，然后友元函数定义中直接使用 <code>box.width</code>，因为有了友元，类的用户（类对象）也能直接访问 <code>private</code> 成员了</p>\n</blockquote>\n<h3 id=\"3-protected\"><a href=\"#3-protected\" class=\"headerlink\" title=\"3. protected\"></a>3. protected</h3><p>对于基类的 protected 成员</p>\n<ul>\n<li><p><u>基类的用户（对象）</u><strong>不</strong>可访问 <code>protected</code> 成员（类似于 <code>private</code>）</p>\n</li>\n<li><p>基类的成员和友元当然能访问基类的 <code>protected</code> 成员</p>\n</li>\n<li><p>派生类的成员和友元也能访问基类的 <code>protected</code> 成员（这里没有说明继承方式的影响）</p>\n</li>\n<li><p>派生类的成员或友元只能访问<strong>派生类对象</strong>的<strong>基类部分</strong>的 <code>protected</code> 成员，<strong>不能</strong>通过<strong>基类对象</strong>访问 <code>protected</code> 成员</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pub_mem</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        cout &lt;&lt; prot_mem &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> prot_mem;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">char</span> priv_mem;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sneaky</span> :</span><span class=\"keyword\">public</span> Base &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">clobber</span><span class=\"params\">(Sneaky&amp; s)</span> </span>&#123;</span><br><span class=\"line\">        cout &lt;&lt; s.prot_mem &lt;&lt; endl; <span class=\"comment\">//可以通过派生类对象访问该对象基类部分的 protected 成员</span></span><br><span class=\"line\">        prot_mem = <span class=\"number\">1</span>;\t\t\t    <span class=\"comment\">//这里可以理解为：通过this对象（仍是派生类对象）访问该对象基类部分的 protected 成员</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">cloober</span><span class=\"params\">(Base&amp; b)</span> </span>&#123;</span><br><span class=\"line\">        cout &lt;&lt; b.prot_mem &lt;&lt; endl; <span class=\"comment\">//错误，不能访问基类对象的 protected 成员</span></span><br><span class=\"line\">        b.<span class=\"built_in\">pub_mem</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>不论 <code>void cloober(Base&amp; b)</code> 是派生类的成员或友元，它都<strong>不能</strong>访问<strong>基类对象</strong>的 protected 成员</p>\n<blockquote>\n<p>注意在 <code>cloober</code> 中使用 <code>b.prot_mem</code> 理解为<u><code>cloober</code>访问基类对象的 <code>protected</code> 成员</u>，而不是理解为<u>基类对象访问基类的 <code>protected</code> 成员</u></p>\n<p>如果 <code>b.prot_mem</code> 不在 <code>Sneaky</code> 的成员/友元函数中，而是在 <code>main</code> 函数中，那也是错误的“类对象不能访问类的 protected 成员</p>\n</blockquote>\n<p>可以这样理解：因为对于一个<strong>基类对象</strong>而言，它本身就有“类对象不能访问类的 protected 成员“ 这个限制，而且基类对象的眼中是没有派生的概念的，所以凭什么一个派生类的成员/友元遇到它就要搞特殊啊，所以派生类对于<u>一个基类对象的 protected 成员</u>没有任何访问特权</p>\n</li>\n</ul>\n<h3 id=\"4-公有、私有和受保护继承\"><a href=\"#4-公有、私有和受保护继承\" class=\"headerlink\" title=\"4. 公有、私有和受保护继承\"></a>4. 公有、私有和受保护继承</h3><blockquote>\n<p>如果访问说明符被忽略掉了，则关键字<code>class</code>对应的默认访问说明符是<code>private</code>，关键字<code>struct</code>对应的<code>public</code></p>\n</blockquote>\n<h4 id=\"1-继承方式（派生访问说明符）对于派生类的成员-友元能否访问其直接基类的成员没有什么影响，对基类成员的访问权限只与基类中的访问说明符有关\"><a href=\"#1-继承方式（派生访问说明符）对于派生类的成员-友元能否访问其直接基类的成员没有什么影响，对基类成员的访问权限只与基类中的访问说明符有关\" class=\"headerlink\" title=\"1. 继承方式（派生访问说明符）对于派生类的成员/友元能否访问其直接基类的成员没有什么影响，对基类成员的访问权限只与基类中的访问说明符有关\"></a>1. <code>继承方式</code>（<code>派生访问说明符</code>）对于<code>派生类的成员/友元</code>能否访问其<code>直接基类的成员</code><u>没有什么影响</u>，对基类成员的访问权限<strong>只与</strong><code>基类中的访问说明符</code>有关</h4><h4 id=\"2-继承方式的目的是控制派生类对象（包括派生类的派生类在内——孙子）对于基类成员的访问权限\"><a href=\"#2-继承方式的目的是控制派生类对象（包括派生类的派生类在内——孙子）对于基类成员的访问权限\" class=\"headerlink\" title=\"2. 继承方式的目的是控制派生类对象（包括派生类的派生类在内——孙子）对于基类成员的访问权限\"></a>2. <code>继承方式</code>的目的是控制<code>派生类对象</code>（包括派生类的派生类在内——孙子）对于<code>基类成员</code>的访问权限</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pub_mem</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> prot_mem;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">char</span> priv_mem;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Pub_Derv</span> :</span><span class=\"keyword\">public</span> Base &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">f</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> prot_mem; &#125;  <span class=\"comment\">//正确，派生类能访问protected成员</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">char</span> <span class=\"title\">g</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> priv_mem; &#125; <span class=\"comment\">//错误，派生类无权访问private成员，即使priv_mem继承下来了</span></span><br><span class=\"line\">    <span class=\"comment\">//（我有个想法，既然priv_mem继承下来了，给Pub_Derv自己也复制了一份，Pub_Derv类的成员/友元应该能访问自己的piv_mem，即使它是private的，但是事实是它不行!）</span></span><br><span class=\"line\">    <span class=\"comment\">//继承的是基类的成员，它还是 Base::priv_mem，只是说位置在派生类的内存地址范围内，但是其前缀还是 Base:: 还是属于基类！所以派生类不能访问它——基类的private</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Priv_Derv</span> :</span><span class=\"keyword\">private</span> Base &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">f</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> prot_mem; &#125; <span class=\"comment\">//private的继承方式不影响派生类的访问权限</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Pub_Derv d1;   \t\t<span class=\"comment\">//继承自Base的成员是public的</span></span><br><span class=\"line\">Priv_Derv d2; \t\t<span class=\"comment\">//继承自Base的成员是private的</span></span><br><span class=\"line\">d1.<span class=\"built_in\">pub_mem</span>(); \t\t<span class=\"comment\">//正确，pub_mem()在派生类中是public的</span></span><br><span class=\"line\">d2.<span class=\"built_in\">pub_mem</span>();\t\t<span class=\"comment\">//错误，pub_mem()在派生类中是private的</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>公有继承</code> ：派生类成员将遵循其原有的访问说明符（该是啥还是啥）</li>\n<li><code>私有继承</code>：继承过来的东西都是私有的，派生类对象不能直接访问</li>\n<li><code>保护继承</code>：基类的<code>public</code>成员将变为<code>protected</code>，其他两个不变</li>\n</ul>\n<blockquote>\n<p>继承方式类似于规定一种<code>上限</code>，任何超过这个上限的都要降级为这个上限。规定上限对于已经在上限中的元素是无影响的</p>\n</blockquote>\n<h4 id=\"3-孙子的访问权限\"><a href=\"#3-孙子的访问权限\" class=\"headerlink\" title=\"3. 孙子的访问权限\"></a>3. 孙子的访问权限</h4><p>继承方式（派生类访问说明符）还可以控制继承自派生类的新类的访问权限</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Derived_from_Public</span> :</span> <span class=\"keyword\">public</span> Pub_Derv &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">use_base</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> prot_mem; &#125;  <span class=\"comment\">//正确，Base::prot_mem在Pub_Derv中仍然是protected的，所以Pub_Derv的儿子可以访问</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Derived_from_Private</span> :</span> <span class=\"keyword\">public</span> Priv_Derv &#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">use_base</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> prot_mem; &#125; <span class=\"comment\">//错误，Base::prot_mem在Priv_Derv中是private的（由于private继承），所以Priv_Derv的儿子无权访问它直接基类的private成员</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-派生类向基类转换的可访问性\"><a href=\"#5-派生类向基类转换的可访问性\" class=\"headerlink\" title=\"5. 派生类向基类转换的可访问性\"></a>5. 派生类向基类转换的可访问性</h3><p>即动态绑定，假定 <code>D</code> 继承自 <code>B</code>：</p>\n<ul>\n<li>仅当 <code>D</code> <strong>公有继承</strong> B 时，用户代码（main函数中）才能使用派生类向基类的转换；如果 <code>D</code> <strong>受保护继承</strong>或<strong>私有继承</strong>于 <code>B</code>，用户代码<strong>不能</strong>使用该转换</li>\n<li>不论 <code>D</code> 以什么方式继承 <code>B</code>，<code>D</code> 的<u>成员/友元</u><strong>总是能</strong>使用派生类向基类的转换</li>\n<li>对于 <code>B</code> 的孙子，如果 <code>D</code> 继承 <code>B</code> 的方式是 <code>public</code> 的或 <code>protected</code>，则 <u><code>D</code> 的派生类</u>的成员/友元可以使用 <code>D</code> 向 <code>B</code> 的类型转换。反之，如果 <code>D</code> 继承 <code>B</code> 的方式是 <code>private</code> 的，则不能使用 </li>\n</ul>\n"},{"_content":"隐式类型转换\n\n转换构造函数：只接受一个实参，或者其他参数都有默认参数，\n\n```c++\nclass Sale_data {\npublic:\n\tSale_data() = default;\n\tSale_data(const string& s) :bookNo(s) { } //转换构造函数\n\tSale_data(const Sale_data& temp) :bookNo(temp.bookNo), units_sold(temp.units_sold), revenue(temp.revenue) { cout << \"拷构\" << endl; }//拷贝构造函数\n\t...\n\tSale_data& combine( const Sale_data temp&) {\n\t\treturn ;\n\t}\nprivate:\n\tstring bookNo;\n\tunsigned units_sold = 0;\n\tdouble revenue = 0.0;\n};\n\nint main()\n{\n\tSale_data item;\n\tstring null_book = \"999\"; //这有一次 string 的拷构\n\t//Sale_data tt;\n\titem.combine(null_book);\n\t//cout <<<< endl;\n\treturn 0;\n}\n```\n\n\n\n","source":"_posts/C++基础/类/隐式类型转换.md","raw":"隐式类型转换\n\n转换构造函数：只接受一个实参，或者其他参数都有默认参数，\n\n```c++\nclass Sale_data {\npublic:\n\tSale_data() = default;\n\tSale_data(const string& s) :bookNo(s) { } //转换构造函数\n\tSale_data(const Sale_data& temp) :bookNo(temp.bookNo), units_sold(temp.units_sold), revenue(temp.revenue) { cout << \"拷构\" << endl; }//拷贝构造函数\n\t...\n\tSale_data& combine( const Sale_data temp&) {\n\t\treturn ;\n\t}\nprivate:\n\tstring bookNo;\n\tunsigned units_sold = 0;\n\tdouble revenue = 0.0;\n};\n\nint main()\n{\n\tSale_data item;\n\tstring null_book = \"999\"; //这有一次 string 的拷构\n\t//Sale_data tt;\n\titem.combine(null_book);\n\t//cout <<<< endl;\n\treturn 0;\n}\n```\n\n\n\n","slug":"C++基础/类/隐式类型转换","published":1,"date":"2021-12-31T02:09:01.631Z","updated":"2021-11-23T14:43:42.160Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckxzva9fx000q7cu32m75a5ld","content":"<p>隐式类型转换</p>\n<p>转换构造函数：只接受一个实参，或者其他参数都有默认参数，</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sale_data</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">Sale_data</span>() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">Sale_data</span>(<span class=\"keyword\">const</span> string&amp; s) :<span class=\"built_in\">bookNo</span>(s) &#123; &#125; <span class=\"comment\">//转换构造函数</span></span><br><span class=\"line\">\t<span class=\"built_in\">Sale_data</span>(<span class=\"keyword\">const</span> Sale_data&amp; temp) :<span class=\"built_in\">bookNo</span>(temp.bookNo), <span class=\"built_in\">units_sold</span>(temp.units_sold), <span class=\"built_in\">revenue</span>(temp.revenue) &#123; cout &lt;&lt; <span class=\"string\">&quot;拷构&quot;</span> &lt;&lt; endl; &#125;<span class=\"comment\">//拷贝构造函数</span></span><br><span class=\"line\">\t...</span><br><span class=\"line\">\t<span class=\"function\">Sale_data&amp; <span class=\"title\">combine</span><span class=\"params\">( <span class=\"keyword\">const</span> Sale_data temp&amp;)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\tstring bookNo;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> units_sold = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">double</span> revenue = <span class=\"number\">0.0</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tSale_data item;</span><br><span class=\"line\">\tstring null_book = <span class=\"string\">&quot;999&quot;</span>; <span class=\"comment\">//这有一次 string 的拷构</span></span><br><span class=\"line\">\t<span class=\"comment\">//Sale_data tt;</span></span><br><span class=\"line\">\titem.<span class=\"built_in\">combine</span>(null_book);</span><br><span class=\"line\">\t<span class=\"comment\">//cout &lt;&lt;&lt;&lt; endl;</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<p>隐式类型转换</p>\n<p>转换构造函数：只接受一个实参，或者其他参数都有默认参数，</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sale_data</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">Sale_data</span>() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">Sale_data</span>(<span class=\"keyword\">const</span> string&amp; s) :<span class=\"built_in\">bookNo</span>(s) &#123; &#125; <span class=\"comment\">//转换构造函数</span></span><br><span class=\"line\">\t<span class=\"built_in\">Sale_data</span>(<span class=\"keyword\">const</span> Sale_data&amp; temp) :<span class=\"built_in\">bookNo</span>(temp.bookNo), <span class=\"built_in\">units_sold</span>(temp.units_sold), <span class=\"built_in\">revenue</span>(temp.revenue) &#123; cout &lt;&lt; <span class=\"string\">&quot;拷构&quot;</span> &lt;&lt; endl; &#125;<span class=\"comment\">//拷贝构造函数</span></span><br><span class=\"line\">\t...</span><br><span class=\"line\">\t<span class=\"function\">Sale_data&amp; <span class=\"title\">combine</span><span class=\"params\">( <span class=\"keyword\">const</span> Sale_data temp&amp;)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\tstring bookNo;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> units_sold = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">double</span> revenue = <span class=\"number\">0.0</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tSale_data item;</span><br><span class=\"line\">\tstring null_book = <span class=\"string\">&quot;999&quot;</span>; <span class=\"comment\">//这有一次 string 的拷构</span></span><br><span class=\"line\">\t<span class=\"comment\">//Sale_data tt;</span></span><br><span class=\"line\">\titem.<span class=\"built_in\">combine</span>(null_book);</span><br><span class=\"line\">\t<span class=\"comment\">//cout &lt;&lt;&lt;&lt; endl;</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n"},{"_content":"**静态类型**\n\n1. 编译时已知\n2. 变量声明时的类型或表达式生成的类型\n\n**动态类型**\n\n1. 直到运行时才可知\n2. 变量或表达式在内存中的对象的类型\n\n如果表达式**不是指针/引用**，则其动态类型与静态类型**一致**\n\n\n\n不存在**从基类到派生类**的隐式类型转换，因为基类有可能不是派生类的一部分\n\n即使一个基类指针/引用绑定在一个派生类对象上，我们也不能执行从基类向派生类的**自动**转换：\n\n```cpp\nBulk_quote bulk;\nQuote *itemP = &bulk;\t\t\t\t\t\t\nBulk_quote *bulkP = itemP;\t\t\t\t//错误，不能将基类自动转换为派生类\n```\n\n虽然这个转换是安全的，但是过不了编译器静态时的安全检查，编译器只能通过检查指针/引用的静态类型来推断该转换是否合法\n\n如果基类中有虚函数，可以用 `dynamic_cast`，执行**运行时**的安全检查\n\n如果确认基类向派生类的转换是安全的，可以使用 `static_cast` 来强制覆盖掉编译器的检查工作\n\n\n\n因为基类的拷贝/移动操作的参数是引用，所以可以给基类的拷贝/移动构造函数传递一个派生类对象，仅处理（拷贝/赋值）该派生类对象中的基类自己的部分，该派生类对象中的其他部分相当于被**切掉（sliced down）**了\n\n\n\n***虚函数***\n\n使用基类的引用/指针调用一个虚函数时会执行动态绑定——编译器直到运行时才能确定应该调用哪个版本的虚函数，被调用的函数是与绑定到指针/引用上的对象的动态类型相匹配\n\n所有虚函数都必须定义，不管它是否被用到了，因为连编译器也无法确定到底会使用哪个虚函数\n\n\n\n***派生类中的虚函数***\n\n一旦某个函数被声明成虚函数，则在所有派生类中它都是虚函数\n\n派生类中**覆盖**基类虚函数，要求形参类型一致，返回类型要么一致，要么可自动转换\n\n虚函数的**默认实参**由本次调用的**静态类型**决定\n\n\n\n***抽象基类***\n\n用`=0`声明一个纯虚函数，一个纯虚函数无需定义（也可以有定义，但**必须定义在类外部**）\n\n含有纯虚函数的类是抽象基类，**不能**直接创建一个抽象基类的对象\n\n\n\n派生类构造函数**只**初始化它的直接基类\n\n\n\n***虚析构函数***\n\n基类的析构函数一般是虚函数，派生类的析构函数也因此是虚函数\n\n基类指针指向派生类对象，那么 delete 该指针的时候，会实际调用派生类的析构函数，派生类析构完成之后，再调用基类的析构函数（这里的调用细节涉及到虚函数底层实现）\n\n\n\n***定义派生类的拷贝或移动构造函数***\n\n```cpp\nclass Base { /*..*/};\nclass D: public Base {\npublic:\n\t//默认情况下，基类的默认构造函数初始化对象的基类部分\n    //要想使用拷贝或移动构造函数，必须在构造函数初始值列表中显示地调用该构造函数\n    D(const D& d): Base(d)           //拷贝基类成员\n    \t\t\t/* D的成员的初始值 */  {/*...*/}\n    D(D&& d): Base(std::move(d))     //移动基类成员\n                /* D的成员的初始值 */  {/*...*/}\n}\n```\n\n`Base(d)` 匹配 `Base` 的拷贝构造函数，然后 `Base` 的拷贝构造函数负责将 `d` 的基类部分拷贝给要创建的对象\n\n\n\n***在构造函数中调用虚函数***\n\n当**基类构造函数**调用**虚函数的派生类版本**，当执行基类构造函数时，它要用到的派生类成员尚未初始化\n\n\n\n***构造函数不能是虚函数***\n\n1. 从`vptr`角度解释\n\n   虚函数的调用是通过虚函数表来查找的，而虚函数表由类的实例化对象的`vptr`指针指向\n\n   \n\n   该指针存放在对象的内部空间中，需要调用构造函数完成初始化。\n\n   \n\n   如果构造函数是虚函数，那么调用构造函数就需要去找`vptr`，但此时`vptr`还没有初始化！\n\n2. 从多态角度解释【挖坑】\n\n   \n","source":"_posts/C++基础/类/虚函数专题.md","raw":"**静态类型**\n\n1. 编译时已知\n2. 变量声明时的类型或表达式生成的类型\n\n**动态类型**\n\n1. 直到运行时才可知\n2. 变量或表达式在内存中的对象的类型\n\n如果表达式**不是指针/引用**，则其动态类型与静态类型**一致**\n\n\n\n不存在**从基类到派生类**的隐式类型转换，因为基类有可能不是派生类的一部分\n\n即使一个基类指针/引用绑定在一个派生类对象上，我们也不能执行从基类向派生类的**自动**转换：\n\n```cpp\nBulk_quote bulk;\nQuote *itemP = &bulk;\t\t\t\t\t\t\nBulk_quote *bulkP = itemP;\t\t\t\t//错误，不能将基类自动转换为派生类\n```\n\n虽然这个转换是安全的，但是过不了编译器静态时的安全检查，编译器只能通过检查指针/引用的静态类型来推断该转换是否合法\n\n如果基类中有虚函数，可以用 `dynamic_cast`，执行**运行时**的安全检查\n\n如果确认基类向派生类的转换是安全的，可以使用 `static_cast` 来强制覆盖掉编译器的检查工作\n\n\n\n因为基类的拷贝/移动操作的参数是引用，所以可以给基类的拷贝/移动构造函数传递一个派生类对象，仅处理（拷贝/赋值）该派生类对象中的基类自己的部分，该派生类对象中的其他部分相当于被**切掉（sliced down）**了\n\n\n\n***虚函数***\n\n使用基类的引用/指针调用一个虚函数时会执行动态绑定——编译器直到运行时才能确定应该调用哪个版本的虚函数，被调用的函数是与绑定到指针/引用上的对象的动态类型相匹配\n\n所有虚函数都必须定义，不管它是否被用到了，因为连编译器也无法确定到底会使用哪个虚函数\n\n\n\n***派生类中的虚函数***\n\n一旦某个函数被声明成虚函数，则在所有派生类中它都是虚函数\n\n派生类中**覆盖**基类虚函数，要求形参类型一致，返回类型要么一致，要么可自动转换\n\n虚函数的**默认实参**由本次调用的**静态类型**决定\n\n\n\n***抽象基类***\n\n用`=0`声明一个纯虚函数，一个纯虚函数无需定义（也可以有定义，但**必须定义在类外部**）\n\n含有纯虚函数的类是抽象基类，**不能**直接创建一个抽象基类的对象\n\n\n\n派生类构造函数**只**初始化它的直接基类\n\n\n\n***虚析构函数***\n\n基类的析构函数一般是虚函数，派生类的析构函数也因此是虚函数\n\n基类指针指向派生类对象，那么 delete 该指针的时候，会实际调用派生类的析构函数，派生类析构完成之后，再调用基类的析构函数（这里的调用细节涉及到虚函数底层实现）\n\n\n\n***定义派生类的拷贝或移动构造函数***\n\n```cpp\nclass Base { /*..*/};\nclass D: public Base {\npublic:\n\t//默认情况下，基类的默认构造函数初始化对象的基类部分\n    //要想使用拷贝或移动构造函数，必须在构造函数初始值列表中显示地调用该构造函数\n    D(const D& d): Base(d)           //拷贝基类成员\n    \t\t\t/* D的成员的初始值 */  {/*...*/}\n    D(D&& d): Base(std::move(d))     //移动基类成员\n                /* D的成员的初始值 */  {/*...*/}\n}\n```\n\n`Base(d)` 匹配 `Base` 的拷贝构造函数，然后 `Base` 的拷贝构造函数负责将 `d` 的基类部分拷贝给要创建的对象\n\n\n\n***在构造函数中调用虚函数***\n\n当**基类构造函数**调用**虚函数的派生类版本**，当执行基类构造函数时，它要用到的派生类成员尚未初始化\n\n\n\n***构造函数不能是虚函数***\n\n1. 从`vptr`角度解释\n\n   虚函数的调用是通过虚函数表来查找的，而虚函数表由类的实例化对象的`vptr`指针指向\n\n   \n\n   该指针存放在对象的内部空间中，需要调用构造函数完成初始化。\n\n   \n\n   如果构造函数是虚函数，那么调用构造函数就需要去找`vptr`，但此时`vptr`还没有初始化！\n\n2. 从多态角度解释【挖坑】\n\n   \n","slug":"C++基础/类/虚函数专题","published":1,"date":"2021-12-31T02:09:01.616Z","updated":"2021-12-14T01:09:07.594Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckxzva9fy000t7cu3hxllgt5r","content":"<p><strong>静态类型</strong></p>\n<ol>\n<li>编译时已知</li>\n<li>变量声明时的类型或表达式生成的类型</li>\n</ol>\n<p><strong>动态类型</strong></p>\n<ol>\n<li>直到运行时才可知</li>\n<li>变量或表达式在内存中的对象的类型</li>\n</ol>\n<p>如果表达式<strong>不是指针/引用</strong>，则其动态类型与静态类型<strong>一致</strong></p>\n<p>不存在<strong>从基类到派生类</strong>的隐式类型转换，因为基类有可能不是派生类的一部分</p>\n<p>即使一个基类指针/引用绑定在一个派生类对象上，我们也不能执行从基类向派生类的<strong>自动</strong>转换：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Bulk_quote bulk;</span><br><span class=\"line\">Quote *itemP = &amp;bulk;\t\t\t\t\t\t</span><br><span class=\"line\">Bulk_quote *bulkP = itemP;\t\t\t\t<span class=\"comment\">//错误，不能将基类自动转换为派生类</span></span><br></pre></td></tr></table></figure>\n\n<p>虽然这个转换是安全的，但是过不了编译器静态时的安全检查，编译器只能通过检查指针/引用的静态类型来推断该转换是否合法</p>\n<p>如果基类中有虚函数，可以用 <code>dynamic_cast</code>，执行<strong>运行时</strong>的安全检查</p>\n<p>如果确认基类向派生类的转换是安全的，可以使用 <code>static_cast</code> 来强制覆盖掉编译器的检查工作</p>\n<p>因为基类的拷贝/移动操作的参数是引用，所以可以给基类的拷贝/移动构造函数传递一个派生类对象，仅处理（拷贝/赋值）该派生类对象中的基类自己的部分，该派生类对象中的其他部分相当于被<strong>切掉（sliced down）</strong>了</p>\n<p><em><strong>虚函数</strong></em></p>\n<p>使用基类的引用/指针调用一个虚函数时会执行动态绑定——编译器直到运行时才能确定应该调用哪个版本的虚函数，被调用的函数是与绑定到指针/引用上的对象的动态类型相匹配</p>\n<p>所有虚函数都必须定义，不管它是否被用到了，因为连编译器也无法确定到底会使用哪个虚函数</p>\n<p><em><strong>派生类中的虚函数</strong></em></p>\n<p>一旦某个函数被声明成虚函数，则在所有派生类中它都是虚函数</p>\n<p>派生类中<strong>覆盖</strong>基类虚函数，要求形参类型一致，返回类型要么一致，要么可自动转换</p>\n<p>虚函数的<strong>默认实参</strong>由本次调用的<strong>静态类型</strong>决定</p>\n<p><em><strong>抽象基类</strong></em></p>\n<p>用<code>=0</code>声明一个纯虚函数，一个纯虚函数无需定义（也可以有定义，但<strong>必须定义在类外部</strong>）</p>\n<p>含有纯虚函数的类是抽象基类，<strong>不能</strong>直接创建一个抽象基类的对象</p>\n<p>派生类构造函数<strong>只</strong>初始化它的直接基类</p>\n<p><em><strong>虚析构函数</strong></em></p>\n<p>基类的析构函数一般是虚函数，派生类的析构函数也因此是虚函数</p>\n<p>基类指针指向派生类对象，那么 delete 该指针的时候，会实际调用派生类的析构函数，派生类析构完成之后，再调用基类的析构函数（这里的调用细节涉及到虚函数底层实现）</p>\n<p><em><strong>定义派生类的拷贝或移动构造函数</strong></em></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span> &#123;</span> <span class=\"comment\">/*..*/</span>&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">D</span>:</span> <span class=\"keyword\">public</span> Base &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"comment\">//默认情况下，基类的默认构造函数初始化对象的基类部分</span></span><br><span class=\"line\">    <span class=\"comment\">//要想使用拷贝或移动构造函数，必须在构造函数初始值列表中显示地调用该构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">D</span>(<span class=\"keyword\">const</span> D&amp; d): <span class=\"built_in\">Base</span>(d)           <span class=\"comment\">//拷贝基类成员</span></span><br><span class=\"line\">    \t\t\t<span class=\"comment\">/* D的成员的初始值 */</span>  &#123;<span class=\"comment\">/*...*/</span>&#125;</span><br><span class=\"line\">    <span class=\"built_in\">D</span>(D&amp;&amp; d): <span class=\"built_in\">Base</span>(std::<span class=\"built_in\">move</span>(d))     <span class=\"comment\">//移动基类成员</span></span><br><span class=\"line\">                <span class=\"comment\">/* D的成员的初始值 */</span>  &#123;<span class=\"comment\">/*...*/</span>&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>Base(d)</code> 匹配 <code>Base</code> 的拷贝构造函数，然后 <code>Base</code> 的拷贝构造函数负责将 <code>d</code> 的基类部分拷贝给要创建的对象</p>\n<p><em><strong>在构造函数中调用虚函数</strong></em></p>\n<p>当<strong>基类构造函数</strong>调用<strong>虚函数的派生类版本</strong>，当执行基类构造函数时，它要用到的派生类成员尚未初始化</p>\n<p><em><strong>构造函数不能是虚函数</strong></em></p>\n<ol>\n<li><p>从<code>vptr</code>角度解释</p>\n<p>虚函数的调用是通过虚函数表来查找的，而虚函数表由类的实例化对象的<code>vptr</code>指针指向</p>\n<p>该指针存放在对象的内部空间中，需要调用构造函数完成初始化。</p>\n<p>如果构造函数是虚函数，那么调用构造函数就需要去找<code>vptr</code>，但此时<code>vptr</code>还没有初始化！</p>\n</li>\n<li><p>从多态角度解释【挖坑】</p>\n</li>\n</ol>\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<p><strong>静态类型</strong></p>\n<ol>\n<li>编译时已知</li>\n<li>变量声明时的类型或表达式生成的类型</li>\n</ol>\n<p><strong>动态类型</strong></p>\n<ol>\n<li>直到运行时才可知</li>\n<li>变量或表达式在内存中的对象的类型</li>\n</ol>\n<p>如果表达式<strong>不是指针/引用</strong>，则其动态类型与静态类型<strong>一致</strong></p>\n<p>不存在<strong>从基类到派生类</strong>的隐式类型转换，因为基类有可能不是派生类的一部分</p>\n<p>即使一个基类指针/引用绑定在一个派生类对象上，我们也不能执行从基类向派生类的<strong>自动</strong>转换：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Bulk_quote bulk;</span><br><span class=\"line\">Quote *itemP = &amp;bulk;\t\t\t\t\t\t</span><br><span class=\"line\">Bulk_quote *bulkP = itemP;\t\t\t\t<span class=\"comment\">//错误，不能将基类自动转换为派生类</span></span><br></pre></td></tr></table></figure>\n\n<p>虽然这个转换是安全的，但是过不了编译器静态时的安全检查，编译器只能通过检查指针/引用的静态类型来推断该转换是否合法</p>\n<p>如果基类中有虚函数，可以用 <code>dynamic_cast</code>，执行<strong>运行时</strong>的安全检查</p>\n<p>如果确认基类向派生类的转换是安全的，可以使用 <code>static_cast</code> 来强制覆盖掉编译器的检查工作</p>\n<p>因为基类的拷贝/移动操作的参数是引用，所以可以给基类的拷贝/移动构造函数传递一个派生类对象，仅处理（拷贝/赋值）该派生类对象中的基类自己的部分，该派生类对象中的其他部分相当于被<strong>切掉（sliced down）</strong>了</p>\n<p><em><strong>虚函数</strong></em></p>\n<p>使用基类的引用/指针调用一个虚函数时会执行动态绑定——编译器直到运行时才能确定应该调用哪个版本的虚函数，被调用的函数是与绑定到指针/引用上的对象的动态类型相匹配</p>\n<p>所有虚函数都必须定义，不管它是否被用到了，因为连编译器也无法确定到底会使用哪个虚函数</p>\n<p><em><strong>派生类中的虚函数</strong></em></p>\n<p>一旦某个函数被声明成虚函数，则在所有派生类中它都是虚函数</p>\n<p>派生类中<strong>覆盖</strong>基类虚函数，要求形参类型一致，返回类型要么一致，要么可自动转换</p>\n<p>虚函数的<strong>默认实参</strong>由本次调用的<strong>静态类型</strong>决定</p>\n<p><em><strong>抽象基类</strong></em></p>\n<p>用<code>=0</code>声明一个纯虚函数，一个纯虚函数无需定义（也可以有定义，但<strong>必须定义在类外部</strong>）</p>\n<p>含有纯虚函数的类是抽象基类，<strong>不能</strong>直接创建一个抽象基类的对象</p>\n<p>派生类构造函数<strong>只</strong>初始化它的直接基类</p>\n<p><em><strong>虚析构函数</strong></em></p>\n<p>基类的析构函数一般是虚函数，派生类的析构函数也因此是虚函数</p>\n<p>基类指针指向派生类对象，那么 delete 该指针的时候，会实际调用派生类的析构函数，派生类析构完成之后，再调用基类的析构函数（这里的调用细节涉及到虚函数底层实现）</p>\n<p><em><strong>定义派生类的拷贝或移动构造函数</strong></em></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span> &#123;</span> <span class=\"comment\">/*..*/</span>&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">D</span>:</span> <span class=\"keyword\">public</span> Base &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"comment\">//默认情况下，基类的默认构造函数初始化对象的基类部分</span></span><br><span class=\"line\">    <span class=\"comment\">//要想使用拷贝或移动构造函数，必须在构造函数初始值列表中显示地调用该构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">D</span>(<span class=\"keyword\">const</span> D&amp; d): <span class=\"built_in\">Base</span>(d)           <span class=\"comment\">//拷贝基类成员</span></span><br><span class=\"line\">    \t\t\t<span class=\"comment\">/* D的成员的初始值 */</span>  &#123;<span class=\"comment\">/*...*/</span>&#125;</span><br><span class=\"line\">    <span class=\"built_in\">D</span>(D&amp;&amp; d): <span class=\"built_in\">Base</span>(std::<span class=\"built_in\">move</span>(d))     <span class=\"comment\">//移动基类成员</span></span><br><span class=\"line\">                <span class=\"comment\">/* D的成员的初始值 */</span>  &#123;<span class=\"comment\">/*...*/</span>&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>Base(d)</code> 匹配 <code>Base</code> 的拷贝构造函数，然后 <code>Base</code> 的拷贝构造函数负责将 <code>d</code> 的基类部分拷贝给要创建的对象</p>\n<p><em><strong>在构造函数中调用虚函数</strong></em></p>\n<p>当<strong>基类构造函数</strong>调用<strong>虚函数的派生类版本</strong>，当执行基类构造函数时，它要用到的派生类成员尚未初始化</p>\n<p><em><strong>构造函数不能是虚函数</strong></em></p>\n<ol>\n<li><p>从<code>vptr</code>角度解释</p>\n<p>虚函数的调用是通过虚函数表来查找的，而虚函数表由类的实例化对象的<code>vptr</code>指针指向</p>\n<p>该指针存放在对象的内部空间中，需要调用构造函数完成初始化。</p>\n<p>如果构造函数是虚函数，那么调用构造函数就需要去找<code>vptr</code>，但此时<code>vptr</code>还没有初始化！</p>\n</li>\n<li><p>从多态角度解释【挖坑】</p>\n</li>\n</ol>\n"},{"typora-root-url":"..\\..\\..\\..\\..\\..\\..\\static","_content":"\n\n\n## 关联容器(map, set, pair)\n\n### 定义\n\n- **空容器**（调用默认构造函数）\n\n```c++\nmap<string, size_t> mp; \nset<string> st; \n```\n\n- **列表初始化**\n\n```c++\nset<string> st = {\"aaa\",\"bbb\"};\nmap<string, string> mp = {{\"Joey\",\"Phoebe\"},{\"Ross\",\"Rachel\"}};\n```\n\n- **迭代器**\n\n```c++\nvector<int> ivec{1,2,3,4};\nset<int> iset(ivec.begin(), ivec.end());\n```\n\n也可以将关联容器初始化为另一个同类型容器的**拷贝**【?】\n\n从一个**值范围**来初始化关联容器，只要这些值能转化为容器所需类型【?】\n\n**值初始化**【?】\n\n### **pair** 相关\n\n- 基础操作\n\n![pair上的操作](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211113101831838.png)\n\n- 返回值类型为 pair（对返回值列表初始化）\n\n```c++\npair<string, int> my_fun(){\n    ...\n    return {s1, i1};\n    return pair<string, int>(); //构造一个空的 pair\n    \n}\n```\n\n### 关键字、值类型\n\n```c++\nkey_type\t\t\t键类型\nmapped_type\t\t\t值类型（只适用于map）\nvalue_type\t\t\t对set，与key_type相同\n\t\t\t\t\t对map，pair键值对：pair<const key_type, mapped_type>, //注意第一个为const\n```\n\n如何使用？：**域运算符**\n\n```c++\nmap<string, int>::mapped_type v1;  //其余类似\n```\n\n### 迭代器\n\n解引用一个关联容器迭代器，会得到一个 `value_type` 的**引用**\n\n```c++\nauto map_it = mp.begin();\n//(*map_it) 是 value_type，一个pair类型的引用\n// -> 可以用来解引用\nmap_it->first   // 关键字，是const的\nmap_it->second  // 值，非const，可以改变\n++map_it->second; // 值自增 1\n\n// set 的迭代器是 const 的，set的关键字是只读的\nauto set_it = st.begin();\n```\n\n### 遍历\n\n1. 用**迭代器**遍历\n\n```c++\nauto map_it = mp.cbegin();\nwhile(map_it != mp.cend()){\n    // do something with map_it->first, map_it->second\n    ++map_it;\n}\n```\n\n2. **for each** 语法\n\n```c++\nfor(auto x:mp){\n    //每一个 x 都是 pair 类型\n    //x.first\n    //x.second\n}\n```\n\n### 添加元素\n\n1. set\n\n```c++\nvecrot<int> v = {2,4,6,8,2,5,1};\n\nset<int> st;\nst.insert(v.begin(), v.end()); //一对迭代器\nst.insert({1,3,4,5,6,7});\n```\n\n2. map\n\n`insert` 一个 `pair`\n\n``` c++\nmap<string, int> mp;\nstring word;\n\nmp.insert({word, 1});  // 初始化列表构造 pair\nmp.insert(pair<string, int>(word, 1);  // pair 没有不带等号的列表初始化\nmp.insert(make_pair<string, int>(word, 1)); // make_pair 是一个函数\nmp.insert(map<string, int>::value_type(word, 1)); //也用小括号来初始化一个 pair\n```\n\n\n\n3. **`insert` 的返回值**\n\n- **不重**（有添加失败的风险，已存在）\n\n添加**单一元素**的 `insert` 和 `emplace` 返回一个 **pair<迭代器，bool>**\n\n`迭代器`：指向刚添加的元素\n\n`bool`：如果插入成功（**从无到有**），返回 `true`，否则返回 `false`\n\n- **可重**（没有添加失败的风险）\n\nmulti，`insert`只返回一个迭代器，指向刚添加的新元素\n\n### 删除元素\n\n![从关联容器删除元素](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211113111113342.png)\n\n### 特殊的map下标\n\n```c++\nmp[key]==value  访问 键key 对应的 value值\n```\n\n- 若 `key` 不存在，则**插入**，并且将其值进行初始化 `value`\n\n- 只能对 **非const** 的 `map` 使用下标，因为可能会插入值\n- map 的下标操作返回一个 **mapped_type** 对象，**左值**\n\n![map的下标操作](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211113111754675.png)\n\n### 访问、查找元素\n\n![在一个关联容器中查找操作](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211113112310777.png)\n\n![查找](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211113112230892.png)\n\n```c++\nif(mp.find(\"one key\") == mp.end()){\n    ...\n}\n```\n\n### 无序容器\n\nunordered_map，unordered_set\n\n底层由哈希表实现，查找迅速\n","source":"_posts/C++基础/STL/关联容器/关联容器基础.md","raw":"---\ntypora-root-url: ..\\..\\..\\..\\..\\..\\..\\static\n---\n\n\n\n## 关联容器(map, set, pair)\n\n### 定义\n\n- **空容器**（调用默认构造函数）\n\n```c++\nmap<string, size_t> mp; \nset<string> st; \n```\n\n- **列表初始化**\n\n```c++\nset<string> st = {\"aaa\",\"bbb\"};\nmap<string, string> mp = {{\"Joey\",\"Phoebe\"},{\"Ross\",\"Rachel\"}};\n```\n\n- **迭代器**\n\n```c++\nvector<int> ivec{1,2,3,4};\nset<int> iset(ivec.begin(), ivec.end());\n```\n\n也可以将关联容器初始化为另一个同类型容器的**拷贝**【?】\n\n从一个**值范围**来初始化关联容器，只要这些值能转化为容器所需类型【?】\n\n**值初始化**【?】\n\n### **pair** 相关\n\n- 基础操作\n\n![pair上的操作](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211113101831838.png)\n\n- 返回值类型为 pair（对返回值列表初始化）\n\n```c++\npair<string, int> my_fun(){\n    ...\n    return {s1, i1};\n    return pair<string, int>(); //构造一个空的 pair\n    \n}\n```\n\n### 关键字、值类型\n\n```c++\nkey_type\t\t\t键类型\nmapped_type\t\t\t值类型（只适用于map）\nvalue_type\t\t\t对set，与key_type相同\n\t\t\t\t\t对map，pair键值对：pair<const key_type, mapped_type>, //注意第一个为const\n```\n\n如何使用？：**域运算符**\n\n```c++\nmap<string, int>::mapped_type v1;  //其余类似\n```\n\n### 迭代器\n\n解引用一个关联容器迭代器，会得到一个 `value_type` 的**引用**\n\n```c++\nauto map_it = mp.begin();\n//(*map_it) 是 value_type，一个pair类型的引用\n// -> 可以用来解引用\nmap_it->first   // 关键字，是const的\nmap_it->second  // 值，非const，可以改变\n++map_it->second; // 值自增 1\n\n// set 的迭代器是 const 的，set的关键字是只读的\nauto set_it = st.begin();\n```\n\n### 遍历\n\n1. 用**迭代器**遍历\n\n```c++\nauto map_it = mp.cbegin();\nwhile(map_it != mp.cend()){\n    // do something with map_it->first, map_it->second\n    ++map_it;\n}\n```\n\n2. **for each** 语法\n\n```c++\nfor(auto x:mp){\n    //每一个 x 都是 pair 类型\n    //x.first\n    //x.second\n}\n```\n\n### 添加元素\n\n1. set\n\n```c++\nvecrot<int> v = {2,4,6,8,2,5,1};\n\nset<int> st;\nst.insert(v.begin(), v.end()); //一对迭代器\nst.insert({1,3,4,5,6,7});\n```\n\n2. map\n\n`insert` 一个 `pair`\n\n``` c++\nmap<string, int> mp;\nstring word;\n\nmp.insert({word, 1});  // 初始化列表构造 pair\nmp.insert(pair<string, int>(word, 1);  // pair 没有不带等号的列表初始化\nmp.insert(make_pair<string, int>(word, 1)); // make_pair 是一个函数\nmp.insert(map<string, int>::value_type(word, 1)); //也用小括号来初始化一个 pair\n```\n\n\n\n3. **`insert` 的返回值**\n\n- **不重**（有添加失败的风险，已存在）\n\n添加**单一元素**的 `insert` 和 `emplace` 返回一个 **pair<迭代器，bool>**\n\n`迭代器`：指向刚添加的元素\n\n`bool`：如果插入成功（**从无到有**），返回 `true`，否则返回 `false`\n\n- **可重**（没有添加失败的风险）\n\nmulti，`insert`只返回一个迭代器，指向刚添加的新元素\n\n### 删除元素\n\n![从关联容器删除元素](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211113111113342.png)\n\n### 特殊的map下标\n\n```c++\nmp[key]==value  访问 键key 对应的 value值\n```\n\n- 若 `key` 不存在，则**插入**，并且将其值进行初始化 `value`\n\n- 只能对 **非const** 的 `map` 使用下标，因为可能会插入值\n- map 的下标操作返回一个 **mapped_type** 对象，**左值**\n\n![map的下标操作](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211113111754675.png)\n\n### 访问、查找元素\n\n![在一个关联容器中查找操作](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211113112310777.png)\n\n![查找](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211113112230892.png)\n\n```c++\nif(mp.find(\"one key\") == mp.end()){\n    ...\n}\n```\n\n### 无序容器\n\nunordered_map，unordered_set\n\n底层由哈希表实现，查找迅速\n","slug":"C++基础/STL/关联容器/关联容器基础","published":1,"date":"2021-12-31T02:09:01.563Z","updated":"2021-12-06T08:02:08.999Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckxzva9fz000v7cu3fchd1opv","content":"<h2 id=\"关联容器-map-set-pair\"><a href=\"#关联容器-map-set-pair\" class=\"headerlink\" title=\"关联容器(map, set, pair)\"></a>关联容器(map, set, pair)</h2><h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><ul>\n<li><strong>空容器</strong>（调用默认构造函数）</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">map&lt;string, <span class=\"keyword\">size_t</span>&gt; mp; </span><br><span class=\"line\">set&lt;string&gt; st; </span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>列表初始化</strong></li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set&lt;string&gt; st = &#123;<span class=\"string\">&quot;aaa&quot;</span>,<span class=\"string\">&quot;bbb&quot;</span>&#125;;</span><br><span class=\"line\">map&lt;string, string&gt; mp = &#123;&#123;<span class=\"string\">&quot;Joey&quot;</span>,<span class=\"string\">&quot;Phoebe&quot;</span>&#125;,&#123;<span class=\"string\">&quot;Ross&quot;</span>,<span class=\"string\">&quot;Rachel&quot;</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>迭代器</strong></li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;<span class=\"keyword\">int</span>&gt; ivec&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>&#125;;</span><br><span class=\"line\"><span class=\"function\">set&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">iset</span><span class=\"params\">(ivec.begin(), ivec.end())</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>也可以将关联容器初始化为另一个同类型容器的<strong>拷贝</strong>【?】</p>\n<p>从一个<strong>值范围</strong>来初始化关联容器，只要这些值能转化为容器所需类型【?】</p>\n<p><strong>值初始化</strong>【?】</p>\n<h3 id=\"pair-相关\"><a href=\"#pair-相关\" class=\"headerlink\" title=\"pair 相关\"></a><strong>pair</strong> 相关</h3><ul>\n<li>基础操作</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211113101831838.png\" alt=\"pair上的操作\"></p>\n<ul>\n<li>返回值类型为 pair（对返回值列表初始化）</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">pair&lt;string, <span class=\"keyword\">int</span>&gt; <span class=\"title\">my_fun</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;s1, i1&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pair&lt;string, <span class=\"keyword\">int</span>&gt;(); <span class=\"comment\">//构造一个空的 pair</span></span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"关键字、值类型\"><a href=\"#关键字、值类型\" class=\"headerlink\" title=\"关键字、值类型\"></a>关键字、值类型</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">key_type\t\t\t键类型</span><br><span class=\"line\">mapped_type\t\t\t值类型（只适用于map）</span><br><span class=\"line\">value_type\t\t\t对set，与key_type相同</span><br><span class=\"line\">\t\t\t\t\t对map，pair键值对：pair&lt;<span class=\"keyword\">const</span> key_type, mapped_type&gt;, <span class=\"comment\">//注意第一个为const</span></span><br></pre></td></tr></table></figure>\n\n<p>如何使用？：<strong>域运算符</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">map&lt;string, <span class=\"keyword\">int</span>&gt;::mapped_type v1;  <span class=\"comment\">//其余类似</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"迭代器\"><a href=\"#迭代器\" class=\"headerlink\" title=\"迭代器\"></a>迭代器</h3><p>解引用一个关联容器迭代器，会得到一个 <code>value_type</code> 的<strong>引用</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> map_it = mp.<span class=\"built_in\">begin</span>();</span><br><span class=\"line\"><span class=\"comment\">//(*map_it) 是 value_type，一个pair类型的引用</span></span><br><span class=\"line\"><span class=\"comment\">// -&gt; 可以用来解引用</span></span><br><span class=\"line\">map_it-&gt;first   <span class=\"comment\">// 关键字，是const的</span></span><br><span class=\"line\">map_it-&gt;second  <span class=\"comment\">// 值，非const，可以改变</span></span><br><span class=\"line\">++map_it-&gt;second; <span class=\"comment\">// 值自增 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// set 的迭代器是 const 的，set的关键字是只读的</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> set_it = st.<span class=\"built_in\">begin</span>();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"遍历\"><a href=\"#遍历\" class=\"headerlink\" title=\"遍历\"></a>遍历</h3><ol>\n<li>用<strong>迭代器</strong>遍历</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> map_it = mp.<span class=\"built_in\">cbegin</span>();</span><br><span class=\"line\"><span class=\"keyword\">while</span>(map_it != mp.<span class=\"built_in\">cend</span>())&#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something with map_it-&gt;first, map_it-&gt;second</span></span><br><span class=\"line\">    ++map_it;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>for each</strong> 语法</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> x:mp)&#123;</span><br><span class=\"line\">    <span class=\"comment\">//每一个 x 都是 pair 类型</span></span><br><span class=\"line\">    <span class=\"comment\">//x.first</span></span><br><span class=\"line\">    <span class=\"comment\">//x.second</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"添加元素\"><a href=\"#添加元素\" class=\"headerlink\" title=\"添加元素\"></a>添加元素</h3><ol>\n<li>set</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vecrot&lt;<span class=\"keyword\">int</span>&gt; v = &#123;<span class=\"number\">2</span>,<span class=\"number\">4</span>,<span class=\"number\">6</span>,<span class=\"number\">8</span>,<span class=\"number\">2</span>,<span class=\"number\">5</span>,<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">set&lt;<span class=\"keyword\">int</span>&gt; st;</span><br><span class=\"line\">st.<span class=\"built_in\">insert</span>(v.<span class=\"built_in\">begin</span>(), v.<span class=\"built_in\">end</span>()); <span class=\"comment\">//一对迭代器</span></span><br><span class=\"line\">st.<span class=\"built_in\">insert</span>(&#123;<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>&#125;);</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>map</li>\n</ol>\n<p><code>insert</code> 一个 <code>pair</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">map&lt;string, <span class=\"keyword\">int</span>&gt; mp;</span><br><span class=\"line\">string word;</span><br><span class=\"line\"></span><br><span class=\"line\">mp.<span class=\"built_in\">insert</span>(&#123;word, <span class=\"number\">1</span>&#125;);  <span class=\"comment\">// 初始化列表构造 pair</span></span><br><span class=\"line\">mp.<span class=\"built_in\">insert</span>(pair&lt;string, <span class=\"keyword\">int</span>&gt;(word, <span class=\"number\">1</span>);  <span class=\"comment\">// pair 没有不带等号的列表初始化</span></span><br><span class=\"line\">mp.<span class=\"built_in\">insert</span>(make_pair&lt;string, <span class=\"keyword\">int</span>&gt;(word, <span class=\"number\">1</span>)); <span class=\"comment\">// make_pair 是一个函数</span></span><br><span class=\"line\">mp.<span class=\"built_in\">insert</span>(map&lt;string, <span class=\"keyword\">int</span>&gt;::<span class=\"built_in\">value_type</span>(word, <span class=\"number\">1</span>)); <span class=\"comment\">//也用小括号来初始化一个 pair</span></span><br></pre></td></tr></table></figure>\n\n\n\n<ol start=\"3\">\n<li><strong><code>insert</code> 的返回值</strong></li>\n</ol>\n<ul>\n<li><strong>不重</strong>（有添加失败的风险，已存在）</li>\n</ul>\n<p>添加<strong>单一元素</strong>的 <code>insert</code> 和 <code>emplace</code> 返回一个 <strong>pair&lt;迭代器，bool&gt;</strong></p>\n<p><code>迭代器</code>：指向刚添加的元素</p>\n<p><code>bool</code>：如果插入成功（<strong>从无到有</strong>），返回 <code>true</code>，否则返回 <code>false</code></p>\n<ul>\n<li><strong>可重</strong>（没有添加失败的风险）</li>\n</ul>\n<p>multi，<code>insert</code>只返回一个迭代器，指向刚添加的新元素</p>\n<h3 id=\"删除元素\"><a href=\"#删除元素\" class=\"headerlink\" title=\"删除元素\"></a>删除元素</h3><p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211113111113342.png\" alt=\"从关联容器删除元素\"></p>\n<h3 id=\"特殊的map下标\"><a href=\"#特殊的map下标\" class=\"headerlink\" title=\"特殊的map下标\"></a>特殊的map下标</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mp[key]==value  访问 键key 对应的 value值</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>若 <code>key</code> 不存在，则<strong>插入</strong>，并且将其值进行初始化 <code>value</code></p>\n</li>\n<li><p>只能对 <strong>非const</strong> 的 <code>map</code> 使用下标，因为可能会插入值</p>\n</li>\n<li><p>map 的下标操作返回一个 <strong>mapped_type</strong> 对象，<strong>左值</strong></p>\n</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211113111754675.png\" alt=\"map的下标操作\"></p>\n<h3 id=\"访问、查找元素\"><a href=\"#访问、查找元素\" class=\"headerlink\" title=\"访问、查找元素\"></a>访问、查找元素</h3><p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211113112310777.png\" alt=\"在一个关联容器中查找操作\"></p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211113112230892.png\" alt=\"查找\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(mp.<span class=\"built_in\">find</span>(<span class=\"string\">&quot;one key&quot;</span>) == mp.<span class=\"built_in\">end</span>())&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"无序容器\"><a href=\"#无序容器\" class=\"headerlink\" title=\"无序容器\"></a>无序容器</h3><p>unordered_map，unordered_set</p>\n<p>底层由哈希表实现，查找迅速</p>\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<h2 id=\"关联容器-map-set-pair\"><a href=\"#关联容器-map-set-pair\" class=\"headerlink\" title=\"关联容器(map, set, pair)\"></a>关联容器(map, set, pair)</h2><h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><ul>\n<li><strong>空容器</strong>（调用默认构造函数）</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">map&lt;string, <span class=\"keyword\">size_t</span>&gt; mp; </span><br><span class=\"line\">set&lt;string&gt; st; </span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>列表初始化</strong></li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set&lt;string&gt; st = &#123;<span class=\"string\">&quot;aaa&quot;</span>,<span class=\"string\">&quot;bbb&quot;</span>&#125;;</span><br><span class=\"line\">map&lt;string, string&gt; mp = &#123;&#123;<span class=\"string\">&quot;Joey&quot;</span>,<span class=\"string\">&quot;Phoebe&quot;</span>&#125;,&#123;<span class=\"string\">&quot;Ross&quot;</span>,<span class=\"string\">&quot;Rachel&quot;</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>迭代器</strong></li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;<span class=\"keyword\">int</span>&gt; ivec&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>&#125;;</span><br><span class=\"line\"><span class=\"function\">set&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">iset</span><span class=\"params\">(ivec.begin(), ivec.end())</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>也可以将关联容器初始化为另一个同类型容器的<strong>拷贝</strong>【?】</p>\n<p>从一个<strong>值范围</strong>来初始化关联容器，只要这些值能转化为容器所需类型【?】</p>\n<p><strong>值初始化</strong>【?】</p>\n<h3 id=\"pair-相关\"><a href=\"#pair-相关\" class=\"headerlink\" title=\"pair 相关\"></a><strong>pair</strong> 相关</h3><ul>\n<li>基础操作</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211113101831838.png\" alt=\"pair上的操作\"></p>\n<ul>\n<li>返回值类型为 pair（对返回值列表初始化）</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">pair&lt;string, <span class=\"keyword\">int</span>&gt; <span class=\"title\">my_fun</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;s1, i1&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pair&lt;string, <span class=\"keyword\">int</span>&gt;(); <span class=\"comment\">//构造一个空的 pair</span></span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"关键字、值类型\"><a href=\"#关键字、值类型\" class=\"headerlink\" title=\"关键字、值类型\"></a>关键字、值类型</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">key_type\t\t\t键类型</span><br><span class=\"line\">mapped_type\t\t\t值类型（只适用于map）</span><br><span class=\"line\">value_type\t\t\t对set，与key_type相同</span><br><span class=\"line\">\t\t\t\t\t对map，pair键值对：pair&lt;<span class=\"keyword\">const</span> key_type, mapped_type&gt;, <span class=\"comment\">//注意第一个为const</span></span><br></pre></td></tr></table></figure>\n\n<p>如何使用？：<strong>域运算符</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">map&lt;string, <span class=\"keyword\">int</span>&gt;::mapped_type v1;  <span class=\"comment\">//其余类似</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"迭代器\"><a href=\"#迭代器\" class=\"headerlink\" title=\"迭代器\"></a>迭代器</h3><p>解引用一个关联容器迭代器，会得到一个 <code>value_type</code> 的<strong>引用</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> map_it = mp.<span class=\"built_in\">begin</span>();</span><br><span class=\"line\"><span class=\"comment\">//(*map_it) 是 value_type，一个pair类型的引用</span></span><br><span class=\"line\"><span class=\"comment\">// -&gt; 可以用来解引用</span></span><br><span class=\"line\">map_it-&gt;first   <span class=\"comment\">// 关键字，是const的</span></span><br><span class=\"line\">map_it-&gt;second  <span class=\"comment\">// 值，非const，可以改变</span></span><br><span class=\"line\">++map_it-&gt;second; <span class=\"comment\">// 值自增 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// set 的迭代器是 const 的，set的关键字是只读的</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> set_it = st.<span class=\"built_in\">begin</span>();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"遍历\"><a href=\"#遍历\" class=\"headerlink\" title=\"遍历\"></a>遍历</h3><ol>\n<li>用<strong>迭代器</strong>遍历</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> map_it = mp.<span class=\"built_in\">cbegin</span>();</span><br><span class=\"line\"><span class=\"keyword\">while</span>(map_it != mp.<span class=\"built_in\">cend</span>())&#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something with map_it-&gt;first, map_it-&gt;second</span></span><br><span class=\"line\">    ++map_it;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>for each</strong> 语法</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> x:mp)&#123;</span><br><span class=\"line\">    <span class=\"comment\">//每一个 x 都是 pair 类型</span></span><br><span class=\"line\">    <span class=\"comment\">//x.first</span></span><br><span class=\"line\">    <span class=\"comment\">//x.second</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"添加元素\"><a href=\"#添加元素\" class=\"headerlink\" title=\"添加元素\"></a>添加元素</h3><ol>\n<li>set</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vecrot&lt;<span class=\"keyword\">int</span>&gt; v = &#123;<span class=\"number\">2</span>,<span class=\"number\">4</span>,<span class=\"number\">6</span>,<span class=\"number\">8</span>,<span class=\"number\">2</span>,<span class=\"number\">5</span>,<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">set&lt;<span class=\"keyword\">int</span>&gt; st;</span><br><span class=\"line\">st.<span class=\"built_in\">insert</span>(v.<span class=\"built_in\">begin</span>(), v.<span class=\"built_in\">end</span>()); <span class=\"comment\">//一对迭代器</span></span><br><span class=\"line\">st.<span class=\"built_in\">insert</span>(&#123;<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>&#125;);</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>map</li>\n</ol>\n<p><code>insert</code> 一个 <code>pair</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">map&lt;string, <span class=\"keyword\">int</span>&gt; mp;</span><br><span class=\"line\">string word;</span><br><span class=\"line\"></span><br><span class=\"line\">mp.<span class=\"built_in\">insert</span>(&#123;word, <span class=\"number\">1</span>&#125;);  <span class=\"comment\">// 初始化列表构造 pair</span></span><br><span class=\"line\">mp.<span class=\"built_in\">insert</span>(pair&lt;string, <span class=\"keyword\">int</span>&gt;(word, <span class=\"number\">1</span>);  <span class=\"comment\">// pair 没有不带等号的列表初始化</span></span><br><span class=\"line\">mp.<span class=\"built_in\">insert</span>(make_pair&lt;string, <span class=\"keyword\">int</span>&gt;(word, <span class=\"number\">1</span>)); <span class=\"comment\">// make_pair 是一个函数</span></span><br><span class=\"line\">mp.<span class=\"built_in\">insert</span>(map&lt;string, <span class=\"keyword\">int</span>&gt;::<span class=\"built_in\">value_type</span>(word, <span class=\"number\">1</span>)); <span class=\"comment\">//也用小括号来初始化一个 pair</span></span><br></pre></td></tr></table></figure>\n\n\n\n<ol start=\"3\">\n<li><strong><code>insert</code> 的返回值</strong></li>\n</ol>\n<ul>\n<li><strong>不重</strong>（有添加失败的风险，已存在）</li>\n</ul>\n<p>添加<strong>单一元素</strong>的 <code>insert</code> 和 <code>emplace</code> 返回一个 <strong>pair&lt;迭代器，bool&gt;</strong></p>\n<p><code>迭代器</code>：指向刚添加的元素</p>\n<p><code>bool</code>：如果插入成功（<strong>从无到有</strong>），返回 <code>true</code>，否则返回 <code>false</code></p>\n<ul>\n<li><strong>可重</strong>（没有添加失败的风险）</li>\n</ul>\n<p>multi，<code>insert</code>只返回一个迭代器，指向刚添加的新元素</p>\n<h3 id=\"删除元素\"><a href=\"#删除元素\" class=\"headerlink\" title=\"删除元素\"></a>删除元素</h3><p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211113111113342.png\" alt=\"从关联容器删除元素\"></p>\n<h3 id=\"特殊的map下标\"><a href=\"#特殊的map下标\" class=\"headerlink\" title=\"特殊的map下标\"></a>特殊的map下标</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mp[key]==value  访问 键key 对应的 value值</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>若 <code>key</code> 不存在，则<strong>插入</strong>，并且将其值进行初始化 <code>value</code></p>\n</li>\n<li><p>只能对 <strong>非const</strong> 的 <code>map</code> 使用下标，因为可能会插入值</p>\n</li>\n<li><p>map 的下标操作返回一个 <strong>mapped_type</strong> 对象，<strong>左值</strong></p>\n</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211113111754675.png\" alt=\"map的下标操作\"></p>\n<h3 id=\"访问、查找元素\"><a href=\"#访问、查找元素\" class=\"headerlink\" title=\"访问、查找元素\"></a>访问、查找元素</h3><p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211113112310777.png\" alt=\"在一个关联容器中查找操作\"></p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211113112230892.png\" alt=\"查找\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(mp.<span class=\"built_in\">find</span>(<span class=\"string\">&quot;one key&quot;</span>) == mp.<span class=\"built_in\">end</span>())&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"无序容器\"><a href=\"#无序容器\" class=\"headerlink\" title=\"无序容器\"></a>无序容器</h3><p>unordered_map，unordered_set</p>\n<p>底层由哈希表实现，查找迅速</p>\n"},{"title":"顺序容器总结","date":"2021-12-02T16:00:00.000Z","draft":false,"_content":"\n### 定义和初始化\n\n![表9.3：容器定义与初始化](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211113203927524.png)\n\n- **拷贝初始化**：要求两个**容器的类型**及其**元素类型**必须**匹配**\n\n- **迭代器初始化**：**容器类型**可以**不同**，**元素类型**能**转换**就行\n\n  ```cpp\n  vector<const char*> v1;\n  forward_list<string> words(v1.begin(), v1.end()); //OK\n  ```\n\n### assign、swap\n\n- **assign**（赋值、替换）：**容器类型**可以**不同**，**元素类型**能**转换**就行\n\n  ```cpp\n  vector<const char*> v1;\n  forward_list<string> words;\n  \n  word.assign(v1.begin(), v1.end()); //替换，可以转换类型\n  word.assign(10, \"abc\"); //替换\n  ```\n\n- **swap**\n\n  <u>元素本身并未交换，只是交换了两个容器的内部数据结构</u>【有点不理解，先挖个坑，待细究】\n\n  除 `string` 外，指向容器的迭代器、引用、指针在 swap 操作后都**不会失效**\n\n  `string` 的 `swap` 会导致迭代器、引用、指针**失效**\n\n### 添加元素\n\n\n\n![添加元素](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211113210410280.png)\n\n\n\n以下记录几点需要特别注意的地方：\n\n1. 注意 `push_back` 是**拷贝**，会创建一个**局部临时对象**\n2. `insert` 返回指向刚加入元素的迭代器【想想也是】\n3. `emplace` 是**直接构造**而不是拷贝，参数必须和构造函数相匹配\n\n### 访问元素\n\n![访问元素](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211113211340830.png)\n\n需要注意的都已经在图中标出\n\n### 删除元素\n\n![删除元素](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211113211754174.png)\n\n注意点：\n\n1. 返回 void，需要自行保存元素\n\n### 特殊的 forward_list\n\n- 单链表添加或删除一个元素，需要访问其**前驱**，所以需要有其前驱的迭代器\n\n- 为了方便访问头元素，定义 `before_begin()`，指向**头元素之前**的位置\n\n![forward_list](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211113212237994.png)\n\n### 容器大小\n\n#### 1. resize\n\n不减小容器的 `capacity`，对 `size` 可增可减\n\n![容器大小](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211115095132554.png)\n\n```c++\nlist<int> li(10, 42); //10个42\nli.resize(15); //多添5个0，总个数为15个\nli.resize(25, -1); //多添10个-1，旧元素不管\nli.resize(5); //删除20个元素\n```\n\n#### 2. reverse\n\n通知容器它应该准备保存多少个元素，如果**需求<=当前容量**，`reverse` 什么也不做，它不会减小 `capacity`\n\n如果**需求>当前容量**，`reverse` 至少分配与需求一样大的内存空间\n\n#### 3. capacity VS size\n\n`capacity` 是容器当前分配的**最大内存空间**，表示**最多**可以存储多少个元素\n\n`size` 是容器中**当前现有**元素个数\n\n![保留空间](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211115100400348.png)\n\n### 迭代器失效\n\n记录几个不好理解的吧：\n\n- 对于 `deque`\n\n  如果在**首尾位置添加**元素，**迭代器**会失效，但**指向存在的元素的引用和指针**不会失效\n\n  如果在**首尾之外**的其他任何位置**删除**元素，那么**所有**元素（包括被删除元素）的迭代器、指针、引用都会失效\n\n  如果是**删除** `deque` 的**尾（首）元素**，**尾后（首元素）**迭代器失效，但**其他**迭代器、指针、引用不受影响\n\n- 对于 `list` 和 `forward_list`\n\n  不管是添加还是删除（被删除的肯定失效了），三大件均有效【其实这个好理解...】\n\n### 额外的string操作\n\n大致可分为\n\n1. 提供 string 类和 C 风格字符数组之间的相互转换\n2. 用下标替换迭代器的版本\n\n#### `C c1(c2)`的扩展\n\n![构造string的其他方法](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211115102024853.png)\n\n```cpp\nstring s(cp);  //如果不加 n，要求cp（字符数组）必须要以空字符结束\n\nconst char* cp = \"Hello World\";  //以空字符结束\nchar noNull[] = {'H', 'i'}; //没有以空字符结束\n```\n\n#### `substr`\n\n（开始位置，计数值）\n\n```cpp\nstring substr (size_t pos = 0, size_t len = npos) const;\n```\n\n如果开始位置超过了 `string` 的大小，`substr` 函数抛出 `out_of_range `异常\n\n如果开始位置加上计数值大于 `string` 的大小，则只拷贝到 `string` 的末尾\n\n#### 下标版本的 `insert` 和 `erase`\n\n还有 `assign`、`append`、`replace`\n\n![修改string的操作](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211115103633100.png)\n\n`pos=0`，头插\n\n`pos=s.size()`，尾插\n\n#### `string`搜索\n\n只记一个好了\n\n```cpp\nstring.find(args)    //查找 s 中 args 第一次出现的位置\n```\n\n![args必须是以下形式之一](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211115104416494.png)\n\n#### `s.compare` 比较\n\n```cpp\ns.compare(s2);  \n// s == s2 返回 0\n// s > s2 正数\n// s < s2 负数\n```\n\n![s.compare的几种参数形式](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211130160159724.png)\n\n#### `string`和数值之间的转换\n\n```cpp\nto_string(val)    //val可以是任何算数类型\n```\n\n要转换为数值的 `string` 的第一个非空白符必须是数值中可能出现的字符（+ - . 0x 等）\n\n```cpp\nstoi(s, p, b=10);    // b表示进制，默认是10\n\t\t\t\t\t// p 没搞懂有啥用，先不管，平时可以为空【?】\n```\n\n如果 `string` 无法转换为一个数值，函数抛出 `invalid_argument` 异常\n\n如果被转换的数值无法用任何类型表示，则抛出 `out_of_range` 异常\n\n### 容器适配器\n\nstack、queue、priority_queue\n\n![所有容器适配器都支持的操作](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211115111743807.png)\n\n默认情况下，`stack` 和 `queue` 是基于 `deque` 实现的，`priority_queue` 是在 `vector` 之上实现的\n\n\n\n可以在创建适配器的时候，给予第二个类型参数，以**改变底层容器**类型，例如：\n\n```cpp\nstack<string, vector<string>> str_stk; //基于vector实现\n```\n\n#### stack\n\n要求能添加、删除、访问尾元素，所以不能基于 `forward_list` 和 `array` 实现，其他都行\n\n![表9.17未列出的栈操作](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211115112645958.png)\n\n**不能**使用底层容器类型的操作\n\n#### queue\n\n可以基于 `list`、`deque` 实现，不能基于 `vector` 实现\n\n![queue图](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211115113710892.png)\n\n#### priority_queue\n\nfront、push_back、pop_back，随机访问\n\n可以基于 `vector`、`deque`，不能基于 `list`\n\n![未列出的queue](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211115113250578.png)\n\n![图queue](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211115113258764.png)\n\n*书中存在错误，pop() 是要删除的*\n\n![heap](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211115113844367.png)\n\n*事实上，**priority_queue** 的底层实现是 **heap***\n\n\n\n优先队列自定义比较器，未完待续...\n\n\n\n参考资料：Primer C++ 第五版\n\n","source":"_posts/C++基础/STL/顺序容器/顺序容器基础.md","raw":"---\ntitle: \"顺序容器总结\"\ndate: 2021-12-03\ndraft: false\ntags: [\"STL\"]\ncategories: [\"C++\"]\n---\n\n### 定义和初始化\n\n![表9.3：容器定义与初始化](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211113203927524.png)\n\n- **拷贝初始化**：要求两个**容器的类型**及其**元素类型**必须**匹配**\n\n- **迭代器初始化**：**容器类型**可以**不同**，**元素类型**能**转换**就行\n\n  ```cpp\n  vector<const char*> v1;\n  forward_list<string> words(v1.begin(), v1.end()); //OK\n  ```\n\n### assign、swap\n\n- **assign**（赋值、替换）：**容器类型**可以**不同**，**元素类型**能**转换**就行\n\n  ```cpp\n  vector<const char*> v1;\n  forward_list<string> words;\n  \n  word.assign(v1.begin(), v1.end()); //替换，可以转换类型\n  word.assign(10, \"abc\"); //替换\n  ```\n\n- **swap**\n\n  <u>元素本身并未交换，只是交换了两个容器的内部数据结构</u>【有点不理解，先挖个坑，待细究】\n\n  除 `string` 外，指向容器的迭代器、引用、指针在 swap 操作后都**不会失效**\n\n  `string` 的 `swap` 会导致迭代器、引用、指针**失效**\n\n### 添加元素\n\n\n\n![添加元素](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211113210410280.png)\n\n\n\n以下记录几点需要特别注意的地方：\n\n1. 注意 `push_back` 是**拷贝**，会创建一个**局部临时对象**\n2. `insert` 返回指向刚加入元素的迭代器【想想也是】\n3. `emplace` 是**直接构造**而不是拷贝，参数必须和构造函数相匹配\n\n### 访问元素\n\n![访问元素](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211113211340830.png)\n\n需要注意的都已经在图中标出\n\n### 删除元素\n\n![删除元素](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211113211754174.png)\n\n注意点：\n\n1. 返回 void，需要自行保存元素\n\n### 特殊的 forward_list\n\n- 单链表添加或删除一个元素，需要访问其**前驱**，所以需要有其前驱的迭代器\n\n- 为了方便访问头元素，定义 `before_begin()`，指向**头元素之前**的位置\n\n![forward_list](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211113212237994.png)\n\n### 容器大小\n\n#### 1. resize\n\n不减小容器的 `capacity`，对 `size` 可增可减\n\n![容器大小](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211115095132554.png)\n\n```c++\nlist<int> li(10, 42); //10个42\nli.resize(15); //多添5个0，总个数为15个\nli.resize(25, -1); //多添10个-1，旧元素不管\nli.resize(5); //删除20个元素\n```\n\n#### 2. reverse\n\n通知容器它应该准备保存多少个元素，如果**需求<=当前容量**，`reverse` 什么也不做，它不会减小 `capacity`\n\n如果**需求>当前容量**，`reverse` 至少分配与需求一样大的内存空间\n\n#### 3. capacity VS size\n\n`capacity` 是容器当前分配的**最大内存空间**，表示**最多**可以存储多少个元素\n\n`size` 是容器中**当前现有**元素个数\n\n![保留空间](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211115100400348.png)\n\n### 迭代器失效\n\n记录几个不好理解的吧：\n\n- 对于 `deque`\n\n  如果在**首尾位置添加**元素，**迭代器**会失效，但**指向存在的元素的引用和指针**不会失效\n\n  如果在**首尾之外**的其他任何位置**删除**元素，那么**所有**元素（包括被删除元素）的迭代器、指针、引用都会失效\n\n  如果是**删除** `deque` 的**尾（首）元素**，**尾后（首元素）**迭代器失效，但**其他**迭代器、指针、引用不受影响\n\n- 对于 `list` 和 `forward_list`\n\n  不管是添加还是删除（被删除的肯定失效了），三大件均有效【其实这个好理解...】\n\n### 额外的string操作\n\n大致可分为\n\n1. 提供 string 类和 C 风格字符数组之间的相互转换\n2. 用下标替换迭代器的版本\n\n#### `C c1(c2)`的扩展\n\n![构造string的其他方法](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211115102024853.png)\n\n```cpp\nstring s(cp);  //如果不加 n，要求cp（字符数组）必须要以空字符结束\n\nconst char* cp = \"Hello World\";  //以空字符结束\nchar noNull[] = {'H', 'i'}; //没有以空字符结束\n```\n\n#### `substr`\n\n（开始位置，计数值）\n\n```cpp\nstring substr (size_t pos = 0, size_t len = npos) const;\n```\n\n如果开始位置超过了 `string` 的大小，`substr` 函数抛出 `out_of_range `异常\n\n如果开始位置加上计数值大于 `string` 的大小，则只拷贝到 `string` 的末尾\n\n#### 下标版本的 `insert` 和 `erase`\n\n还有 `assign`、`append`、`replace`\n\n![修改string的操作](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211115103633100.png)\n\n`pos=0`，头插\n\n`pos=s.size()`，尾插\n\n#### `string`搜索\n\n只记一个好了\n\n```cpp\nstring.find(args)    //查找 s 中 args 第一次出现的位置\n```\n\n![args必须是以下形式之一](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211115104416494.png)\n\n#### `s.compare` 比较\n\n```cpp\ns.compare(s2);  \n// s == s2 返回 0\n// s > s2 正数\n// s < s2 负数\n```\n\n![s.compare的几种参数形式](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211130160159724.png)\n\n#### `string`和数值之间的转换\n\n```cpp\nto_string(val)    //val可以是任何算数类型\n```\n\n要转换为数值的 `string` 的第一个非空白符必须是数值中可能出现的字符（+ - . 0x 等）\n\n```cpp\nstoi(s, p, b=10);    // b表示进制，默认是10\n\t\t\t\t\t// p 没搞懂有啥用，先不管，平时可以为空【?】\n```\n\n如果 `string` 无法转换为一个数值，函数抛出 `invalid_argument` 异常\n\n如果被转换的数值无法用任何类型表示，则抛出 `out_of_range` 异常\n\n### 容器适配器\n\nstack、queue、priority_queue\n\n![所有容器适配器都支持的操作](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211115111743807.png)\n\n默认情况下，`stack` 和 `queue` 是基于 `deque` 实现的，`priority_queue` 是在 `vector` 之上实现的\n\n\n\n可以在创建适配器的时候，给予第二个类型参数，以**改变底层容器**类型，例如：\n\n```cpp\nstack<string, vector<string>> str_stk; //基于vector实现\n```\n\n#### stack\n\n要求能添加、删除、访问尾元素，所以不能基于 `forward_list` 和 `array` 实现，其他都行\n\n![表9.17未列出的栈操作](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211115112645958.png)\n\n**不能**使用底层容器类型的操作\n\n#### queue\n\n可以基于 `list`、`deque` 实现，不能基于 `vector` 实现\n\n![queue图](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211115113710892.png)\n\n#### priority_queue\n\nfront、push_back、pop_back，随机访问\n\n可以基于 `vector`、`deque`，不能基于 `list`\n\n![未列出的queue](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211115113250578.png)\n\n![图queue](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211115113258764.png)\n\n*书中存在错误，pop() 是要删除的*\n\n![heap](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211115113844367.png)\n\n*事实上，**priority_queue** 的底层实现是 **heap***\n\n\n\n优先队列自定义比较器，未完待续...\n\n\n\n参考资料：Primer C++ 第五版\n\n","slug":"C++基础/STL/顺序容器/顺序容器基础","published":1,"updated":"2021-12-31T02:54:04.993Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckxzva9g0000x7cu31cqn1bkc","content":"<h3 id=\"定义和初始化\"><a href=\"#定义和初始化\" class=\"headerlink\" title=\"定义和初始化\"></a>定义和初始化</h3><p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211113203927524.png\" alt=\"表9.3：容器定义与初始化\"></p>\n<ul>\n<li><p><strong>拷贝初始化</strong>：要求两个<strong>容器的类型</strong>及其<strong>元素类型</strong>必须<strong>匹配</strong></p>\n</li>\n<li><p><strong>迭代器初始化</strong>：<strong>容器类型</strong>可以<strong>不同</strong>，<strong>元素类型</strong>能<strong>转换</strong>就行</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>*&gt; v1;</span><br><span class=\"line\"><span class=\"function\">forward_list&lt;string&gt; <span class=\"title\">words</span><span class=\"params\">(v1.begin(), v1.end())</span></span>; <span class=\"comment\">//OK</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"assign、swap\"><a href=\"#assign、swap\" class=\"headerlink\" title=\"assign、swap\"></a>assign、swap</h3><ul>\n<li><p><strong>assign</strong>（赋值、替换）：<strong>容器类型</strong>可以<strong>不同</strong>，<strong>元素类型</strong>能<strong>转换</strong>就行</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>*&gt; v1;</span><br><span class=\"line\">forward_list&lt;string&gt; words;</span><br><span class=\"line\"></span><br><span class=\"line\">word.<span class=\"built_in\">assign</span>(v1.<span class=\"built_in\">begin</span>(), v1.<span class=\"built_in\">end</span>()); <span class=\"comment\">//替换，可以转换类型</span></span><br><span class=\"line\">word.<span class=\"built_in\">assign</span>(<span class=\"number\">10</span>, <span class=\"string\">&quot;abc&quot;</span>); <span class=\"comment\">//替换</span></span><br></pre></td></tr></table></figure></li>\n<li><p><strong>swap</strong></p>\n<p><u>元素本身并未交换，只是交换了两个容器的内部数据结构</u>【有点不理解，先挖个坑，待细究】</p>\n<p>除 <code>string</code> 外，指向容器的迭代器、引用、指针在 swap 操作后都<strong>不会失效</strong></p>\n<p><code>string</code> 的 <code>swap</code> 会导致迭代器、引用、指针<strong>失效</strong></p>\n</li>\n</ul>\n<h3 id=\"添加元素\"><a href=\"#添加元素\" class=\"headerlink\" title=\"添加元素\"></a>添加元素</h3><p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211113210410280.png\" alt=\"添加元素\"></p>\n<p>以下记录几点需要特别注意的地方：</p>\n<ol>\n<li>注意 <code>push_back</code> 是<strong>拷贝</strong>，会创建一个<strong>局部临时对象</strong></li>\n<li><code>insert</code> 返回指向刚加入元素的迭代器【想想也是】</li>\n<li><code>emplace</code> 是<strong>直接构造</strong>而不是拷贝，参数必须和构造函数相匹配</li>\n</ol>\n<h3 id=\"访问元素\"><a href=\"#访问元素\" class=\"headerlink\" title=\"访问元素\"></a>访问元素</h3><p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211113211340830.png\" alt=\"访问元素\"></p>\n<p>需要注意的都已经在图中标出</p>\n<h3 id=\"删除元素\"><a href=\"#删除元素\" class=\"headerlink\" title=\"删除元素\"></a>删除元素</h3><p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211113211754174.png\" alt=\"删除元素\"></p>\n<p>注意点：</p>\n<ol>\n<li>返回 void，需要自行保存元素</li>\n</ol>\n<h3 id=\"特殊的-forward-list\"><a href=\"#特殊的-forward-list\" class=\"headerlink\" title=\"特殊的 forward_list\"></a>特殊的 forward_list</h3><ul>\n<li><p>单链表添加或删除一个元素，需要访问其<strong>前驱</strong>，所以需要有其前驱的迭代器</p>\n</li>\n<li><p>为了方便访问头元素，定义 <code>before_begin()</code>，指向<strong>头元素之前</strong>的位置</p>\n</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211113212237994.png\" alt=\"forward_list\"></p>\n<h3 id=\"容器大小\"><a href=\"#容器大小\" class=\"headerlink\" title=\"容器大小\"></a>容器大小</h3><h4 id=\"1-resize\"><a href=\"#1-resize\" class=\"headerlink\" title=\"1. resize\"></a>1. resize</h4><p>不减小容器的 <code>capacity</code>，对 <code>size</code> 可增可减</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211115095132554.png\" alt=\"容器大小\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">list&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">li</span><span class=\"params\">(<span class=\"number\">10</span>, <span class=\"number\">42</span>)</span></span>; <span class=\"comment\">//10个42</span></span><br><span class=\"line\">li.<span class=\"built_in\">resize</span>(<span class=\"number\">15</span>); <span class=\"comment\">//多添5个0，总个数为15个</span></span><br><span class=\"line\">li.<span class=\"built_in\">resize</span>(<span class=\"number\">25</span>, <span class=\"number\">-1</span>); <span class=\"comment\">//多添10个-1，旧元素不管</span></span><br><span class=\"line\">li.<span class=\"built_in\">resize</span>(<span class=\"number\">5</span>); <span class=\"comment\">//删除20个元素</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-reverse\"><a href=\"#2-reverse\" class=\"headerlink\" title=\"2. reverse\"></a>2. reverse</h4><p>通知容器它应该准备保存多少个元素，如果<strong>需求&lt;=当前容量</strong>，<code>reverse</code> 什么也不做，它不会减小 <code>capacity</code></p>\n<p>如果<strong>需求&gt;当前容量</strong>，<code>reverse</code> 至少分配与需求一样大的内存空间</p>\n<h4 id=\"3-capacity-VS-size\"><a href=\"#3-capacity-VS-size\" class=\"headerlink\" title=\"3. capacity VS size\"></a>3. capacity VS size</h4><p><code>capacity</code> 是容器当前分配的<strong>最大内存空间</strong>，表示<strong>最多</strong>可以存储多少个元素</p>\n<p><code>size</code> 是容器中<strong>当前现有</strong>元素个数</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211115100400348.png\" alt=\"保留空间\"></p>\n<h3 id=\"迭代器失效\"><a href=\"#迭代器失效\" class=\"headerlink\" title=\"迭代器失效\"></a>迭代器失效</h3><p>记录几个不好理解的吧：</p>\n<ul>\n<li><p>对于 <code>deque</code></p>\n<p>如果在<strong>首尾位置添加</strong>元素，<strong>迭代器</strong>会失效，但<strong>指向存在的元素的引用和指针</strong>不会失效</p>\n<p>如果在<strong>首尾之外</strong>的其他任何位置<strong>删除</strong>元素，那么<strong>所有</strong>元素（包括被删除元素）的迭代器、指针、引用都会失效</p>\n<p>如果是<strong>删除</strong> <code>deque</code> 的<strong>尾（首）元素</strong>，<strong>尾后（首元素）</strong>迭代器失效，但<strong>其他</strong>迭代器、指针、引用不受影响</p>\n</li>\n<li><p>对于 <code>list</code> 和 <code>forward_list</code></p>\n<p>不管是添加还是删除（被删除的肯定失效了），三大件均有效【其实这个好理解…】</p>\n</li>\n</ul>\n<h3 id=\"额外的string操作\"><a href=\"#额外的string操作\" class=\"headerlink\" title=\"额外的string操作\"></a>额外的string操作</h3><p>大致可分为</p>\n<ol>\n<li>提供 string 类和 C 风格字符数组之间的相互转换</li>\n<li>用下标替换迭代器的版本</li>\n</ol>\n<h4 id=\"C-c1-c2-的扩展\"><a href=\"#C-c1-c2-的扩展\" class=\"headerlink\" title=\"C c1(c2)的扩展\"></a><code>C c1(c2)</code>的扩展</h4><p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211115102024853.png\" alt=\"构造string的其他方法\"></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">string <span class=\"title\">s</span><span class=\"params\">(cp)</span></span>;  <span class=\"comment\">//如果不加 n，要求cp（字符数组）必须要以空字符结束</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* cp = <span class=\"string\">&quot;Hello World&quot;</span>;  <span class=\"comment\">//以空字符结束</span></span><br><span class=\"line\"><span class=\"keyword\">char</span> noNull[] = &#123;<span class=\"string\">&#x27;H&#x27;</span>, <span class=\"string\">&#x27;i&#x27;</span>&#125;; <span class=\"comment\">//没有以空字符结束</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"substr\"><a href=\"#substr\" class=\"headerlink\" title=\"substr\"></a><code>substr</code></h4><p>（开始位置，计数值）</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">string <span class=\"title\">substr</span> <span class=\"params\">(<span class=\"keyword\">size_t</span> pos = <span class=\"number\">0</span>, <span class=\"keyword\">size_t</span> len = npos)</span> <span class=\"keyword\">const</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>如果开始位置超过了 <code>string</code> 的大小，<code>substr</code> 函数抛出 <code>out_of_range </code>异常</p>\n<p>如果开始位置加上计数值大于 <code>string</code> 的大小，则只拷贝到 <code>string</code> 的末尾</p>\n<h4 id=\"下标版本的-insert-和-erase\"><a href=\"#下标版本的-insert-和-erase\" class=\"headerlink\" title=\"下标版本的 insert 和 erase\"></a>下标版本的 <code>insert</code> 和 <code>erase</code></h4><p>还有 <code>assign</code>、<code>append</code>、<code>replace</code></p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211115103633100.png\" alt=\"修改string的操作\"></p>\n<p><code>pos=0</code>，头插</p>\n<p><code>pos=s.size()</code>，尾插</p>\n<h4 id=\"string搜索\"><a href=\"#string搜索\" class=\"headerlink\" title=\"string搜索\"></a><code>string</code>搜索</h4><p>只记一个好了</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string.<span class=\"built_in\">find</span>(args)    <span class=\"comment\">//查找 s 中 args 第一次出现的位置</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211115104416494.png\" alt=\"args必须是以下形式之一\"></p>\n<h4 id=\"s-compare-比较\"><a href=\"#s-compare-比较\" class=\"headerlink\" title=\"s.compare 比较\"></a><code>s.compare</code> 比较</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s.<span class=\"built_in\">compare</span>(s2);  </span><br><span class=\"line\"><span class=\"comment\">// s == s2 返回 0</span></span><br><span class=\"line\"><span class=\"comment\">// s &gt; s2 正数</span></span><br><span class=\"line\"><span class=\"comment\">// s &lt; s2 负数</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211130160159724.png\" alt=\"s.compare的几种参数形式\"></p>\n<h4 id=\"string和数值之间的转换\"><a href=\"#string和数值之间的转换\" class=\"headerlink\" title=\"string和数值之间的转换\"></a><code>string</code>和数值之间的转换</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">to_string</span>(val)    <span class=\"comment\">//val可以是任何算数类型</span></span><br></pre></td></tr></table></figure>\n\n<p>要转换为数值的 <code>string</code> 的第一个非空白符必须是数值中可能出现的字符（+ - . 0x 等）</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">stoi</span>(s, p, b=<span class=\"number\">10</span>);    <span class=\"comment\">// b表示进制，默认是10</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// p 没搞懂有啥用，先不管，平时可以为空【?】</span></span><br></pre></td></tr></table></figure>\n\n<p>如果 <code>string</code> 无法转换为一个数值，函数抛出 <code>invalid_argument</code> 异常</p>\n<p>如果被转换的数值无法用任何类型表示，则抛出 <code>out_of_range</code> 异常</p>\n<h3 id=\"容器适配器\"><a href=\"#容器适配器\" class=\"headerlink\" title=\"容器适配器\"></a>容器适配器</h3><p>stack、queue、priority_queue</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211115111743807.png\" alt=\"所有容器适配器都支持的操作\"></p>\n<p>默认情况下，<code>stack</code> 和 <code>queue</code> 是基于 <code>deque</code> 实现的，<code>priority_queue</code> 是在 <code>vector</code> 之上实现的</p>\n<p>可以在创建适配器的时候，给予第二个类型参数，以<strong>改变底层容器</strong>类型，例如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stack&lt;string, vector&lt;string&gt;&gt; str_stk; <span class=\"comment\">//基于vector实现</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"stack\"><a href=\"#stack\" class=\"headerlink\" title=\"stack\"></a>stack</h4><p>要求能添加、删除、访问尾元素，所以不能基于 <code>forward_list</code> 和 <code>array</code> 实现，其他都行</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211115112645958.png\" alt=\"表9.17未列出的栈操作\"></p>\n<p><strong>不能</strong>使用底层容器类型的操作</p>\n<h4 id=\"queue\"><a href=\"#queue\" class=\"headerlink\" title=\"queue\"></a>queue</h4><p>可以基于 <code>list</code>、<code>deque</code> 实现，不能基于 <code>vector</code> 实现</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211115113710892.png\" alt=\"queue图\"></p>\n<h4 id=\"priority-queue\"><a href=\"#priority-queue\" class=\"headerlink\" title=\"priority_queue\"></a>priority_queue</h4><p>front、push_back、pop_back，随机访问</p>\n<p>可以基于 <code>vector</code>、<code>deque</code>，不能基于 <code>list</code></p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211115113250578.png\" alt=\"未列出的queue\"></p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211115113258764.png\" alt=\"图queue\"></p>\n<p><em>书中存在错误，pop() 是要删除的</em></p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211115113844367.png\" alt=\"heap\"></p>\n<p><em>事实上，*<em>priority_queue</em></em> 的底层实现是 <strong>heap</strong>*</p>\n<p>优先队列自定义比较器，未完待续…</p>\n<p>参考资料：Primer C++ 第五版</p>\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<h3 id=\"定义和初始化\"><a href=\"#定义和初始化\" class=\"headerlink\" title=\"定义和初始化\"></a>定义和初始化</h3><p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211113203927524.png\" alt=\"表9.3：容器定义与初始化\"></p>\n<ul>\n<li><p><strong>拷贝初始化</strong>：要求两个<strong>容器的类型</strong>及其<strong>元素类型</strong>必须<strong>匹配</strong></p>\n</li>\n<li><p><strong>迭代器初始化</strong>：<strong>容器类型</strong>可以<strong>不同</strong>，<strong>元素类型</strong>能<strong>转换</strong>就行</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>*&gt; v1;</span><br><span class=\"line\"><span class=\"function\">forward_list&lt;string&gt; <span class=\"title\">words</span><span class=\"params\">(v1.begin(), v1.end())</span></span>; <span class=\"comment\">//OK</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"assign、swap\"><a href=\"#assign、swap\" class=\"headerlink\" title=\"assign、swap\"></a>assign、swap</h3><ul>\n<li><p><strong>assign</strong>（赋值、替换）：<strong>容器类型</strong>可以<strong>不同</strong>，<strong>元素类型</strong>能<strong>转换</strong>就行</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>*&gt; v1;</span><br><span class=\"line\">forward_list&lt;string&gt; words;</span><br><span class=\"line\"></span><br><span class=\"line\">word.<span class=\"built_in\">assign</span>(v1.<span class=\"built_in\">begin</span>(), v1.<span class=\"built_in\">end</span>()); <span class=\"comment\">//替换，可以转换类型</span></span><br><span class=\"line\">word.<span class=\"built_in\">assign</span>(<span class=\"number\">10</span>, <span class=\"string\">&quot;abc&quot;</span>); <span class=\"comment\">//替换</span></span><br></pre></td></tr></table></figure></li>\n<li><p><strong>swap</strong></p>\n<p><u>元素本身并未交换，只是交换了两个容器的内部数据结构</u>【有点不理解，先挖个坑，待细究】</p>\n<p>除 <code>string</code> 外，指向容器的迭代器、引用、指针在 swap 操作后都<strong>不会失效</strong></p>\n<p><code>string</code> 的 <code>swap</code> 会导致迭代器、引用、指针<strong>失效</strong></p>\n</li>\n</ul>\n<h3 id=\"添加元素\"><a href=\"#添加元素\" class=\"headerlink\" title=\"添加元素\"></a>添加元素</h3><p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211113210410280.png\" alt=\"添加元素\"></p>\n<p>以下记录几点需要特别注意的地方：</p>\n<ol>\n<li>注意 <code>push_back</code> 是<strong>拷贝</strong>，会创建一个<strong>局部临时对象</strong></li>\n<li><code>insert</code> 返回指向刚加入元素的迭代器【想想也是】</li>\n<li><code>emplace</code> 是<strong>直接构造</strong>而不是拷贝，参数必须和构造函数相匹配</li>\n</ol>\n<h3 id=\"访问元素\"><a href=\"#访问元素\" class=\"headerlink\" title=\"访问元素\"></a>访问元素</h3><p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211113211340830.png\" alt=\"访问元素\"></p>\n<p>需要注意的都已经在图中标出</p>\n<h3 id=\"删除元素\"><a href=\"#删除元素\" class=\"headerlink\" title=\"删除元素\"></a>删除元素</h3><p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211113211754174.png\" alt=\"删除元素\"></p>\n<p>注意点：</p>\n<ol>\n<li>返回 void，需要自行保存元素</li>\n</ol>\n<h3 id=\"特殊的-forward-list\"><a href=\"#特殊的-forward-list\" class=\"headerlink\" title=\"特殊的 forward_list\"></a>特殊的 forward_list</h3><ul>\n<li><p>单链表添加或删除一个元素，需要访问其<strong>前驱</strong>，所以需要有其前驱的迭代器</p>\n</li>\n<li><p>为了方便访问头元素，定义 <code>before_begin()</code>，指向<strong>头元素之前</strong>的位置</p>\n</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211113212237994.png\" alt=\"forward_list\"></p>\n<h3 id=\"容器大小\"><a href=\"#容器大小\" class=\"headerlink\" title=\"容器大小\"></a>容器大小</h3><h4 id=\"1-resize\"><a href=\"#1-resize\" class=\"headerlink\" title=\"1. resize\"></a>1. resize</h4><p>不减小容器的 <code>capacity</code>，对 <code>size</code> 可增可减</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211115095132554.png\" alt=\"容器大小\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">list&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">li</span><span class=\"params\">(<span class=\"number\">10</span>, <span class=\"number\">42</span>)</span></span>; <span class=\"comment\">//10个42</span></span><br><span class=\"line\">li.<span class=\"built_in\">resize</span>(<span class=\"number\">15</span>); <span class=\"comment\">//多添5个0，总个数为15个</span></span><br><span class=\"line\">li.<span class=\"built_in\">resize</span>(<span class=\"number\">25</span>, <span class=\"number\">-1</span>); <span class=\"comment\">//多添10个-1，旧元素不管</span></span><br><span class=\"line\">li.<span class=\"built_in\">resize</span>(<span class=\"number\">5</span>); <span class=\"comment\">//删除20个元素</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-reverse\"><a href=\"#2-reverse\" class=\"headerlink\" title=\"2. reverse\"></a>2. reverse</h4><p>通知容器它应该准备保存多少个元素，如果<strong>需求&lt;=当前容量</strong>，<code>reverse</code> 什么也不做，它不会减小 <code>capacity</code></p>\n<p>如果<strong>需求&gt;当前容量</strong>，<code>reverse</code> 至少分配与需求一样大的内存空间</p>\n<h4 id=\"3-capacity-VS-size\"><a href=\"#3-capacity-VS-size\" class=\"headerlink\" title=\"3. capacity VS size\"></a>3. capacity VS size</h4><p><code>capacity</code> 是容器当前分配的<strong>最大内存空间</strong>，表示<strong>最多</strong>可以存储多少个元素</p>\n<p><code>size</code> 是容器中<strong>当前现有</strong>元素个数</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211115100400348.png\" alt=\"保留空间\"></p>\n<h3 id=\"迭代器失效\"><a href=\"#迭代器失效\" class=\"headerlink\" title=\"迭代器失效\"></a>迭代器失效</h3><p>记录几个不好理解的吧：</p>\n<ul>\n<li><p>对于 <code>deque</code></p>\n<p>如果在<strong>首尾位置添加</strong>元素，<strong>迭代器</strong>会失效，但<strong>指向存在的元素的引用和指针</strong>不会失效</p>\n<p>如果在<strong>首尾之外</strong>的其他任何位置<strong>删除</strong>元素，那么<strong>所有</strong>元素（包括被删除元素）的迭代器、指针、引用都会失效</p>\n<p>如果是<strong>删除</strong> <code>deque</code> 的<strong>尾（首）元素</strong>，<strong>尾后（首元素）</strong>迭代器失效，但<strong>其他</strong>迭代器、指针、引用不受影响</p>\n</li>\n<li><p>对于 <code>list</code> 和 <code>forward_list</code></p>\n<p>不管是添加还是删除（被删除的肯定失效了），三大件均有效【其实这个好理解…】</p>\n</li>\n</ul>\n<h3 id=\"额外的string操作\"><a href=\"#额外的string操作\" class=\"headerlink\" title=\"额外的string操作\"></a>额外的string操作</h3><p>大致可分为</p>\n<ol>\n<li>提供 string 类和 C 风格字符数组之间的相互转换</li>\n<li>用下标替换迭代器的版本</li>\n</ol>\n<h4 id=\"C-c1-c2-的扩展\"><a href=\"#C-c1-c2-的扩展\" class=\"headerlink\" title=\"C c1(c2)的扩展\"></a><code>C c1(c2)</code>的扩展</h4><p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211115102024853.png\" alt=\"构造string的其他方法\"></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">string <span class=\"title\">s</span><span class=\"params\">(cp)</span></span>;  <span class=\"comment\">//如果不加 n，要求cp（字符数组）必须要以空字符结束</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* cp = <span class=\"string\">&quot;Hello World&quot;</span>;  <span class=\"comment\">//以空字符结束</span></span><br><span class=\"line\"><span class=\"keyword\">char</span> noNull[] = &#123;<span class=\"string\">&#x27;H&#x27;</span>, <span class=\"string\">&#x27;i&#x27;</span>&#125;; <span class=\"comment\">//没有以空字符结束</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"substr\"><a href=\"#substr\" class=\"headerlink\" title=\"substr\"></a><code>substr</code></h4><p>（开始位置，计数值）</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">string <span class=\"title\">substr</span> <span class=\"params\">(<span class=\"keyword\">size_t</span> pos = <span class=\"number\">0</span>, <span class=\"keyword\">size_t</span> len = npos)</span> <span class=\"keyword\">const</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>如果开始位置超过了 <code>string</code> 的大小，<code>substr</code> 函数抛出 <code>out_of_range </code>异常</p>\n<p>如果开始位置加上计数值大于 <code>string</code> 的大小，则只拷贝到 <code>string</code> 的末尾</p>\n<h4 id=\"下标版本的-insert-和-erase\"><a href=\"#下标版本的-insert-和-erase\" class=\"headerlink\" title=\"下标版本的 insert 和 erase\"></a>下标版本的 <code>insert</code> 和 <code>erase</code></h4><p>还有 <code>assign</code>、<code>append</code>、<code>replace</code></p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211115103633100.png\" alt=\"修改string的操作\"></p>\n<p><code>pos=0</code>，头插</p>\n<p><code>pos=s.size()</code>，尾插</p>\n<h4 id=\"string搜索\"><a href=\"#string搜索\" class=\"headerlink\" title=\"string搜索\"></a><code>string</code>搜索</h4><p>只记一个好了</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string.<span class=\"built_in\">find</span>(args)    <span class=\"comment\">//查找 s 中 args 第一次出现的位置</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211115104416494.png\" alt=\"args必须是以下形式之一\"></p>\n<h4 id=\"s-compare-比较\"><a href=\"#s-compare-比较\" class=\"headerlink\" title=\"s.compare 比较\"></a><code>s.compare</code> 比较</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s.<span class=\"built_in\">compare</span>(s2);  </span><br><span class=\"line\"><span class=\"comment\">// s == s2 返回 0</span></span><br><span class=\"line\"><span class=\"comment\">// s &gt; s2 正数</span></span><br><span class=\"line\"><span class=\"comment\">// s &lt; s2 负数</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211130160159724.png\" alt=\"s.compare的几种参数形式\"></p>\n<h4 id=\"string和数值之间的转换\"><a href=\"#string和数值之间的转换\" class=\"headerlink\" title=\"string和数值之间的转换\"></a><code>string</code>和数值之间的转换</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">to_string</span>(val)    <span class=\"comment\">//val可以是任何算数类型</span></span><br></pre></td></tr></table></figure>\n\n<p>要转换为数值的 <code>string</code> 的第一个非空白符必须是数值中可能出现的字符（+ - . 0x 等）</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">stoi</span>(s, p, b=<span class=\"number\">10</span>);    <span class=\"comment\">// b表示进制，默认是10</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// p 没搞懂有啥用，先不管，平时可以为空【?】</span></span><br></pre></td></tr></table></figure>\n\n<p>如果 <code>string</code> 无法转换为一个数值，函数抛出 <code>invalid_argument</code> 异常</p>\n<p>如果被转换的数值无法用任何类型表示，则抛出 <code>out_of_range</code> 异常</p>\n<h3 id=\"容器适配器\"><a href=\"#容器适配器\" class=\"headerlink\" title=\"容器适配器\"></a>容器适配器</h3><p>stack、queue、priority_queue</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211115111743807.png\" alt=\"所有容器适配器都支持的操作\"></p>\n<p>默认情况下，<code>stack</code> 和 <code>queue</code> 是基于 <code>deque</code> 实现的，<code>priority_queue</code> 是在 <code>vector</code> 之上实现的</p>\n<p>可以在创建适配器的时候，给予第二个类型参数，以<strong>改变底层容器</strong>类型，例如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stack&lt;string, vector&lt;string&gt;&gt; str_stk; <span class=\"comment\">//基于vector实现</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"stack\"><a href=\"#stack\" class=\"headerlink\" title=\"stack\"></a>stack</h4><p>要求能添加、删除、访问尾元素，所以不能基于 <code>forward_list</code> 和 <code>array</code> 实现，其他都行</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211115112645958.png\" alt=\"表9.17未列出的栈操作\"></p>\n<p><strong>不能</strong>使用底层容器类型的操作</p>\n<h4 id=\"queue\"><a href=\"#queue\" class=\"headerlink\" title=\"queue\"></a>queue</h4><p>可以基于 <code>list</code>、<code>deque</code> 实现，不能基于 <code>vector</code> 实现</p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211115113710892.png\" alt=\"queue图\"></p>\n<h4 id=\"priority-queue\"><a href=\"#priority-queue\" class=\"headerlink\" title=\"priority_queue\"></a>priority_queue</h4><p>front、push_back、pop_back，随机访问</p>\n<p>可以基于 <code>vector</code>、<code>deque</code>，不能基于 <code>list</code></p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211115113250578.png\" alt=\"未列出的queue\"></p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211115113258764.png\" alt=\"图queue\"></p>\n<p><em>书中存在错误，pop() 是要删除的</em></p>\n<p><img src=\"https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211115113844367.png\" alt=\"heap\"></p>\n<p><em>事实上，*<em>priority_queue</em></em> 的底层实现是 <strong>heap</strong>*</p>\n<p>优先队列自定义比较器，未完待续…</p>\n<p>参考资料：Primer C++ 第五版</p>\n"},{"title":"主语从句","date":"2022-01-04T09:02:03.000Z","_content":"\n## 1. 三种类型的主语从句\n\n###### (1) 由 `that` 引导的主语从句\n\n​\t<u>That</u> he hasn't arrived is odd.\n\n​\tIt's certain <u>that</u> prices will go up.\n\n###### (2) 由<u>连接代（副）词</u>引导的主语从句\n\n<u>\tWhy</u> he left wasn't Important.\n\n<u>\tIt</u> was uncertain <u>whether</u> he would come or not.\n\n###### (3) 由关系代词型和 <u>what</u> 和 <u>whatever</u> 引导的从句：\n\n<u>\tWhat I want</u> is a canvas travelling bag.\n\n<u>\tWhatever she did</u> was right.\n\n## 2. 由 that 引导的主语从句\n\n一般都用 `it` 作形式主语\n\n###### a. it + be + 形容词 + that 从句\n\n<u>It</u> is natural <u>that</u> they should have different views.\n\n<u>It</u> was quite plain <u>that</u> she didn't want to come.\n\n###### b. it + be + 名词 + that 从句\n\n<u>It's</u> a pity (<u>that</u>) he can't swim.\n\n###### c. it + 动词 + （宾、状） + that\n\n<u>It happened that</u> she wasn't in that day. ( happen 这里不及物，碰巧那天她不在家 )\n\n<u>It</u> never occurred to me <u>that</u> perhaps she was lying.\n\n<u>It</u> seems <u>that</u> you are right.\n\n<u>It</u> struck me <u>that</u> we ought to make a new plan.\n\n###### d. it + 动词的被动语态 + that 从句\n\n<u>It</u> was rumoured <u>that</u> he was suffering from a stone in the kidney.\n\n<u>It</u> is estimated <u>that</u> 25 million school lunches are sold each day.  \n\n###### 在口语中 `that` 有时可以省略\n\nIt was clear his words pleased her.\n\nIt strikes me Kent is a nice lad.\n\n## 3. 由连接代（副）词引导的主语从句\n\n可放句首，不用 it：\n\n<u>When he'll be back</u> depends much on the weather.\n\n<u>How it was done</u> was a mystery.\n\n<u>Who is to be sent there</u> hasn't been decided. \n\n<u>Whether we'll succeed</u> remains to be seen.\n\n一般用 it 作形式主语\n\n###### a. it + be + 形容词 + 从句\n\n<u>It</u> was not clear to me <u>why</u> he behaved like that.\n\n<u>It's</u> uncertain <u>whether</u> the game will be held.\n\n<u>It</u> is amazing <u>that</u> he should have said nothing about the murder.\n\n###### b. it + be + 名词 + 从句\n\n<u>It's</u> a puzzle <u>how</u> life began.\n\n<u>It</u> was a question <u>whether</u> he should get married.\n\n###### c. it + 动词 （宾语、状语）+ 从句\n\n<u>It</u> doesn't matter much <u>where</u> we live.\n\n<u>It</u> struck her <u>how</u> considerate he was.\n\n###### d. it + 动词被动语态 + 从句\n\n<u>It</u> is not decided <u>who</u> will edit it.\n\n## 4. 由关系代词型 what 引导的主语从句\n\n<u>What is over</u> is over.\n\n<u>What you should do</u> is to choose a company to invest in.\n\n<u>Whoever wants to go</u> may sign up here.\n\n<u>Whichever you want</u> is yours.\n\n","source":"_posts/英语/名词性从句/主语从句.md","raw":"---\ntitle: 主语从句\ndate: 2022-01-04 17:02:03\ntags: [\"Grammar\"]\ncategories: [\"English\"]\n---\n\n## 1. 三种类型的主语从句\n\n###### (1) 由 `that` 引导的主语从句\n\n​\t<u>That</u> he hasn't arrived is odd.\n\n​\tIt's certain <u>that</u> prices will go up.\n\n###### (2) 由<u>连接代（副）词</u>引导的主语从句\n\n<u>\tWhy</u> he left wasn't Important.\n\n<u>\tIt</u> was uncertain <u>whether</u> he would come or not.\n\n###### (3) 由关系代词型和 <u>what</u> 和 <u>whatever</u> 引导的从句：\n\n<u>\tWhat I want</u> is a canvas travelling bag.\n\n<u>\tWhatever she did</u> was right.\n\n## 2. 由 that 引导的主语从句\n\n一般都用 `it` 作形式主语\n\n###### a. it + be + 形容词 + that 从句\n\n<u>It</u> is natural <u>that</u> they should have different views.\n\n<u>It</u> was quite plain <u>that</u> she didn't want to come.\n\n###### b. it + be + 名词 + that 从句\n\n<u>It's</u> a pity (<u>that</u>) he can't swim.\n\n###### c. it + 动词 + （宾、状） + that\n\n<u>It happened that</u> she wasn't in that day. ( happen 这里不及物，碰巧那天她不在家 )\n\n<u>It</u> never occurred to me <u>that</u> perhaps she was lying.\n\n<u>It</u> seems <u>that</u> you are right.\n\n<u>It</u> struck me <u>that</u> we ought to make a new plan.\n\n###### d. it + 动词的被动语态 + that 从句\n\n<u>It</u> was rumoured <u>that</u> he was suffering from a stone in the kidney.\n\n<u>It</u> is estimated <u>that</u> 25 million school lunches are sold each day.  \n\n###### 在口语中 `that` 有时可以省略\n\nIt was clear his words pleased her.\n\nIt strikes me Kent is a nice lad.\n\n## 3. 由连接代（副）词引导的主语从句\n\n可放句首，不用 it：\n\n<u>When he'll be back</u> depends much on the weather.\n\n<u>How it was done</u> was a mystery.\n\n<u>Who is to be sent there</u> hasn't been decided. \n\n<u>Whether we'll succeed</u> remains to be seen.\n\n一般用 it 作形式主语\n\n###### a. it + be + 形容词 + 从句\n\n<u>It</u> was not clear to me <u>why</u> he behaved like that.\n\n<u>It's</u> uncertain <u>whether</u> the game will be held.\n\n<u>It</u> is amazing <u>that</u> he should have said nothing about the murder.\n\n###### b. it + be + 名词 + 从句\n\n<u>It's</u> a puzzle <u>how</u> life began.\n\n<u>It</u> was a question <u>whether</u> he should get married.\n\n###### c. it + 动词 （宾语、状语）+ 从句\n\n<u>It</u> doesn't matter much <u>where</u> we live.\n\n<u>It</u> struck her <u>how</u> considerate he was.\n\n###### d. it + 动词被动语态 + 从句\n\n<u>It</u> is not decided <u>who</u> will edit it.\n\n## 4. 由关系代词型 what 引导的主语从句\n\n<u>What is over</u> is over.\n\n<u>What you should do</u> is to choose a company to invest in.\n\n<u>Whoever wants to go</u> may sign up here.\n\n<u>Whichever you want</u> is yours.\n\n","slug":"英语/名词性从句/主语从句","published":1,"updated":"2022-01-04T10:39:17.166Z","_id":"ckxzw7n0x0000esu3gmf08yrh","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"1-三种类型的主语从句\"><a href=\"#1-三种类型的主语从句\" class=\"headerlink\" title=\"1. 三种类型的主语从句\"></a>1. 三种类型的主语从句</h2><h6 id=\"1-由-that-引导的主语从句\"><a href=\"#1-由-that-引导的主语从句\" class=\"headerlink\" title=\"(1) 由 that 引导的主语从句\"></a>(1) 由 <code>that</code> 引导的主语从句</h6><p>​    <u>That</u> he hasn’t arrived is odd.</p>\n<p>​    It’s certain <u>that</u> prices will go up.</p>\n<h6 id=\"2-由连接代（副）词引导的主语从句\"><a href=\"#2-由连接代（副）词引导的主语从句\" class=\"headerlink\" title=\"(2) 由连接代（副）词引导的主语从句\"></a>(2) 由<u>连接代（副）词</u>引导的主语从句</h6><p><u>    Why</u> he left wasn’t Important.</p>\n<p><u>    It</u> was uncertain <u>whether</u> he would come or not.</p>\n<h6 id=\"3-由关系代词型和-what-和-whatever-引导的从句：\"><a href=\"#3-由关系代词型和-what-和-whatever-引导的从句：\" class=\"headerlink\" title=\"(3) 由关系代词型和 what 和 whatever 引导的从句：\"></a>(3) 由关系代词型和 <u>what</u> 和 <u>whatever</u> 引导的从句：</h6><p><u>    What I want</u> is a canvas travelling bag.</p>\n<p><u>    Whatever she did</u> was right.</p>\n<h2 id=\"2-由-that-引导的主语从句\"><a href=\"#2-由-that-引导的主语从句\" class=\"headerlink\" title=\"2. 由 that 引导的主语从句\"></a>2. 由 that 引导的主语从句</h2><p>一般都用 <code>it</code> 作形式主语</p>\n<h6 id=\"a-it-be-形容词-that-从句\"><a href=\"#a-it-be-形容词-that-从句\" class=\"headerlink\" title=\"a. it + be + 形容词 + that 从句\"></a>a. it + be + 形容词 + that 从句</h6><p><u>It</u> is natural <u>that</u> they should have different views.</p>\n<p><u>It</u> was quite plain <u>that</u> she didn’t want to come.</p>\n<h6 id=\"b-it-be-名词-that-从句\"><a href=\"#b-it-be-名词-that-从句\" class=\"headerlink\" title=\"b. it + be + 名词 + that 从句\"></a>b. it + be + 名词 + that 从句</h6><p><u>It’s</u> a pity (<u>that</u>) he can’t swim.</p>\n<h6 id=\"c-it-动词-（宾、状）-that\"><a href=\"#c-it-动词-（宾、状）-that\" class=\"headerlink\" title=\"c. it + 动词 + （宾、状） + that\"></a>c. it + 动词 + （宾、状） + that</h6><p><u>It happened that</u> she wasn’t in that day. ( happen 这里不及物，碰巧那天她不在家 )</p>\n<p><u>It</u> never occurred to me <u>that</u> perhaps she was lying.</p>\n<p><u>It</u> seems <u>that</u> you are right.</p>\n<p><u>It</u> struck me <u>that</u> we ought to make a new plan.</p>\n<h6 id=\"d-it-动词的被动语态-that-从句\"><a href=\"#d-it-动词的被动语态-that-从句\" class=\"headerlink\" title=\"d. it + 动词的被动语态 + that 从句\"></a>d. it + 动词的被动语态 + that 从句</h6><p><u>It</u> was rumoured <u>that</u> he was suffering from a stone in the kidney.</p>\n<p><u>It</u> is estimated <u>that</u> 25 million school lunches are sold each day.  </p>\n<h6 id=\"在口语中-that-有时可以省略\"><a href=\"#在口语中-that-有时可以省略\" class=\"headerlink\" title=\"在口语中 that 有时可以省略\"></a>在口语中 <code>that</code> 有时可以省略</h6><p>It was clear his words pleased her.</p>\n<p>It strikes me Kent is a nice lad.</p>\n<h2 id=\"3-由连接代（副）词引导的主语从句\"><a href=\"#3-由连接代（副）词引导的主语从句\" class=\"headerlink\" title=\"3. 由连接代（副）词引导的主语从句\"></a>3. 由连接代（副）词引导的主语从句</h2><p>可放句首，不用 it：</p>\n<p><u>When he’ll be back</u> depends much on the weather.</p>\n<p><u>How it was done</u> was a mystery.</p>\n<p><u>Who is to be sent there</u> hasn’t been decided. </p>\n<p><u>Whether we’ll succeed</u> remains to be seen.</p>\n<p>一般用 it 作形式主语</p>\n<h6 id=\"a-it-be-形容词-从句\"><a href=\"#a-it-be-形容词-从句\" class=\"headerlink\" title=\"a. it + be + 形容词 + 从句\"></a>a. it + be + 形容词 + 从句</h6><p><u>It</u> was not clear to me <u>why</u> he behaved like that.</p>\n<p><u>It’s</u> uncertain <u>whether</u> the game will be held.</p>\n<p><u>It</u> is amazing <u>that</u> he should have said nothing about the murder.</p>\n<h6 id=\"b-it-be-名词-从句\"><a href=\"#b-it-be-名词-从句\" class=\"headerlink\" title=\"b. it + be + 名词 + 从句\"></a>b. it + be + 名词 + 从句</h6><p><u>It’s</u> a puzzle <u>how</u> life began.</p>\n<p><u>It</u> was a question <u>whether</u> he should get married.</p>\n<h6 id=\"c-it-动词-（宾语、状语）-从句\"><a href=\"#c-it-动词-（宾语、状语）-从句\" class=\"headerlink\" title=\"c. it + 动词 （宾语、状语）+ 从句\"></a>c. it + 动词 （宾语、状语）+ 从句</h6><p><u>It</u> doesn’t matter much <u>where</u> we live.</p>\n<p><u>It</u> struck her <u>how</u> considerate he was.</p>\n<h6 id=\"d-it-动词被动语态-从句\"><a href=\"#d-it-动词被动语态-从句\" class=\"headerlink\" title=\"d. it + 动词被动语态 + 从句\"></a>d. it + 动词被动语态 + 从句</h6><p><u>It</u> is not decided <u>who</u> will edit it.</p>\n<h2 id=\"4-由关系代词型-what-引导的主语从句\"><a href=\"#4-由关系代词型-what-引导的主语从句\" class=\"headerlink\" title=\"4. 由关系代词型 what 引导的主语从句\"></a>4. 由关系代词型 what 引导的主语从句</h2><p><u>What is over</u> is over.</p>\n<p><u>What you should do</u> is to choose a company to invest in.</p>\n<p><u>Whoever wants to go</u> may sign up here.</p>\n<p><u>Whichever you want</u> is yours.</p>\n","site":{"data":{"styles":"body {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  min-width: 1000px;\n  background: url(\"/images/longmao-02.jpg\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center 0;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -o-background-size: cover;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.8;\n}\n.header-inner {\n  background: rgba(255,255,255,0.8);\n}\n.popup {\n  opacity: 0.8;\n}\n.post-block {\n  background: rgba(255,255,255,0.7) none repeat scroll !important;\n}\n"}},"excerpt":"","more":"<h2 id=\"1-三种类型的主语从句\"><a href=\"#1-三种类型的主语从句\" class=\"headerlink\" title=\"1. 三种类型的主语从句\"></a>1. 三种类型的主语从句</h2><h6 id=\"1-由-that-引导的主语从句\"><a href=\"#1-由-that-引导的主语从句\" class=\"headerlink\" title=\"(1) 由 that 引导的主语从句\"></a>(1) 由 <code>that</code> 引导的主语从句</h6><p>​    <u>That</u> he hasn’t arrived is odd.</p>\n<p>​    It’s certain <u>that</u> prices will go up.</p>\n<h6 id=\"2-由连接代（副）词引导的主语从句\"><a href=\"#2-由连接代（副）词引导的主语从句\" class=\"headerlink\" title=\"(2) 由连接代（副）词引导的主语从句\"></a>(2) 由<u>连接代（副）词</u>引导的主语从句</h6><p><u>    Why</u> he left wasn’t Important.</p>\n<p><u>    It</u> was uncertain <u>whether</u> he would come or not.</p>\n<h6 id=\"3-由关系代词型和-what-和-whatever-引导的从句：\"><a href=\"#3-由关系代词型和-what-和-whatever-引导的从句：\" class=\"headerlink\" title=\"(3) 由关系代词型和 what 和 whatever 引导的从句：\"></a>(3) 由关系代词型和 <u>what</u> 和 <u>whatever</u> 引导的从句：</h6><p><u>    What I want</u> is a canvas travelling bag.</p>\n<p><u>    Whatever she did</u> was right.</p>\n<h2 id=\"2-由-that-引导的主语从句\"><a href=\"#2-由-that-引导的主语从句\" class=\"headerlink\" title=\"2. 由 that 引导的主语从句\"></a>2. 由 that 引导的主语从句</h2><p>一般都用 <code>it</code> 作形式主语</p>\n<h6 id=\"a-it-be-形容词-that-从句\"><a href=\"#a-it-be-形容词-that-从句\" class=\"headerlink\" title=\"a. it + be + 形容词 + that 从句\"></a>a. it + be + 形容词 + that 从句</h6><p><u>It</u> is natural <u>that</u> they should have different views.</p>\n<p><u>It</u> was quite plain <u>that</u> she didn’t want to come.</p>\n<h6 id=\"b-it-be-名词-that-从句\"><a href=\"#b-it-be-名词-that-从句\" class=\"headerlink\" title=\"b. it + be + 名词 + that 从句\"></a>b. it + be + 名词 + that 从句</h6><p><u>It’s</u> a pity (<u>that</u>) he can’t swim.</p>\n<h6 id=\"c-it-动词-（宾、状）-that\"><a href=\"#c-it-动词-（宾、状）-that\" class=\"headerlink\" title=\"c. it + 动词 + （宾、状） + that\"></a>c. it + 动词 + （宾、状） + that</h6><p><u>It happened that</u> she wasn’t in that day. ( happen 这里不及物，碰巧那天她不在家 )</p>\n<p><u>It</u> never occurred to me <u>that</u> perhaps she was lying.</p>\n<p><u>It</u> seems <u>that</u> you are right.</p>\n<p><u>It</u> struck me <u>that</u> we ought to make a new plan.</p>\n<h6 id=\"d-it-动词的被动语态-that-从句\"><a href=\"#d-it-动词的被动语态-that-从句\" class=\"headerlink\" title=\"d. it + 动词的被动语态 + that 从句\"></a>d. it + 动词的被动语态 + that 从句</h6><p><u>It</u> was rumoured <u>that</u> he was suffering from a stone in the kidney.</p>\n<p><u>It</u> is estimated <u>that</u> 25 million school lunches are sold each day.  </p>\n<h6 id=\"在口语中-that-有时可以省略\"><a href=\"#在口语中-that-有时可以省略\" class=\"headerlink\" title=\"在口语中 that 有时可以省略\"></a>在口语中 <code>that</code> 有时可以省略</h6><p>It was clear his words pleased her.</p>\n<p>It strikes me Kent is a nice lad.</p>\n<h2 id=\"3-由连接代（副）词引导的主语从句\"><a href=\"#3-由连接代（副）词引导的主语从句\" class=\"headerlink\" title=\"3. 由连接代（副）词引导的主语从句\"></a>3. 由连接代（副）词引导的主语从句</h2><p>可放句首，不用 it：</p>\n<p><u>When he’ll be back</u> depends much on the weather.</p>\n<p><u>How it was done</u> was a mystery.</p>\n<p><u>Who is to be sent there</u> hasn’t been decided. </p>\n<p><u>Whether we’ll succeed</u> remains to be seen.</p>\n<p>一般用 it 作形式主语</p>\n<h6 id=\"a-it-be-形容词-从句\"><a href=\"#a-it-be-形容词-从句\" class=\"headerlink\" title=\"a. it + be + 形容词 + 从句\"></a>a. it + be + 形容词 + 从句</h6><p><u>It</u> was not clear to me <u>why</u> he behaved like that.</p>\n<p><u>It’s</u> uncertain <u>whether</u> the game will be held.</p>\n<p><u>It</u> is amazing <u>that</u> he should have said nothing about the murder.</p>\n<h6 id=\"b-it-be-名词-从句\"><a href=\"#b-it-be-名词-从句\" class=\"headerlink\" title=\"b. it + be + 名词 + 从句\"></a>b. it + be + 名词 + 从句</h6><p><u>It’s</u> a puzzle <u>how</u> life began.</p>\n<p><u>It</u> was a question <u>whether</u> he should get married.</p>\n<h6 id=\"c-it-动词-（宾语、状语）-从句\"><a href=\"#c-it-动词-（宾语、状语）-从句\" class=\"headerlink\" title=\"c. it + 动词 （宾语、状语）+ 从句\"></a>c. it + 动词 （宾语、状语）+ 从句</h6><p><u>It</u> doesn’t matter much <u>where</u> we live.</p>\n<p><u>It</u> struck her <u>how</u> considerate he was.</p>\n<h6 id=\"d-it-动词被动语态-从句\"><a href=\"#d-it-动词被动语态-从句\" class=\"headerlink\" title=\"d. it + 动词被动语态 + 从句\"></a>d. it + 动词被动语态 + 从句</h6><p><u>It</u> is not decided <u>who</u> will edit it.</p>\n<h2 id=\"4-由关系代词型-what-引导的主语从句\"><a href=\"#4-由关系代词型-what-引导的主语从句\" class=\"headerlink\" title=\"4. 由关系代词型 what 引导的主语从句\"></a>4. 由关系代词型 what 引导的主语从句</h2><p><u>What is over</u> is over.</p>\n<p><u>What you should do</u> is to choose a company to invest in.</p>\n<p><u>Whoever wants to go</u> may sign up here.</p>\n<p><u>Whichever you want</u> is yours.</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ckxzva9fi00077cu3earvf4mp","category_id":"ckxzva9fk00097cu30ccdewtq","_id":"ckxzva9ft000j7cu3cbj55pt1"},{"post_id":"ckxzva9fs000i7cu38awh4tgw","category_id":"ckxzva9fk00097cu30ccdewtq","_id":"ckxzva9fy000r7cu30xgb1jhs"},{"post_id":"ckxzva9fo000c7cu3geclgj0x","category_id":"ckxzva9fr000e7cu3bfps6s75","_id":"ckxzva9fz000u7cu37fet4j38"},{"post_id":"ckxzva9fp000d7cu37usm3efu","category_id":"ckxzva9fr000e7cu3bfps6s75","_id":"ckxzva9fz000w7cu38gzf7p17"},{"post_id":"ckxzva9g0000x7cu31cqn1bkc","category_id":"ckxzva9g0000y7cu3df0rdgzg","_id":"ckxzva9g100117cu3h2c39xpk"},{"post_id":"ckxzw7n0x0000esu3gmf08yrh","category_id":"ckxzva9fr000e7cu3bfps6s75","_id":"ckxzw7n100002esu3656iaryb"}],"PostTag":[{"post_id":"ckxzva9fi00077cu3earvf4mp","tag_id":"ckxzva9fm000a7cu3cxa5gi8m","_id":"ckxzva9fr000g7cu37zo720np"},{"post_id":"ckxzva9fs000i7cu38awh4tgw","tag_id":"ckxzva9fm000a7cu3cxa5gi8m","_id":"ckxzva9fw000n7cu3e0xlfw85"},{"post_id":"ckxzva9fo000c7cu3geclgj0x","tag_id":"ckxzva9fr000f7cu31cze0l20","_id":"ckxzva9fx000p7cu3ashq1uam"},{"post_id":"ckxzva9fp000d7cu37usm3efu","tag_id":"ckxzva9fr000f7cu31cze0l20","_id":"ckxzva9fy000s7cu36vrpa0bm"},{"post_id":"ckxzva9g0000x7cu31cqn1bkc","tag_id":"ckxzva9g1000z7cu35x9c3fs8","_id":"ckxzva9g100107cu3exrv5xl9"},{"post_id":"ckxzw7n0x0000esu3gmf08yrh","tag_id":"ckxzva9fr000f7cu31cze0l20","_id":"ckxzw7n100001esu3arzc21ft"}],"Tag":[{"name":"C/C++","_id":"ckxzva9fm000a7cu3cxa5gi8m"},{"name":"Grammar","_id":"ckxzva9fr000f7cu31cze0l20"},{"name":"STL","_id":"ckxzva9g1000z7cu35x9c3fs8"}]}}