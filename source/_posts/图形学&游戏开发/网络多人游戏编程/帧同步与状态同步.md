![preview](https://raw.githubusercontent.com/Vio1ette/blog-img/main/v2-1eaef9fbb1768e716b146b0a2a4e1a41_r.jpg)

图片来源：https://zhuanlan.zhihu.com/p/105390563

帧同步又叫“锁步模式”。这种模式用形象的比喻来说，就是把所有参与对战的客户端，看成是排成一列的囚犯。这些囚犯们的左脚都被链子所在一起，因此他们如果要往前走，就只能同时迈步，如果其中某个人走快了，或者走慢了，都会让整队人停下来。

作者：合肥黑
链接：https://www.jianshu.com/p/81050871cce7
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

帧同步要求每一帧都是一样的，而状态同步允许每个客户端屏幕上显示的内容不一样，只需要最后在逻辑上统一

帧同步的优缺点：

| 优点                                                   | 缺点                                                     |
| ------------------------------------------------------ | -------------------------------------------------------- |
| 开发效率高<br />打击感强<br />流量低<br />回放实现简单 | 网络要求高<br />反外挂能力弱<br />断线重连的时间长<br /> |

状态同步的优缺点：

| 优点                                             | 缺点                                       |
| ------------------------------------------------ | ------------------------------------------ |
| 安全性高<br />网络要求宽松<br />断线重连快<br /> | 开发效率低<br />打击感差<br />网络流量复杂 |


## 1. 帧同步

![image-20220505085138953](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220505085138953.png)

`Server`将逻辑时间切分为一个个等长的逻辑时间片，每一个时间片对应一个`Frame`，每个`Frame`有一个代表逻辑时间的序号。`Client`的输入模块在接收到玩家输入的命令（`Cmd`）后，并不直接将`Cmd`直接传给游戏逻辑，而是发送给`Server`。如果`Server`在同一个时间片（比如`Frame3`）的周期里，收到了`Client A`和`Client B`的输入，那么就会将这两个`Client`的输入以`Cmd`列表的形式包含在`Frame 3`里。等到`Frame 3`的周期结束时，就会将`Frame 3`分别发送给`Client A`和`Client B`。那么，两个`Client`在相同的逻辑时间里，就会收到完全相同的`Cmd`列表。

如果`Client A`与`Client B`的逻辑也完全相同，那么对于完全相同的`Cmd`输入，理论上，将会计算得出完全相同的逻辑结果，从而实现了高一致性的网络同步

一个客户端做出操作，发送操作指令给服务器，服务器将这个<u>操作指令再广播</u>到其他客户端，其他客户端本地的逻辑层计算出结果，表现层根据逻辑层计算的结果刷新状态

帧同步的优点：

- 容易实现回放系统，客户端向服务器申请重新执行一遍操作指令

- 逻辑表现分离

- 服务器转发的是操作指令，数据量小


### 1.1 延迟和卡顿

这俩是一个tradeoff，一个好了另一个差了，比如延迟很低的情况下，严格按照逻辑计算结果进行表现，每帧就会出现不连贯的情况。

解决办法：缓冲，积累两、三帧的数据，然后一块播放

#### 1.1.1. 帧锁定

#### 1.1.2 预测、快照、回滚

##### 1.1.2.1 预测

一般情况下，客户端将自己的输入指令发送给服务器，服务器会收集所有的客户端上传的操作指令，然后再一起广播给所有客户端。

在某一帧，客户端A将自己的输入指令发送给服务器后，A预测自己的指令是有效的，预先执行自己的输入指令（逻辑计算->渲染），客户端不需要服务端确认帧返回才执行指令，而其他玩家的输入也可以预测（例如按照其上一个输入做预测）

> 真实逻辑的预测执行和view层面的预测执行

##### 1.1.2.2 快照

客户端会保存服务端最后一次成功确认的帧和预测帧的数据和状态，方便后面回滚

##### 1.1.2.3 回滚

收到服务器的确认操作之后，如果确认操作和之前预测的操作一样，则万事大吉，不做任何改变；否则，客户端就需要回滚到最后一次服务器确认的正确帧，然后在执行**追帧**操作（从正确帧开始，快速执行中间的帧，直至最新的帧）

### 1.2 逻辑表现分离

why？

有效解决“卡顿”现象，对于由延迟引发的卡顿，逻辑不平滑，但可以在逻辑值之间进行插值，让表现平滑。逻辑空间严格按照帧同步的要求进行计算，表现空间获得逻辑计算的结果进行显示，并利用插值来平滑显示效果

how？

将一个游戏对象类拆分为两个类，分别为逻辑类和表现类

逻辑类严格按照帧同步的要求进行计算（比如碰撞啊技能释放啊都是在这里，<u>不能用浮点数</u>），表现类就是`gameObject`的位置啊、动画等信息。逻辑对象和表现对象都有自己的ID，然后各自持有对方的引用，表现层就可以通过引用来获取逻辑层的计算结果

### 1.3 安全性（外挂）

帧同步的逻辑计算是放在客户端的，所以客户端一旦被破解，就可以很容易地获得数据，开发外挂

### 1.4 避免使用浮点数

帧同步技术的难点之一就是需要客户端计算结果的一致性。其中浮点数的运算在一些情况下是会产生不同的结果，所以实现帧同步要避免使用浮点数

### 1.5 使用UDP

在UDP之上实现了可靠性，增加序号和确认机制

1. 为每个数据包增加序列号，每发一次，增加本地序号
2. 每次收到包，把收到的包上序列号变为确认字符，发送包的时候带上这些确认字符

## 2. 状态同步

一个客户端发出操作指令给服务器，<u>服务器计算出结果</u>，更新状态，再将游戏中的所有<u>状态广播</u>给其他客户端

> 逻辑计算在服务端，逻辑计算包括普攻、属性、移动、AI、碰撞、技能逻辑

- 安全性高
- 断线重连容易，服务器再传一次数据就行了

为什么不能用浮点数（float）？因为要保证计算结果一致



https://zhuanlan.zhihu.com/p/105390563

https://jonyzhao.gitbooks.io/gamedev/content/Network/FrameLockStepSync.html

https://zhuanlan.zhihu.com/p/36884005

https://www.zhihu.com/question/323505671

https://www.youxituoluo.com/528021.html

http://codebear.fun/index.php/2020/04/02/548.html

https://www.jianshu.com/p/8cca5458c45b

http://bindog.github.io/blog/2015/03/10/synchronization-in-multiplayer-networked-game-lockstep/

