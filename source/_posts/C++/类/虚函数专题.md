

参考资料：

1. 《effective C++ 第三版》
2. 《C++ Primer 第五版》
3. 《C++编程思想》
4. 《深入探索C++对象模型》
5. 利用 visual studio 查看 C++ 类内存布局：https://www.cnblogs.com/jerry19880126/p/3616999.html
6.  

### 1. 静态类型 vs. 动态类型 

静态类型：编译时已知，是变量声明时的类型或表达式生成的类型

动态类型：直到运行时才可知，变量或表达式在内存中的对象的类型

> 如果表达式**不是指针/引用**，则其动态类型与静态类型**一致**

不存在**从基类到派生类**的隐式类型转换，因为基类有可能不是派生类的一部分

即使一个基类指针/引用绑定在一个派生类对象上，我们也不能执行从基类向派生类的**自动**转换：

```cpp
C_derived child;  					//派生类对象
C *father = &child;					//	
C_derived *cc = father;				//错误，不能将基类自动转换为派生类
```

虽然这个转换是安全的，但是<u>过不了编译器静态时的安全检查</u>，编译器只能通过检查指针/引用的静态类型来推断该转换是否合法

如果基类中有虚函数，可以用 `dynamic_cast`，执行**运行时**的安全检查

> 如果确认基类向派生类的转换是安全的，可以使用 `static_cast` 来强制覆盖掉编译器的检查工作

因为基类的拷贝/移动操作的参数是引用，所以可以给基类的拷贝/移动构造函数传递一个派生类对象，仅处理（拷贝/赋值）该派生类对象中的基类自己的部分，该派生类对象中的其他部分相当于被**切掉（sliced down）**了

### 2. 虚函数

使用基类的引用/指针调用一个虚函数时会执行动态绑定，编译器直到运行时才能确定应该调用哪个版本的虚函数，被调用的函数是与绑定到指针/引用上的对象的动态类型相匹配

> 所有虚函数都必须定义，不管它是否被用到了，因为连编译器也无法确定到底会使用哪个虚函数

##### 2.1 派生类中的虚函数

- 一旦某个函数被声明成虚函数，则在所有派生类中它都是虚函数

- 派生类中**覆盖**基类虚函数，要求形参类型一致，返回类型要么一致，要么可自动转换

- 虚函数的**默认实参**由本次调用的**静态类型**决定

##### 2.2 抽象基类

- 用`=0`声明一个纯虚函数，一个纯虚函数无需定义（也可以有定义，但**必须定义在类外部**）
- 含有纯虚函数的类是抽象基类，**不能**直接创建一个抽象基类的对象

##### 2.3 构造/析构函数与虚函数

1. 基类的析构函数一般是虚函数

   派生类的析构函数也因此是虚函数。基类指针指向派生类对象，那么 delete 该指针的时候，会实际调用派生类的析构函数，派生类析构完成之后，再调用基类的析构函数。如果基类的析构函数不是虚函数，那么 delete <u>基类</u>指针的时候，只会调用基类的析构函数，因此子类无法正常析构。

2. 构造函数不能是虚函数
   - 从`vptr`角度解释：虚函数的调用是通过虚函数表来查找的，而虚函数表由类的实例化对象的`vptr`指针指向。该指针存放在对象的内部空间中，需要调用构造函数完成初始化。如果构造函数是虚函数，那么调用构造函数就需要去找`vptr`，但此时`vptr`还没有初始化！
   - 从多态角度解释【挖坑】

**定义派生类的拷贝或移动构造函数**

```cpp
class Base { /*..*/};
class D: public Base {
public:
	//默认情况下，基类的默认构造函数初始化对象的基类部分
    //要想使用拷贝或移动构造函数，必须在构造函数初始值列表中显示地调用该构造函数
    D(const D& d): Base(d)           //拷贝基类成员
    			/* D的成员的初始值 */  {/*...*/}
    D(D&& d): Base(std::move(d))     //移动基类成员
                /* D的成员的初始值 */  {/*...*/}
}
```

`Base(d)` 匹配 `Base` 的拷贝构造函数，然后 `Base` 的拷贝构造函数负责将 <u>`d` 的基类部分</u>拷贝给要创建的对象

##### 2.4 名字查找和继承 

查找名字和确定调用哪个虚函数是分开的

![image-20220311115032636](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220311115032636.png)

##### 2.5 怎么根据虚函数的名字找到最终要调用的函数地址？

每一个含有虚函数的类都有自己的虚表，它是一个静态指针数组，由编译器在编译时填好。虚表中每个条目都对应一个虚函数的地址（函数指针），指向此类可以访问到的 `most-derived` 虚函数。

每个对象中都存在一个隐藏指针（`*__vptr`），指向整个虚表，当一个对象被创建时，`*__vptr`会由构造函数进行初始化，决定它指向哪张虚表。所以每个对象的占用内存会偏大，因为其中也存储了`*__vptr`

每个多态 class object 身上会有额外两个 members：

1. RTTI 信息，用于在运行时确定对象的实际类型
2. 虚表指针+虚表

为了完成多态，编译器完成两项工作：

1. 构造虚表，填好虚表中的地址
2. 确定好每个虚函数的偏移

现在有这样的式子：`ptr->z();`表示一个虚函数调用，如何确定要调用的`z()`地址？由于：

（1）所有类的虚表已经在编译时确定

（2）`z()`在虚表中的偏移在编译时已经设定好且固定了，这里假设偏移为`4`

所以该式子可以被转化为：`(*ptr->vptr[4])(ptr)`，虚表已知，偏移已知，需要在<u>运行时</u>让构造函数对`vptr`进行初始化，确定该`vptr`应该指向哪一个虚表，再利用已知的偏移信息，就可以找到正确的虚函数的地址

> 运行时，对于`ptr->z()`这个函数调用，`ptr`的首地址，即`this`的地址会被压栈，`this`的地址实际上也是`vptr`的位置，根据`vptr`找到虚表，根据偏移取出函数地址，执行`call`指令 

##### 2.6 虚表指针放在什么位置

通常放在对象开头，到底能不能放在对象最后呢？这个还没有查到靠谱的资料，在《深入探索C++对象模型》书中说到`*__vptr`曾经有被放在对象尾部（为了兼容C）

### 3. 多继承中的虚函数

```cpp
class Base
{
    int a;
    int b;
public:
    void CommonFunction();
    void virtual VirtualFunction();
};

class DerivedClass1 : public Base
{
    int c;
public:
    void DerivedCommonFunction();
    void virtual VirtualFunction();
};

class DerivedClass2 : public Base
{
    int d;
public:
    void DerivedCommonFunction();
    void virtual VirtualFunction();
};

class DerivedDerivedClass : public DerivedClass1, public DerivedClass2
{
   	int e;
public:
    void DerivedDerivedCommonFunction();
    void virtual VirtualFunction();
};
```

多重继承情况下，（没有虚继承 ），`DerivedDerivedClass`的内存布局会是怎样的？

![image-20220523100657194](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220523100657194.png)

可以看到，`DerivedDerivedClass`的两个基类按顺序排布，两份`Base`类内存，有两个虚表指针，第二个虚表指针的偏移为`24`。由于多继承，同一个 object 的地址会出现不一样的情况：

```cpp
    DerivedDerivedClass* d = new DerivedDerivedClass;
    DerivedClass1* a = d;
    DerivedClass2* b = d;
	// a 和 b 的值会不一样，就像是 d 有两份地址一样
    cout << a << endl;
    cout << b << endl;
```

`DerivedDerivedClass`的虚表结构：

![image-20220523104144845](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220523104144845.png)

可以看到这里有两张虚表了，第二张虚表中的`-24`表示指向这张虚表的`*__vptr`偏移，这正是`DerivedDerivedClass`内存布局中第二个`*__vptr`的位置偏移

### 4. 虚继承中的虚函数

虚基类的偏移量在运行时才可以确定 【】

引入虚继承后

```cpp
```



