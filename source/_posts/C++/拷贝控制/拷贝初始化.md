---
title: "拷贝初始化那些事儿"
date: 2021-11-24
draft: false
tags: ["C/C++"]
categories: ["我为什么这么菜~~"]

---

### 拷贝构造函数

要么只有一个参数，此参数是自身类类型的常引用，要么多个参数，第一个参数为自身类类型的常引用，其他参数都有默认值

```cpp
class Foo {
public:
    Foo();
    Foo(const  Foo&);  //可以用初始化列表，或在花括号里一一拷贝
};
```

### 合成拷贝构造函数

如果用户没有为类定义一个拷贝构造函数，编译器会自动生成一个，执行**浅拷贝**，依次拷贝每个非 `static` 成员

### 直接初始化（无`=`号）

匹配最佳的构造函数（注意也有可能匹配上拷贝构造函数）

### 拷贝初始化

使用拷贝初始化的常见四种情况：

1. `=`号
2. 函数非引用形参
3. 函数非引用返回类型 
4. 用花括号列表初始化一个数组中的元素或一个聚合类中的成员



拷贝初始化有时候会使用**移动构造函数**而非**拷贝构造函数**

```cpp
class Foo{
public:
    Foo(Foo &&f){} //移动构造函数
    Foo& operator=(Foo f){} //普通左值既可以接受左值也可以接受右值，反正都是要拷贝的
    //注意上面这个不是拷贝赋值运算符，拷贝赋值运算符要求参数为常引用
};
```

观察：

```cpp
    Foo& operator=(Foo f){} //单一的赋值运算符实现了拷贝赋值运算符和移动赋值运算符两种可能
```

此运算符有一个<u>非引用</u>参数，所以要进行<u>拷贝初始化</u>

依赖于实参的类型，拷贝初始化要么使用拷贝构造函数，要么使用移动构造函数——<u>左值</u>被拷贝，<u>右值</u>被移动

```cpp
hp = hp2; 				//拷贝构造函数来拷贝hp2
hp = std::move(hp2);    //移动构造函数移动hp2
```

> 有点奇怪，按理说=号赋值应该调用拷贝赋值运算符，这里却调用那个非拷贝赋值运算符？

### 为什么拷贝构造函数自己的参数必须是引用类型？

如果不是引用，则会调用拷贝构造函数，形成拷贝构造函数调用拷贝构造函数的死循环

### 编译器可以绕过拷贝/移动构造函数

拷贝初始化中，编译器可以选择跳过拷贝/移动构造函数，直接创建对象

```cpp
string null_book = "9999"; //拷贝初始化
```

> **隐式类型转换（转换构造函数）**：只接受一个实参，或者其他参数都有默认参数
>
> 在需要类对象的时候，编译器可以根据已经有的一个参数，调用转换构造函数，自动创建一个（临时）对象

正常来讲，字符串字面值`"9999"` 是`const char*`类型，由于要进行拷贝初始化，`=`号右边需要一个`string`对象，所以根据**隐式类型转换**，在需要`string`对象的时候，可以调用相应的**转换构造函数**，自动创建一个临时`string`对象：

```cpp
string (const char* s); //from c-string (4)	转换构造函数
```

有了临时`string`对象后，按理说要调用拷贝构造函数，完成对`null_book`的拷贝初始化

然而，这里**并没有**调用拷贝构造函数，经测试**也没有**调用移动构造函数，原因是编译器对拷贝初始化表达式进行了改写

把

```cpp
string null_book = "9999"; //拷贝初始化
```

改写为

```cpp
string null_book("9999"); // 使临时对象成为要创建的对象
```

按理说被改写后应该属于（调用拷贝构造函数的）直接初始化

但是在利用转换构造函数生成临时`string`对象后

编译器直接使临时对象成为要创建的对象（编译器优化），所以没有调用拷贝/移动构造函数

其他例子：

```cpp
class Foo {
public:
    Foo() = default;
    Foo(const Foo& other) :len(other.len) { cout << "拷贝构造函数！" << endl; }  //拷贝构造函数
    Foo(int length) :len(length) { cout << "转换构造函数" << endl; } 		       //转换构造函数
    Foo(Foo&&) { cout << "移动构造函数" << endl; } 							   //移动构造函数
    Foo& temp_f(Foo temp) {
        return *this;
    }
private:
    int len;
};

int main() {
    Foo c1 = 10; //本身为拷贝初始化，编译器将其改写为下一行的语句，不会调用拷贝/移动构造函数！
    Foo c(10);  //不会调用拷贝/移动构造函数！只会调用转换构造函数
    c.temp_f(10); // 虽然形参非引用，但是也不会调用拷贝/移动构造函数！
    return 0;
}
```

解析一下这个：

```cpp
c.temp_f(10); // 虽然形参非引用，但是也不会调用拷贝/移动构造函数！
```

形参非引用，参数`10`被作为参数传入，先会调用转换构造函数，使`10`被隐式转换为一个`Foo临时对象`

注意，这个对象是临时的，临时量具有<u>常量性</u>（`const`属性）

<u>常量性</u>意味着：

1. 如果`temp_f`的形参是`左值引用&`，将会报错，左值<u>引用</u>不能接受一个`const`值，左值引用也不能接受一个右值

2. 如果`temp_f`的形参是`常量左值引用const &`或`右值引用&&`，不会报错，因为它们都可以接受一个右值，而且因为是引用了，所以也不会调用拷贝构造函数

3. 如果`temp_f`的形参是`普通左值`：

   ```cpp
   Foo& temp_f(Foo temp);
   ```

   普通左值可以接受`const值`或`右值`，因为这就直接<u>拷贝</u>了，`const值`或`右值`没有被改变的风险

   例如：

   ```cpp
   int i = 42;const int ci = i;int j = ci;  // ci的常量特征仅仅在执行改变ci的操作时才会发挥作用，一旦拷贝完成，新的对象就和原来的对象没什么关系了
   ```

   然后按理来说，函数形参非引用，应该是个拷贝初始化，调用拷贝构造函数

   但是没有！因为传给 temp_f 是一个**匿名临时对象**！

   只有一个对象对另一个同类型的对象进行初始化才会调用拷贝构造函数，但是<u>匿名对象对另一个同类型的对象初始化**不会**调用拷贝构造函数</u>，因为c++**编译器**对这种情况进行**优化**，<u>直接将匿名对象转化为该对象</u>，不需要进行额外的内存分配，提高了效率；

   编译器在此时进行了优化，<u>绕过了拷贝/移动构造函数</u>，将`Foo临时对象`直接创建了`Foo对象`作为形参，所以并没有调用拷贝/移动构造函数！

   参考解析：https://blog.csdn.net/weicao1990/article/details/81629955

   > 即使编译器略过了拷贝/移动构造函数，但在这个程序点上，拷贝/移动构造函数必须是可存在且可访问的（必须是`public`的，不能是`private`）


### 拷贝赋值运算符

注意区分赋值和初始化

返回类型为<u>引用</u>，形参为<u>常引用</u>：

```cpp
class Foo {
public:
    Foo& operator=(const Foo&); //赋值运算符
}
```

> 拷贝赋值运算符=重载赋值运算符
>
> 重载赋值运算符的参数表示运算符的**运算对象**
>
> 如果一个运算符是成员函数（**赋值运算符必须定义为成员函数**），则其第一个参数肯定是**隐式this参数**，这也是该运算符的（**左侧**）运算对象
>
> - 如果是一元运算符，就只有这一个运算对象
> - 如果是二元运算符（例如赋值运算符），其**右侧**运算对象作为**显示**参数传递

如果类没有定义自己的拷贝赋值运算符，编译器会自动合成一个合成拷贝赋值运算符

但是**合成拷贝赋值运算符**实行**浅**拷贝，当对象中存在指针成员变量时，存在如下问题：

![原生赋值运算符](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211124194517073.png)

所以当对象中存在指针成员变量， 应该自定义新的拷贝赋值构造函数，执行**深**拷贝

### 2. 对象移动

#### 2.1 右值引用

符号：`&&`

**右值引用**只能绑定到一个将要销毁的对象（临时对象）

**左值引用**不能被绑定到要求转换的表达式，字面常量或是返回右值的表达式，但<u>右值引用可以</u>，但不能将一个右值引用直接绑定到一个左值上

- 返回左值的表达式（可以被`左值引用`绑定）：返回左值引用的函数，包括赋值、下标、解引用和前置递增/递减运算符
- 返回右值的表达式（可以被`const左值引用`、`右值引用&&`绑定）：返回非引用类型的函数，包括算数、关系、位以及后置递增/递减运算符

变量是持久的，包括右值引用类型的左值，所以<u>不能将一个右值引用绑定到一个右值引用类型的变量上</u>：

```cpp
int &&rr1 = 42;
int &&rr2 = rr1; //错误！变量表达式 rr1 是左值
```

`std::move`显示地将左值转变为右值

#### 2.2 移动构造函数（移动语义）

以移动而非深拷贝的方式初始化含有指针成员的类对象

移动构造函数的第一个参数为右值引用，任何额外的参数都必须有默认实参

1. 指针资源交接
2. 原来的指针应该指向`nullptr`

浅拷贝+销毁=移动

```cpp
#include <iostream>
using namespace std;
class demo{
public:
    demo():num(new int(0)){
        cout<<"construct!"<<endl;
    }
    demo(const demo &d):num(new int(*d.num)){
        cout<<"copy construct!"<<endl;
    }
    //添加移动构造函数
    demo(demo &&d):num(d.num){
        d.num = NULL;
        cout<<"move construct!"<<endl;
    }
    ~demo(){
        cout<<"class destruct!"<<endl;
    }
private:
    int *num;
};
demo get_demo(){
    return demo();
}
int main(){
    demo a = get_demo();
    return 0;
}

//结果：为 demo 类添加移动构造函数之后，使用临时对象初始化 a 对象过程中产生的 2 次拷贝操作，都由移动构造函数完成
```

> 当类中同时包含拷贝构造函数和移动构造函数时，如果使用**临时对象**初始化当前类的对象，编译器会**优先调用移动构造函数**来完成此操作。
>
> 只有当类中没有合适的移动构造函数时，编译器才会退而求其次，用拷贝构造函数**代替**移动构造函数（赋值运算符的情况类类似）

#### 2.3 移动赋值运算符

```cpp
StrVec& StrVec::operator=(StrVec &&rhs) {
    //直接检测自赋值
    if (this != &rhs) { //rhs是个右值引用变量表达式，所以它是个左值，所以可以对它取地址
        free();    		//释放已有元素
        elements = rhs.elements; // 从rhs接管资源
        first_free = rhs.first_free;
        cap = rhs.cap;
        // 将rhs置于可析构状态
        rhs.elements = rhs.first_free = rhs.cap = nullptr;
    }
    return *this;
}
```

#### 2.4 合成的移动操作

如果一个类定义了自己的拷贝构造函数、拷贝赋值运算符或者析构函数，编译器就**不会自动合成**移动构造函数和移动赋值运算符

仅当一个类没有定义任何自己版本的拷贝控制成员（三大件），且类的每个非static数据成员都可以移动时，编译器才会自动合成移动构造函数或移动赋值运算符

可移动：

- 内置类型总是可移动的
- 类类型，要求该类有对应的移动操作

```cpp
//编译器会为X和hasX合成移动操作
struct X {
    int i;  			//内置类型可以移动
    std::string s; 		//string定义了自己的移动操作
};
struct hasX {
    X mem;				// X有合成的移动操作
};
X x, x2 = std::move(x); 	  //使用合成的移动构造操作
hasX hx, hx2 = std::move(hx); //使用合成的移动构造函数
```





