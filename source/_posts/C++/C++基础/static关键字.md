## static

### 1. static 的引入

函数中的`static`，既可以<u>控制此变量的访问范围</u>，又可以<u>使此变量的值保存至下一次调用</u>

类中的`static`，需要<u>一个对象服务于整个类</u>， 同时又力求<u>不破坏类的封装性</u>

【那函数和类外的static呢？】

### 2. static变量的内存分配和初始化

在 `linux` 系统中，程序在内存中的分布如下所示：	

![image-20211214120006624](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211214120006624.png)

#### 2.1 全局静态变量

处在<u>全局/静态存储区</u>，<u>在**编译期**就为其分配内存</u>并<u>初始化</u>，在程序结束时释放

#### 2.2 局部静态变量

内存位置在<u>全局/静态存储区</u>，C++在<u>第一次执行到</u>局部静态变量的<u>定义</u>时进行<u>内存的分配和初始化</u>，且<u>仅会初始化一次</u>。

> C++引入了对象的概念，对象一般需要构造函数，无法简单的分配内存，故可以用变量赋值，并且在第一次使用时初始化

> C语言中的局部静态变量是<u>编译期初始化并分配内存的</u>，故不能用变量给局部静态变量赋值，只能用常量

##### 局部静态变量（对象）内存泄漏问题

面试题：请问下面这段代码是否会造成内存泄漏？

```cpp
void fun(){
    static char* temp = new char[20];
}
```

答：<u>不会</u>造成内存泄漏，因为temp<u>只会被初始化一次</u>，所以new只会执行一次，多次调用`fun()`不会多次new，所以不会出现内存增长。temp为局部静态指针，退出`fun()`后，temp仍然存在，且指向着那块内存（但不能访问，因为已经脱离作用域了）

> 如何实现只初始化一次？编译器会维护一个状态标志，来标识该变量是否已被初始化，并安插代码，在每一次函数被调用时进行判断

> C++11之前，可能由于<u>线程安全</u>问题而造成内存泄漏。如果一个线程正在执行local static对象的初始化语句，但还没有完成初始化，此时若其它线程也执行到该语句，那么这个线程会认为自己是第一次执行该语句并进入该local static对象的构造函数中。这会造成这个local static对象的重复构造，进而产生内存泄露问题。这就造成了local static对象在多线程环境下的重复构造问题
>
> C++11则在语言规范中解决了这个问题。C++11规定，在一个线程开始local static 对象的初始化后到完成初始化前，其他线程执行到这个local static对象的初始化语句就会等待，直到该local static 对象初始化完成

参考资料：

https://www.cnblogs.com/dylan-liang/p/14407237.html

https://stackoverflow.com/questions/246564/what-is-the-lifetime-of-a-static-variable-in-a-c-function

https://blog.csdn.net/zzuchengming/article/details/51829615

[C++局部静态变量在什么时候分配内存和初始化？ - SegmentFault 思否](https://segmentfault.com/q/1010000004157283)

[局部变量内存分配时间、静态变量的初始化时间、常量折叠 - 代码先锋网 (codeleading.com)](https://www.codeleading.com/article/75132255757/)

#### 2.3 静态成员变量

静态数据成员是在程序开始运行时被分配空间，到程序结束之后才释放，只要类中指定了静态数据成员，即使不定义对象，也会为静态数据成员分配空间。

##### 静态成员变量使用前一定要在类外定义

静态成员变量在类中仅仅是声明，没有定义，所以要在类的外面定义，实际上是给静态成员变量分配内存，才能正常使用

```cpp
class my_class {
public:
    static int a;
};
//int my_class::a;
int main()
{
    cout << my_class::a << endl;  //无法识别a，因为a没有定义，没有内存的分配，类中的"static int a;" 只是一个声明
    return 0;
}
```

将类外的 `int my_class::a;` 取消注释后，就可以正确输出`my_class::a`的值了（因为没有给定初始值，所以这里被编译器值初始化为0）

参考资料：

https://www.whcsrl.com/blog/8271

https://cxyzjd.com/article/chidanzhu4790/100851834

### 3. `static` 的四个作用

#### 3.1 **隐藏**

同时编译多个文件的时候，所有**未加**`static`的全局变量和函数都具有全局可见性，别的源文件也能访问（`extern`）。而加了`static`的变量以及函数就只在本文件可见，其他源文件不能够访问

```cpp
//file1
int error = 20; //external declaration
...
--------------------------------------
//file2
int error = 5;  // 报错，多重定义error
void froobish(){
    cout << errors; //报错
    ...
}
```

上面的代码会报多重定义错误，但如果一个文件定义了`static`外部（全局）变量，其名称与另一个文件中声明的常规外部变量相同，则在该文件中，静态变量将**隐藏**常规外部变量

```cpp
//file1
int error = 20; //external declaration
...
--------------------------------------
//file2
static int error = 5;  // 隐藏其他文件的同名变量
void froobish(){
    cout << errors; // 输出 error ： 5
    ...
}
```

2. **保持**变量内容的持久（`static`变量中的记忆功能与全局生存期）

   存储在**静态数据区**的变量会在程序刚开始运行时就完成初始化， 也是**唯一的一次初始化**

   > 如果作为`static`局部变量在**函数内**定义，它的**生存期**为整个源程序，但是其**作用域**仍与自动变量相同，只能在定义该变量的函数内使用该变量。退出函数后，尽管该变量还继续存在，但不能使用它

3. **默认初始化**

   在静态数据区，内存中所有字节默认都是0x00

#### **面向对象的static**

1. 类的静态成员变量

   - 属于类，使用前**必须**在类外进行初始化，编译器不会自动为其赋值

   ```cpp
   int A::a = 0;
   ```

   > 不要在头文件中定义（初始化）静态数据成员，在大多数情况下，这样做会引起重复定义的错误

   - 多个对象共享，在内存中只占一份空间
   - 既可以通过对象名引用，也可以通过类名引用

2. 类的静态成员函数

   - 没有`this`指针
   - 只能访问静态成员，不能访问非静态成员

3. 类的对象**可以**使用静态成员函数**和**非静态成员函数

4. 静态成员函数**不能**使用非静态成员

5. 类的非静态成员函数**可以**调用静态成员函数，反之不能

> 静态资源属于类，是在类初始化的时候加载的，而非静态资源是类实例化对象的时候加载的。类的初始化早于类实例化对象，所以对于静态资源来说，它是不可能知道类中有哪些非静态资源的，但非静态资源却认识类中早已存在的静态资源

参考资料：

https://www.cnblogs.com/33debug/p/7223869.html

https://www.daimajiaoliu.com/daima/479591b11900404

https://blog.csdn.net/xiajun07061225/article/details/6955226
