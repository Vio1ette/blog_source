## C++初始化那些事儿

### 1. 初始化 vs 赋值💢

初始化不等于赋值，这是两个完全不同的操作

初始化：创建变量时赋予其一个初始值

赋值：把对象的当前值擦除，再用一个新值替换

### 2. 列表初始化

C++初始化有很多种形式，这也是初始化问题复杂性的一个体现。 例如，想要定义一个名为 `units_sold` 的 `int` 变量并初始化为 `0`，以下 4 条语句都能做到这一点：

```c++
int units_sold = 0;  //最正常的方式
int units_sold = {0}; //列表初始化
int units_sold{0}; // 列表初始化【】
int units_sold(0); // 直接初始化
```

当用于内置类型的变量时，如果列表初始化存在丢失信息的风险，则编译器将报错：

```c++
long double ld = 3.1415026536;
int a{ld}, b = {ld}; // 列表初始化，报错，转换未执行，因为存在丢失信息（精度）的风险
int c(ld), d = ld; // 正常，转换执行，虽然确实丢失了精度
```

### 3. 值初始化 vs. 默认初始化

#### 3.1 值初始化

值初始化对于<u>内置类型</u>初始化为 0，对于<u>类类型</u>则调用<u>默认构造函数</u>，如果没有默认构造函数，则不能进行初始化

如何判断是值初始化：

1. 使用了初始化器（如，圆括号，花括号）
2. **没有**提供初始值

例如：

```cpp
int *p = new int();
vector<string> vec(10);  // 10表示个数
```

> 当不采用动态分配内存的方式（即不用`new`时），`int a()`是错误的值初始化方式，因为它会<u>被理解为一个函数的声明</u>，而不是值初始化
>
> 正确的初始化方式：`int a = int();`

#### 3.2 默认初始化

如果**定义变量**的时候**没有指定初值**，则变量被**默认初始化（default initialized）**，此时变量被赋予“**默认值**”

>  **默认值到底是什么？**
>
>  （1）内置类型
>
>  由定义的位置决定：
>
>  1. **任何函数之外**的变量，它被初始化为 0
>  2. **在函数体内部**，将**不被初始化**，其值是**未定义**的，是**不能被访问**的
>
>  （2）类对象
>
>  **类自己决定**其变量的**初始化方式**、**初始化值**、**是否允许不经初始化变量就定义出对象**
>
>  绝大多数类都支持**无须显示初始化而定义对象**，它会给没有初始化的**类内变量**提供一个合适的**默认值**
>
>  ```c++
>  std::string empty; // 默认值为空串
>  Sales_item item; // item的默认值是什么，由 Sales_item 这个类自己定义
>  ```
>
>  一些类要求每个对象都显示初始化， 如果没有就会报错

### 4. 直接初始化 vs. 拷贝初始化



直接初始化：要求编译器使用**普通的函数匹配**，选择与我们提供的参数**最匹配**的构造函数（也可能最佳匹配上**拷构**）

拷贝初始化：要求编译器将**右侧运算对象**拷贝到正在创建的对象中，需要的话可以进行类型转换

> **拷贝初始化**一般调用**拷贝构造函数**，但也可能调用**移动构造函数**

```
string dots(10, '.');   //直初
string s(dots);  		//使用了拷构的直初
string s = dots; 		//拷初
string null_book = "9999";  //拷初
string nines = string(100, '9'); //拷初
```

> 哪里有临时量生成？ 拷初的参数是 `const&` 肯定没有临时量

发生拷初的常见情况

1. `=`
2. 非引用函数传参
3. 非引用函数返回值

### 5. 数组的初始化

#### 5.1 数组的初始化规则

1. 只有在定义数组的时候才能使用初始化，以后就不能使用了

```c++
int cards[4] = {3,6,8,10}; //okay
int hand[4];
hand[4] = {5, 6, 7, 9}; //not allowed，可以使用下标一一赋值
```

2. 不允许数组间赋值

```c++
hand = cards; // not allowed
```

3. 允许部分初始化，剩余的默认采用<u>值初始化</u>

#### 5.2 c++11新特性

#### 列表初始化新特性

```c++
double earnings[4] {1.2e4, 1.6e4}; // 列表初始化，省略等号是可以的
unsigned int counts[10] = {}; //所有10个元素都为0
long plifs[] = {25, 92, 3.0}; //报错，列表初始化禁止缩窄转换
```

关于`缩窄转换`[C++11 narrowing convertions(缩窄转换)_dai_peixian的专栏-CSDN博客_缩窄转换](https://blog.csdn.net/dai_peixian/article/details/52767057)

### 6. string初始化【6，7都是顺序容器，初始化可以放到一起】

![初始化string](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211109100945293.png)

<center style="color:#C0C0C0;text-decoration:underline">Primer C++ 第五版，P76</center>

### 7. vector初始化【】

```c++
vector<T> v1;    // 空vector，默认初始化
vector<T> v2(v1); //拷贝初始化，要求两个vector对象的类型必须相同
vector<T> v2 = v1; //同上
vector<T> v3(n,val); // v3包含n个重复元素，每个元素的值都是val
vector<T> v4(n); // v4包含n个元素，每个元素都被值初始化（如果是内置类型，0，如果是类类型，则执行类定义默认初始化）
vector<T> v5{a,b,c...} //列表初始化
vector<T> v6 = {a,b,c...} //同上 
```

> 如果使用了花括号，但是提供的值不能用来完成列表初始化，编译器就会考虑用提供的值来构造 vector 对象
>
> ```c++
> vector<string> v7{10};  //v7有10个默认初始化元素
> vector<string> v8{10, "hi"}; //v8 有10个值为"hi"的元素
> ```

### 8. 

