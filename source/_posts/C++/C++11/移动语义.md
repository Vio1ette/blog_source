# 1. C++移动语义的前世今生

## 1.1 浅拷贝与深拷贝

深拷贝可以解决浅拷贝中会产生的悬挂指针的问题，但也增大了开销。默认的拷贝构造函数执行的是浅拷贝，需要自己实现深拷贝的拷贝构造函数。

## 1.2 临时对象

在某些情况下，一些依赖于深拷贝的临时对象的产生与销毁会带来一些不必要的开销，为了解决这个问题，引入移动语义

## 1.3 左值、右值与右值引用

左值：有名字，能取地址

右值：没有名字，没有地址，一些临时量，lambda表达式

![6FED5766DA66F67A18C061E3A45686DF](https://raw.githubusercontent.com/Vio1ette/blog-img/main/6FED5766DA66F67A18C061E3A45686DF.png)

## 1.4 std::move

面试题：移动语义是先浅拷贝，再将被拷贝过的指针置空，如果是这样的话，那么仅仅定义一个普通的函数也可以做到这一点（先浅拷贝指针，然后再将被拷贝过的指针置空），那么移动语义存在的意义是什么？

> 为什么要将源对象的指针置空？
>
> 要防止源对象析构时对其指针进行delete操作把移动后的不属于它的资源给释放掉了

首先，移动语义要解决的问题是<u>临时对象的重复拷贝、销毁所带来的额外开销</u>，所以其函数参数是<u>右值引用</u>，仅接受右值作为传入参数，而是拷贝构造函数的常量左值引用

> 拷贝构造函数和移动构造函数同时存在的话，如果参数为右值，将会优先调用移动构造函数

<u>常量左值引用可以接受右值（临时对象），可以实现这个移动语义</u>。但如果把拷贝构造函数实现为移动语义就相当于所有（临时/非临时）资源都会进行移动，而非深拷贝，这完全消灭了深拷贝。深拷贝时，对新分配的内存空间进行操作不会影响到源内存空间，这是移动语义做不到的，所以不能完全消灭深拷贝

移动构造函数只接受非常量右值，对临时资源的移动是需要的，但是对于非临时资源，深拷贝是需要的
