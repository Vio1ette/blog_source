TCP是可靠的传输，它通过乱序、丢包重传、流量控制、拥塞控制来保证可靠性

### 1. 流量控制（滑动窗口）

每发送一个包，必须接收到它的确认后才能发下一个包，这种方式效率太低。滑动窗口可以允许发送方一次发送多个包，只用接收方确认一次，且还能根据接收方的接收窗口调整发送窗口的大小， 以避免发送过多的包

![image-20220501193841881](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220501193841881.png)

发送窗口的大小 = 接收窗口的大小 - 已发送但没被确认的包的数量

### 2. 拥塞控制

流量控制和拥塞控制的区别

> 流量控制为了解决发送方和接收方速率不匹配的问题，而拥塞控制是作用于网络的，是为了防止过多的数据注入到网络中，避免出现网络负载过大的情况。

#### 2.1 慢开始

> 为了讨论方便，假设接收方总是有足够大的接收缓存

发送方维持一个拥塞窗口（cwnd）的状态变量，拥塞窗口的大小取决于网络的拥塞程度，并且动态地变化，通常情况下，发送窗口 = min(cwnd, 接收窗口)，这里由于假设接收窗口足够大，所以，发送窗口 = 拥塞窗口

为了对网络进行“试探”，拥塞窗口的初始值很小，只有一个发送方的最大报文段MSS的大小，然后在随后的过程中，没收到一个新的对报文段的确认，就可以把拥塞窗口增加一个MSS

![image-20220501202208725](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220501202208725.png)

从图中可以看出cwnd是呈指数增长，每过一个轮次就加倍

> 一个传输轮次：发送方从发送一批分组到收到它们的确认所经历的时间，即往返时间RTT

#### 2.2 拥塞避免

为了防止过大的拥塞窗口，出现了慢开始门限，当拥塞窗口的大小小于慢开始门限时，使用慢开始算法，反之，当拥塞窗口大于慢开始门限时，说明拥塞窗口的大小已经很大了，需要加以限制，于是就有了拥塞避免算法，即加法增大拥塞窗口



![image-20220501201652395](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220501201652395.png)

无论何时（慢开始阶段或拥塞避免阶段），只要出现<u>超时</u>现象，就把慢开始门限设置为超时时拥塞窗口的一半大小，然后将拥塞窗口大小重置为1，重新开始慢开始阶段

#### 2.3 快重传和快恢复

快重传：发送方如果收到了三个冗余ACK，就说明个别包已经丢失，执行快重传，立即重传这个包（即使现在还没有超时）

快恢复：收到三个冗余的ACK时，虽然还未出现超时现象，但已经直到个别包出现了丢失现象，此时调整慢开始门限值为当前拥塞窗口的一半，同时设置拥塞窗口为新的门限值，简单来讲就是拥塞窗口变为了原来的一半，然后执行加法增大（门限值=拥塞窗口大小）

### 3. TCP三次握手

![image-20220501185937682](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220501185937682.png)

#### 2.1 二次握手可以吗？

不行，因为

（1）需要三次握手才能确定发送方和接受方的发送功能和接收功能都是正常的

（2）假设只需两次握手就可以建立连接，且客户端向服务端发送的同步包在网络中滞留时间过长，导致重传，如果在重传正常建立连接、传输数据、关闭连接后，原先滞留的数据包到达服务器，服务器回传确认包给发送方，由于是二次握手，就会导致异常的连接被建立。

#### 2.2 三次握手可以携带数据吗？

第三次握手可以

### 3. TCP四次挥手

![image-20220501190853686](https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20220501190853686.png)

#### 3.1 为什么客户端要等待2MSL

MSL是报文在网络中可存活的最大时间，如果客户端发的最后一个ACK丢失了，服务器将会重发一个FIN，此时如果客户端早早关闭了的话，服务器就无法正常关闭了



和UDP的区别

1. TCP是有连接的，需要三次握手建立连接，UDP是无连接的
2. TCP保证可靠的传输，而UDP不是
3. TCP是端到端的，而UDP除了端到端还可以多播、广播
4. TCP传输的是字节流，而UDP传输的是报文